(() => {
  // output-es/runtime.js
  function binding(init5) {
    let state = 0;
    let value;
    return () => {
      if (state === 2) {
        return value;
      }
      if (state === 1) {
        throw new Error("Binding demanded before initialized");
      }
      state = 1;
      value = init5();
      state = 2;
      return value;
    };
  }
  function fail() {
    throw new Error("Failed pattern match");
  }
  function intDiv(x2, y2) {
    if (y2 > 0)
      return Math.floor(x2 / y2);
    if (y2 < 0)
      return -Math.floor(x2 / -y2);
    return 0;
  }

  // node_modules/d3-array/src/ascending.js
  function ascending(a, b) {
    return a == null || b == null ? NaN : a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
  }

  // node_modules/d3-array/src/descending.js
  function descending(a, b) {
    return a == null || b == null ? NaN : b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
  }

  // node_modules/d3-array/src/bisector.js
  function bisector(f) {
    let compare1, compare2, delta;
    if (f.length !== 2) {
      compare1 = ascending;
      compare2 = (d, x2) => ascending(f(d), x2);
      delta = (d, x2) => f(d) - x2;
    } else {
      compare1 = f === ascending || f === descending ? f : zero;
      compare2 = f;
      delta = f;
    }
    function left2(a, x2, lo = 0, hi = a.length) {
      if (lo < hi) {
        if (compare1(x2, x2) !== 0)
          return hi;
        do {
          const mid = lo + hi >>> 1;
          if (compare2(a[mid], x2) < 0)
            lo = mid + 1;
          else
            hi = mid;
        } while (lo < hi);
      }
      return lo;
    }
    function right2(a, x2, lo = 0, hi = a.length) {
      if (lo < hi) {
        if (compare1(x2, x2) !== 0)
          return hi;
        do {
          const mid = lo + hi >>> 1;
          if (compare2(a[mid], x2) <= 0)
            lo = mid + 1;
          else
            hi = mid;
        } while (lo < hi);
      }
      return lo;
    }
    function center2(a, x2, lo = 0, hi = a.length) {
      const i = left2(a, x2, lo, hi - 1);
      return i > lo && delta(a[i - 1], x2) > -delta(a[i], x2) ? i - 1 : i;
    }
    return { left: left2, center: center2, right: right2 };
  }
  function zero() {
    return 0;
  }

  // node_modules/d3-array/src/number.js
  function number(x2) {
    return x2 === null ? NaN : +x2;
  }

  // node_modules/d3-array/src/bisect.js
  var ascendingBisect = bisector(ascending);
  var bisectRight = ascendingBisect.right;
  var bisectLeft = ascendingBisect.left;
  var bisectCenter = bisector(number).center;
  var bisect_default = bisectRight;

  // node_modules/internmap/src/index.js
  var InternMap = class extends Map {
    constructor(entries, key = keyof) {
      super();
      Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: key } });
      if (entries != null)
        for (const [key2, value] of entries)
          this.set(key2, value);
    }
    get(key) {
      return super.get(intern_get(this, key));
    }
    has(key) {
      return super.has(intern_get(this, key));
    }
    set(key, value) {
      return super.set(intern_set(this, key), value);
    }
    delete(key) {
      return super.delete(intern_delete(this, key));
    }
  };
  function intern_get({ _intern, _key }, value) {
    const key = _key(value);
    return _intern.has(key) ? _intern.get(key) : value;
  }
  function intern_set({ _intern, _key }, value) {
    const key = _key(value);
    if (_intern.has(key))
      return _intern.get(key);
    _intern.set(key, value);
    return value;
  }
  function intern_delete({ _intern, _key }, value) {
    const key = _key(value);
    if (_intern.has(key)) {
      value = _intern.get(key);
      _intern.delete(key);
    }
    return value;
  }
  function keyof(value) {
    return value !== null && typeof value === "object" ? value.valueOf() : value;
  }

  // node_modules/d3-array/src/ticks.js
  var e10 = Math.sqrt(50);
  var e5 = Math.sqrt(10);
  var e2 = Math.sqrt(2);
  function tickSpec(start2, stop, count) {
    const step = (stop - start2) / Math.max(0, count), power = Math.floor(Math.log10(step)), error3 = step / Math.pow(10, power), factor = error3 >= e10 ? 10 : error3 >= e5 ? 5 : error3 >= e2 ? 2 : 1;
    let i1, i2, inc;
    if (power < 0) {
      inc = Math.pow(10, -power) / factor;
      i1 = Math.round(start2 * inc);
      i2 = Math.round(stop * inc);
      if (i1 / inc < start2)
        ++i1;
      if (i2 / inc > stop)
        --i2;
      inc = -inc;
    } else {
      inc = Math.pow(10, power) * factor;
      i1 = Math.round(start2 / inc);
      i2 = Math.round(stop / inc);
      if (i1 * inc < start2)
        ++i1;
      if (i2 * inc > stop)
        --i2;
    }
    if (i2 < i1 && 0.5 <= count && count < 2)
      return tickSpec(start2, stop, count * 2);
    return [i1, i2, inc];
  }
  function ticks(start2, stop, count) {
    stop = +stop, start2 = +start2, count = +count;
    if (!(count > 0))
      return [];
    if (start2 === stop)
      return [start2];
    const reverse3 = stop < start2, [i1, i2, inc] = reverse3 ? tickSpec(stop, start2, count) : tickSpec(start2, stop, count);
    if (!(i2 >= i1))
      return [];
    const n = i2 - i1 + 1, ticks2 = new Array(n);
    if (reverse3) {
      if (inc < 0)
        for (let i = 0; i < n; ++i)
          ticks2[i] = (i2 - i) / -inc;
      else
        for (let i = 0; i < n; ++i)
          ticks2[i] = (i2 - i) * inc;
    } else {
      if (inc < 0)
        for (let i = 0; i < n; ++i)
          ticks2[i] = (i1 + i) / -inc;
      else
        for (let i = 0; i < n; ++i)
          ticks2[i] = (i1 + i) * inc;
    }
    return ticks2;
  }
  function tickIncrement(start2, stop, count) {
    stop = +stop, start2 = +start2, count = +count;
    return tickSpec(start2, stop, count)[2];
  }
  function tickStep(start2, stop, count) {
    stop = +stop, start2 = +start2, count = +count;
    const reverse3 = stop < start2, inc = reverse3 ? tickIncrement(stop, start2, count) : tickIncrement(start2, stop, count);
    return (reverse3 ? -1 : 1) * (inc < 0 ? 1 / -inc : inc);
  }

  // node_modules/d3-array/src/range.js
  function range(start2, stop, step) {
    start2 = +start2, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start2, start2 = 0, 1) : n < 3 ? 1 : +step;
    var i = -1, n = Math.max(0, Math.ceil((stop - start2) / step)) | 0, range4 = new Array(n);
    while (++i < n) {
      range4[i] = start2 + i * step;
    }
    return range4;
  }

  // node_modules/d3-axis/src/identity.js
  function identity_default(x2) {
    return x2;
  }

  // node_modules/d3-axis/src/axis.js
  var top = 1;
  var right = 2;
  var bottom = 3;
  var left = 4;
  var epsilon = 1e-6;
  function translateX(x2) {
    return "translate(" + x2 + ",0)";
  }
  function translateY(y2) {
    return "translate(0," + y2 + ")";
  }
  function number2(scale) {
    return (d) => +scale(d);
  }
  function center(scale, offset) {
    offset = Math.max(0, scale.bandwidth() - offset * 2) / 2;
    if (scale.round())
      offset = Math.round(offset);
    return (d) => +scale(d) + offset;
  }
  function entering() {
    return !this.__axis;
  }
  function axis(orient, scale) {
    var tickArguments = [], tickValues = null, tickFormat2 = null, tickSizeInner = 6, tickSizeOuter = 6, tickPadding = 3, offset = typeof window !== "undefined" && window.devicePixelRatio > 1 ? 0 : 0.5, k = orient === top || orient === left ? -1 : 1, x2 = orient === left || orient === right ? "x" : "y", transform2 = orient === top || orient === bottom ? translateX : translateY;
    function axis2(context) {
      var values3 = tickValues == null ? scale.ticks ? scale.ticks.apply(scale, tickArguments) : scale.domain() : tickValues, format2 = tickFormat2 == null ? scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments) : identity_default : tickFormat2, spacing = Math.max(tickSizeInner, 0) + tickPadding, range4 = scale.range(), range0 = +range4[0] + offset, range1 = +range4[range4.length - 1] + offset, position2 = (scale.bandwidth ? center : number2)(scale.copy(), offset), selection2 = context.selection ? context.selection() : context, path2 = selection2.selectAll(".domain").data([null]), tick = selection2.selectAll(".tick").data(values3, scale).order(), tickExit = tick.exit(), tickEnter = tick.enter().append("g").attr("class", "tick"), line2 = tick.select("line"), text2 = tick.select("text");
      path2 = path2.merge(path2.enter().insert("path", ".tick").attr("class", "domain").attr("stroke", "currentColor"));
      tick = tick.merge(tickEnter);
      line2 = line2.merge(tickEnter.append("line").attr("stroke", "currentColor").attr(x2 + "2", k * tickSizeInner));
      text2 = text2.merge(tickEnter.append("text").attr("fill", "currentColor").attr(x2, k * spacing).attr("dy", orient === top ? "0em" : orient === bottom ? "0.71em" : "0.32em"));
      if (context !== selection2) {
        path2 = path2.transition(context);
        tick = tick.transition(context);
        line2 = line2.transition(context);
        text2 = text2.transition(context);
        tickExit = tickExit.transition(context).attr("opacity", epsilon).attr("transform", function(d) {
          return isFinite(d = position2(d)) ? transform2(d + offset) : this.getAttribute("transform");
        });
        tickEnter.attr("opacity", epsilon).attr("transform", function(d) {
          var p = this.parentNode.__axis;
          return transform2((p && isFinite(p = p(d)) ? p : position2(d)) + offset);
        });
      }
      tickExit.remove();
      path2.attr("d", orient === left || orient === right ? tickSizeOuter ? "M" + k * tickSizeOuter + "," + range0 + "H" + offset + "V" + range1 + "H" + k * tickSizeOuter : "M" + offset + "," + range0 + "V" + range1 : tickSizeOuter ? "M" + range0 + "," + k * tickSizeOuter + "V" + offset + "H" + range1 + "V" + k * tickSizeOuter : "M" + range0 + "," + offset + "H" + range1);
      tick.attr("opacity", 1).attr("transform", function(d) {
        return transform2(position2(d) + offset);
      });
      line2.attr(x2 + "2", k * tickSizeInner);
      text2.attr(x2, k * spacing).text(format2);
      selection2.filter(entering).attr("fill", "none").attr("font-size", 10).attr("font-family", "sans-serif").attr("text-anchor", orient === right ? "start" : orient === left ? "end" : "middle");
      selection2.each(function() {
        this.__axis = position2;
      });
    }
    axis2.scale = function(_) {
      return arguments.length ? (scale = _, axis2) : scale;
    };
    axis2.ticks = function() {
      return tickArguments = Array.from(arguments), axis2;
    };
    axis2.tickArguments = function(_) {
      return arguments.length ? (tickArguments = _ == null ? [] : Array.from(_), axis2) : tickArguments.slice();
    };
    axis2.tickValues = function(_) {
      return arguments.length ? (tickValues = _ == null ? null : Array.from(_), axis2) : tickValues && tickValues.slice();
    };
    axis2.tickFormat = function(_) {
      return arguments.length ? (tickFormat2 = _, axis2) : tickFormat2;
    };
    axis2.tickSize = function(_) {
      return arguments.length ? (tickSizeInner = tickSizeOuter = +_, axis2) : tickSizeInner;
    };
    axis2.tickSizeInner = function(_) {
      return arguments.length ? (tickSizeInner = +_, axis2) : tickSizeInner;
    };
    axis2.tickSizeOuter = function(_) {
      return arguments.length ? (tickSizeOuter = +_, axis2) : tickSizeOuter;
    };
    axis2.tickPadding = function(_) {
      return arguments.length ? (tickPadding = +_, axis2) : tickPadding;
    };
    axis2.offset = function(_) {
      return arguments.length ? (offset = +_, axis2) : offset;
    };
    return axis2;
  }
  function axisBottom(scale) {
    return axis(bottom, scale);
  }
  function axisLeft(scale) {
    return axis(left, scale);
  }

  // node_modules/d3-dispatch/src/dispatch.js
  var noop = { value: () => {
  } };
  function dispatch() {
    for (var i = 0, n = arguments.length, _ = {}, t2; i < n; ++i) {
      if (!(t2 = arguments[i] + "") || t2 in _ || /[\s.]/.test(t2))
        throw new Error("illegal type: " + t2);
      _[t2] = [];
    }
    return new Dispatch(_);
  }
  function Dispatch(_) {
    this._ = _;
  }
  function parseTypenames(typenames, types2) {
    return typenames.trim().split(/^|\s+/).map(function(t2) {
      var name3 = "", i = t2.indexOf(".");
      if (i >= 0)
        name3 = t2.slice(i + 1), t2 = t2.slice(0, i);
      if (t2 && !types2.hasOwnProperty(t2))
        throw new Error("unknown type: " + t2);
      return { type: t2, name: name3 };
    });
  }
  Dispatch.prototype = dispatch.prototype = {
    constructor: Dispatch,
    on: function(typename, callback) {
      var _ = this._, T = parseTypenames(typename + "", _), t2, i = -1, n = T.length;
      if (arguments.length < 2) {
        while (++i < n)
          if ((t2 = (typename = T[i]).type) && (t2 = get(_[t2], typename.name)))
            return t2;
        return;
      }
      if (callback != null && typeof callback !== "function")
        throw new Error("invalid callback: " + callback);
      while (++i < n) {
        if (t2 = (typename = T[i]).type)
          _[t2] = set(_[t2], typename.name, callback);
        else if (callback == null)
          for (t2 in _)
            _[t2] = set(_[t2], typename.name, null);
      }
      return this;
    },
    copy: function() {
      var copy2 = {}, _ = this._;
      for (var t2 in _)
        copy2[t2] = _[t2].slice();
      return new Dispatch(copy2);
    },
    call: function(type2, that) {
      if ((n = arguments.length - 2) > 0)
        for (var args = new Array(n), i = 0, n, t2; i < n; ++i)
          args[i] = arguments[i + 2];
      if (!this._.hasOwnProperty(type2))
        throw new Error("unknown type: " + type2);
      for (t2 = this._[type2], i = 0, n = t2.length; i < n; ++i)
        t2[i].value.apply(that, args);
    },
    apply: function(type2, that, args) {
      if (!this._.hasOwnProperty(type2))
        throw new Error("unknown type: " + type2);
      for (var t2 = this._[type2], i = 0, n = t2.length; i < n; ++i)
        t2[i].value.apply(that, args);
    }
  };
  function get(type2, name3) {
    for (var i = 0, n = type2.length, c; i < n; ++i) {
      if ((c = type2[i]).name === name3) {
        return c.value;
      }
    }
  }
  function set(type2, name3, callback) {
    for (var i = 0, n = type2.length; i < n; ++i) {
      if (type2[i].name === name3) {
        type2[i] = noop, type2 = type2.slice(0, i).concat(type2.slice(i + 1));
        break;
      }
    }
    if (callback != null)
      type2.push({ name: name3, value: callback });
    return type2;
  }
  var dispatch_default = dispatch;

  // node_modules/d3-selection/src/namespaces.js
  var xhtml = "http://www.w3.org/1999/xhtml";
  var namespaces_default = {
    svg: "http://www.w3.org/2000/svg",
    xhtml,
    xlink: "http://www.w3.org/1999/xlink",
    xml: "http://www.w3.org/XML/1998/namespace",
    xmlns: "http://www.w3.org/2000/xmlns/"
  };

  // node_modules/d3-selection/src/namespace.js
  function namespace_default(name3) {
    var prefix = name3 += "", i = prefix.indexOf(":");
    if (i >= 0 && (prefix = name3.slice(0, i)) !== "xmlns")
      name3 = name3.slice(i + 1);
    return namespaces_default.hasOwnProperty(prefix) ? { space: namespaces_default[prefix], local: name3 } : name3;
  }

  // node_modules/d3-selection/src/creator.js
  function creatorInherit(name3) {
    return function() {
      var document2 = this.ownerDocument, uri = this.namespaceURI;
      return uri === xhtml && document2.documentElement.namespaceURI === xhtml ? document2.createElement(name3) : document2.createElementNS(uri, name3);
    };
  }
  function creatorFixed(fullname) {
    return function() {
      return this.ownerDocument.createElementNS(fullname.space, fullname.local);
    };
  }
  function creator_default(name3) {
    var fullname = namespace_default(name3);
    return (fullname.local ? creatorFixed : creatorInherit)(fullname);
  }

  // node_modules/d3-selection/src/selector.js
  function none() {
  }
  function selector_default(selector2) {
    return selector2 == null ? none : function() {
      return this.querySelector(selector2);
    };
  }

  // node_modules/d3-selection/src/selection/select.js
  function select_default(select2) {
    if (typeof select2 !== "function")
      select2 = selector_default(select2);
    for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
      for (var group3 = groups[j], n = group3.length, subgroup = subgroups[j] = new Array(n), node2, subnode, i = 0; i < n; ++i) {
        if ((node2 = group3[i]) && (subnode = select2.call(node2, node2.__data__, i, group3))) {
          if ("__data__" in node2)
            subnode.__data__ = node2.__data__;
          subgroup[i] = subnode;
        }
      }
    }
    return new Selection(subgroups, this._parents);
  }

  // node_modules/d3-selection/src/array.js
  function array(x2) {
    return x2 == null ? [] : Array.isArray(x2) ? x2 : Array.from(x2);
  }

  // node_modules/d3-selection/src/selectorAll.js
  function empty() {
    return [];
  }
  function selectorAll_default(selector2) {
    return selector2 == null ? empty : function() {
      return this.querySelectorAll(selector2);
    };
  }

  // node_modules/d3-selection/src/selection/selectAll.js
  function arrayAll(select2) {
    return function() {
      return array(select2.apply(this, arguments));
    };
  }
  function selectAll_default(select2) {
    if (typeof select2 === "function")
      select2 = arrayAll(select2);
    else
      select2 = selectorAll_default(select2);
    for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
      for (var group3 = groups[j], n = group3.length, node2, i = 0; i < n; ++i) {
        if (node2 = group3[i]) {
          subgroups.push(select2.call(node2, node2.__data__, i, group3));
          parents.push(node2);
        }
      }
    }
    return new Selection(subgroups, parents);
  }

  // node_modules/d3-selection/src/matcher.js
  function matcher_default(selector2) {
    return function() {
      return this.matches(selector2);
    };
  }
  function childMatcher(selector2) {
    return function(node2) {
      return node2.matches(selector2);
    };
  }

  // node_modules/d3-selection/src/selection/selectChild.js
  var find = Array.prototype.find;
  function childFind(match4) {
    return function() {
      return find.call(this.children, match4);
    };
  }
  function childFirst() {
    return this.firstElementChild;
  }
  function selectChild_default(match4) {
    return this.select(match4 == null ? childFirst : childFind(typeof match4 === "function" ? match4 : childMatcher(match4)));
  }

  // node_modules/d3-selection/src/selection/selectChildren.js
  var filter = Array.prototype.filter;
  function children() {
    return Array.from(this.children);
  }
  function childrenFilter(match4) {
    return function() {
      return filter.call(this.children, match4);
    };
  }
  function selectChildren_default(match4) {
    return this.selectAll(match4 == null ? children : childrenFilter(typeof match4 === "function" ? match4 : childMatcher(match4)));
  }

  // node_modules/d3-selection/src/selection/filter.js
  function filter_default(match4) {
    if (typeof match4 !== "function")
      match4 = matcher_default(match4);
    for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
      for (var group3 = groups[j], n = group3.length, subgroup = subgroups[j] = [], node2, i = 0; i < n; ++i) {
        if ((node2 = group3[i]) && match4.call(node2, node2.__data__, i, group3)) {
          subgroup.push(node2);
        }
      }
    }
    return new Selection(subgroups, this._parents);
  }

  // node_modules/d3-selection/src/selection/sparse.js
  function sparse_default(update3) {
    return new Array(update3.length);
  }

  // node_modules/d3-selection/src/selection/enter.js
  function enter_default() {
    return new Selection(this._enter || this._groups.map(sparse_default), this._parents);
  }
  function EnterNode(parent, datum3) {
    this.ownerDocument = parent.ownerDocument;
    this.namespaceURI = parent.namespaceURI;
    this._next = null;
    this._parent = parent;
    this.__data__ = datum3;
  }
  EnterNode.prototype = {
    constructor: EnterNode,
    appendChild: function(child) {
      return this._parent.insertBefore(child, this._next);
    },
    insertBefore: function(child, next) {
      return this._parent.insertBefore(child, next);
    },
    querySelector: function(selector2) {
      return this._parent.querySelector(selector2);
    },
    querySelectorAll: function(selector2) {
      return this._parent.querySelectorAll(selector2);
    }
  };

  // node_modules/d3-selection/src/constant.js
  function constant_default(x2) {
    return function() {
      return x2;
    };
  }

  // node_modules/d3-selection/src/selection/data.js
  function bindIndex(parent, group3, enter, update3, exit, data) {
    var i = 0, node2, groupLength = group3.length, dataLength = data.length;
    for (; i < dataLength; ++i) {
      if (node2 = group3[i]) {
        node2.__data__ = data[i];
        update3[i] = node2;
      } else {
        enter[i] = new EnterNode(parent, data[i]);
      }
    }
    for (; i < groupLength; ++i) {
      if (node2 = group3[i]) {
        exit[i] = node2;
      }
    }
  }
  function bindKey(parent, group3, enter, update3, exit, data, key) {
    var i, node2, nodeByKeyValue = /* @__PURE__ */ new Map(), groupLength = group3.length, dataLength = data.length, keyValues = new Array(groupLength), keyValue;
    for (i = 0; i < groupLength; ++i) {
      if (node2 = group3[i]) {
        keyValues[i] = keyValue = key.call(node2, node2.__data__, i, group3) + "";
        if (nodeByKeyValue.has(keyValue)) {
          exit[i] = node2;
        } else {
          nodeByKeyValue.set(keyValue, node2);
        }
      }
    }
    for (i = 0; i < dataLength; ++i) {
      keyValue = key.call(parent, data[i], i, data) + "";
      if (node2 = nodeByKeyValue.get(keyValue)) {
        update3[i] = node2;
        node2.__data__ = data[i];
        nodeByKeyValue.delete(keyValue);
      } else {
        enter[i] = new EnterNode(parent, data[i]);
      }
    }
    for (i = 0; i < groupLength; ++i) {
      if ((node2 = group3[i]) && nodeByKeyValue.get(keyValues[i]) === node2) {
        exit[i] = node2;
      }
    }
  }
  function datum(node2) {
    return node2.__data__;
  }
  function data_default(value, key) {
    if (!arguments.length)
      return Array.from(this, datum);
    var bind = key ? bindKey : bindIndex, parents = this._parents, groups = this._groups;
    if (typeof value !== "function")
      value = constant_default(value);
    for (var m = groups.length, update3 = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
      var parent = parents[j], group3 = groups[j], groupLength = group3.length, data = arraylike(value.call(parent, parent && parent.__data__, j, parents)), dataLength = data.length, enterGroup = enter[j] = new Array(dataLength), updateGroup = update3[j] = new Array(dataLength), exitGroup = exit[j] = new Array(groupLength);
      bind(parent, group3, enterGroup, updateGroup, exitGroup, data, key);
      for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
        if (previous = enterGroup[i0]) {
          if (i0 >= i1)
            i1 = i0 + 1;
          while (!(next = updateGroup[i1]) && ++i1 < dataLength)
            ;
          previous._next = next || null;
        }
      }
    }
    update3 = new Selection(update3, parents);
    update3._enter = enter;
    update3._exit = exit;
    return update3;
  }
  function arraylike(data) {
    return typeof data === "object" && "length" in data ? data : Array.from(data);
  }

  // node_modules/d3-selection/src/selection/exit.js
  function exit_default() {
    return new Selection(this._exit || this._groups.map(sparse_default), this._parents);
  }

  // node_modules/d3-selection/src/selection/join.js
  function join_default(onenter, onupdate, onexit) {
    var enter = this.enter(), update3 = this, exit = this.exit();
    if (typeof onenter === "function") {
      enter = onenter(enter);
      if (enter)
        enter = enter.selection();
    } else {
      enter = enter.append(onenter + "");
    }
    if (onupdate != null) {
      update3 = onupdate(update3);
      if (update3)
        update3 = update3.selection();
    }
    if (onexit == null)
      exit.remove();
    else
      onexit(exit);
    return enter && update3 ? enter.merge(update3).order() : update3;
  }

  // node_modules/d3-selection/src/selection/merge.js
  function merge_default(context) {
    var selection2 = context.selection ? context.selection() : context;
    for (var groups0 = this._groups, groups1 = selection2._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
      for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node2, i = 0; i < n; ++i) {
        if (node2 = group0[i] || group1[i]) {
          merge[i] = node2;
        }
      }
    }
    for (; j < m0; ++j) {
      merges[j] = groups0[j];
    }
    return new Selection(merges, this._parents);
  }

  // node_modules/d3-selection/src/selection/order.js
  function order_default() {
    for (var groups = this._groups, j = -1, m = groups.length; ++j < m; ) {
      for (var group3 = groups[j], i = group3.length - 1, next = group3[i], node2; --i >= 0; ) {
        if (node2 = group3[i]) {
          if (next && node2.compareDocumentPosition(next) ^ 4)
            next.parentNode.insertBefore(node2, next);
          next = node2;
        }
      }
    }
    return this;
  }

  // node_modules/d3-selection/src/selection/sort.js
  function sort_default(compare2) {
    if (!compare2)
      compare2 = ascending2;
    function compareNode(a, b) {
      return a && b ? compare2(a.__data__, b.__data__) : !a - !b;
    }
    for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
      for (var group3 = groups[j], n = group3.length, sortgroup = sortgroups[j] = new Array(n), node2, i = 0; i < n; ++i) {
        if (node2 = group3[i]) {
          sortgroup[i] = node2;
        }
      }
      sortgroup.sort(compareNode);
    }
    return new Selection(sortgroups, this._parents).order();
  }
  function ascending2(a, b) {
    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
  }

  // node_modules/d3-selection/src/selection/call.js
  function call_default() {
    var callback = arguments[0];
    arguments[0] = this;
    callback.apply(null, arguments);
    return this;
  }

  // node_modules/d3-selection/src/selection/nodes.js
  function nodes_default() {
    return Array.from(this);
  }

  // node_modules/d3-selection/src/selection/node.js
  function node_default() {
    for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
      for (var group3 = groups[j], i = 0, n = group3.length; i < n; ++i) {
        var node2 = group3[i];
        if (node2)
          return node2;
      }
    }
    return null;
  }

  // node_modules/d3-selection/src/selection/size.js
  function size_default() {
    let size3 = 0;
    for (const node2 of this)
      ++size3;
    return size3;
  }

  // node_modules/d3-selection/src/selection/empty.js
  function empty_default() {
    return !this.node();
  }

  // node_modules/d3-selection/src/selection/each.js
  function each_default(callback) {
    for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
      for (var group3 = groups[j], i = 0, n = group3.length, node2; i < n; ++i) {
        if (node2 = group3[i])
          callback.call(node2, node2.__data__, i, group3);
      }
    }
    return this;
  }

  // node_modules/d3-selection/src/selection/attr.js
  function attrRemove(name3) {
    return function() {
      this.removeAttribute(name3);
    };
  }
  function attrRemoveNS(fullname) {
    return function() {
      this.removeAttributeNS(fullname.space, fullname.local);
    };
  }
  function attrConstant(name3, value) {
    return function() {
      this.setAttribute(name3, value);
    };
  }
  function attrConstantNS(fullname, value) {
    return function() {
      this.setAttributeNS(fullname.space, fullname.local, value);
    };
  }
  function attrFunction(name3, value) {
    return function() {
      var v = value.apply(this, arguments);
      if (v == null)
        this.removeAttribute(name3);
      else
        this.setAttribute(name3, v);
    };
  }
  function attrFunctionNS(fullname, value) {
    return function() {
      var v = value.apply(this, arguments);
      if (v == null)
        this.removeAttributeNS(fullname.space, fullname.local);
      else
        this.setAttributeNS(fullname.space, fullname.local, v);
    };
  }
  function attr_default(name3, value) {
    var fullname = namespace_default(name3);
    if (arguments.length < 2) {
      var node2 = this.node();
      return fullname.local ? node2.getAttributeNS(fullname.space, fullname.local) : node2.getAttribute(fullname);
    }
    return this.each((value == null ? fullname.local ? attrRemoveNS : attrRemove : typeof value === "function" ? fullname.local ? attrFunctionNS : attrFunction : fullname.local ? attrConstantNS : attrConstant)(fullname, value));
  }

  // node_modules/d3-selection/src/window.js
  function window_default(node2) {
    return node2.ownerDocument && node2.ownerDocument.defaultView || node2.document && node2 || node2.defaultView;
  }

  // node_modules/d3-selection/src/selection/style.js
  function styleRemove(name3) {
    return function() {
      this.style.removeProperty(name3);
    };
  }
  function styleConstant(name3, value, priority) {
    return function() {
      this.style.setProperty(name3, value, priority);
    };
  }
  function styleFunction(name3, value, priority) {
    return function() {
      var v = value.apply(this, arguments);
      if (v == null)
        this.style.removeProperty(name3);
      else
        this.style.setProperty(name3, v, priority);
    };
  }
  function style_default(name3, value, priority) {
    return arguments.length > 1 ? this.each((value == null ? styleRemove : typeof value === "function" ? styleFunction : styleConstant)(name3, value, priority == null ? "" : priority)) : styleValue(this.node(), name3);
  }
  function styleValue(node2, name3) {
    return node2.style.getPropertyValue(name3) || window_default(node2).getComputedStyle(node2, null).getPropertyValue(name3);
  }

  // node_modules/d3-selection/src/selection/property.js
  function propertyRemove(name3) {
    return function() {
      delete this[name3];
    };
  }
  function propertyConstant(name3, value) {
    return function() {
      this[name3] = value;
    };
  }
  function propertyFunction(name3, value) {
    return function() {
      var v = value.apply(this, arguments);
      if (v == null)
        delete this[name3];
      else
        this[name3] = v;
    };
  }
  function property_default(name3, value) {
    return arguments.length > 1 ? this.each((value == null ? propertyRemove : typeof value === "function" ? propertyFunction : propertyConstant)(name3, value)) : this.node()[name3];
  }

  // node_modules/d3-selection/src/selection/classed.js
  function classArray(string4) {
    return string4.trim().split(/^|\s+/);
  }
  function classList(node2) {
    return node2.classList || new ClassList(node2);
  }
  function ClassList(node2) {
    this._node = node2;
    this._names = classArray(node2.getAttribute("class") || "");
  }
  ClassList.prototype = {
    add: function(name3) {
      var i = this._names.indexOf(name3);
      if (i < 0) {
        this._names.push(name3);
        this._node.setAttribute("class", this._names.join(" "));
      }
    },
    remove: function(name3) {
      var i = this._names.indexOf(name3);
      if (i >= 0) {
        this._names.splice(i, 1);
        this._node.setAttribute("class", this._names.join(" "));
      }
    },
    contains: function(name3) {
      return this._names.indexOf(name3) >= 0;
    }
  };
  function classedAdd(node2, names2) {
    var list = classList(node2), i = -1, n = names2.length;
    while (++i < n)
      list.add(names2[i]);
  }
  function classedRemove(node2, names2) {
    var list = classList(node2), i = -1, n = names2.length;
    while (++i < n)
      list.remove(names2[i]);
  }
  function classedTrue(names2) {
    return function() {
      classedAdd(this, names2);
    };
  }
  function classedFalse(names2) {
    return function() {
      classedRemove(this, names2);
    };
  }
  function classedFunction(names2, value) {
    return function() {
      (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names2);
    };
  }
  function classed_default(name3, value) {
    var names2 = classArray(name3 + "");
    if (arguments.length < 2) {
      var list = classList(this.node()), i = -1, n = names2.length;
      while (++i < n)
        if (!list.contains(names2[i]))
          return false;
      return true;
    }
    return this.each((typeof value === "function" ? classedFunction : value ? classedTrue : classedFalse)(names2, value));
  }

  // node_modules/d3-selection/src/selection/text.js
  function textRemove() {
    this.textContent = "";
  }
  function textConstant(value) {
    return function() {
      this.textContent = value;
    };
  }
  function textFunction(value) {
    return function() {
      var v = value.apply(this, arguments);
      this.textContent = v == null ? "" : v;
    };
  }
  function text_default(value) {
    return arguments.length ? this.each(value == null ? textRemove : (typeof value === "function" ? textFunction : textConstant)(value)) : this.node().textContent;
  }

  // node_modules/d3-selection/src/selection/html.js
  function htmlRemove() {
    this.innerHTML = "";
  }
  function htmlConstant(value) {
    return function() {
      this.innerHTML = value;
    };
  }
  function htmlFunction(value) {
    return function() {
      var v = value.apply(this, arguments);
      this.innerHTML = v == null ? "" : v;
    };
  }
  function html_default(value) {
    return arguments.length ? this.each(value == null ? htmlRemove : (typeof value === "function" ? htmlFunction : htmlConstant)(value)) : this.node().innerHTML;
  }

  // node_modules/d3-selection/src/selection/raise.js
  function raise() {
    if (this.nextSibling)
      this.parentNode.appendChild(this);
  }
  function raise_default() {
    return this.each(raise);
  }

  // node_modules/d3-selection/src/selection/lower.js
  function lower() {
    if (this.previousSibling)
      this.parentNode.insertBefore(this, this.parentNode.firstChild);
  }
  function lower_default() {
    return this.each(lower);
  }

  // node_modules/d3-selection/src/selection/append.js
  function append_default(name3) {
    var create2 = typeof name3 === "function" ? name3 : creator_default(name3);
    return this.select(function() {
      return this.appendChild(create2.apply(this, arguments));
    });
  }

  // node_modules/d3-selection/src/selection/insert.js
  function constantNull() {
    return null;
  }
  function insert_default(name3, before) {
    var create2 = typeof name3 === "function" ? name3 : creator_default(name3), select2 = before == null ? constantNull : typeof before === "function" ? before : selector_default(before);
    return this.select(function() {
      return this.insertBefore(create2.apply(this, arguments), select2.apply(this, arguments) || null);
    });
  }

  // node_modules/d3-selection/src/selection/remove.js
  function remove() {
    var parent = this.parentNode;
    if (parent)
      parent.removeChild(this);
  }
  function remove_default() {
    return this.each(remove);
  }

  // node_modules/d3-selection/src/selection/clone.js
  function selection_cloneShallow() {
    var clone = this.cloneNode(false), parent = this.parentNode;
    return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
  }
  function selection_cloneDeep() {
    var clone = this.cloneNode(true), parent = this.parentNode;
    return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
  }
  function clone_default(deep) {
    return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
  }

  // node_modules/d3-selection/src/selection/datum.js
  function datum_default(value) {
    return arguments.length ? this.property("__data__", value) : this.node().__data__;
  }

  // node_modules/d3-selection/src/selection/on.js
  function contextListener(listener) {
    return function(event) {
      listener.call(this, event, this.__data__);
    };
  }
  function parseTypenames2(typenames) {
    return typenames.trim().split(/^|\s+/).map(function(t2) {
      var name3 = "", i = t2.indexOf(".");
      if (i >= 0)
        name3 = t2.slice(i + 1), t2 = t2.slice(0, i);
      return { type: t2, name: name3 };
    });
  }
  function onRemove(typename) {
    return function() {
      var on2 = this.__on;
      if (!on2)
        return;
      for (var j = 0, i = -1, m = on2.length, o; j < m; ++j) {
        if (o = on2[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
          this.removeEventListener(o.type, o.listener, o.options);
        } else {
          on2[++i] = o;
        }
      }
      if (++i)
        on2.length = i;
      else
        delete this.__on;
    };
  }
  function onAdd(typename, value, options) {
    return function() {
      var on2 = this.__on, o, listener = contextListener(value);
      if (on2)
        for (var j = 0, m = on2.length; j < m; ++j) {
          if ((o = on2[j]).type === typename.type && o.name === typename.name) {
            this.removeEventListener(o.type, o.listener, o.options);
            this.addEventListener(o.type, o.listener = listener, o.options = options);
            o.value = value;
            return;
          }
        }
      this.addEventListener(typename.type, listener, options);
      o = { type: typename.type, name: typename.name, value, listener, options };
      if (!on2)
        this.__on = [o];
      else
        on2.push(o);
    };
  }
  function on_default(typename, value, options) {
    var typenames = parseTypenames2(typename + ""), i, n = typenames.length, t2;
    if (arguments.length < 2) {
      var on2 = this.node().__on;
      if (on2)
        for (var j = 0, m = on2.length, o; j < m; ++j) {
          for (i = 0, o = on2[j]; i < n; ++i) {
            if ((t2 = typenames[i]).type === o.type && t2.name === o.name) {
              return o.value;
            }
          }
        }
      return;
    }
    on2 = value ? onAdd : onRemove;
    for (i = 0; i < n; ++i)
      this.each(on2(typenames[i], value, options));
    return this;
  }

  // node_modules/d3-selection/src/selection/dispatch.js
  function dispatchEvent(node2, type2, params) {
    var window2 = window_default(node2), event = window2.CustomEvent;
    if (typeof event === "function") {
      event = new event(type2, params);
    } else {
      event = window2.document.createEvent("Event");
      if (params)
        event.initEvent(type2, params.bubbles, params.cancelable), event.detail = params.detail;
      else
        event.initEvent(type2, false, false);
    }
    node2.dispatchEvent(event);
  }
  function dispatchConstant(type2, params) {
    return function() {
      return dispatchEvent(this, type2, params);
    };
  }
  function dispatchFunction(type2, params) {
    return function() {
      return dispatchEvent(this, type2, params.apply(this, arguments));
    };
  }
  function dispatch_default2(type2, params) {
    return this.each((typeof params === "function" ? dispatchFunction : dispatchConstant)(type2, params));
  }

  // node_modules/d3-selection/src/selection/iterator.js
  function* iterator_default() {
    for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
      for (var group3 = groups[j], i = 0, n = group3.length, node2; i < n; ++i) {
        if (node2 = group3[i])
          yield node2;
      }
    }
  }

  // node_modules/d3-selection/src/selection/index.js
  var root = [null];
  function Selection(groups, parents) {
    this._groups = groups;
    this._parents = parents;
  }
  function selection() {
    return new Selection([[document.documentElement]], root);
  }
  function selection_selection() {
    return this;
  }
  Selection.prototype = selection.prototype = {
    constructor: Selection,
    select: select_default,
    selectAll: selectAll_default,
    selectChild: selectChild_default,
    selectChildren: selectChildren_default,
    filter: filter_default,
    data: data_default,
    enter: enter_default,
    exit: exit_default,
    join: join_default,
    merge: merge_default,
    selection: selection_selection,
    order: order_default,
    sort: sort_default,
    call: call_default,
    nodes: nodes_default,
    node: node_default,
    size: size_default,
    empty: empty_default,
    each: each_default,
    attr: attr_default,
    style: style_default,
    property: property_default,
    classed: classed_default,
    text: text_default,
    html: html_default,
    raise: raise_default,
    lower: lower_default,
    append: append_default,
    insert: insert_default,
    remove: remove_default,
    clone: clone_default,
    datum: datum_default,
    on: on_default,
    dispatch: dispatch_default2,
    [Symbol.iterator]: iterator_default
  };
  var selection_default = selection;

  // node_modules/d3-selection/src/select.js
  function select_default2(selector2) {
    return typeof selector2 === "string" ? new Selection([[document.querySelector(selector2)]], [document.documentElement]) : new Selection([[selector2]], root);
  }

  // node_modules/d3-color/src/define.js
  function define_default(constructor, factory, prototype) {
    constructor.prototype = factory.prototype = prototype;
    prototype.constructor = constructor;
  }
  function extend(parent, definition) {
    var prototype = Object.create(parent.prototype);
    for (var key in definition)
      prototype[key] = definition[key];
    return prototype;
  }

  // node_modules/d3-color/src/color.js
  function Color() {
  }
  var darker = 0.7;
  var brighter = 1 / darker;
  var reI = "\\s*([+-]?\\d+)\\s*";
  var reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*";
  var reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*";
  var reHex = /^#([0-9a-f]{3,8})$/;
  var reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`);
  var reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`);
  var reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`);
  var reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`);
  var reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`);
  var reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);
  var named = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
  };
  define_default(Color, color, {
    copy(channels) {
      return Object.assign(new this.constructor(), this, channels);
    },
    displayable() {
      return this.rgb().displayable();
    },
    hex: color_formatHex,
    formatHex: color_formatHex,
    formatHex8: color_formatHex8,
    formatHsl: color_formatHsl,
    formatRgb: color_formatRgb,
    toString: color_formatRgb
  });
  function color_formatHex() {
    return this.rgb().formatHex();
  }
  function color_formatHex8() {
    return this.rgb().formatHex8();
  }
  function color_formatHsl() {
    return hslConvert(this).formatHsl();
  }
  function color_formatRgb() {
    return this.rgb().formatRgb();
  }
  function color(format2) {
    var m, l;
    format2 = (format2 + "").trim().toLowerCase();
    return (m = reHex.exec(format2)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) : l === 3 ? new Rgb(m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, (m & 15) << 4 | m & 15, 1) : l === 8 ? rgba(m >> 24 & 255, m >> 16 & 255, m >> 8 & 255, (m & 255) / 255) : l === 4 ? rgba(m >> 12 & 15 | m >> 8 & 240, m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, ((m & 15) << 4 | m & 15) / 255) : null) : (m = reRgbInteger.exec(format2)) ? new Rgb(m[1], m[2], m[3], 1) : (m = reRgbPercent.exec(format2)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) : (m = reRgbaInteger.exec(format2)) ? rgba(m[1], m[2], m[3], m[4]) : (m = reRgbaPercent.exec(format2)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) : (m = reHslPercent.exec(format2)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) : (m = reHslaPercent.exec(format2)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) : named.hasOwnProperty(format2) ? rgbn(named[format2]) : format2 === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
  }
  function rgbn(n) {
    return new Rgb(n >> 16 & 255, n >> 8 & 255, n & 255, 1);
  }
  function rgba(r, g, b, a) {
    if (a <= 0)
      r = g = b = NaN;
    return new Rgb(r, g, b, a);
  }
  function rgbConvert(o) {
    if (!(o instanceof Color))
      o = color(o);
    if (!o)
      return new Rgb();
    o = o.rgb();
    return new Rgb(o.r, o.g, o.b, o.opacity);
  }
  function rgb(r, g, b, opacity) {
    return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
  }
  function Rgb(r, g, b, opacity) {
    this.r = +r;
    this.g = +g;
    this.b = +b;
    this.opacity = +opacity;
  }
  define_default(Rgb, rgb, extend(Color, {
    brighter(k) {
      k = k == null ? brighter : Math.pow(brighter, k);
      return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
    },
    darker(k) {
      k = k == null ? darker : Math.pow(darker, k);
      return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
    },
    rgb() {
      return this;
    },
    clamp() {
      return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
    },
    displayable() {
      return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
    },
    hex: rgb_formatHex,
    formatHex: rgb_formatHex,
    formatHex8: rgb_formatHex8,
    formatRgb: rgb_formatRgb,
    toString: rgb_formatRgb
  }));
  function rgb_formatHex() {
    return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;
  }
  function rgb_formatHex8() {
    return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
  }
  function rgb_formatRgb() {
    const a = clampa(this.opacity);
    return `${a === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a === 1 ? ")" : `, ${a})`}`;
  }
  function clampa(opacity) {
    return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
  }
  function clampi(value) {
    return Math.max(0, Math.min(255, Math.round(value) || 0));
  }
  function hex(value) {
    value = clampi(value);
    return (value < 16 ? "0" : "") + value.toString(16);
  }
  function hsla(h, s, l, a) {
    if (a <= 0)
      h = s = l = NaN;
    else if (l <= 0 || l >= 1)
      h = s = NaN;
    else if (s <= 0)
      h = NaN;
    return new Hsl(h, s, l, a);
  }
  function hslConvert(o) {
    if (o instanceof Hsl)
      return new Hsl(o.h, o.s, o.l, o.opacity);
    if (!(o instanceof Color))
      o = color(o);
    if (!o)
      return new Hsl();
    if (o instanceof Hsl)
      return o;
    o = o.rgb();
    var r = o.r / 255, g = o.g / 255, b = o.b / 255, min3 = Math.min(r, g, b), max5 = Math.max(r, g, b), h = NaN, s = max5 - min3, l = (max5 + min3) / 2;
    if (s) {
      if (r === max5)
        h = (g - b) / s + (g < b) * 6;
      else if (g === max5)
        h = (b - r) / s + 2;
      else
        h = (r - g) / s + 4;
      s /= l < 0.5 ? max5 + min3 : 2 - max5 - min3;
      h *= 60;
    } else {
      s = l > 0 && l < 1 ? 0 : h;
    }
    return new Hsl(h, s, l, o.opacity);
  }
  function hsl(h, s, l, opacity) {
    return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
  }
  function Hsl(h, s, l, opacity) {
    this.h = +h;
    this.s = +s;
    this.l = +l;
    this.opacity = +opacity;
  }
  define_default(Hsl, hsl, extend(Color, {
    brighter(k) {
      k = k == null ? brighter : Math.pow(brighter, k);
      return new Hsl(this.h, this.s, this.l * k, this.opacity);
    },
    darker(k) {
      k = k == null ? darker : Math.pow(darker, k);
      return new Hsl(this.h, this.s, this.l * k, this.opacity);
    },
    rgb() {
      var h = this.h % 360 + (this.h < 0) * 360, s = isNaN(h) || isNaN(this.s) ? 0 : this.s, l = this.l, m2 = l + (l < 0.5 ? l : 1 - l) * s, m1 = 2 * l - m2;
      return new Rgb(
        hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
        hsl2rgb(h, m1, m2),
        hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
        this.opacity
      );
    },
    clamp() {
      return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
    },
    displayable() {
      return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
    },
    formatHsl() {
      const a = clampa(this.opacity);
      return `${a === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a === 1 ? ")" : `, ${a})`}`;
    }
  }));
  function clamph(value) {
    value = (value || 0) % 360;
    return value < 0 ? value + 360 : value;
  }
  function clampt(value) {
    return Math.max(0, Math.min(1, value || 0));
  }
  function hsl2rgb(h, m1, m2) {
    return (h < 60 ? m1 + (m2 - m1) * h / 60 : h < 180 ? m2 : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60 : m1) * 255;
  }

  // node_modules/d3-interpolate/src/basis.js
  function basis(t1, v0, v1, v2, v3) {
    var t2 = t1 * t1, t3 = t2 * t1;
    return ((1 - 3 * t1 + 3 * t2 - t3) * v0 + (4 - 6 * t2 + 3 * t3) * v1 + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2 + t3 * v3) / 6;
  }
  function basis_default(values3) {
    var n = values3.length - 1;
    return function(t2) {
      var i = t2 <= 0 ? t2 = 0 : t2 >= 1 ? (t2 = 1, n - 1) : Math.floor(t2 * n), v1 = values3[i], v2 = values3[i + 1], v0 = i > 0 ? values3[i - 1] : 2 * v1 - v2, v3 = i < n - 1 ? values3[i + 2] : 2 * v2 - v1;
      return basis((t2 - i / n) * n, v0, v1, v2, v3);
    };
  }

  // node_modules/d3-interpolate/src/basisClosed.js
  function basisClosed_default(values3) {
    var n = values3.length;
    return function(t2) {
      var i = Math.floor(((t2 %= 1) < 0 ? ++t2 : t2) * n), v0 = values3[(i + n - 1) % n], v1 = values3[i % n], v2 = values3[(i + 1) % n], v3 = values3[(i + 2) % n];
      return basis((t2 - i / n) * n, v0, v1, v2, v3);
    };
  }

  // node_modules/d3-interpolate/src/constant.js
  var constant_default2 = (x2) => () => x2;

  // node_modules/d3-interpolate/src/color.js
  function linear(a, d) {
    return function(t2) {
      return a + t2 * d;
    };
  }
  function exponential(a, b, y2) {
    return a = Math.pow(a, y2), b = Math.pow(b, y2) - a, y2 = 1 / y2, function(t2) {
      return Math.pow(a + t2 * b, y2);
    };
  }
  function gamma(y2) {
    return (y2 = +y2) === 1 ? nogamma : function(a, b) {
      return b - a ? exponential(a, b, y2) : constant_default2(isNaN(a) ? b : a);
    };
  }
  function nogamma(a, b) {
    var d = b - a;
    return d ? linear(a, d) : constant_default2(isNaN(a) ? b : a);
  }

  // node_modules/d3-interpolate/src/rgb.js
  var rgb_default = function rgbGamma(y2) {
    var color2 = gamma(y2);
    function rgb2(start2, end) {
      var r = color2((start2 = rgb(start2)).r, (end = rgb(end)).r), g = color2(start2.g, end.g), b = color2(start2.b, end.b), opacity = nogamma(start2.opacity, end.opacity);
      return function(t2) {
        start2.r = r(t2);
        start2.g = g(t2);
        start2.b = b(t2);
        start2.opacity = opacity(t2);
        return start2 + "";
      };
    }
    rgb2.gamma = rgbGamma;
    return rgb2;
  }(1);
  function rgbSpline(spline) {
    return function(colors) {
      var n = colors.length, r = new Array(n), g = new Array(n), b = new Array(n), i, color2;
      for (i = 0; i < n; ++i) {
        color2 = rgb(colors[i]);
        r[i] = color2.r || 0;
        g[i] = color2.g || 0;
        b[i] = color2.b || 0;
      }
      r = spline(r);
      g = spline(g);
      b = spline(b);
      color2.opacity = 1;
      return function(t2) {
        color2.r = r(t2);
        color2.g = g(t2);
        color2.b = b(t2);
        return color2 + "";
      };
    };
  }
  var rgbBasis = rgbSpline(basis_default);
  var rgbBasisClosed = rgbSpline(basisClosed_default);

  // node_modules/d3-interpolate/src/numberArray.js
  function numberArray_default(a, b) {
    if (!b)
      b = [];
    var n = a ? Math.min(b.length, a.length) : 0, c = b.slice(), i;
    return function(t2) {
      for (i = 0; i < n; ++i)
        c[i] = a[i] * (1 - t2) + b[i] * t2;
      return c;
    };
  }
  function isNumberArray(x2) {
    return ArrayBuffer.isView(x2) && !(x2 instanceof DataView);
  }

  // node_modules/d3-interpolate/src/array.js
  function genericArray(a, b) {
    var nb = b ? b.length : 0, na = a ? Math.min(nb, a.length) : 0, x2 = new Array(na), c = new Array(nb), i;
    for (i = 0; i < na; ++i)
      x2[i] = value_default(a[i], b[i]);
    for (; i < nb; ++i)
      c[i] = b[i];
    return function(t2) {
      for (i = 0; i < na; ++i)
        c[i] = x2[i](t2);
      return c;
    };
  }

  // node_modules/d3-interpolate/src/date.js
  function date_default(a, b) {
    var d = new Date();
    return a = +a, b = +b, function(t2) {
      return d.setTime(a * (1 - t2) + b * t2), d;
    };
  }

  // node_modules/d3-interpolate/src/number.js
  function number_default(a, b) {
    return a = +a, b = +b, function(t2) {
      return a * (1 - t2) + b * t2;
    };
  }

  // node_modules/d3-interpolate/src/object.js
  function object_default(a, b) {
    var i = {}, c = {}, k;
    if (a === null || typeof a !== "object")
      a = {};
    if (b === null || typeof b !== "object")
      b = {};
    for (k in b) {
      if (k in a) {
        i[k] = value_default(a[k], b[k]);
      } else {
        c[k] = b[k];
      }
    }
    return function(t2) {
      for (k in i)
        c[k] = i[k](t2);
      return c;
    };
  }

  // node_modules/d3-interpolate/src/string.js
  var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
  var reB = new RegExp(reA.source, "g");
  function zero2(b) {
    return function() {
      return b;
    };
  }
  function one(b) {
    return function(t2) {
      return b(t2) + "";
    };
  }
  function string_default(a, b) {
    var bi = reA.lastIndex = reB.lastIndex = 0, am, bm, bs, i = -1, s = [], q = [];
    a = a + "", b = b + "";
    while ((am = reA.exec(a)) && (bm = reB.exec(b))) {
      if ((bs = bm.index) > bi) {
        bs = b.slice(bi, bs);
        if (s[i])
          s[i] += bs;
        else
          s[++i] = bs;
      }
      if ((am = am[0]) === (bm = bm[0])) {
        if (s[i])
          s[i] += bm;
        else
          s[++i] = bm;
      } else {
        s[++i] = null;
        q.push({ i, x: number_default(am, bm) });
      }
      bi = reB.lastIndex;
    }
    if (bi < b.length) {
      bs = b.slice(bi);
      if (s[i])
        s[i] += bs;
      else
        s[++i] = bs;
    }
    return s.length < 2 ? q[0] ? one(q[0].x) : zero2(b) : (b = q.length, function(t2) {
      for (var i2 = 0, o; i2 < b; ++i2)
        s[(o = q[i2]).i] = o.x(t2);
      return s.join("");
    });
  }

  // node_modules/d3-interpolate/src/value.js
  function value_default(a, b) {
    var t2 = typeof b, c;
    return b == null || t2 === "boolean" ? constant_default2(b) : (t2 === "number" ? number_default : t2 === "string" ? (c = color(b)) ? (b = c, rgb_default) : string_default : b instanceof color ? rgb_default : b instanceof Date ? date_default : isNumberArray(b) ? numberArray_default : Array.isArray(b) ? genericArray : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object_default : number_default)(a, b);
  }

  // node_modules/d3-interpolate/src/round.js
  function round_default(a, b) {
    return a = +a, b = +b, function(t2) {
      return Math.round(a * (1 - t2) + b * t2);
    };
  }

  // node_modules/d3-interpolate/src/transform/decompose.js
  var degrees = 180 / Math.PI;
  var identity = {
    translateX: 0,
    translateY: 0,
    rotate: 0,
    skewX: 0,
    scaleX: 1,
    scaleY: 1
  };
  function decompose_default(a, b, c, d, e, f) {
    var scaleX, scaleY, skewX;
    if (scaleX = Math.sqrt(a * a + b * b))
      a /= scaleX, b /= scaleX;
    if (skewX = a * c + b * d)
      c -= a * skewX, d -= b * skewX;
    if (scaleY = Math.sqrt(c * c + d * d))
      c /= scaleY, d /= scaleY, skewX /= scaleY;
    if (a * d < b * c)
      a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
    return {
      translateX: e,
      translateY: f,
      rotate: Math.atan2(b, a) * degrees,
      skewX: Math.atan(skewX) * degrees,
      scaleX,
      scaleY
    };
  }

  // node_modules/d3-interpolate/src/transform/parse.js
  var svgNode;
  function parseCss(value) {
    const m = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value + "");
    return m.isIdentity ? identity : decompose_default(m.a, m.b, m.c, m.d, m.e, m.f);
  }
  function parseSvg(value) {
    if (value == null)
      return identity;
    if (!svgNode)
      svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
    svgNode.setAttribute("transform", value);
    if (!(value = svgNode.transform.baseVal.consolidate()))
      return identity;
    value = value.matrix;
    return decompose_default(value.a, value.b, value.c, value.d, value.e, value.f);
  }

  // node_modules/d3-interpolate/src/transform/index.js
  function interpolateTransform(parse2, pxComma, pxParen, degParen) {
    function pop(s) {
      return s.length ? s.pop() + " " : "";
    }
    function translate2(xa, ya, xb, yb, s, q) {
      if (xa !== xb || ya !== yb) {
        var i = s.push("translate(", null, pxComma, null, pxParen);
        q.push({ i: i - 4, x: number_default(xa, xb) }, { i: i - 2, x: number_default(ya, yb) });
      } else if (xb || yb) {
        s.push("translate(" + xb + pxComma + yb + pxParen);
      }
    }
    function rotate(a, b, s, q) {
      if (a !== b) {
        if (a - b > 180)
          b += 360;
        else if (b - a > 180)
          a += 360;
        q.push({ i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: number_default(a, b) });
      } else if (b) {
        s.push(pop(s) + "rotate(" + b + degParen);
      }
    }
    function skewX(a, b, s, q) {
      if (a !== b) {
        q.push({ i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: number_default(a, b) });
      } else if (b) {
        s.push(pop(s) + "skewX(" + b + degParen);
      }
    }
    function scale(xa, ya, xb, yb, s, q) {
      if (xa !== xb || ya !== yb) {
        var i = s.push(pop(s) + "scale(", null, ",", null, ")");
        q.push({ i: i - 4, x: number_default(xa, xb) }, { i: i - 2, x: number_default(ya, yb) });
      } else if (xb !== 1 || yb !== 1) {
        s.push(pop(s) + "scale(" + xb + "," + yb + ")");
      }
    }
    return function(a, b) {
      var s = [], q = [];
      a = parse2(a), b = parse2(b);
      translate2(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
      rotate(a.rotate, b.rotate, s, q);
      skewX(a.skewX, b.skewX, s, q);
      scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
      a = b = null;
      return function(t2) {
        var i = -1, n = q.length, o;
        while (++i < n)
          s[(o = q[i]).i] = o.x(t2);
        return s.join("");
      };
    };
  }
  var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
  var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");

  // node_modules/d3-timer/src/timer.js
  var frame = 0;
  var timeout = 0;
  var interval = 0;
  var pokeDelay = 1e3;
  var taskHead;
  var taskTail;
  var clockLast = 0;
  var clockNow = 0;
  var clockSkew = 0;
  var clock = typeof performance === "object" && performance.now ? performance : Date;
  var setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) {
    setTimeout(f, 17);
  };
  function now() {
    return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
  }
  function clearNow() {
    clockNow = 0;
  }
  function Timer() {
    this._call = this._time = this._next = null;
  }
  Timer.prototype = timer.prototype = {
    constructor: Timer,
    restart: function(callback, delay, time2) {
      if (typeof callback !== "function")
        throw new TypeError("callback is not a function");
      time2 = (time2 == null ? now() : +time2) + (delay == null ? 0 : +delay);
      if (!this._next && taskTail !== this) {
        if (taskTail)
          taskTail._next = this;
        else
          taskHead = this;
        taskTail = this;
      }
      this._call = callback;
      this._time = time2;
      sleep();
    },
    stop: function() {
      if (this._call) {
        this._call = null;
        this._time = Infinity;
        sleep();
      }
    }
  };
  function timer(callback, delay, time2) {
    var t2 = new Timer();
    t2.restart(callback, delay, time2);
    return t2;
  }
  function timerFlush() {
    now();
    ++frame;
    var t2 = taskHead, e;
    while (t2) {
      if ((e = clockNow - t2._time) >= 0)
        t2._call.call(void 0, e);
      t2 = t2._next;
    }
    --frame;
  }
  function wake() {
    clockNow = (clockLast = clock.now()) + clockSkew;
    frame = timeout = 0;
    try {
      timerFlush();
    } finally {
      frame = 0;
      nap();
      clockNow = 0;
    }
  }
  function poke() {
    var now3 = clock.now(), delay = now3 - clockLast;
    if (delay > pokeDelay)
      clockSkew -= delay, clockLast = now3;
  }
  function nap() {
    var t0, t1 = taskHead, t2, time2 = Infinity;
    while (t1) {
      if (t1._call) {
        if (time2 > t1._time)
          time2 = t1._time;
        t0 = t1, t1 = t1._next;
      } else {
        t2 = t1._next, t1._next = null;
        t1 = t0 ? t0._next = t2 : taskHead = t2;
      }
    }
    taskTail = t0;
    sleep(time2);
  }
  function sleep(time2) {
    if (frame)
      return;
    if (timeout)
      timeout = clearTimeout(timeout);
    var delay = time2 - clockNow;
    if (delay > 24) {
      if (time2 < Infinity)
        timeout = setTimeout(wake, time2 - clock.now() - clockSkew);
      if (interval)
        interval = clearInterval(interval);
    } else {
      if (!interval)
        clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
      frame = 1, setFrame(wake);
    }
  }

  // node_modules/d3-timer/src/timeout.js
  function timeout_default(callback, delay, time2) {
    var t2 = new Timer();
    delay = delay == null ? 0 : +delay;
    t2.restart((elapsed) => {
      t2.stop();
      callback(elapsed + delay);
    }, delay, time2);
    return t2;
  }

  // node_modules/d3-transition/src/transition/schedule.js
  var emptyOn = dispatch_default("start", "end", "cancel", "interrupt");
  var emptyTween = [];
  var CREATED = 0;
  var SCHEDULED = 1;
  var STARTING = 2;
  var STARTED = 3;
  var RUNNING = 4;
  var ENDING = 5;
  var ENDED = 6;
  function schedule_default(node2, name3, id3, index3, group3, timing) {
    var schedules = node2.__transition;
    if (!schedules)
      node2.__transition = {};
    else if (id3 in schedules)
      return;
    create(node2, id3, {
      name: name3,
      index: index3,
      group: group3,
      on: emptyOn,
      tween: emptyTween,
      time: timing.time,
      delay: timing.delay,
      duration: timing.duration,
      ease: timing.ease,
      timer: null,
      state: CREATED
    });
  }
  function init(node2, id3) {
    var schedule = get2(node2, id3);
    if (schedule.state > CREATED)
      throw new Error("too late; already scheduled");
    return schedule;
  }
  function set2(node2, id3) {
    var schedule = get2(node2, id3);
    if (schedule.state > STARTED)
      throw new Error("too late; already running");
    return schedule;
  }
  function get2(node2, id3) {
    var schedule = node2.__transition;
    if (!schedule || !(schedule = schedule[id3]))
      throw new Error("transition not found");
    return schedule;
  }
  function create(node2, id3, self) {
    var schedules = node2.__transition, tween;
    schedules[id3] = self;
    self.timer = timer(schedule, 0, self.time);
    function schedule(elapsed) {
      self.state = SCHEDULED;
      self.timer.restart(start2, self.delay, self.time);
      if (self.delay <= elapsed)
        start2(elapsed - self.delay);
    }
    function start2(elapsed) {
      var i, j, n, o;
      if (self.state !== SCHEDULED)
        return stop();
      for (i in schedules) {
        o = schedules[i];
        if (o.name !== self.name)
          continue;
        if (o.state === STARTED)
          return timeout_default(start2);
        if (o.state === RUNNING) {
          o.state = ENDED;
          o.timer.stop();
          o.on.call("interrupt", node2, node2.__data__, o.index, o.group);
          delete schedules[i];
        } else if (+i < id3) {
          o.state = ENDED;
          o.timer.stop();
          o.on.call("cancel", node2, node2.__data__, o.index, o.group);
          delete schedules[i];
        }
      }
      timeout_default(function() {
        if (self.state === STARTED) {
          self.state = RUNNING;
          self.timer.restart(tick, self.delay, self.time);
          tick(elapsed);
        }
      });
      self.state = STARTING;
      self.on.call("start", node2, node2.__data__, self.index, self.group);
      if (self.state !== STARTING)
        return;
      self.state = STARTED;
      tween = new Array(n = self.tween.length);
      for (i = 0, j = -1; i < n; ++i) {
        if (o = self.tween[i].value.call(node2, node2.__data__, self.index, self.group)) {
          tween[++j] = o;
        }
      }
      tween.length = j + 1;
    }
    function tick(elapsed) {
      var t2 = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1), i = -1, n = tween.length;
      while (++i < n) {
        tween[i].call(node2, t2);
      }
      if (self.state === ENDING) {
        self.on.call("end", node2, node2.__data__, self.index, self.group);
        stop();
      }
    }
    function stop() {
      self.state = ENDED;
      self.timer.stop();
      delete schedules[id3];
      for (var i in schedules)
        return;
      delete node2.__transition;
    }
  }

  // node_modules/d3-transition/src/interrupt.js
  function interrupt_default(node2, name3) {
    var schedules = node2.__transition, schedule, active, empty4 = true, i;
    if (!schedules)
      return;
    name3 = name3 == null ? null : name3 + "";
    for (i in schedules) {
      if ((schedule = schedules[i]).name !== name3) {
        empty4 = false;
        continue;
      }
      active = schedule.state > STARTING && schedule.state < ENDING;
      schedule.state = ENDED;
      schedule.timer.stop();
      schedule.on.call(active ? "interrupt" : "cancel", node2, node2.__data__, schedule.index, schedule.group);
      delete schedules[i];
    }
    if (empty4)
      delete node2.__transition;
  }

  // node_modules/d3-transition/src/selection/interrupt.js
  function interrupt_default2(name3) {
    return this.each(function() {
      interrupt_default(this, name3);
    });
  }

  // node_modules/d3-transition/src/transition/tween.js
  function tweenRemove(id3, name3) {
    var tween0, tween1;
    return function() {
      var schedule = set2(this, id3), tween = schedule.tween;
      if (tween !== tween0) {
        tween1 = tween0 = tween;
        for (var i = 0, n = tween1.length; i < n; ++i) {
          if (tween1[i].name === name3) {
            tween1 = tween1.slice();
            tween1.splice(i, 1);
            break;
          }
        }
      }
      schedule.tween = tween1;
    };
  }
  function tweenFunction(id3, name3, value) {
    var tween0, tween1;
    if (typeof value !== "function")
      throw new Error();
    return function() {
      var schedule = set2(this, id3), tween = schedule.tween;
      if (tween !== tween0) {
        tween1 = (tween0 = tween).slice();
        for (var t2 = { name: name3, value }, i = 0, n = tween1.length; i < n; ++i) {
          if (tween1[i].name === name3) {
            tween1[i] = t2;
            break;
          }
        }
        if (i === n)
          tween1.push(t2);
      }
      schedule.tween = tween1;
    };
  }
  function tween_default(name3, value) {
    var id3 = this._id;
    name3 += "";
    if (arguments.length < 2) {
      var tween = get2(this.node(), id3).tween;
      for (var i = 0, n = tween.length, t2; i < n; ++i) {
        if ((t2 = tween[i]).name === name3) {
          return t2.value;
        }
      }
      return null;
    }
    return this.each((value == null ? tweenRemove : tweenFunction)(id3, name3, value));
  }
  function tweenValue(transition2, name3, value) {
    var id3 = transition2._id;
    transition2.each(function() {
      var schedule = set2(this, id3);
      (schedule.value || (schedule.value = {}))[name3] = value.apply(this, arguments);
    });
    return function(node2) {
      return get2(node2, id3).value[name3];
    };
  }

  // node_modules/d3-transition/src/transition/interpolate.js
  function interpolate_default(a, b) {
    var c;
    return (typeof b === "number" ? number_default : b instanceof color ? rgb_default : (c = color(b)) ? (b = c, rgb_default) : string_default)(a, b);
  }

  // node_modules/d3-transition/src/transition/attr.js
  function attrRemove2(name3) {
    return function() {
      this.removeAttribute(name3);
    };
  }
  function attrRemoveNS2(fullname) {
    return function() {
      this.removeAttributeNS(fullname.space, fullname.local);
    };
  }
  function attrConstant2(name3, interpolate, value1) {
    var string00, string1 = value1 + "", interpolate0;
    return function() {
      var string0 = this.getAttribute(name3);
      return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
    };
  }
  function attrConstantNS2(fullname, interpolate, value1) {
    var string00, string1 = value1 + "", interpolate0;
    return function() {
      var string0 = this.getAttributeNS(fullname.space, fullname.local);
      return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
    };
  }
  function attrFunction2(name3, interpolate, value) {
    var string00, string10, interpolate0;
    return function() {
      var string0, value1 = value(this), string1;
      if (value1 == null)
        return void this.removeAttribute(name3);
      string0 = this.getAttribute(name3);
      string1 = value1 + "";
      return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
    };
  }
  function attrFunctionNS2(fullname, interpolate, value) {
    var string00, string10, interpolate0;
    return function() {
      var string0, value1 = value(this), string1;
      if (value1 == null)
        return void this.removeAttributeNS(fullname.space, fullname.local);
      string0 = this.getAttributeNS(fullname.space, fullname.local);
      string1 = value1 + "";
      return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
    };
  }
  function attr_default2(name3, value) {
    var fullname = namespace_default(name3), i = fullname === "transform" ? interpolateTransformSvg : interpolate_default;
    return this.attrTween(name3, typeof value === "function" ? (fullname.local ? attrFunctionNS2 : attrFunction2)(fullname, i, tweenValue(this, "attr." + name3, value)) : value == null ? (fullname.local ? attrRemoveNS2 : attrRemove2)(fullname) : (fullname.local ? attrConstantNS2 : attrConstant2)(fullname, i, value));
  }

  // node_modules/d3-transition/src/transition/attrTween.js
  function attrInterpolate(name3, i) {
    return function(t2) {
      this.setAttribute(name3, i.call(this, t2));
    };
  }
  function attrInterpolateNS(fullname, i) {
    return function(t2) {
      this.setAttributeNS(fullname.space, fullname.local, i.call(this, t2));
    };
  }
  function attrTweenNS(fullname, value) {
    var t0, i0;
    function tween() {
      var i = value.apply(this, arguments);
      if (i !== i0)
        t0 = (i0 = i) && attrInterpolateNS(fullname, i);
      return t0;
    }
    tween._value = value;
    return tween;
  }
  function attrTween(name3, value) {
    var t0, i0;
    function tween() {
      var i = value.apply(this, arguments);
      if (i !== i0)
        t0 = (i0 = i) && attrInterpolate(name3, i);
      return t0;
    }
    tween._value = value;
    return tween;
  }
  function attrTween_default(name3, value) {
    var key = "attr." + name3;
    if (arguments.length < 2)
      return (key = this.tween(key)) && key._value;
    if (value == null)
      return this.tween(key, null);
    if (typeof value !== "function")
      throw new Error();
    var fullname = namespace_default(name3);
    return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
  }

  // node_modules/d3-transition/src/transition/delay.js
  function delayFunction(id3, value) {
    return function() {
      init(this, id3).delay = +value.apply(this, arguments);
    };
  }
  function delayConstant(id3, value) {
    return value = +value, function() {
      init(this, id3).delay = value;
    };
  }
  function delay_default(value) {
    var id3 = this._id;
    return arguments.length ? this.each((typeof value === "function" ? delayFunction : delayConstant)(id3, value)) : get2(this.node(), id3).delay;
  }

  // node_modules/d3-transition/src/transition/duration.js
  function durationFunction(id3, value) {
    return function() {
      set2(this, id3).duration = +value.apply(this, arguments);
    };
  }
  function durationConstant(id3, value) {
    return value = +value, function() {
      set2(this, id3).duration = value;
    };
  }
  function duration_default(value) {
    var id3 = this._id;
    return arguments.length ? this.each((typeof value === "function" ? durationFunction : durationConstant)(id3, value)) : get2(this.node(), id3).duration;
  }

  // node_modules/d3-transition/src/transition/ease.js
  function easeConstant(id3, value) {
    if (typeof value !== "function")
      throw new Error();
    return function() {
      set2(this, id3).ease = value;
    };
  }
  function ease_default(value) {
    var id3 = this._id;
    return arguments.length ? this.each(easeConstant(id3, value)) : get2(this.node(), id3).ease;
  }

  // node_modules/d3-transition/src/transition/easeVarying.js
  function easeVarying(id3, value) {
    return function() {
      var v = value.apply(this, arguments);
      if (typeof v !== "function")
        throw new Error();
      set2(this, id3).ease = v;
    };
  }
  function easeVarying_default(value) {
    if (typeof value !== "function")
      throw new Error();
    return this.each(easeVarying(this._id, value));
  }

  // node_modules/d3-transition/src/transition/filter.js
  function filter_default2(match4) {
    if (typeof match4 !== "function")
      match4 = matcher_default(match4);
    for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
      for (var group3 = groups[j], n = group3.length, subgroup = subgroups[j] = [], node2, i = 0; i < n; ++i) {
        if ((node2 = group3[i]) && match4.call(node2, node2.__data__, i, group3)) {
          subgroup.push(node2);
        }
      }
    }
    return new Transition(subgroups, this._parents, this._name, this._id);
  }

  // node_modules/d3-transition/src/transition/merge.js
  function merge_default2(transition2) {
    if (transition2._id !== this._id)
      throw new Error();
    for (var groups0 = this._groups, groups1 = transition2._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
      for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node2, i = 0; i < n; ++i) {
        if (node2 = group0[i] || group1[i]) {
          merge[i] = node2;
        }
      }
    }
    for (; j < m0; ++j) {
      merges[j] = groups0[j];
    }
    return new Transition(merges, this._parents, this._name, this._id);
  }

  // node_modules/d3-transition/src/transition/on.js
  function start(name3) {
    return (name3 + "").trim().split(/^|\s+/).every(function(t2) {
      var i = t2.indexOf(".");
      if (i >= 0)
        t2 = t2.slice(0, i);
      return !t2 || t2 === "start";
    });
  }
  function onFunction(id3, name3, listener) {
    var on0, on1, sit = start(name3) ? init : set2;
    return function() {
      var schedule = sit(this, id3), on2 = schedule.on;
      if (on2 !== on0)
        (on1 = (on0 = on2).copy()).on(name3, listener);
      schedule.on = on1;
    };
  }
  function on_default2(name3, listener) {
    var id3 = this._id;
    return arguments.length < 2 ? get2(this.node(), id3).on.on(name3) : this.each(onFunction(id3, name3, listener));
  }

  // node_modules/d3-transition/src/transition/remove.js
  function removeFunction(id3) {
    return function() {
      var parent = this.parentNode;
      for (var i in this.__transition)
        if (+i !== id3)
          return;
      if (parent)
        parent.removeChild(this);
    };
  }
  function remove_default2() {
    return this.on("end.remove", removeFunction(this._id));
  }

  // node_modules/d3-transition/src/transition/select.js
  function select_default3(select2) {
    var name3 = this._name, id3 = this._id;
    if (typeof select2 !== "function")
      select2 = selector_default(select2);
    for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
      for (var group3 = groups[j], n = group3.length, subgroup = subgroups[j] = new Array(n), node2, subnode, i = 0; i < n; ++i) {
        if ((node2 = group3[i]) && (subnode = select2.call(node2, node2.__data__, i, group3))) {
          if ("__data__" in node2)
            subnode.__data__ = node2.__data__;
          subgroup[i] = subnode;
          schedule_default(subgroup[i], name3, id3, i, subgroup, get2(node2, id3));
        }
      }
    }
    return new Transition(subgroups, this._parents, name3, id3);
  }

  // node_modules/d3-transition/src/transition/selectAll.js
  function selectAll_default2(select2) {
    var name3 = this._name, id3 = this._id;
    if (typeof select2 !== "function")
      select2 = selectorAll_default(select2);
    for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
      for (var group3 = groups[j], n = group3.length, node2, i = 0; i < n; ++i) {
        if (node2 = group3[i]) {
          for (var children2 = select2.call(node2, node2.__data__, i, group3), child, inherit2 = get2(node2, id3), k = 0, l = children2.length; k < l; ++k) {
            if (child = children2[k]) {
              schedule_default(child, name3, id3, k, children2, inherit2);
            }
          }
          subgroups.push(children2);
          parents.push(node2);
        }
      }
    }
    return new Transition(subgroups, parents, name3, id3);
  }

  // node_modules/d3-transition/src/transition/selection.js
  var Selection2 = selection_default.prototype.constructor;
  function selection_default2() {
    return new Selection2(this._groups, this._parents);
  }

  // node_modules/d3-transition/src/transition/style.js
  function styleNull(name3, interpolate) {
    var string00, string10, interpolate0;
    return function() {
      var string0 = styleValue(this, name3), string1 = (this.style.removeProperty(name3), styleValue(this, name3));
      return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : interpolate0 = interpolate(string00 = string0, string10 = string1);
    };
  }
  function styleRemove2(name3) {
    return function() {
      this.style.removeProperty(name3);
    };
  }
  function styleConstant2(name3, interpolate, value1) {
    var string00, string1 = value1 + "", interpolate0;
    return function() {
      var string0 = styleValue(this, name3);
      return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
    };
  }
  function styleFunction2(name3, interpolate, value) {
    var string00, string10, interpolate0;
    return function() {
      var string0 = styleValue(this, name3), value1 = value(this), string1 = value1 + "";
      if (value1 == null)
        string1 = value1 = (this.style.removeProperty(name3), styleValue(this, name3));
      return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
    };
  }
  function styleMaybeRemove(id3, name3) {
    var on0, on1, listener0, key = "style." + name3, event = "end." + key, remove4;
    return function() {
      var schedule = set2(this, id3), on2 = schedule.on, listener = schedule.value[key] == null ? remove4 || (remove4 = styleRemove2(name3)) : void 0;
      if (on2 !== on0 || listener0 !== listener)
        (on1 = (on0 = on2).copy()).on(event, listener0 = listener);
      schedule.on = on1;
    };
  }
  function style_default2(name3, value, priority) {
    var i = (name3 += "") === "transform" ? interpolateTransformCss : interpolate_default;
    return value == null ? this.styleTween(name3, styleNull(name3, i)).on("end.style." + name3, styleRemove2(name3)) : typeof value === "function" ? this.styleTween(name3, styleFunction2(name3, i, tweenValue(this, "style." + name3, value))).each(styleMaybeRemove(this._id, name3)) : this.styleTween(name3, styleConstant2(name3, i, value), priority).on("end.style." + name3, null);
  }

  // node_modules/d3-transition/src/transition/styleTween.js
  function styleInterpolate(name3, i, priority) {
    return function(t2) {
      this.style.setProperty(name3, i.call(this, t2), priority);
    };
  }
  function styleTween(name3, value, priority) {
    var t2, i0;
    function tween() {
      var i = value.apply(this, arguments);
      if (i !== i0)
        t2 = (i0 = i) && styleInterpolate(name3, i, priority);
      return t2;
    }
    tween._value = value;
    return tween;
  }
  function styleTween_default(name3, value, priority) {
    var key = "style." + (name3 += "");
    if (arguments.length < 2)
      return (key = this.tween(key)) && key._value;
    if (value == null)
      return this.tween(key, null);
    if (typeof value !== "function")
      throw new Error();
    return this.tween(key, styleTween(name3, value, priority == null ? "" : priority));
  }

  // node_modules/d3-transition/src/transition/text.js
  function textConstant2(value) {
    return function() {
      this.textContent = value;
    };
  }
  function textFunction2(value) {
    return function() {
      var value1 = value(this);
      this.textContent = value1 == null ? "" : value1;
    };
  }
  function text_default2(value) {
    return this.tween("text", typeof value === "function" ? textFunction2(tweenValue(this, "text", value)) : textConstant2(value == null ? "" : value + ""));
  }

  // node_modules/d3-transition/src/transition/textTween.js
  function textInterpolate(i) {
    return function(t2) {
      this.textContent = i.call(this, t2);
    };
  }
  function textTween(value) {
    var t0, i0;
    function tween() {
      var i = value.apply(this, arguments);
      if (i !== i0)
        t0 = (i0 = i) && textInterpolate(i);
      return t0;
    }
    tween._value = value;
    return tween;
  }
  function textTween_default(value) {
    var key = "text";
    if (arguments.length < 1)
      return (key = this.tween(key)) && key._value;
    if (value == null)
      return this.tween(key, null);
    if (typeof value !== "function")
      throw new Error();
    return this.tween(key, textTween(value));
  }

  // node_modules/d3-transition/src/transition/transition.js
  function transition_default() {
    var name3 = this._name, id0 = this._id, id1 = newId();
    for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
      for (var group3 = groups[j], n = group3.length, node2, i = 0; i < n; ++i) {
        if (node2 = group3[i]) {
          var inherit2 = get2(node2, id0);
          schedule_default(node2, name3, id1, i, group3, {
            time: inherit2.time + inherit2.delay + inherit2.duration,
            delay: 0,
            duration: inherit2.duration,
            ease: inherit2.ease
          });
        }
      }
    }
    return new Transition(groups, this._parents, name3, id1);
  }

  // node_modules/d3-transition/src/transition/end.js
  function end_default() {
    var on0, on1, that = this, id3 = that._id, size3 = that.size();
    return new Promise(function(resolve, reject) {
      var cancel = { value: reject }, end = { value: function() {
        if (--size3 === 0)
          resolve();
      } };
      that.each(function() {
        var schedule = set2(this, id3), on2 = schedule.on;
        if (on2 !== on0) {
          on1 = (on0 = on2).copy();
          on1._.cancel.push(cancel);
          on1._.interrupt.push(cancel);
          on1._.end.push(end);
        }
        schedule.on = on1;
      });
      if (size3 === 0)
        resolve();
    });
  }

  // node_modules/d3-transition/src/transition/index.js
  var id = 0;
  function Transition(groups, parents, name3, id3) {
    this._groups = groups;
    this._parents = parents;
    this._name = name3;
    this._id = id3;
  }
  function transition(name3) {
    return selection_default().transition(name3);
  }
  function newId() {
    return ++id;
  }
  var selection_prototype = selection_default.prototype;
  Transition.prototype = transition.prototype = {
    constructor: Transition,
    select: select_default3,
    selectAll: selectAll_default2,
    selectChild: selection_prototype.selectChild,
    selectChildren: selection_prototype.selectChildren,
    filter: filter_default2,
    merge: merge_default2,
    selection: selection_default2,
    transition: transition_default,
    call: selection_prototype.call,
    nodes: selection_prototype.nodes,
    node: selection_prototype.node,
    size: selection_prototype.size,
    empty: selection_prototype.empty,
    each: selection_prototype.each,
    on: on_default2,
    attr: attr_default2,
    attrTween: attrTween_default,
    style: style_default2,
    styleTween: styleTween_default,
    text: text_default2,
    textTween: textTween_default,
    remove: remove_default2,
    tween: tween_default,
    delay: delay_default,
    duration: duration_default,
    ease: ease_default,
    easeVarying: easeVarying_default,
    end: end_default,
    [Symbol.iterator]: selection_prototype[Symbol.iterator]
  };

  // node_modules/d3-ease/src/cubic.js
  function cubicInOut(t2) {
    return ((t2 *= 2) <= 1 ? t2 * t2 * t2 : (t2 -= 2) * t2 * t2 + 2) / 2;
  }

  // node_modules/d3-transition/src/selection/transition.js
  var defaultTiming = {
    time: null,
    delay: 0,
    duration: 250,
    ease: cubicInOut
  };
  function inherit(node2, id3) {
    var timing;
    while (!(timing = node2.__transition) || !(timing = timing[id3])) {
      if (!(node2 = node2.parentNode)) {
        throw new Error(`transition ${id3} not found`);
      }
    }
    return timing;
  }
  function transition_default2(name3) {
    var id3, timing;
    if (name3 instanceof Transition) {
      id3 = name3._id, name3 = name3._name;
    } else {
      id3 = newId(), (timing = defaultTiming).time = now(), name3 = name3 == null ? null : name3 + "";
    }
    for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
      for (var group3 = groups[j], n = group3.length, node2, i = 0; i < n; ++i) {
        if (node2 = group3[i]) {
          schedule_default(node2, name3, id3, i, group3, timing || inherit(node2, id3));
        }
      }
    }
    return new Transition(groups, this._parents, name3, id3);
  }

  // node_modules/d3-transition/src/selection/index.js
  selection_default.prototype.interrupt = interrupt_default2;
  selection_default.prototype.transition = transition_default2;

  // node_modules/d3-brush/src/brush.js
  var { abs, max, min } = Math;
  function number1(e) {
    return [+e[0], +e[1]];
  }
  function number22(e) {
    return [number1(e[0]), number1(e[1])];
  }
  var X = {
    name: "x",
    handles: ["w", "e"].map(type),
    input: function(x2, e) {
      return x2 == null ? null : [[+x2[0], e[0][1]], [+x2[1], e[1][1]]];
    },
    output: function(xy) {
      return xy && [xy[0][0], xy[1][0]];
    }
  };
  var Y = {
    name: "y",
    handles: ["n", "s"].map(type),
    input: function(y2, e) {
      return y2 == null ? null : [[e[0][0], +y2[0]], [e[1][0], +y2[1]]];
    },
    output: function(xy) {
      return xy && [xy[0][1], xy[1][1]];
    }
  };
  var XY = {
    name: "xy",
    handles: ["n", "w", "e", "s", "nw", "ne", "sw", "se"].map(type),
    input: function(xy) {
      return xy == null ? null : number22(xy);
    },
    output: function(xy) {
      return xy;
    }
  };
  function type(t2) {
    return { type: t2 };
  }

  // node_modules/d3-path/src/path.js
  var pi = Math.PI;
  var tau = 2 * pi;
  var epsilon2 = 1e-6;
  var tauEpsilon = tau - epsilon2;
  function append(strings) {
    this._ += strings[0];
    for (let i = 1, n = strings.length; i < n; ++i) {
      this._ += arguments[i] + strings[i];
    }
  }
  function appendRound(digits) {
    let d = Math.floor(digits);
    if (!(d >= 0))
      throw new Error(`invalid digits: ${digits}`);
    if (d > 15)
      return append;
    const k = 10 ** d;
    return function(strings) {
      this._ += strings[0];
      for (let i = 1, n = strings.length; i < n; ++i) {
        this._ += Math.round(arguments[i] * k) / k + strings[i];
      }
    };
  }
  var Path = class {
    constructor(digits) {
      this._x0 = this._y0 = this._x1 = this._y1 = null;
      this._ = "";
      this._append = digits == null ? append : appendRound(digits);
    }
    moveTo(x2, y2) {
      this._append`M${this._x0 = this._x1 = +x2},${this._y0 = this._y1 = +y2}`;
    }
    closePath() {
      if (this._x1 !== null) {
        this._x1 = this._x0, this._y1 = this._y0;
        this._append`Z`;
      }
    }
    lineTo(x2, y2) {
      this._append`L${this._x1 = +x2},${this._y1 = +y2}`;
    }
    quadraticCurveTo(x1, y1, x2, y2) {
      this._append`Q${+x1},${+y1},${this._x1 = +x2},${this._y1 = +y2}`;
    }
    bezierCurveTo(x1, y1, x2, y2, x3, y3) {
      this._append`C${+x1},${+y1},${+x2},${+y2},${this._x1 = +x3},${this._y1 = +y3}`;
    }
    arcTo(x1, y1, x2, y2, r) {
      x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;
      if (r < 0)
        throw new Error(`negative radius: ${r}`);
      let x0 = this._x1, y0 = this._y1, x21 = x2 - x1, y21 = y2 - y1, x01 = x0 - x1, y01 = y0 - y1, l01_2 = x01 * x01 + y01 * y01;
      if (this._x1 === null) {
        this._append`M${this._x1 = x1},${this._y1 = y1}`;
      } else if (!(l01_2 > epsilon2))
        ;
      else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon2) || !r) {
        this._append`L${this._x1 = x1},${this._y1 = y1}`;
      } else {
        let x20 = x2 - x0, y20 = y2 - y0, l21_2 = x21 * x21 + y21 * y21, l20_2 = x20 * x20 + y20 * y20, l21 = Math.sqrt(l21_2), l01 = Math.sqrt(l01_2), l = r * Math.tan((pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2), t01 = l / l01, t21 = l / l21;
        if (Math.abs(t01 - 1) > epsilon2) {
          this._append`L${x1 + t01 * x01},${y1 + t01 * y01}`;
        }
        this._append`A${r},${r},0,0,${+(y01 * x20 > x01 * y20)},${this._x1 = x1 + t21 * x21},${this._y1 = y1 + t21 * y21}`;
      }
    }
    arc(x2, y2, r, a0, a1, ccw) {
      x2 = +x2, y2 = +y2, r = +r, ccw = !!ccw;
      if (r < 0)
        throw new Error(`negative radius: ${r}`);
      let dx = r * Math.cos(a0), dy = r * Math.sin(a0), x0 = x2 + dx, y0 = y2 + dy, cw = 1 ^ ccw, da = ccw ? a0 - a1 : a1 - a0;
      if (this._x1 === null) {
        this._append`M${x0},${y0}`;
      } else if (Math.abs(this._x1 - x0) > epsilon2 || Math.abs(this._y1 - y0) > epsilon2) {
        this._append`L${x0},${y0}`;
      }
      if (!r)
        return;
      if (da < 0)
        da = da % tau + tau;
      if (da > tauEpsilon) {
        this._append`A${r},${r},0,1,${cw},${x2 - dx},${y2 - dy}A${r},${r},0,1,${cw},${this._x1 = x0},${this._y1 = y0}`;
      } else if (da > epsilon2) {
        this._append`A${r},${r},0,${+(da >= pi)},${cw},${this._x1 = x2 + r * Math.cos(a1)},${this._y1 = y2 + r * Math.sin(a1)}`;
      }
    }
    rect(x2, y2, w, h) {
      this._append`M${this._x0 = this._x1 = +x2},${this._y0 = this._y1 = +y2}h${w = +w}v${+h}h${-w}Z`;
    }
    toString() {
      return this._;
    }
  };
  function path() {
    return new Path();
  }
  path.prototype = Path.prototype;

  // node_modules/d3-format/src/formatDecimal.js
  function formatDecimal_default(x2) {
    return Math.abs(x2 = Math.round(x2)) >= 1e21 ? x2.toLocaleString("en").replace(/,/g, "") : x2.toString(10);
  }
  function formatDecimalParts(x2, p) {
    if ((i = (x2 = p ? x2.toExponential(p - 1) : x2.toExponential()).indexOf("e")) < 0)
      return null;
    var i, coefficient = x2.slice(0, i);
    return [
      coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
      +x2.slice(i + 1)
    ];
  }

  // node_modules/d3-format/src/exponent.js
  function exponent_default(x2) {
    return x2 = formatDecimalParts(Math.abs(x2)), x2 ? x2[1] : NaN;
  }

  // node_modules/d3-format/src/formatGroup.js
  function formatGroup_default(grouping, thousands) {
    return function(value, width) {
      var i = value.length, t2 = [], j = 0, g = grouping[0], length6 = 0;
      while (i > 0 && g > 0) {
        if (length6 + g + 1 > width)
          g = Math.max(1, width - length6);
        t2.push(value.substring(i -= g, i + g));
        if ((length6 += g + 1) > width)
          break;
        g = grouping[j = (j + 1) % grouping.length];
      }
      return t2.reverse().join(thousands);
    };
  }

  // node_modules/d3-format/src/formatNumerals.js
  function formatNumerals_default(numerals) {
    return function(value) {
      return value.replace(/[0-9]/g, function(i) {
        return numerals[+i];
      });
    };
  }

  // node_modules/d3-format/src/formatSpecifier.js
  var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
  function formatSpecifier(specifier) {
    if (!(match4 = re.exec(specifier)))
      throw new Error("invalid format: " + specifier);
    var match4;
    return new FormatSpecifier({
      fill: match4[1],
      align: match4[2],
      sign: match4[3],
      symbol: match4[4],
      zero: match4[5],
      width: match4[6],
      comma: match4[7],
      precision: match4[8] && match4[8].slice(1),
      trim: match4[9],
      type: match4[10]
    });
  }
  formatSpecifier.prototype = FormatSpecifier.prototype;
  function FormatSpecifier(specifier) {
    this.fill = specifier.fill === void 0 ? " " : specifier.fill + "";
    this.align = specifier.align === void 0 ? ">" : specifier.align + "";
    this.sign = specifier.sign === void 0 ? "-" : specifier.sign + "";
    this.symbol = specifier.symbol === void 0 ? "" : specifier.symbol + "";
    this.zero = !!specifier.zero;
    this.width = specifier.width === void 0 ? void 0 : +specifier.width;
    this.comma = !!specifier.comma;
    this.precision = specifier.precision === void 0 ? void 0 : +specifier.precision;
    this.trim = !!specifier.trim;
    this.type = specifier.type === void 0 ? "" : specifier.type + "";
  }
  FormatSpecifier.prototype.toString = function() {
    return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
  };

  // node_modules/d3-format/src/formatTrim.js
  function formatTrim_default(s) {
    out:
      for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
        switch (s[i]) {
          case ".":
            i0 = i1 = i;
            break;
          case "0":
            if (i0 === 0)
              i0 = i;
            i1 = i;
            break;
          default:
            if (!+s[i])
              break out;
            if (i0 > 0)
              i0 = 0;
            break;
        }
      }
    return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
  }

  // node_modules/d3-format/src/formatPrefixAuto.js
  var prefixExponent;
  function formatPrefixAuto_default(x2, p) {
    var d = formatDecimalParts(x2, p);
    if (!d)
      return x2 + "";
    var coefficient = d[0], exponent = d[1], i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1, n = coefficient.length;
    return i === n ? coefficient : i > n ? coefficient + new Array(i - n + 1).join("0") : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i) : "0." + new Array(1 - i).join("0") + formatDecimalParts(x2, Math.max(0, p + i - 1))[0];
  }

  // node_modules/d3-format/src/formatRounded.js
  function formatRounded_default(x2, p) {
    var d = formatDecimalParts(x2, p);
    if (!d)
      return x2 + "";
    var coefficient = d[0], exponent = d[1];
    return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1) : coefficient + new Array(exponent - coefficient.length + 2).join("0");
  }

  // node_modules/d3-format/src/formatTypes.js
  var formatTypes_default = {
    "%": (x2, p) => (x2 * 100).toFixed(p),
    "b": (x2) => Math.round(x2).toString(2),
    "c": (x2) => x2 + "",
    "d": formatDecimal_default,
    "e": (x2, p) => x2.toExponential(p),
    "f": (x2, p) => x2.toFixed(p),
    "g": (x2, p) => x2.toPrecision(p),
    "o": (x2) => Math.round(x2).toString(8),
    "p": (x2, p) => formatRounded_default(x2 * 100, p),
    "r": formatRounded_default,
    "s": formatPrefixAuto_default,
    "X": (x2) => Math.round(x2).toString(16).toUpperCase(),
    "x": (x2) => Math.round(x2).toString(16)
  };

  // node_modules/d3-format/src/identity.js
  function identity_default2(x2) {
    return x2;
  }

  // node_modules/d3-format/src/locale.js
  var map = Array.prototype.map;
  var prefixes = ["y", "z", "a", "f", "p", "n", "\xB5", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
  function locale_default(locale2) {
    var group3 = locale2.grouping === void 0 || locale2.thousands === void 0 ? identity_default2 : formatGroup_default(map.call(locale2.grouping, Number), locale2.thousands + ""), currencyPrefix = locale2.currency === void 0 ? "" : locale2.currency[0] + "", currencySuffix = locale2.currency === void 0 ? "" : locale2.currency[1] + "", decimal = locale2.decimal === void 0 ? "." : locale2.decimal + "", numerals = locale2.numerals === void 0 ? identity_default2 : formatNumerals_default(map.call(locale2.numerals, String)), percent = locale2.percent === void 0 ? "%" : locale2.percent + "", minus = locale2.minus === void 0 ? "\u2212" : locale2.minus + "", nan2 = locale2.nan === void 0 ? "NaN" : locale2.nan + "";
    function newFormat(specifier) {
      specifier = formatSpecifier(specifier);
      var fill = specifier.fill, align = specifier.align, sign2 = specifier.sign, symbol = specifier.symbol, zero3 = specifier.zero, width = specifier.width, comma2 = specifier.comma, precision = specifier.precision, trim2 = specifier.trim, type2 = specifier.type;
      if (type2 === "n")
        comma2 = true, type2 = "g";
      else if (!formatTypes_default[type2])
        precision === void 0 && (precision = 12), trim2 = true, type2 = "g";
      if (zero3 || fill === "0" && align === "=")
        zero3 = true, fill = "0", align = "=";
      var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type2) ? "0" + type2.toLowerCase() : "", suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type2) ? percent : "";
      var formatType = formatTypes_default[type2], maybeSuffix = /[defgprs%]/.test(type2);
      precision = precision === void 0 ? 6 : /[gprs]/.test(type2) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));
      function format2(value) {
        var valuePrefix = prefix, valueSuffix = suffix, i, n, c;
        if (type2 === "c") {
          valueSuffix = formatType(value) + valueSuffix;
          value = "";
        } else {
          value = +value;
          var valueNegative = value < 0 || 1 / value < 0;
          value = isNaN(value) ? nan2 : formatType(Math.abs(value), precision);
          if (trim2)
            value = formatTrim_default(value);
          if (valueNegative && +value === 0 && sign2 !== "+")
            valueNegative = false;
          valuePrefix = (valueNegative ? sign2 === "(" ? sign2 : minus : sign2 === "-" || sign2 === "(" ? "" : sign2) + valuePrefix;
          valueSuffix = (type2 === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign2 === "(" ? ")" : "");
          if (maybeSuffix) {
            i = -1, n = value.length;
            while (++i < n) {
              if (c = value.charCodeAt(i), 48 > c || c > 57) {
                valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
                value = value.slice(0, i);
                break;
              }
            }
          }
        }
        if (comma2 && !zero3)
          value = group3(value, Infinity);
        var length6 = valuePrefix.length + value.length + valueSuffix.length, padding = length6 < width ? new Array(width - length6 + 1).join(fill) : "";
        if (comma2 && zero3)
          value = group3(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";
        switch (align) {
          case "<":
            value = valuePrefix + value + valueSuffix + padding;
            break;
          case "=":
            value = valuePrefix + padding + value + valueSuffix;
            break;
          case "^":
            value = padding.slice(0, length6 = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length6);
            break;
          default:
            value = padding + valuePrefix + value + valueSuffix;
            break;
        }
        return numerals(value);
      }
      format2.toString = function() {
        return specifier + "";
      };
      return format2;
    }
    function formatPrefix2(specifier, value) {
      var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)), e = Math.max(-8, Math.min(8, Math.floor(exponent_default(value) / 3))) * 3, k = Math.pow(10, -e), prefix = prefixes[8 + e / 3];
      return function(value2) {
        return f(k * value2) + prefix;
      };
    }
    return {
      format: newFormat,
      formatPrefix: formatPrefix2
    };
  }

  // node_modules/d3-format/src/defaultLocale.js
  var locale;
  var format;
  var formatPrefix;
  defaultLocale({
    thousands: ",",
    grouping: [3],
    currency: ["$", ""]
  });
  function defaultLocale(definition) {
    locale = locale_default(definition);
    format = locale.format;
    formatPrefix = locale.formatPrefix;
    return locale;
  }

  // node_modules/d3-format/src/precisionFixed.js
  function precisionFixed_default(step) {
    return Math.max(0, -exponent_default(Math.abs(step)));
  }

  // node_modules/d3-format/src/precisionPrefix.js
  function precisionPrefix_default(step, value) {
    return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent_default(value) / 3))) * 3 - exponent_default(Math.abs(step)));
  }

  // node_modules/d3-format/src/precisionRound.js
  function precisionRound_default(step, max5) {
    step = Math.abs(step), max5 = Math.abs(max5) - step;
    return Math.max(0, exponent_default(max5) - exponent_default(step)) + 1;
  }

  // node_modules/d3-scale/src/init.js
  function initRange(domain, range4) {
    switch (arguments.length) {
      case 0:
        break;
      case 1:
        this.range(domain);
        break;
      default:
        this.range(range4).domain(domain);
        break;
    }
    return this;
  }

  // node_modules/d3-scale/src/ordinal.js
  var implicit = Symbol("implicit");
  function ordinal() {
    var index3 = new InternMap(), domain = [], range4 = [], unknown = implicit;
    function scale(d) {
      let i = index3.get(d);
      if (i === void 0) {
        if (unknown !== implicit)
          return unknown;
        index3.set(d, i = domain.push(d) - 1);
      }
      return range4[i % range4.length];
    }
    scale.domain = function(_) {
      if (!arguments.length)
        return domain.slice();
      domain = [], index3 = new InternMap();
      for (const value of _) {
        if (index3.has(value))
          continue;
        index3.set(value, domain.push(value) - 1);
      }
      return scale;
    };
    scale.range = function(_) {
      return arguments.length ? (range4 = Array.from(_), scale) : range4.slice();
    };
    scale.unknown = function(_) {
      return arguments.length ? (unknown = _, scale) : unknown;
    };
    scale.copy = function() {
      return ordinal(domain, range4).unknown(unknown);
    };
    initRange.apply(scale, arguments);
    return scale;
  }

  // node_modules/d3-scale/src/band.js
  function band() {
    var scale = ordinal().unknown(void 0), domain = scale.domain, ordinalRange = scale.range, r0 = 0, r1 = 1, step, bandwidth, round2 = false, paddingInner = 0, paddingOuter = 0, align = 0.5;
    delete scale.unknown;
    function rescale() {
      var n = domain().length, reverse3 = r1 < r0, start2 = reverse3 ? r1 : r0, stop = reverse3 ? r0 : r1;
      step = (stop - start2) / Math.max(1, n - paddingInner + paddingOuter * 2);
      if (round2)
        step = Math.floor(step);
      start2 += (stop - start2 - step * (n - paddingInner)) * align;
      bandwidth = step * (1 - paddingInner);
      if (round2)
        start2 = Math.round(start2), bandwidth = Math.round(bandwidth);
      var values3 = range(n).map(function(i) {
        return start2 + step * i;
      });
      return ordinalRange(reverse3 ? values3.reverse() : values3);
    }
    scale.domain = function(_) {
      return arguments.length ? (domain(_), rescale()) : domain();
    };
    scale.range = function(_) {
      return arguments.length ? ([r0, r1] = _, r0 = +r0, r1 = +r1, rescale()) : [r0, r1];
    };
    scale.rangeRound = function(_) {
      return [r0, r1] = _, r0 = +r0, r1 = +r1, round2 = true, rescale();
    };
    scale.bandwidth = function() {
      return bandwidth;
    };
    scale.step = function() {
      return step;
    };
    scale.round = function(_) {
      return arguments.length ? (round2 = !!_, rescale()) : round2;
    };
    scale.padding = function(_) {
      return arguments.length ? (paddingInner = Math.min(1, paddingOuter = +_), rescale()) : paddingInner;
    };
    scale.paddingInner = function(_) {
      return arguments.length ? (paddingInner = Math.min(1, _), rescale()) : paddingInner;
    };
    scale.paddingOuter = function(_) {
      return arguments.length ? (paddingOuter = +_, rescale()) : paddingOuter;
    };
    scale.align = function(_) {
      return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;
    };
    scale.copy = function() {
      return band(domain(), [r0, r1]).round(round2).paddingInner(paddingInner).paddingOuter(paddingOuter).align(align);
    };
    return initRange.apply(rescale(), arguments);
  }

  // node_modules/d3-scale/src/constant.js
  function constants(x2) {
    return function() {
      return x2;
    };
  }

  // node_modules/d3-scale/src/number.js
  function number3(x2) {
    return +x2;
  }

  // node_modules/d3-scale/src/continuous.js
  var unit = [0, 1];
  function identity2(x2) {
    return x2;
  }
  function normalize(a, b) {
    return (b -= a = +a) ? function(x2) {
      return (x2 - a) / b;
    } : constants(isNaN(b) ? NaN : 0.5);
  }
  function clamper(a, b) {
    var t2;
    if (a > b)
      t2 = a, a = b, b = t2;
    return function(x2) {
      return Math.max(a, Math.min(b, x2));
    };
  }
  function bimap(domain, range4, interpolate) {
    var d0 = domain[0], d1 = domain[1], r0 = range4[0], r1 = range4[1];
    if (d1 < d0)
      d0 = normalize(d1, d0), r0 = interpolate(r1, r0);
    else
      d0 = normalize(d0, d1), r0 = interpolate(r0, r1);
    return function(x2) {
      return r0(d0(x2));
    };
  }
  function polymap(domain, range4, interpolate) {
    var j = Math.min(domain.length, range4.length) - 1, d = new Array(j), r = new Array(j), i = -1;
    if (domain[j] < domain[0]) {
      domain = domain.slice().reverse();
      range4 = range4.slice().reverse();
    }
    while (++i < j) {
      d[i] = normalize(domain[i], domain[i + 1]);
      r[i] = interpolate(range4[i], range4[i + 1]);
    }
    return function(x2) {
      var i2 = bisect_default(domain, x2, 1, j) - 1;
      return r[i2](d[i2](x2));
    };
  }
  function copy(source2, target) {
    return target.domain(source2.domain()).range(source2.range()).interpolate(source2.interpolate()).clamp(source2.clamp()).unknown(source2.unknown());
  }
  function transformer() {
    var domain = unit, range4 = unit, interpolate = value_default, transform2, untransform, unknown, clamp3 = identity2, piecewise, output, input;
    function rescale() {
      var n = Math.min(domain.length, range4.length);
      if (clamp3 !== identity2)
        clamp3 = clamper(domain[0], domain[n - 1]);
      piecewise = n > 2 ? polymap : bimap;
      output = input = null;
      return scale;
    }
    function scale(x2) {
      return x2 == null || isNaN(x2 = +x2) ? unknown : (output || (output = piecewise(domain.map(transform2), range4, interpolate)))(transform2(clamp3(x2)));
    }
    scale.invert = function(y2) {
      return clamp3(untransform((input || (input = piecewise(range4, domain.map(transform2), number_default)))(y2)));
    };
    scale.domain = function(_) {
      return arguments.length ? (domain = Array.from(_, number3), rescale()) : domain.slice();
    };
    scale.range = function(_) {
      return arguments.length ? (range4 = Array.from(_), rescale()) : range4.slice();
    };
    scale.rangeRound = function(_) {
      return range4 = Array.from(_), interpolate = round_default, rescale();
    };
    scale.clamp = function(_) {
      return arguments.length ? (clamp3 = _ ? true : identity2, rescale()) : clamp3 !== identity2;
    };
    scale.interpolate = function(_) {
      return arguments.length ? (interpolate = _, rescale()) : interpolate;
    };
    scale.unknown = function(_) {
      return arguments.length ? (unknown = _, scale) : unknown;
    };
    return function(t2, u) {
      transform2 = t2, untransform = u;
      return rescale();
    };
  }
  function continuous() {
    return transformer()(identity2, identity2);
  }

  // node_modules/d3-scale/src/tickFormat.js
  function tickFormat(start2, stop, count, specifier) {
    var step = tickStep(start2, stop, count), precision;
    specifier = formatSpecifier(specifier == null ? ",f" : specifier);
    switch (specifier.type) {
      case "s": {
        var value = Math.max(Math.abs(start2), Math.abs(stop));
        if (specifier.precision == null && !isNaN(precision = precisionPrefix_default(step, value)))
          specifier.precision = precision;
        return formatPrefix(specifier, value);
      }
      case "":
      case "e":
      case "g":
      case "p":
      case "r": {
        if (specifier.precision == null && !isNaN(precision = precisionRound_default(step, Math.max(Math.abs(start2), Math.abs(stop)))))
          specifier.precision = precision - (specifier.type === "e");
        break;
      }
      case "f":
      case "%": {
        if (specifier.precision == null && !isNaN(precision = precisionFixed_default(step)))
          specifier.precision = precision - (specifier.type === "%") * 2;
        break;
      }
    }
    return format(specifier);
  }

  // node_modules/d3-scale/src/linear.js
  function linearish(scale) {
    var domain = scale.domain;
    scale.ticks = function(count) {
      var d = domain();
      return ticks(d[0], d[d.length - 1], count == null ? 10 : count);
    };
    scale.tickFormat = function(count, specifier) {
      var d = domain();
      return tickFormat(d[0], d[d.length - 1], count == null ? 10 : count, specifier);
    };
    scale.nice = function(count) {
      if (count == null)
        count = 10;
      var d = domain();
      var i0 = 0;
      var i1 = d.length - 1;
      var start2 = d[i0];
      var stop = d[i1];
      var prestep;
      var step;
      var maxIter = 10;
      if (stop < start2) {
        step = start2, start2 = stop, stop = step;
        step = i0, i0 = i1, i1 = step;
      }
      while (maxIter-- > 0) {
        step = tickIncrement(start2, stop, count);
        if (step === prestep) {
          d[i0] = start2;
          d[i1] = stop;
          return domain(d);
        } else if (step > 0) {
          start2 = Math.floor(start2 / step) * step;
          stop = Math.ceil(stop / step) * step;
        } else if (step < 0) {
          start2 = Math.ceil(start2 * step) / step;
          stop = Math.floor(stop * step) / step;
        } else {
          break;
        }
        prestep = step;
      }
      return scale;
    };
    return scale;
  }
  function linear2() {
    var scale = continuous();
    scale.copy = function() {
      return copy(scale, linear2());
    };
    initRange.apply(scale, arguments);
    return linearish(scale);
  }

  // node_modules/d3-scale-chromatic/src/colors.js
  function colors_default(specifier) {
    var n = specifier.length / 6 | 0, colors = new Array(n), i = 0;
    while (i < n)
      colors[i] = "#" + specifier.slice(i * 6, ++i * 6);
    return colors;
  }

  // node_modules/d3-scale-chromatic/src/categorical/Accent.js
  var Accent_default = colors_default("7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666");

  // node_modules/d3-scale-chromatic/src/categorical/Pastel1.js
  var Pastel1_default = colors_default("fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2");

  // node_modules/d3-shape/src/constant.js
  function constant_default4(x2) {
    return function constant() {
      return x2;
    };
  }

  // node_modules/d3-shape/src/path.js
  function withPath(shape) {
    let digits = 3;
    shape.digits = function(_) {
      if (!arguments.length)
        return digits;
      if (_ == null) {
        digits = null;
      } else {
        const d = Math.floor(_);
        if (!(d >= 0))
          throw new RangeError(`invalid digits: ${_}`);
        digits = d;
      }
      return shape;
    };
    return () => new Path(digits);
  }

  // node_modules/d3-shape/src/array.js
  var slice = Array.prototype.slice;
  function array_default(x2) {
    return typeof x2 === "object" && "length" in x2 ? x2 : Array.from(x2);
  }

  // node_modules/d3-shape/src/curve/linear.js
  function Linear(context) {
    this._context = context;
  }
  Linear.prototype = {
    areaStart: function() {
      this._line = 0;
    },
    areaEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._point = 0;
    },
    lineEnd: function() {
      if (this._line || this._line !== 0 && this._point === 1)
        this._context.closePath();
      this._line = 1 - this._line;
    },
    point: function(x2, y2) {
      x2 = +x2, y2 = +y2;
      switch (this._point) {
        case 0:
          this._point = 1;
          this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
          break;
        case 1:
          this._point = 2;
        default:
          this._context.lineTo(x2, y2);
          break;
      }
    }
  };
  function linear_default(context) {
    return new Linear(context);
  }

  // node_modules/d3-shape/src/point.js
  function x(p) {
    return p[0];
  }
  function y(p) {
    return p[1];
  }

  // node_modules/d3-shape/src/line.js
  function line_default(x2, y2) {
    var defined2 = constant_default4(true), context = null, curve = linear_default, output = null, path2 = withPath(line2);
    x2 = typeof x2 === "function" ? x2 : x2 === void 0 ? x : constant_default4(x2);
    y2 = typeof y2 === "function" ? y2 : y2 === void 0 ? y : constant_default4(y2);
    function line2(data) {
      var i, n = (data = array_default(data)).length, d, defined0 = false, buffer;
      if (context == null)
        output = curve(buffer = path2());
      for (i = 0; i <= n; ++i) {
        if (!(i < n && defined2(d = data[i], i, data)) === defined0) {
          if (defined0 = !defined0)
            output.lineStart();
          else
            output.lineEnd();
        }
        if (defined0)
          output.point(+x2(d, i, data), +y2(d, i, data));
      }
      if (buffer)
        return output = null, buffer + "" || null;
    }
    line2.x = function(_) {
      return arguments.length ? (x2 = typeof _ === "function" ? _ : constant_default4(+_), line2) : x2;
    };
    line2.y = function(_) {
      return arguments.length ? (y2 = typeof _ === "function" ? _ : constant_default4(+_), line2) : y2;
    };
    line2.defined = function(_) {
      return arguments.length ? (defined2 = typeof _ === "function" ? _ : constant_default4(!!_), line2) : defined2;
    };
    line2.curve = function(_) {
      return arguments.length ? (curve = _, context != null && (output = curve(context)), line2) : curve;
    };
    line2.context = function(_) {
      return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line2) : context;
    };
    return line2;
  }

  // node_modules/d3-zoom/src/transform.js
  function Transform(k, x2, y2) {
    this.k = k;
    this.x = x2;
    this.y = y2;
  }
  Transform.prototype = {
    constructor: Transform,
    scale: function(k) {
      return k === 1 ? this : new Transform(this.k * k, this.x, this.y);
    },
    translate: function(x2, y2) {
      return x2 === 0 & y2 === 0 ? this : new Transform(this.k, this.x + this.k * x2, this.y + this.k * y2);
    },
    apply: function(point2) {
      return [point2[0] * this.k + this.x, point2[1] * this.k + this.y];
    },
    applyX: function(x2) {
      return x2 * this.k + this.x;
    },
    applyY: function(y2) {
      return y2 * this.k + this.y;
    },
    invert: function(location) {
      return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];
    },
    invertX: function(x2) {
      return (x2 - this.x) / this.k;
    },
    invertY: function(y2) {
      return (y2 - this.y) / this.k;
    },
    rescaleX: function(x2) {
      return x2.copy().domain(x2.range().map(this.invertX, this).map(x2.invert, x2));
    },
    rescaleY: function(y2) {
      return y2.copy().domain(y2.range().map(this.invertY, this).map(y2.invert, y2));
    },
    toString: function() {
      return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
    }
  };
  var identity3 = new Transform(1, 0, 0);
  transform.prototype = Transform.prototype;
  function transform(node2) {
    while (!node2.__zoom)
      if (!(node2 = node2.parentNode))
        return identity3;
    return node2.__zoom;
  }

  // node_modules/@codemirror/state/dist/index.js
  var Text = class {
    lineAt(pos) {
      if (pos < 0 || pos > this.length)
        throw new RangeError(`Invalid position ${pos} in document of length ${this.length}`);
      return this.lineInner(pos, false, 1, 0);
    }
    line(n) {
      if (n < 1 || n > this.lines)
        throw new RangeError(`Invalid line number ${n} in ${this.lines}-line document`);
      return this.lineInner(n, true, 1, 0);
    }
    replace(from, to, text2) {
      [from, to] = clip(this, from, to);
      let parts = [];
      this.decompose(0, from, parts, 2);
      if (text2.length)
        text2.decompose(0, text2.length, parts, 1 | 2);
      this.decompose(to, this.length, parts, 1);
      return TextNode.from(parts, this.length - (to - from) + text2.length);
    }
    append(other) {
      return this.replace(this.length, this.length, other);
    }
    slice(from, to = this.length) {
      [from, to] = clip(this, from, to);
      let parts = [];
      this.decompose(from, to, parts, 0);
      return TextNode.from(parts, to - from);
    }
    eq(other) {
      if (other == this)
        return true;
      if (other.length != this.length || other.lines != this.lines)
        return false;
      let start2 = this.scanIdentical(other, 1), end = this.length - this.scanIdentical(other, -1);
      let a = new RawTextCursor(this), b = new RawTextCursor(other);
      for (let skip = start2, pos = start2; ; ) {
        a.next(skip);
        b.next(skip);
        skip = 0;
        if (a.lineBreak != b.lineBreak || a.done != b.done || a.value != b.value)
          return false;
        pos += a.value.length;
        if (a.done || pos >= end)
          return true;
      }
    }
    iter(dir = 1) {
      return new RawTextCursor(this, dir);
    }
    iterRange(from, to = this.length) {
      return new PartialTextCursor(this, from, to);
    }
    iterLines(from, to) {
      let inner;
      if (from == null) {
        inner = this.iter();
      } else {
        if (to == null)
          to = this.lines + 1;
        let start2 = this.line(from).from;
        inner = this.iterRange(start2, Math.max(start2, to == this.lines + 1 ? this.length : to <= 1 ? 0 : this.line(to - 1).to));
      }
      return new LineCursor(inner);
    }
    toString() {
      return this.sliceString(0);
    }
    toJSON() {
      let lines = [];
      this.flatten(lines);
      return lines;
    }
    constructor() {
    }
    static of(text2) {
      if (text2.length == 0)
        throw new RangeError("A document must have at least one line");
      if (text2.length == 1 && !text2[0])
        return Text.empty;
      return text2.length <= 32 ? new TextLeaf(text2) : TextNode.from(TextLeaf.split(text2, []));
    }
  };
  var TextLeaf = class extends Text {
    constructor(text2, length6 = textLength(text2)) {
      super();
      this.text = text2;
      this.length = length6;
    }
    get lines() {
      return this.text.length;
    }
    get children() {
      return null;
    }
    lineInner(target, isLine, line2, offset) {
      for (let i = 0; ; i++) {
        let string4 = this.text[i], end = offset + string4.length;
        if ((isLine ? line2 : end) >= target)
          return new Line(offset, end, line2, string4);
        offset = end + 1;
        line2++;
      }
    }
    decompose(from, to, target, open) {
      let text2 = from <= 0 && to >= this.length ? this : new TextLeaf(sliceText(this.text, from, to), Math.min(to, this.length) - Math.max(0, from));
      if (open & 1) {
        let prev = target.pop();
        let joined = appendText(text2.text, prev.text.slice(), 0, text2.length);
        if (joined.length <= 32) {
          target.push(new TextLeaf(joined, prev.length + text2.length));
        } else {
          let mid = joined.length >> 1;
          target.push(new TextLeaf(joined.slice(0, mid)), new TextLeaf(joined.slice(mid)));
        }
      } else {
        target.push(text2);
      }
    }
    replace(from, to, text2) {
      if (!(text2 instanceof TextLeaf))
        return super.replace(from, to, text2);
      [from, to] = clip(this, from, to);
      let lines = appendText(this.text, appendText(text2.text, sliceText(this.text, 0, from)), to);
      let newLen = this.length + text2.length - (to - from);
      if (lines.length <= 32)
        return new TextLeaf(lines, newLen);
      return TextNode.from(TextLeaf.split(lines, []), newLen);
    }
    sliceString(from, to = this.length, lineSep = "\n") {
      [from, to] = clip(this, from, to);
      let result = "";
      for (let pos = 0, i = 0; pos <= to && i < this.text.length; i++) {
        let line2 = this.text[i], end = pos + line2.length;
        if (pos > from && i)
          result += lineSep;
        if (from < end && to > pos)
          result += line2.slice(Math.max(0, from - pos), to - pos);
        pos = end + 1;
      }
      return result;
    }
    flatten(target) {
      for (let line2 of this.text)
        target.push(line2);
    }
    scanIdentical() {
      return 0;
    }
    static split(text2, target) {
      let part = [], len = -1;
      for (let line2 of text2) {
        part.push(line2);
        len += line2.length + 1;
        if (part.length == 32) {
          target.push(new TextLeaf(part, len));
          part = [];
          len = -1;
        }
      }
      if (len > -1)
        target.push(new TextLeaf(part, len));
      return target;
    }
  };
  var TextNode = class extends Text {
    constructor(children2, length6) {
      super();
      this.children = children2;
      this.length = length6;
      this.lines = 0;
      for (let child of children2)
        this.lines += child.lines;
    }
    lineInner(target, isLine, line2, offset) {
      for (let i = 0; ; i++) {
        let child = this.children[i], end = offset + child.length, endLine = line2 + child.lines - 1;
        if ((isLine ? endLine : end) >= target)
          return child.lineInner(target, isLine, line2, offset);
        offset = end + 1;
        line2 = endLine + 1;
      }
    }
    decompose(from, to, target, open) {
      for (let i = 0, pos = 0; pos <= to && i < this.children.length; i++) {
        let child = this.children[i], end = pos + child.length;
        if (from <= end && to >= pos) {
          let childOpen = open & ((pos <= from ? 1 : 0) | (end >= to ? 2 : 0));
          if (pos >= from && end <= to && !childOpen)
            target.push(child);
          else
            child.decompose(from - pos, to - pos, target, childOpen);
        }
        pos = end + 1;
      }
    }
    replace(from, to, text2) {
      [from, to] = clip(this, from, to);
      if (text2.lines < this.lines)
        for (let i = 0, pos = 0; i < this.children.length; i++) {
          let child = this.children[i], end = pos + child.length;
          if (from >= pos && to <= end) {
            let updated = child.replace(from - pos, to - pos, text2);
            let totalLines = this.lines - child.lines + updated.lines;
            if (updated.lines < totalLines >> 5 - 1 && updated.lines > totalLines >> 5 + 1) {
              let copy2 = this.children.slice();
              copy2[i] = updated;
              return new TextNode(copy2, this.length - (to - from) + text2.length);
            }
            return super.replace(pos, end, updated);
          }
          pos = end + 1;
        }
      return super.replace(from, to, text2);
    }
    sliceString(from, to = this.length, lineSep = "\n") {
      [from, to] = clip(this, from, to);
      let result = "";
      for (let i = 0, pos = 0; i < this.children.length && pos <= to; i++) {
        let child = this.children[i], end = pos + child.length;
        if (pos > from && i)
          result += lineSep;
        if (from < end && to > pos)
          result += child.sliceString(from - pos, to - pos, lineSep);
        pos = end + 1;
      }
      return result;
    }
    flatten(target) {
      for (let child of this.children)
        child.flatten(target);
    }
    scanIdentical(other, dir) {
      if (!(other instanceof TextNode))
        return 0;
      let length6 = 0;
      let [iA, iB, eA, eB] = dir > 0 ? [0, 0, this.children.length, other.children.length] : [this.children.length - 1, other.children.length - 1, -1, -1];
      for (; ; iA += dir, iB += dir) {
        if (iA == eA || iB == eB)
          return length6;
        let chA = this.children[iA], chB = other.children[iB];
        if (chA != chB)
          return length6 + chA.scanIdentical(chB, dir);
        length6 += chA.length + 1;
      }
    }
    static from(children2, length6 = children2.reduce((l, ch) => l + ch.length + 1, -1)) {
      let lines = 0;
      for (let ch of children2)
        lines += ch.lines;
      if (lines < 32) {
        let flat = [];
        for (let ch of children2)
          ch.flatten(flat);
        return new TextLeaf(flat, length6);
      }
      let chunk = Math.max(32, lines >> 5), maxChunk = chunk << 1, minChunk = chunk >> 1;
      let chunked = [], currentLines = 0, currentLen = -1, currentChunk = [];
      function add(child) {
        let last3;
        if (child.lines > maxChunk && child instanceof TextNode) {
          for (let node2 of child.children)
            add(node2);
        } else if (child.lines > minChunk && (currentLines > minChunk || !currentLines)) {
          flush();
          chunked.push(child);
        } else if (child instanceof TextLeaf && currentLines && (last3 = currentChunk[currentChunk.length - 1]) instanceof TextLeaf && child.lines + last3.lines <= 32) {
          currentLines += child.lines;
          currentLen += child.length + 1;
          currentChunk[currentChunk.length - 1] = new TextLeaf(last3.text.concat(child.text), last3.length + 1 + child.length);
        } else {
          if (currentLines + child.lines > chunk)
            flush();
          currentLines += child.lines;
          currentLen += child.length + 1;
          currentChunk.push(child);
        }
      }
      function flush() {
        if (currentLines == 0)
          return;
        chunked.push(currentChunk.length == 1 ? currentChunk[0] : TextNode.from(currentChunk, currentLen));
        currentLen = -1;
        currentLines = currentChunk.length = 0;
      }
      for (let child of children2)
        add(child);
      flush();
      return chunked.length == 1 ? chunked[0] : new TextNode(chunked, length6);
    }
  };
  Text.empty = /* @__PURE__ */ new TextLeaf([""], 0);
  function textLength(text2) {
    let length6 = -1;
    for (let line2 of text2)
      length6 += line2.length + 1;
    return length6;
  }
  function appendText(text2, target, from = 0, to = 1e9) {
    for (let pos = 0, i = 0, first = true; i < text2.length && pos <= to; i++) {
      let line2 = text2[i], end = pos + line2.length;
      if (end >= from) {
        if (end > to)
          line2 = line2.slice(0, to - pos);
        if (pos < from)
          line2 = line2.slice(from - pos);
        if (first) {
          target[target.length - 1] += line2;
          first = false;
        } else
          target.push(line2);
      }
      pos = end + 1;
    }
    return target;
  }
  function sliceText(text2, from, to) {
    return appendText(text2, [""], from, to);
  }
  var RawTextCursor = class {
    constructor(text2, dir = 1) {
      this.dir = dir;
      this.done = false;
      this.lineBreak = false;
      this.value = "";
      this.nodes = [text2];
      this.offsets = [dir > 0 ? 1 : (text2 instanceof TextLeaf ? text2.text.length : text2.children.length) << 1];
    }
    nextInner(skip, dir) {
      this.done = this.lineBreak = false;
      for (; ; ) {
        let last3 = this.nodes.length - 1;
        let top3 = this.nodes[last3], offsetValue = this.offsets[last3], offset = offsetValue >> 1;
        let size3 = top3 instanceof TextLeaf ? top3.text.length : top3.children.length;
        if (offset == (dir > 0 ? size3 : 0)) {
          if (last3 == 0) {
            this.done = true;
            this.value = "";
            return this;
          }
          if (dir > 0)
            this.offsets[last3 - 1]++;
          this.nodes.pop();
          this.offsets.pop();
        } else if ((offsetValue & 1) == (dir > 0 ? 0 : 1)) {
          this.offsets[last3] += dir;
          if (skip == 0) {
            this.lineBreak = true;
            this.value = "\n";
            return this;
          }
          skip--;
        } else if (top3 instanceof TextLeaf) {
          let next = top3.text[offset + (dir < 0 ? -1 : 0)];
          this.offsets[last3] += dir;
          if (next.length > Math.max(0, skip)) {
            this.value = skip == 0 ? next : dir > 0 ? next.slice(skip) : next.slice(0, next.length - skip);
            return this;
          }
          skip -= next.length;
        } else {
          let next = top3.children[offset + (dir < 0 ? -1 : 0)];
          if (skip > next.length) {
            skip -= next.length;
            this.offsets[last3] += dir;
          } else {
            if (dir < 0)
              this.offsets[last3]--;
            this.nodes.push(next);
            this.offsets.push(dir > 0 ? 1 : (next instanceof TextLeaf ? next.text.length : next.children.length) << 1);
          }
        }
      }
    }
    next(skip = 0) {
      if (skip < 0) {
        this.nextInner(-skip, -this.dir);
        skip = this.value.length;
      }
      return this.nextInner(skip, this.dir);
    }
  };
  var PartialTextCursor = class {
    constructor(text2, start2, end) {
      this.value = "";
      this.done = false;
      this.cursor = new RawTextCursor(text2, start2 > end ? -1 : 1);
      this.pos = start2 > end ? text2.length : 0;
      this.from = Math.min(start2, end);
      this.to = Math.max(start2, end);
    }
    nextInner(skip, dir) {
      if (dir < 0 ? this.pos <= this.from : this.pos >= this.to) {
        this.value = "";
        this.done = true;
        return this;
      }
      skip += Math.max(0, dir < 0 ? this.pos - this.to : this.from - this.pos);
      let limit = dir < 0 ? this.pos - this.from : this.to - this.pos;
      if (skip > limit)
        skip = limit;
      limit -= skip;
      let { value } = this.cursor.next(skip);
      this.pos += (value.length + skip) * dir;
      this.value = value.length <= limit ? value : dir < 0 ? value.slice(value.length - limit) : value.slice(0, limit);
      this.done = !this.value;
      return this;
    }
    next(skip = 0) {
      if (skip < 0)
        skip = Math.max(skip, this.from - this.pos);
      else if (skip > 0)
        skip = Math.min(skip, this.to - this.pos);
      return this.nextInner(skip, this.cursor.dir);
    }
    get lineBreak() {
      return this.cursor.lineBreak && this.value != "";
    }
  };
  var LineCursor = class {
    constructor(inner) {
      this.inner = inner;
      this.afterBreak = true;
      this.value = "";
      this.done = false;
    }
    next(skip = 0) {
      let { done, lineBreak, value } = this.inner.next(skip);
      if (done && this.afterBreak) {
        this.value = "";
        this.afterBreak = false;
      } else if (done) {
        this.done = true;
        this.value = "";
      } else if (lineBreak) {
        if (this.afterBreak) {
          this.value = "";
        } else {
          this.afterBreak = true;
          this.next();
        }
      } else {
        this.value = value;
        this.afterBreak = false;
      }
      return this;
    }
    get lineBreak() {
      return false;
    }
  };
  if (typeof Symbol != "undefined") {
    Text.prototype[Symbol.iterator] = function() {
      return this.iter();
    };
    RawTextCursor.prototype[Symbol.iterator] = PartialTextCursor.prototype[Symbol.iterator] = LineCursor.prototype[Symbol.iterator] = function() {
      return this;
    };
  }
  var Line = class {
    constructor(from, to, number6, text2) {
      this.from = from;
      this.to = to;
      this.number = number6;
      this.text = text2;
    }
    get length() {
      return this.to - this.from;
    }
  };
  function clip(text2, from, to) {
    from = Math.max(0, Math.min(text2.length, from));
    return [from, Math.max(from, Math.min(text2.length, to))];
  }
  var extend2 = /* @__PURE__ */ "lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map((s) => s ? parseInt(s, 36) : 1);
  for (let i = 1; i < extend2.length; i++)
    extend2[i] += extend2[i - 1];
  function isExtendingChar(code) {
    for (let i = 1; i < extend2.length; i += 2)
      if (extend2[i] > code)
        return extend2[i - 1] <= code;
    return false;
  }
  function isRegionalIndicator(code) {
    return code >= 127462 && code <= 127487;
  }
  var ZWJ = 8205;
  function findClusterBreak(str, pos, forward = true, includeExtending = true) {
    return (forward ? nextClusterBreak : prevClusterBreak)(str, pos, includeExtending);
  }
  function nextClusterBreak(str, pos, includeExtending) {
    if (pos == str.length)
      return pos;
    if (pos && surrogateLow(str.charCodeAt(pos)) && surrogateHigh(str.charCodeAt(pos - 1)))
      pos--;
    let prev = codePointAt(str, pos);
    pos += codePointSize(prev);
    while (pos < str.length) {
      let next = codePointAt(str, pos);
      if (prev == ZWJ || next == ZWJ || includeExtending && isExtendingChar(next)) {
        pos += codePointSize(next);
        prev = next;
      } else if (isRegionalIndicator(next)) {
        let countBefore = 0, i = pos - 2;
        while (i >= 0 && isRegionalIndicator(codePointAt(str, i))) {
          countBefore++;
          i -= 2;
        }
        if (countBefore % 2 == 0)
          break;
        else
          pos += 2;
      } else {
        break;
      }
    }
    return pos;
  }
  function prevClusterBreak(str, pos, includeExtending) {
    while (pos > 0) {
      let found = nextClusterBreak(str, pos - 2, includeExtending);
      if (found < pos)
        return found;
      pos--;
    }
    return 0;
  }
  function surrogateLow(ch) {
    return ch >= 56320 && ch < 57344;
  }
  function surrogateHigh(ch) {
    return ch >= 55296 && ch < 56320;
  }
  function codePointAt(str, pos) {
    let code0 = str.charCodeAt(pos);
    if (!surrogateHigh(code0) || pos + 1 == str.length)
      return code0;
    let code1 = str.charCodeAt(pos + 1);
    if (!surrogateLow(code1))
      return code0;
    return (code0 - 55296 << 10) + (code1 - 56320) + 65536;
  }
  function codePointSize(code) {
    return code < 65536 ? 1 : 2;
  }
  var DefaultSplit = /\r\n?|\n/;
  var MapMode = /* @__PURE__ */ function(MapMode2) {
    MapMode2[MapMode2["Simple"] = 0] = "Simple";
    MapMode2[MapMode2["TrackDel"] = 1] = "TrackDel";
    MapMode2[MapMode2["TrackBefore"] = 2] = "TrackBefore";
    MapMode2[MapMode2["TrackAfter"] = 3] = "TrackAfter";
    return MapMode2;
  }(MapMode || (MapMode = {}));
  var ChangeDesc = class {
    constructor(sections) {
      this.sections = sections;
    }
    get length() {
      let result = 0;
      for (let i = 0; i < this.sections.length; i += 2)
        result += this.sections[i];
      return result;
    }
    get newLength() {
      let result = 0;
      for (let i = 0; i < this.sections.length; i += 2) {
        let ins = this.sections[i + 1];
        result += ins < 0 ? this.sections[i] : ins;
      }
      return result;
    }
    get empty() {
      return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0;
    }
    iterGaps(f) {
      for (let i = 0, posA = 0, posB = 0; i < this.sections.length; ) {
        let len = this.sections[i++], ins = this.sections[i++];
        if (ins < 0) {
          f(posA, posB, len);
          posB += len;
        } else {
          posB += ins;
        }
        posA += len;
      }
    }
    iterChangedRanges(f, individual = false) {
      iterChanges(this, f, individual);
    }
    get invertedDesc() {
      let sections = [];
      for (let i = 0; i < this.sections.length; ) {
        let len = this.sections[i++], ins = this.sections[i++];
        if (ins < 0)
          sections.push(len, ins);
        else
          sections.push(ins, len);
      }
      return new ChangeDesc(sections);
    }
    composeDesc(other) {
      return this.empty ? other : other.empty ? this : composeSets(this, other);
    }
    mapDesc(other, before = false) {
      return other.empty ? this : mapSet(this, other, before);
    }
    mapPos(pos, assoc = -1, mode = MapMode.Simple) {
      let posA = 0, posB = 0;
      for (let i = 0; i < this.sections.length; ) {
        let len = this.sections[i++], ins = this.sections[i++], endA = posA + len;
        if (ins < 0) {
          if (endA > pos)
            return posB + (pos - posA);
          posB += len;
        } else {
          if (mode != MapMode.Simple && endA >= pos && (mode == MapMode.TrackDel && posA < pos && endA > pos || mode == MapMode.TrackBefore && posA < pos || mode == MapMode.TrackAfter && endA > pos))
            return null;
          if (endA > pos || endA == pos && assoc < 0 && !len)
            return pos == posA || assoc < 0 ? posB : posB + ins;
          posB += ins;
        }
        posA = endA;
      }
      if (pos > posA)
        throw new RangeError(`Position ${pos} is out of range for changeset of length ${posA}`);
      return posB;
    }
    touchesRange(from, to = from) {
      for (let i = 0, pos = 0; i < this.sections.length && pos <= to; ) {
        let len = this.sections[i++], ins = this.sections[i++], end = pos + len;
        if (ins >= 0 && pos <= to && end >= from)
          return pos < from && end > to ? "cover" : true;
        pos = end;
      }
      return false;
    }
    toString() {
      let result = "";
      for (let i = 0; i < this.sections.length; ) {
        let len = this.sections[i++], ins = this.sections[i++];
        result += (result ? " " : "") + len + (ins >= 0 ? ":" + ins : "");
      }
      return result;
    }
    toJSON() {
      return this.sections;
    }
    static fromJSON(json) {
      if (!Array.isArray(json) || json.length % 2 || json.some((a) => typeof a != "number"))
        throw new RangeError("Invalid JSON representation of ChangeDesc");
      return new ChangeDesc(json);
    }
    static create(sections) {
      return new ChangeDesc(sections);
    }
  };
  var ChangeSet = class extends ChangeDesc {
    constructor(sections, inserted) {
      super(sections);
      this.inserted = inserted;
    }
    apply(doc2) {
      if (this.length != doc2.length)
        throw new RangeError("Applying change set to a document with the wrong length");
      iterChanges(this, (fromA, toA, fromB, _toB, text2) => doc2 = doc2.replace(fromB, fromB + (toA - fromA), text2), false);
      return doc2;
    }
    mapDesc(other, before = false) {
      return mapSet(this, other, before, true);
    }
    invert(doc2) {
      let sections = this.sections.slice(), inserted = [];
      for (let i = 0, pos = 0; i < sections.length; i += 2) {
        let len = sections[i], ins = sections[i + 1];
        if (ins >= 0) {
          sections[i] = ins;
          sections[i + 1] = len;
          let index3 = i >> 1;
          while (inserted.length < index3)
            inserted.push(Text.empty);
          inserted.push(len ? doc2.slice(pos, pos + len) : Text.empty);
        }
        pos += len;
      }
      return new ChangeSet(sections, inserted);
    }
    compose(other) {
      return this.empty ? other : other.empty ? this : composeSets(this, other, true);
    }
    map(other, before = false) {
      return other.empty ? this : mapSet(this, other, before, true);
    }
    iterChanges(f, individual = false) {
      iterChanges(this, f, individual);
    }
    get desc() {
      return ChangeDesc.create(this.sections);
    }
    filter(ranges) {
      let resultSections = [], resultInserted = [], filteredSections = [];
      let iter = new SectionIter(this);
      done:
        for (let i = 0, pos = 0; ; ) {
          let next = i == ranges.length ? 1e9 : ranges[i++];
          while (pos < next || pos == next && iter.len == 0) {
            if (iter.done)
              break done;
            let len = Math.min(iter.len, next - pos);
            addSection(filteredSections, len, -1);
            let ins = iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0;
            addSection(resultSections, len, ins);
            if (ins > 0)
              addInsert(resultInserted, resultSections, iter.text);
            iter.forward(len);
            pos += len;
          }
          let end = ranges[i++];
          while (pos < end) {
            if (iter.done)
              break done;
            let len = Math.min(iter.len, end - pos);
            addSection(resultSections, len, -1);
            addSection(filteredSections, len, iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0);
            iter.forward(len);
            pos += len;
          }
        }
      return {
        changes: new ChangeSet(resultSections, resultInserted),
        filtered: ChangeDesc.create(filteredSections)
      };
    }
    toJSON() {
      let parts = [];
      for (let i = 0; i < this.sections.length; i += 2) {
        let len = this.sections[i], ins = this.sections[i + 1];
        if (ins < 0)
          parts.push(len);
        else if (ins == 0)
          parts.push([len]);
        else
          parts.push([len].concat(this.inserted[i >> 1].toJSON()));
      }
      return parts;
    }
    static of(changes, length6, lineSep) {
      let sections = [], inserted = [], pos = 0;
      let total = null;
      function flush(force2 = false) {
        if (!force2 && !sections.length)
          return;
        if (pos < length6)
          addSection(sections, length6 - pos, -1);
        let set3 = new ChangeSet(sections, inserted);
        total = total ? total.compose(set3.map(total)) : set3;
        sections = [];
        inserted = [];
        pos = 0;
      }
      function process(spec) {
        if (Array.isArray(spec)) {
          for (let sub of spec)
            process(sub);
        } else if (spec instanceof ChangeSet) {
          if (spec.length != length6)
            throw new RangeError(`Mismatched change set length (got ${spec.length}, expected ${length6})`);
          flush();
          total = total ? total.compose(spec.map(total)) : spec;
        } else {
          let { from, to = from, insert: insert4 } = spec;
          if (from > to || from < 0 || to > length6)
            throw new RangeError(`Invalid change range ${from} to ${to} (in doc of length ${length6})`);
          let insText = !insert4 ? Text.empty : typeof insert4 == "string" ? Text.of(insert4.split(lineSep || DefaultSplit)) : insert4;
          let insLen = insText.length;
          if (from == to && insLen == 0)
            return;
          if (from < pos)
            flush();
          if (from > pos)
            addSection(sections, from - pos, -1);
          addSection(sections, to - from, insLen);
          addInsert(inserted, sections, insText);
          pos = to;
        }
      }
      process(changes);
      flush(!total);
      return total;
    }
    static empty(length6) {
      return new ChangeSet(length6 ? [length6, -1] : [], []);
    }
    static fromJSON(json) {
      if (!Array.isArray(json))
        throw new RangeError("Invalid JSON representation of ChangeSet");
      let sections = [], inserted = [];
      for (let i = 0; i < json.length; i++) {
        let part = json[i];
        if (typeof part == "number") {
          sections.push(part, -1);
        } else if (!Array.isArray(part) || typeof part[0] != "number" || part.some((e, i2) => i2 && typeof e != "string")) {
          throw new RangeError("Invalid JSON representation of ChangeSet");
        } else if (part.length == 1) {
          sections.push(part[0], 0);
        } else {
          while (inserted.length < i)
            inserted.push(Text.empty);
          inserted[i] = Text.of(part.slice(1));
          sections.push(part[0], inserted[i].length);
        }
      }
      return new ChangeSet(sections, inserted);
    }
    static createSet(sections, inserted) {
      return new ChangeSet(sections, inserted);
    }
  };
  function addSection(sections, len, ins, forceJoin = false) {
    if (len == 0 && ins <= 0)
      return;
    let last3 = sections.length - 2;
    if (last3 >= 0 && ins <= 0 && ins == sections[last3 + 1])
      sections[last3] += len;
    else if (len == 0 && sections[last3] == 0)
      sections[last3 + 1] += ins;
    else if (forceJoin) {
      sections[last3] += len;
      sections[last3 + 1] += ins;
    } else
      sections.push(len, ins);
  }
  function addInsert(values3, sections, value) {
    if (value.length == 0)
      return;
    let index3 = sections.length - 2 >> 1;
    if (index3 < values3.length) {
      values3[values3.length - 1] = values3[values3.length - 1].append(value);
    } else {
      while (values3.length < index3)
        values3.push(Text.empty);
      values3.push(value);
    }
  }
  function iterChanges(desc, f, individual) {
    let inserted = desc.inserted;
    for (let posA = 0, posB = 0, i = 0; i < desc.sections.length; ) {
      let len = desc.sections[i++], ins = desc.sections[i++];
      if (ins < 0) {
        posA += len;
        posB += len;
      } else {
        let endA = posA, endB = posB, text2 = Text.empty;
        for (; ; ) {
          endA += len;
          endB += ins;
          if (ins && inserted)
            text2 = text2.append(inserted[i - 2 >> 1]);
          if (individual || i == desc.sections.length || desc.sections[i + 1] < 0)
            break;
          len = desc.sections[i++];
          ins = desc.sections[i++];
        }
        f(posA, endA, posB, endB, text2);
        posA = endA;
        posB = endB;
      }
    }
  }
  function mapSet(setA, setB, before, mkSet = false) {
    let sections = [], insert4 = mkSet ? [] : null;
    let a = new SectionIter(setA), b = new SectionIter(setB);
    for (let inserted = -1; ; ) {
      if (a.ins == -1 && b.ins == -1) {
        let len = Math.min(a.len, b.len);
        addSection(sections, len, -1);
        a.forward(len);
        b.forward(len);
      } else if (b.ins >= 0 && (a.ins < 0 || inserted == a.i || a.off == 0 && (b.len < a.len || b.len == a.len && !before))) {
        let len = b.len;
        addSection(sections, b.ins, -1);
        while (len) {
          let piece = Math.min(a.len, len);
          if (a.ins >= 0 && inserted < a.i && a.len <= piece) {
            addSection(sections, 0, a.ins);
            if (insert4)
              addInsert(insert4, sections, a.text);
            inserted = a.i;
          }
          a.forward(piece);
          len -= piece;
        }
        b.next();
      } else if (a.ins >= 0) {
        let len = 0, left2 = a.len;
        while (left2) {
          if (b.ins == -1) {
            let piece = Math.min(left2, b.len);
            len += piece;
            left2 -= piece;
            b.forward(piece);
          } else if (b.ins == 0 && b.len < left2) {
            left2 -= b.len;
            b.next();
          } else {
            break;
          }
        }
        addSection(sections, len, inserted < a.i ? a.ins : 0);
        if (insert4 && inserted < a.i)
          addInsert(insert4, sections, a.text);
        inserted = a.i;
        a.forward(a.len - left2);
      } else if (a.done && b.done) {
        return insert4 ? ChangeSet.createSet(sections, insert4) : ChangeDesc.create(sections);
      } else {
        throw new Error("Mismatched change set lengths");
      }
    }
  }
  function composeSets(setA, setB, mkSet = false) {
    let sections = [];
    let insert4 = mkSet ? [] : null;
    let a = new SectionIter(setA), b = new SectionIter(setB);
    for (let open = false; ; ) {
      if (a.done && b.done) {
        return insert4 ? ChangeSet.createSet(sections, insert4) : ChangeDesc.create(sections);
      } else if (a.ins == 0) {
        addSection(sections, a.len, 0, open);
        a.next();
      } else if (b.len == 0 && !b.done) {
        addSection(sections, 0, b.ins, open);
        if (insert4)
          addInsert(insert4, sections, b.text);
        b.next();
      } else if (a.done || b.done) {
        throw new Error("Mismatched change set lengths");
      } else {
        let len = Math.min(a.len2, b.len), sectionLen = sections.length;
        if (a.ins == -1) {
          let insB = b.ins == -1 ? -1 : b.off ? 0 : b.ins;
          addSection(sections, len, insB, open);
          if (insert4 && insB)
            addInsert(insert4, sections, b.text);
        } else if (b.ins == -1) {
          addSection(sections, a.off ? 0 : a.len, len, open);
          if (insert4)
            addInsert(insert4, sections, a.textBit(len));
        } else {
          addSection(sections, a.off ? 0 : a.len, b.off ? 0 : b.ins, open);
          if (insert4 && !b.off)
            addInsert(insert4, sections, b.text);
        }
        open = (a.ins > len || b.ins >= 0 && b.len > len) && (open || sections.length > sectionLen);
        a.forward2(len);
        b.forward(len);
      }
    }
  }
  var SectionIter = class {
    constructor(set3) {
      this.set = set3;
      this.i = 0;
      this.next();
    }
    next() {
      let { sections } = this.set;
      if (this.i < sections.length) {
        this.len = sections[this.i++];
        this.ins = sections[this.i++];
      } else {
        this.len = 0;
        this.ins = -2;
      }
      this.off = 0;
    }
    get done() {
      return this.ins == -2;
    }
    get len2() {
      return this.ins < 0 ? this.len : this.ins;
    }
    get text() {
      let { inserted } = this.set, index3 = this.i - 2 >> 1;
      return index3 >= inserted.length ? Text.empty : inserted[index3];
    }
    textBit(len) {
      let { inserted } = this.set, index3 = this.i - 2 >> 1;
      return index3 >= inserted.length && !len ? Text.empty : inserted[index3].slice(this.off, len == null ? void 0 : this.off + len);
    }
    forward(len) {
      if (len == this.len)
        this.next();
      else {
        this.len -= len;
        this.off += len;
      }
    }
    forward2(len) {
      if (this.ins == -1)
        this.forward(len);
      else if (len == this.ins)
        this.next();
      else {
        this.ins -= len;
        this.off += len;
      }
    }
  };
  var SelectionRange = class {
    constructor(from, to, flags) {
      this.from = from;
      this.to = to;
      this.flags = flags;
    }
    get anchor() {
      return this.flags & 32 ? this.to : this.from;
    }
    get head() {
      return this.flags & 32 ? this.from : this.to;
    }
    get empty() {
      return this.from == this.to;
    }
    get assoc() {
      return this.flags & 8 ? -1 : this.flags & 16 ? 1 : 0;
    }
    get bidiLevel() {
      let level = this.flags & 7;
      return level == 7 ? null : level;
    }
    get goalColumn() {
      let value = this.flags >> 6;
      return value == 16777215 ? void 0 : value;
    }
    map(change, assoc = -1) {
      let from, to;
      if (this.empty) {
        from = to = change.mapPos(this.from, assoc);
      } else {
        from = change.mapPos(this.from, 1);
        to = change.mapPos(this.to, -1);
      }
      return from == this.from && to == this.to ? this : new SelectionRange(from, to, this.flags);
    }
    extend(from, to = from) {
      if (from <= this.anchor && to >= this.anchor)
        return EditorSelection.range(from, to);
      let head = Math.abs(from - this.anchor) > Math.abs(to - this.anchor) ? from : to;
      return EditorSelection.range(this.anchor, head);
    }
    eq(other, includeAssoc = false) {
      return this.anchor == other.anchor && this.head == other.head && (!includeAssoc || !this.empty || this.assoc == other.assoc);
    }
    toJSON() {
      return { anchor: this.anchor, head: this.head };
    }
    static fromJSON(json) {
      if (!json || typeof json.anchor != "number" || typeof json.head != "number")
        throw new RangeError("Invalid JSON representation for SelectionRange");
      return EditorSelection.range(json.anchor, json.head);
    }
    static create(from, to, flags) {
      return new SelectionRange(from, to, flags);
    }
  };
  var EditorSelection = class {
    constructor(ranges, mainIndex) {
      this.ranges = ranges;
      this.mainIndex = mainIndex;
    }
    map(change, assoc = -1) {
      if (change.empty)
        return this;
      return EditorSelection.create(this.ranges.map((r) => r.map(change, assoc)), this.mainIndex);
    }
    eq(other, includeAssoc = false) {
      if (this.ranges.length != other.ranges.length || this.mainIndex != other.mainIndex)
        return false;
      for (let i = 0; i < this.ranges.length; i++)
        if (!this.ranges[i].eq(other.ranges[i], includeAssoc))
          return false;
      return true;
    }
    get main() {
      return this.ranges[this.mainIndex];
    }
    asSingle() {
      return this.ranges.length == 1 ? this : new EditorSelection([this.main], 0);
    }
    addRange(range4, main2 = true) {
      return EditorSelection.create([range4].concat(this.ranges), main2 ? 0 : this.mainIndex + 1);
    }
    replaceRange(range4, which = this.mainIndex) {
      let ranges = this.ranges.slice();
      ranges[which] = range4;
      return EditorSelection.create(ranges, this.mainIndex);
    }
    toJSON() {
      return { ranges: this.ranges.map((r) => r.toJSON()), main: this.mainIndex };
    }
    static fromJSON(json) {
      if (!json || !Array.isArray(json.ranges) || typeof json.main != "number" || json.main >= json.ranges.length)
        throw new RangeError("Invalid JSON representation for EditorSelection");
      return new EditorSelection(json.ranges.map((r) => SelectionRange.fromJSON(r)), json.main);
    }
    static single(anchor, head = anchor) {
      return new EditorSelection([EditorSelection.range(anchor, head)], 0);
    }
    static create(ranges, mainIndex = 0) {
      if (ranges.length == 0)
        throw new RangeError("A selection needs at least one range");
      for (let pos = 0, i = 0; i < ranges.length; i++) {
        let range4 = ranges[i];
        if (range4.empty ? range4.from <= pos : range4.from < pos)
          return EditorSelection.normalized(ranges.slice(), mainIndex);
        pos = range4.to;
      }
      return new EditorSelection(ranges, mainIndex);
    }
    static cursor(pos, assoc = 0, bidiLevel, goalColumn) {
      return SelectionRange.create(pos, pos, (assoc == 0 ? 0 : assoc < 0 ? 8 : 16) | (bidiLevel == null ? 7 : Math.min(6, bidiLevel)) | (goalColumn !== null && goalColumn !== void 0 ? goalColumn : 16777215) << 6);
    }
    static range(anchor, head, goalColumn, bidiLevel) {
      let flags = (goalColumn !== null && goalColumn !== void 0 ? goalColumn : 16777215) << 6 | (bidiLevel == null ? 7 : Math.min(6, bidiLevel));
      return head < anchor ? SelectionRange.create(head, anchor, 32 | 16 | flags) : SelectionRange.create(anchor, head, (head > anchor ? 8 : 0) | flags);
    }
    static normalized(ranges, mainIndex = 0) {
      let main2 = ranges[mainIndex];
      ranges.sort((a, b) => a.from - b.from);
      mainIndex = ranges.indexOf(main2);
      for (let i = 1; i < ranges.length; i++) {
        let range4 = ranges[i], prev = ranges[i - 1];
        if (range4.empty ? range4.from <= prev.to : range4.from < prev.to) {
          let from = prev.from, to = Math.max(range4.to, prev.to);
          if (i <= mainIndex)
            mainIndex--;
          ranges.splice(--i, 2, range4.anchor > range4.head ? EditorSelection.range(to, from) : EditorSelection.range(from, to));
        }
      }
      return new EditorSelection(ranges, mainIndex);
    }
  };
  function checkSelection(selection2, docLength) {
    for (let range4 of selection2.ranges)
      if (range4.to > docLength)
        throw new RangeError("Selection points outside of document");
  }
  var nextID = 0;
  var Facet = class {
    constructor(combine, compareInput, compare2, isStatic, enables) {
      this.combine = combine;
      this.compareInput = compareInput;
      this.compare = compare2;
      this.isStatic = isStatic;
      this.id = nextID++;
      this.default = combine([]);
      this.extensions = typeof enables == "function" ? enables(this) : enables;
    }
    get reader() {
      return this;
    }
    static define(config = {}) {
      return new Facet(config.combine || ((a) => a), config.compareInput || ((a, b) => a === b), config.compare || (!config.combine ? sameArray : (a, b) => a === b), !!config.static, config.enables);
    }
    of(value) {
      return new FacetProvider([], this, 0, value);
    }
    compute(deps, get3) {
      if (this.isStatic)
        throw new Error("Can't compute a static facet");
      return new FacetProvider(deps, this, 1, get3);
    }
    computeN(deps, get3) {
      if (this.isStatic)
        throw new Error("Can't compute a static facet");
      return new FacetProvider(deps, this, 2, get3);
    }
    from(field3, get3) {
      if (!get3)
        get3 = (x2) => x2;
      return this.compute([field3], (state) => get3(state.field(field3)));
    }
  };
  function sameArray(a, b) {
    return a == b || a.length == b.length && a.every((e, i) => e === b[i]);
  }
  var FacetProvider = class {
    constructor(dependencies, facet, type2, value) {
      this.dependencies = dependencies;
      this.facet = facet;
      this.type = type2;
      this.value = value;
      this.id = nextID++;
    }
    dynamicSlot(addresses) {
      var _a2;
      let getter = this.value;
      let compare2 = this.facet.compareInput;
      let id3 = this.id, idx = addresses[id3] >> 1, multi = this.type == 2;
      let depDoc = false, depSel = false, depAddrs = [];
      for (let dep of this.dependencies) {
        if (dep == "doc")
          depDoc = true;
        else if (dep == "selection")
          depSel = true;
        else if ((((_a2 = addresses[dep.id]) !== null && _a2 !== void 0 ? _a2 : 1) & 1) == 0)
          depAddrs.push(addresses[dep.id]);
      }
      return {
        create(state) {
          state.values[idx] = getter(state);
          return 1;
        },
        update(state, tr) {
          if (depDoc && tr.docChanged || depSel && (tr.docChanged || tr.selection) || ensureAll(state, depAddrs)) {
            let newVal = getter(state);
            if (multi ? !compareArray(newVal, state.values[idx], compare2) : !compare2(newVal, state.values[idx])) {
              state.values[idx] = newVal;
              return 1;
            }
          }
          return 0;
        },
        reconfigure: (state, oldState) => {
          let newVal, oldAddr = oldState.config.address[id3];
          if (oldAddr != null) {
            let oldVal = getAddr(oldState, oldAddr);
            if (this.dependencies.every((dep) => {
              return dep instanceof Facet ? oldState.facet(dep) === state.facet(dep) : dep instanceof StateField ? oldState.field(dep, false) == state.field(dep, false) : true;
            }) || (multi ? compareArray(newVal = getter(state), oldVal, compare2) : compare2(newVal = getter(state), oldVal))) {
              state.values[idx] = oldVal;
              return 0;
            }
          } else {
            newVal = getter(state);
          }
          state.values[idx] = newVal;
          return 1;
        }
      };
    }
  };
  function compareArray(a, b, compare2) {
    if (a.length != b.length)
      return false;
    for (let i = 0; i < a.length; i++)
      if (!compare2(a[i], b[i]))
        return false;
    return true;
  }
  function ensureAll(state, addrs) {
    let changed = false;
    for (let addr of addrs)
      if (ensureAddr(state, addr) & 1)
        changed = true;
    return changed;
  }
  function dynamicFacetSlot(addresses, facet, providers) {
    let providerAddrs = providers.map((p) => addresses[p.id]);
    let providerTypes = providers.map((p) => p.type);
    let dynamic = providerAddrs.filter((p) => !(p & 1));
    let idx = addresses[facet.id] >> 1;
    function get3(state) {
      let values3 = [];
      for (let i = 0; i < providerAddrs.length; i++) {
        let value = getAddr(state, providerAddrs[i]);
        if (providerTypes[i] == 2)
          for (let val of value)
            values3.push(val);
        else
          values3.push(value);
      }
      return facet.combine(values3);
    }
    return {
      create(state) {
        for (let addr of providerAddrs)
          ensureAddr(state, addr);
        state.values[idx] = get3(state);
        return 1;
      },
      update(state, tr) {
        if (!ensureAll(state, dynamic))
          return 0;
        let value = get3(state);
        if (facet.compare(value, state.values[idx]))
          return 0;
        state.values[idx] = value;
        return 1;
      },
      reconfigure(state, oldState) {
        let depChanged = ensureAll(state, providerAddrs);
        let oldProviders = oldState.config.facets[facet.id], oldValue = oldState.facet(facet);
        if (oldProviders && !depChanged && sameArray(providers, oldProviders)) {
          state.values[idx] = oldValue;
          return 0;
        }
        let value = get3(state);
        if (facet.compare(value, oldValue)) {
          state.values[idx] = oldValue;
          return 0;
        }
        state.values[idx] = value;
        return 1;
      }
    };
  }
  var initField = /* @__PURE__ */ Facet.define({ static: true });
  var StateField = class {
    constructor(id3, createF, updateF, compareF, spec) {
      this.id = id3;
      this.createF = createF;
      this.updateF = updateF;
      this.compareF = compareF;
      this.spec = spec;
      this.provides = void 0;
    }
    static define(config) {
      let field3 = new StateField(nextID++, config.create, config.update, config.compare || ((a, b) => a === b), config);
      if (config.provide)
        field3.provides = config.provide(field3);
      return field3;
    }
    create(state) {
      let init5 = state.facet(initField).find((i) => i.field == this);
      return ((init5 === null || init5 === void 0 ? void 0 : init5.create) || this.createF)(state);
    }
    slot(addresses) {
      let idx = addresses[this.id] >> 1;
      return {
        create: (state) => {
          state.values[idx] = this.create(state);
          return 1;
        },
        update: (state, tr) => {
          let oldVal = state.values[idx];
          let value = this.updateF(oldVal, tr);
          if (this.compareF(oldVal, value))
            return 0;
          state.values[idx] = value;
          return 1;
        },
        reconfigure: (state, oldState) => {
          if (oldState.config.address[this.id] != null) {
            state.values[idx] = oldState.field(this);
            return 0;
          }
          state.values[idx] = this.create(state);
          return 1;
        }
      };
    }
    init(create2) {
      return [this, initField.of({ field: this, create: create2 })];
    }
    get extension() {
      return this;
    }
  };
  var Prec_ = { lowest: 4, low: 3, default: 2, high: 1, highest: 0 };
  function prec(value) {
    return (ext) => new PrecExtension(ext, value);
  }
  var Prec = {
    highest: /* @__PURE__ */ prec(Prec_.highest),
    high: /* @__PURE__ */ prec(Prec_.high),
    default: /* @__PURE__ */ prec(Prec_.default),
    low: /* @__PURE__ */ prec(Prec_.low),
    lowest: /* @__PURE__ */ prec(Prec_.lowest)
  };
  var PrecExtension = class {
    constructor(inner, prec2) {
      this.inner = inner;
      this.prec = prec2;
    }
  };
  var Compartment = class {
    of(ext) {
      return new CompartmentInstance(this, ext);
    }
    reconfigure(content2) {
      return Compartment.reconfigure.of({ compartment: this, extension: content2 });
    }
    get(state) {
      return state.config.compartments.get(this);
    }
  };
  var CompartmentInstance = class {
    constructor(compartment, inner) {
      this.compartment = compartment;
      this.inner = inner;
    }
  };
  var Configuration = class {
    constructor(base2, compartments, dynamicSlots, address, staticValues, facets) {
      this.base = base2;
      this.compartments = compartments;
      this.dynamicSlots = dynamicSlots;
      this.address = address;
      this.staticValues = staticValues;
      this.facets = facets;
      this.statusTemplate = [];
      while (this.statusTemplate.length < dynamicSlots.length)
        this.statusTemplate.push(0);
    }
    staticFacet(facet) {
      let addr = this.address[facet.id];
      return addr == null ? facet.default : this.staticValues[addr >> 1];
    }
    static resolve(base2, compartments, oldState) {
      let fields = [];
      let facets = /* @__PURE__ */ Object.create(null);
      let newCompartments = /* @__PURE__ */ new Map();
      for (let ext of flatten(base2, compartments, newCompartments)) {
        if (ext instanceof StateField)
          fields.push(ext);
        else
          (facets[ext.facet.id] || (facets[ext.facet.id] = [])).push(ext);
      }
      let address = /* @__PURE__ */ Object.create(null);
      let staticValues = [];
      let dynamicSlots = [];
      for (let field3 of fields) {
        address[field3.id] = dynamicSlots.length << 1;
        dynamicSlots.push((a) => field3.slot(a));
      }
      let oldFacets = oldState === null || oldState === void 0 ? void 0 : oldState.config.facets;
      for (let id3 in facets) {
        let providers = facets[id3], facet = providers[0].facet;
        let oldProviders = oldFacets && oldFacets[id3] || [];
        if (providers.every((p) => p.type == 0)) {
          address[facet.id] = staticValues.length << 1 | 1;
          if (sameArray(oldProviders, providers)) {
            staticValues.push(oldState.facet(facet));
          } else {
            let value = facet.combine(providers.map((p) => p.value));
            staticValues.push(oldState && facet.compare(value, oldState.facet(facet)) ? oldState.facet(facet) : value);
          }
        } else {
          for (let p of providers) {
            if (p.type == 0) {
              address[p.id] = staticValues.length << 1 | 1;
              staticValues.push(p.value);
            } else {
              address[p.id] = dynamicSlots.length << 1;
              dynamicSlots.push((a) => p.dynamicSlot(a));
            }
          }
          address[facet.id] = dynamicSlots.length << 1;
          dynamicSlots.push((a) => dynamicFacetSlot(a, facet, providers));
        }
      }
      let dynamic = dynamicSlots.map((f) => f(address));
      return new Configuration(base2, newCompartments, dynamic, address, staticValues, facets);
    }
  };
  function flatten(extension, compartments, newCompartments) {
    let result = [[], [], [], [], []];
    let seen = /* @__PURE__ */ new Map();
    function inner(ext, prec2) {
      let known = seen.get(ext);
      if (known != null) {
        if (known <= prec2)
          return;
        let found = result[known].indexOf(ext);
        if (found > -1)
          result[known].splice(found, 1);
        if (ext instanceof CompartmentInstance)
          newCompartments.delete(ext.compartment);
      }
      seen.set(ext, prec2);
      if (Array.isArray(ext)) {
        for (let e of ext)
          inner(e, prec2);
      } else if (ext instanceof CompartmentInstance) {
        if (newCompartments.has(ext.compartment))
          throw new RangeError(`Duplicate use of compartment in extensions`);
        let content2 = compartments.get(ext.compartment) || ext.inner;
        newCompartments.set(ext.compartment, content2);
        inner(content2, prec2);
      } else if (ext instanceof PrecExtension) {
        inner(ext.inner, ext.prec);
      } else if (ext instanceof StateField) {
        result[prec2].push(ext);
        if (ext.provides)
          inner(ext.provides, prec2);
      } else if (ext instanceof FacetProvider) {
        result[prec2].push(ext);
        if (ext.facet.extensions)
          inner(ext.facet.extensions, Prec_.default);
      } else {
        let content2 = ext.extension;
        if (!content2)
          throw new Error(`Unrecognized extension value in extension set (${ext}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);
        inner(content2, prec2);
      }
    }
    inner(extension, Prec_.default);
    return result.reduce((a, b) => a.concat(b));
  }
  function ensureAddr(state, addr) {
    if (addr & 1)
      return 2;
    let idx = addr >> 1;
    let status = state.status[idx];
    if (status == 4)
      throw new Error("Cyclic dependency between fields and/or facets");
    if (status & 2)
      return status;
    state.status[idx] = 4;
    let changed = state.computeSlot(state, state.config.dynamicSlots[idx]);
    return state.status[idx] = 2 | changed;
  }
  function getAddr(state, addr) {
    return addr & 1 ? state.config.staticValues[addr >> 1] : state.values[addr >> 1];
  }
  var languageData = /* @__PURE__ */ Facet.define();
  var allowMultipleSelections = /* @__PURE__ */ Facet.define({
    combine: (values3) => values3.some((v) => v),
    static: true
  });
  var lineSeparator = /* @__PURE__ */ Facet.define({
    combine: (values3) => values3.length ? values3[0] : void 0,
    static: true
  });
  var changeFilter = /* @__PURE__ */ Facet.define();
  var transactionFilter = /* @__PURE__ */ Facet.define();
  var transactionExtender = /* @__PURE__ */ Facet.define();
  var readOnly = /* @__PURE__ */ Facet.define({
    combine: (values3) => values3.length ? values3[0] : false
  });
  var Annotation = class {
    constructor(type2, value) {
      this.type = type2;
      this.value = value;
    }
    static define() {
      return new AnnotationType();
    }
  };
  var AnnotationType = class {
    of(value) {
      return new Annotation(this, value);
    }
  };
  var StateEffectType = class {
    constructor(map3) {
      this.map = map3;
    }
    of(value) {
      return new StateEffect(this, value);
    }
  };
  var StateEffect = class {
    constructor(type2, value) {
      this.type = type2;
      this.value = value;
    }
    map(mapping) {
      let mapped = this.type.map(this.value, mapping);
      return mapped === void 0 ? void 0 : mapped == this.value ? this : new StateEffect(this.type, mapped);
    }
    is(type2) {
      return this.type == type2;
    }
    static define(spec = {}) {
      return new StateEffectType(spec.map || ((v) => v));
    }
    static mapEffects(effects, mapping) {
      if (!effects.length)
        return effects;
      let result = [];
      for (let effect of effects) {
        let mapped = effect.map(mapping);
        if (mapped)
          result.push(mapped);
      }
      return result;
    }
  };
  StateEffect.reconfigure = /* @__PURE__ */ StateEffect.define();
  StateEffect.appendConfig = /* @__PURE__ */ StateEffect.define();
  var Transaction = class {
    constructor(startState2, changes, selection2, effects, annotations, scrollIntoView2) {
      this.startState = startState2;
      this.changes = changes;
      this.selection = selection2;
      this.effects = effects;
      this.annotations = annotations;
      this.scrollIntoView = scrollIntoView2;
      this._doc = null;
      this._state = null;
      if (selection2)
        checkSelection(selection2, changes.newLength);
      if (!annotations.some((a) => a.type == Transaction.time))
        this.annotations = annotations.concat(Transaction.time.of(Date.now()));
    }
    static create(startState2, changes, selection2, effects, annotations, scrollIntoView2) {
      return new Transaction(startState2, changes, selection2, effects, annotations, scrollIntoView2);
    }
    get newDoc() {
      return this._doc || (this._doc = this.changes.apply(this.startState.doc));
    }
    get newSelection() {
      return this.selection || this.startState.selection.map(this.changes);
    }
    get state() {
      if (!this._state)
        this.startState.applyTransaction(this);
      return this._state;
    }
    annotation(type2) {
      for (let ann of this.annotations)
        if (ann.type == type2)
          return ann.value;
      return void 0;
    }
    get docChanged() {
      return !this.changes.empty;
    }
    get reconfigured() {
      return this.startState.config != this.state.config;
    }
    isUserEvent(event) {
      let e = this.annotation(Transaction.userEvent);
      return !!(e && (e == event || e.length > event.length && e.slice(0, event.length) == event && e[event.length] == "."));
    }
  };
  Transaction.time = /* @__PURE__ */ Annotation.define();
  Transaction.userEvent = /* @__PURE__ */ Annotation.define();
  Transaction.addToHistory = /* @__PURE__ */ Annotation.define();
  Transaction.remote = /* @__PURE__ */ Annotation.define();
  function joinRanges(a, b) {
    let result = [];
    for (let iA = 0, iB = 0; ; ) {
      let from, to;
      if (iA < a.length && (iB == b.length || b[iB] >= a[iA])) {
        from = a[iA++];
        to = a[iA++];
      } else if (iB < b.length) {
        from = b[iB++];
        to = b[iB++];
      } else
        return result;
      if (!result.length || result[result.length - 1] < from)
        result.push(from, to);
      else if (result[result.length - 1] < to)
        result[result.length - 1] = to;
    }
  }
  function mergeTransaction(a, b, sequential) {
    var _a2;
    let mapForA, mapForB, changes;
    if (sequential) {
      mapForA = b.changes;
      mapForB = ChangeSet.empty(b.changes.length);
      changes = a.changes.compose(b.changes);
    } else {
      mapForA = b.changes.map(a.changes);
      mapForB = a.changes.mapDesc(b.changes, true);
      changes = a.changes.compose(mapForA);
    }
    return {
      changes,
      selection: b.selection ? b.selection.map(mapForB) : (_a2 = a.selection) === null || _a2 === void 0 ? void 0 : _a2.map(mapForA),
      effects: StateEffect.mapEffects(a.effects, mapForA).concat(StateEffect.mapEffects(b.effects, mapForB)),
      annotations: a.annotations.length ? a.annotations.concat(b.annotations) : b.annotations,
      scrollIntoView: a.scrollIntoView || b.scrollIntoView
    };
  }
  function resolveTransactionInner(state, spec, docSize) {
    let sel = spec.selection, annotations = asArray(spec.annotations);
    if (spec.userEvent)
      annotations = annotations.concat(Transaction.userEvent.of(spec.userEvent));
    return {
      changes: spec.changes instanceof ChangeSet ? spec.changes : ChangeSet.of(spec.changes || [], docSize, state.facet(lineSeparator)),
      selection: sel && (sel instanceof EditorSelection ? sel : EditorSelection.single(sel.anchor, sel.head)),
      effects: asArray(spec.effects),
      annotations,
      scrollIntoView: !!spec.scrollIntoView
    };
  }
  function resolveTransaction(state, specs, filter4) {
    let s = resolveTransactionInner(state, specs.length ? specs[0] : {}, state.doc.length);
    if (specs.length && specs[0].filter === false)
      filter4 = false;
    for (let i = 1; i < specs.length; i++) {
      if (specs[i].filter === false)
        filter4 = false;
      let seq = !!specs[i].sequential;
      s = mergeTransaction(s, resolveTransactionInner(state, specs[i], seq ? s.changes.newLength : state.doc.length), seq);
    }
    let tr = Transaction.create(state, s.changes, s.selection, s.effects, s.annotations, s.scrollIntoView);
    return extendTransaction(filter4 ? filterTransaction(tr) : tr);
  }
  function filterTransaction(tr) {
    let state = tr.startState;
    let result = true;
    for (let filter4 of state.facet(changeFilter)) {
      let value = filter4(tr);
      if (value === false) {
        result = false;
        break;
      }
      if (Array.isArray(value))
        result = result === true ? value : joinRanges(result, value);
    }
    if (result !== true) {
      let changes, back;
      if (result === false) {
        back = tr.changes.invertedDesc;
        changes = ChangeSet.empty(state.doc.length);
      } else {
        let filtered = tr.changes.filter(result);
        changes = filtered.changes;
        back = filtered.filtered.mapDesc(filtered.changes).invertedDesc;
      }
      tr = Transaction.create(state, changes, tr.selection && tr.selection.map(back), StateEffect.mapEffects(tr.effects, back), tr.annotations, tr.scrollIntoView);
    }
    let filters = state.facet(transactionFilter);
    for (let i = filters.length - 1; i >= 0; i--) {
      let filtered = filters[i](tr);
      if (filtered instanceof Transaction)
        tr = filtered;
      else if (Array.isArray(filtered) && filtered.length == 1 && filtered[0] instanceof Transaction)
        tr = filtered[0];
      else
        tr = resolveTransaction(state, asArray(filtered), false);
    }
    return tr;
  }
  function extendTransaction(tr) {
    let state = tr.startState, extenders = state.facet(transactionExtender), spec = tr;
    for (let i = extenders.length - 1; i >= 0; i--) {
      let extension = extenders[i](tr);
      if (extension && Object.keys(extension).length)
        spec = mergeTransaction(spec, resolveTransactionInner(state, extension, tr.changes.newLength), true);
    }
    return spec == tr ? tr : Transaction.create(state, tr.changes, tr.selection, spec.effects, spec.annotations, spec.scrollIntoView);
  }
  var none2 = [];
  function asArray(value) {
    return value == null ? none2 : Array.isArray(value) ? value : [value];
  }
  var CharCategory = /* @__PURE__ */ function(CharCategory2) {
    CharCategory2[CharCategory2["Word"] = 0] = "Word";
    CharCategory2[CharCategory2["Space"] = 1] = "Space";
    CharCategory2[CharCategory2["Other"] = 2] = "Other";
    return CharCategory2;
  }(CharCategory || (CharCategory = {}));
  var nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
  var wordChar;
  try {
    wordChar = /* @__PURE__ */ new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u");
  } catch (_) {
  }
  function hasWordChar(str) {
    if (wordChar)
      return wordChar.test(str);
    for (let i = 0; i < str.length; i++) {
      let ch = str[i];
      if (/\w/.test(ch) || ch > "\x80" && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch)))
        return true;
    }
    return false;
  }
  function makeCategorizer(wordChars) {
    return (char2) => {
      if (!/\S/.test(char2))
        return CharCategory.Space;
      if (hasWordChar(char2))
        return CharCategory.Word;
      for (let i = 0; i < wordChars.length; i++)
        if (char2.indexOf(wordChars[i]) > -1)
          return CharCategory.Word;
      return CharCategory.Other;
    };
  }
  var EditorState = class {
    constructor(config, doc2, selection2, values3, computeSlot, tr) {
      this.config = config;
      this.doc = doc2;
      this.selection = selection2;
      this.values = values3;
      this.status = config.statusTemplate.slice();
      this.computeSlot = computeSlot;
      if (tr)
        tr._state = this;
      for (let i = 0; i < this.config.dynamicSlots.length; i++)
        ensureAddr(this, i << 1);
      this.computeSlot = null;
    }
    field(field3, require2 = true) {
      let addr = this.config.address[field3.id];
      if (addr == null) {
        if (require2)
          throw new RangeError("Field is not present in this state");
        return void 0;
      }
      ensureAddr(this, addr);
      return getAddr(this, addr);
    }
    update(...specs) {
      return resolveTransaction(this, specs, true);
    }
    applyTransaction(tr) {
      let conf = this.config, { base: base2, compartments } = conf;
      for (let effect of tr.effects) {
        if (effect.is(Compartment.reconfigure)) {
          if (conf) {
            compartments = /* @__PURE__ */ new Map();
            conf.compartments.forEach((val, key) => compartments.set(key, val));
            conf = null;
          }
          compartments.set(effect.value.compartment, effect.value.extension);
        } else if (effect.is(StateEffect.reconfigure)) {
          conf = null;
          base2 = effect.value;
        } else if (effect.is(StateEffect.appendConfig)) {
          conf = null;
          base2 = asArray(base2).concat(effect.value);
        }
      }
      let startValues;
      if (!conf) {
        conf = Configuration.resolve(base2, compartments, this);
        let intermediateState = new EditorState(conf, this.doc, this.selection, conf.dynamicSlots.map(() => null), (state, slot) => slot.reconfigure(state, this), null);
        startValues = intermediateState.values;
      } else {
        startValues = tr.startState.values.slice();
      }
      let selection2 = tr.startState.facet(allowMultipleSelections) ? tr.newSelection : tr.newSelection.asSingle();
      new EditorState(conf, tr.newDoc, selection2, startValues, (state, slot) => slot.update(state, tr), tr);
    }
    replaceSelection(text2) {
      if (typeof text2 == "string")
        text2 = this.toText(text2);
      return this.changeByRange((range4) => ({
        changes: { from: range4.from, to: range4.to, insert: text2 },
        range: EditorSelection.cursor(range4.from + text2.length)
      }));
    }
    changeByRange(f) {
      let sel = this.selection;
      let result1 = f(sel.ranges[0]);
      let changes = this.changes(result1.changes), ranges = [result1.range];
      let effects = asArray(result1.effects);
      for (let i = 1; i < sel.ranges.length; i++) {
        let result = f(sel.ranges[i]);
        let newChanges = this.changes(result.changes), newMapped = newChanges.map(changes);
        for (let j = 0; j < i; j++)
          ranges[j] = ranges[j].map(newMapped);
        let mapBy = changes.mapDesc(newChanges, true);
        ranges.push(result.range.map(mapBy));
        changes = changes.compose(newMapped);
        effects = StateEffect.mapEffects(effects, newMapped).concat(StateEffect.mapEffects(asArray(result.effects), mapBy));
      }
      return {
        changes,
        selection: EditorSelection.create(ranges, sel.mainIndex),
        effects
      };
    }
    changes(spec = []) {
      if (spec instanceof ChangeSet)
        return spec;
      return ChangeSet.of(spec, this.doc.length, this.facet(EditorState.lineSeparator));
    }
    toText(string4) {
      return Text.of(string4.split(this.facet(EditorState.lineSeparator) || DefaultSplit));
    }
    sliceDoc(from = 0, to = this.doc.length) {
      return this.doc.sliceString(from, to, this.lineBreak);
    }
    facet(facet) {
      let addr = this.config.address[facet.id];
      if (addr == null)
        return facet.default;
      ensureAddr(this, addr);
      return getAddr(this, addr);
    }
    toJSON(fields) {
      let result = {
        doc: this.sliceDoc(),
        selection: this.selection.toJSON()
      };
      if (fields)
        for (let prop in fields) {
          let value = fields[prop];
          if (value instanceof StateField && this.config.address[value.id] != null)
            result[prop] = value.spec.toJSON(this.field(fields[prop]), this);
        }
      return result;
    }
    static fromJSON(json, config = {}, fields) {
      if (!json || typeof json.doc != "string")
        throw new RangeError("Invalid JSON representation for EditorState");
      let fieldInit = [];
      if (fields)
        for (let prop in fields) {
          if (Object.prototype.hasOwnProperty.call(json, prop)) {
            let field3 = fields[prop], value = json[prop];
            fieldInit.push(field3.init((state) => field3.spec.fromJSON(value, state)));
          }
        }
      return EditorState.create({
        doc: json.doc,
        selection: EditorSelection.fromJSON(json.selection),
        extensions: config.extensions ? fieldInit.concat([config.extensions]) : fieldInit
      });
    }
    static create(config = {}) {
      let configuration = Configuration.resolve(config.extensions || [], /* @__PURE__ */ new Map());
      let doc2 = config.doc instanceof Text ? config.doc : Text.of((config.doc || "").split(configuration.staticFacet(EditorState.lineSeparator) || DefaultSplit));
      let selection2 = !config.selection ? EditorSelection.single(0) : config.selection instanceof EditorSelection ? config.selection : EditorSelection.single(config.selection.anchor, config.selection.head);
      checkSelection(selection2, doc2.length);
      if (!configuration.staticFacet(allowMultipleSelections))
        selection2 = selection2.asSingle();
      return new EditorState(configuration, doc2, selection2, configuration.dynamicSlots.map(() => null), (state, slot) => slot.create(state), null);
    }
    get tabSize() {
      return this.facet(EditorState.tabSize);
    }
    get lineBreak() {
      return this.facet(EditorState.lineSeparator) || "\n";
    }
    get readOnly() {
      return this.facet(readOnly);
    }
    phrase(phrase, ...insert4) {
      for (let map3 of this.facet(EditorState.phrases))
        if (Object.prototype.hasOwnProperty.call(map3, phrase)) {
          phrase = map3[phrase];
          break;
        }
      if (insert4.length)
        phrase = phrase.replace(/\$(\$|\d*)/g, (m, i) => {
          if (i == "$")
            return "$";
          let n = +(i || 1);
          return !n || n > insert4.length ? m : insert4[n - 1];
        });
      return phrase;
    }
    languageDataAt(name3, pos, side = -1) {
      let values3 = [];
      for (let provider of this.facet(languageData)) {
        for (let result of provider(this, pos, side)) {
          if (Object.prototype.hasOwnProperty.call(result, name3))
            values3.push(result[name3]);
        }
      }
      return values3;
    }
    charCategorizer(at) {
      return makeCategorizer(this.languageDataAt("wordChars", at).join(""));
    }
    wordAt(pos) {
      let { text: text2, from, length: length6 } = this.doc.lineAt(pos);
      let cat = this.charCategorizer(pos);
      let start2 = pos - from, end = pos - from;
      while (start2 > 0) {
        let prev = findClusterBreak(text2, start2, false);
        if (cat(text2.slice(prev, start2)) != CharCategory.Word)
          break;
        start2 = prev;
      }
      while (end < length6) {
        let next = findClusterBreak(text2, end);
        if (cat(text2.slice(end, next)) != CharCategory.Word)
          break;
        end = next;
      }
      return start2 == end ? null : EditorSelection.range(start2 + from, end + from);
    }
  };
  EditorState.allowMultipleSelections = allowMultipleSelections;
  EditorState.tabSize = /* @__PURE__ */ Facet.define({
    combine: (values3) => values3.length ? values3[0] : 4
  });
  EditorState.lineSeparator = lineSeparator;
  EditorState.readOnly = readOnly;
  EditorState.phrases = /* @__PURE__ */ Facet.define({
    compare(a, b) {
      let kA = Object.keys(a), kB = Object.keys(b);
      return kA.length == kB.length && kA.every((k) => a[k] == b[k]);
    }
  });
  EditorState.languageData = languageData;
  EditorState.changeFilter = changeFilter;
  EditorState.transactionFilter = transactionFilter;
  EditorState.transactionExtender = transactionExtender;
  Compartment.reconfigure = /* @__PURE__ */ StateEffect.define();
  var RangeValue = class {
    eq(other) {
      return this == other;
    }
    range(from, to = from) {
      return Range.create(from, to, this);
    }
  };
  RangeValue.prototype.startSide = RangeValue.prototype.endSide = 0;
  RangeValue.prototype.point = false;
  RangeValue.prototype.mapMode = MapMode.TrackDel;
  var Range = class {
    constructor(from, to, value) {
      this.from = from;
      this.to = to;
      this.value = value;
    }
    static create(from, to, value) {
      return new Range(from, to, value);
    }
  };
  function cmpRange(a, b) {
    return a.from - b.from || a.value.startSide - b.value.startSide;
  }
  var Chunk = class {
    constructor(from, to, value, maxPoint) {
      this.from = from;
      this.to = to;
      this.value = value;
      this.maxPoint = maxPoint;
    }
    get length() {
      return this.to[this.to.length - 1];
    }
    findIndex(pos, side, end, startAt = 0) {
      let arr = end ? this.to : this.from;
      for (let lo = startAt, hi = arr.length; ; ) {
        if (lo == hi)
          return lo;
        let mid = lo + hi >> 1;
        let diff = arr[mid] - pos || (end ? this.value[mid].endSide : this.value[mid].startSide) - side;
        if (mid == lo)
          return diff >= 0 ? lo : hi;
        if (diff >= 0)
          hi = mid;
        else
          lo = mid + 1;
      }
    }
    between(offset, from, to, f) {
      for (let i = this.findIndex(from, -1e9, true), e = this.findIndex(to, 1e9, false, i); i < e; i++)
        if (f(this.from[i] + offset, this.to[i] + offset, this.value[i]) === false)
          return false;
    }
    map(offset, changes) {
      let value = [], from = [], to = [], newPos = -1, maxPoint = -1;
      for (let i = 0; i < this.value.length; i++) {
        let val = this.value[i], curFrom = this.from[i] + offset, curTo = this.to[i] + offset, newFrom, newTo;
        if (curFrom == curTo) {
          let mapped = changes.mapPos(curFrom, val.startSide, val.mapMode);
          if (mapped == null)
            continue;
          newFrom = newTo = mapped;
          if (val.startSide != val.endSide) {
            newTo = changes.mapPos(curFrom, val.endSide);
            if (newTo < newFrom)
              continue;
          }
        } else {
          newFrom = changes.mapPos(curFrom, val.startSide);
          newTo = changes.mapPos(curTo, val.endSide);
          if (newFrom > newTo || newFrom == newTo && val.startSide > 0 && val.endSide <= 0)
            continue;
        }
        if ((newTo - newFrom || val.endSide - val.startSide) < 0)
          continue;
        if (newPos < 0)
          newPos = newFrom;
        if (val.point)
          maxPoint = Math.max(maxPoint, newTo - newFrom);
        value.push(val);
        from.push(newFrom - newPos);
        to.push(newTo - newPos);
      }
      return { mapped: value.length ? new Chunk(from, to, value, maxPoint) : null, pos: newPos };
    }
  };
  var RangeSet = class {
    constructor(chunkPos, chunk, nextLayer, maxPoint) {
      this.chunkPos = chunkPos;
      this.chunk = chunk;
      this.nextLayer = nextLayer;
      this.maxPoint = maxPoint;
    }
    static create(chunkPos, chunk, nextLayer, maxPoint) {
      return new RangeSet(chunkPos, chunk, nextLayer, maxPoint);
    }
    get length() {
      let last3 = this.chunk.length - 1;
      return last3 < 0 ? 0 : Math.max(this.chunkEnd(last3), this.nextLayer.length);
    }
    get size() {
      if (this.isEmpty)
        return 0;
      let size3 = this.nextLayer.size;
      for (let chunk of this.chunk)
        size3 += chunk.value.length;
      return size3;
    }
    chunkEnd(index3) {
      return this.chunkPos[index3] + this.chunk[index3].length;
    }
    update(updateSpec) {
      let { add = [], sort = false, filterFrom = 0, filterTo = this.length } = updateSpec;
      let filter4 = updateSpec.filter;
      if (add.length == 0 && !filter4)
        return this;
      if (sort)
        add = add.slice().sort(cmpRange);
      if (this.isEmpty)
        return add.length ? RangeSet.of(add) : this;
      let cur = new LayerCursor(this, null, -1).goto(0), i = 0, spill = [];
      let builder = new RangeSetBuilder();
      while (cur.value || i < add.length) {
        if (i < add.length && (cur.from - add[i].from || cur.startSide - add[i].value.startSide) >= 0) {
          let range4 = add[i++];
          if (!builder.addInner(range4.from, range4.to, range4.value))
            spill.push(range4);
        } else if (cur.rangeIndex == 1 && cur.chunkIndex < this.chunk.length && (i == add.length || this.chunkEnd(cur.chunkIndex) < add[i].from) && (!filter4 || filterFrom > this.chunkEnd(cur.chunkIndex) || filterTo < this.chunkPos[cur.chunkIndex]) && builder.addChunk(this.chunkPos[cur.chunkIndex], this.chunk[cur.chunkIndex])) {
          cur.nextChunk();
        } else {
          if (!filter4 || filterFrom > cur.to || filterTo < cur.from || filter4(cur.from, cur.to, cur.value)) {
            if (!builder.addInner(cur.from, cur.to, cur.value))
              spill.push(Range.create(cur.from, cur.to, cur.value));
          }
          cur.next();
        }
      }
      return builder.finishInner(this.nextLayer.isEmpty && !spill.length ? RangeSet.empty : this.nextLayer.update({ add: spill, filter: filter4, filterFrom, filterTo }));
    }
    map(changes) {
      if (changes.empty || this.isEmpty)
        return this;
      let chunks = [], chunkPos = [], maxPoint = -1;
      for (let i = 0; i < this.chunk.length; i++) {
        let start2 = this.chunkPos[i], chunk = this.chunk[i];
        let touch = changes.touchesRange(start2, start2 + chunk.length);
        if (touch === false) {
          maxPoint = Math.max(maxPoint, chunk.maxPoint);
          chunks.push(chunk);
          chunkPos.push(changes.mapPos(start2));
        } else if (touch === true) {
          let { mapped, pos } = chunk.map(start2, changes);
          if (mapped) {
            maxPoint = Math.max(maxPoint, mapped.maxPoint);
            chunks.push(mapped);
            chunkPos.push(pos);
          }
        }
      }
      let next = this.nextLayer.map(changes);
      return chunks.length == 0 ? next : new RangeSet(chunkPos, chunks, next || RangeSet.empty, maxPoint);
    }
    between(from, to, f) {
      if (this.isEmpty)
        return;
      for (let i = 0; i < this.chunk.length; i++) {
        let start2 = this.chunkPos[i], chunk = this.chunk[i];
        if (to >= start2 && from <= start2 + chunk.length && chunk.between(start2, from - start2, to - start2, f) === false)
          return;
      }
      this.nextLayer.between(from, to, f);
    }
    iter(from = 0) {
      return HeapCursor.from([this]).goto(from);
    }
    get isEmpty() {
      return this.nextLayer == this;
    }
    static iter(sets, from = 0) {
      return HeapCursor.from(sets).goto(from);
    }
    static compare(oldSets, newSets, textDiff, comparator, minPointSize = -1) {
      let a = oldSets.filter((set3) => set3.maxPoint > 0 || !set3.isEmpty && set3.maxPoint >= minPointSize);
      let b = newSets.filter((set3) => set3.maxPoint > 0 || !set3.isEmpty && set3.maxPoint >= minPointSize);
      let sharedChunks = findSharedChunks(a, b, textDiff);
      let sideA = new SpanCursor(a, sharedChunks, minPointSize);
      let sideB = new SpanCursor(b, sharedChunks, minPointSize);
      textDiff.iterGaps((fromA, fromB, length6) => compare(sideA, fromA, sideB, fromB, length6, comparator));
      if (textDiff.empty && textDiff.length == 0)
        compare(sideA, 0, sideB, 0, 0, comparator);
    }
    static eq(oldSets, newSets, from = 0, to) {
      if (to == null)
        to = 1e9 - 1;
      let a = oldSets.filter((set3) => !set3.isEmpty && newSets.indexOf(set3) < 0);
      let b = newSets.filter((set3) => !set3.isEmpty && oldSets.indexOf(set3) < 0);
      if (a.length != b.length)
        return false;
      if (!a.length)
        return true;
      let sharedChunks = findSharedChunks(a, b);
      let sideA = new SpanCursor(a, sharedChunks, 0).goto(from), sideB = new SpanCursor(b, sharedChunks, 0).goto(from);
      for (; ; ) {
        if (sideA.to != sideB.to || !sameValues(sideA.active, sideB.active) || sideA.point && (!sideB.point || !sideA.point.eq(sideB.point)))
          return false;
        if (sideA.to > to)
          return true;
        sideA.next();
        sideB.next();
      }
    }
    static spans(sets, from, to, iterator, minPointSize = -1) {
      let cursor = new SpanCursor(sets, null, minPointSize).goto(from), pos = from;
      let openRanges = cursor.openStart;
      for (; ; ) {
        let curTo = Math.min(cursor.to, to);
        if (cursor.point) {
          let active = cursor.activeForPoint(cursor.to);
          let openCount = cursor.pointFrom < from ? active.length + 1 : cursor.point.startSide < 0 ? active.length : Math.min(active.length, openRanges);
          iterator.point(pos, curTo, cursor.point, active, openCount, cursor.pointRank);
          openRanges = Math.min(cursor.openEnd(curTo), active.length);
        } else if (curTo > pos) {
          iterator.span(pos, curTo, cursor.active, openRanges);
          openRanges = cursor.openEnd(curTo);
        }
        if (cursor.to > to)
          return openRanges + (cursor.point && cursor.to > to ? 1 : 0);
        pos = cursor.to;
        cursor.next();
      }
    }
    static of(ranges, sort = false) {
      let build = new RangeSetBuilder();
      for (let range4 of ranges instanceof Range ? [ranges] : sort ? lazySort(ranges) : ranges)
        build.add(range4.from, range4.to, range4.value);
      return build.finish();
    }
    static join(sets) {
      if (!sets.length)
        return RangeSet.empty;
      let result = sets[sets.length - 1];
      for (let i = sets.length - 2; i >= 0; i--) {
        for (let layer = sets[i]; layer != RangeSet.empty; layer = layer.nextLayer)
          result = new RangeSet(layer.chunkPos, layer.chunk, result, Math.max(layer.maxPoint, result.maxPoint));
      }
      return result;
    }
  };
  RangeSet.empty = /* @__PURE__ */ new RangeSet([], [], null, -1);
  function lazySort(ranges) {
    if (ranges.length > 1)
      for (let prev = ranges[0], i = 1; i < ranges.length; i++) {
        let cur = ranges[i];
        if (cmpRange(prev, cur) > 0)
          return ranges.slice().sort(cmpRange);
        prev = cur;
      }
    return ranges;
  }
  RangeSet.empty.nextLayer = RangeSet.empty;
  var RangeSetBuilder = class {
    finishChunk(newArrays) {
      this.chunks.push(new Chunk(this.from, this.to, this.value, this.maxPoint));
      this.chunkPos.push(this.chunkStart);
      this.chunkStart = -1;
      this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint);
      this.maxPoint = -1;
      if (newArrays) {
        this.from = [];
        this.to = [];
        this.value = [];
      }
    }
    constructor() {
      this.chunks = [];
      this.chunkPos = [];
      this.chunkStart = -1;
      this.last = null;
      this.lastFrom = -1e9;
      this.lastTo = -1e9;
      this.from = [];
      this.to = [];
      this.value = [];
      this.maxPoint = -1;
      this.setMaxPoint = -1;
      this.nextLayer = null;
    }
    add(from, to, value) {
      if (!this.addInner(from, to, value))
        (this.nextLayer || (this.nextLayer = new RangeSetBuilder())).add(from, to, value);
    }
    addInner(from, to, value) {
      let diff = from - this.lastTo || value.startSide - this.last.endSide;
      if (diff <= 0 && (from - this.lastFrom || value.startSide - this.last.startSide) < 0)
        throw new Error("Ranges must be added sorted by `from` position and `startSide`");
      if (diff < 0)
        return false;
      if (this.from.length == 250)
        this.finishChunk(true);
      if (this.chunkStart < 0)
        this.chunkStart = from;
      this.from.push(from - this.chunkStart);
      this.to.push(to - this.chunkStart);
      this.last = value;
      this.lastFrom = from;
      this.lastTo = to;
      this.value.push(value);
      if (value.point)
        this.maxPoint = Math.max(this.maxPoint, to - from);
      return true;
    }
    addChunk(from, chunk) {
      if ((from - this.lastTo || chunk.value[0].startSide - this.last.endSide) < 0)
        return false;
      if (this.from.length)
        this.finishChunk(true);
      this.setMaxPoint = Math.max(this.setMaxPoint, chunk.maxPoint);
      this.chunks.push(chunk);
      this.chunkPos.push(from);
      let last3 = chunk.value.length - 1;
      this.last = chunk.value[last3];
      this.lastFrom = chunk.from[last3] + from;
      this.lastTo = chunk.to[last3] + from;
      return true;
    }
    finish() {
      return this.finishInner(RangeSet.empty);
    }
    finishInner(next) {
      if (this.from.length)
        this.finishChunk(false);
      if (this.chunks.length == 0)
        return next;
      let result = RangeSet.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(next) : next, this.setMaxPoint);
      this.from = null;
      return result;
    }
  };
  function findSharedChunks(a, b, textDiff) {
    let inA = /* @__PURE__ */ new Map();
    for (let set3 of a)
      for (let i = 0; i < set3.chunk.length; i++)
        if (set3.chunk[i].maxPoint <= 0)
          inA.set(set3.chunk[i], set3.chunkPos[i]);
    let shared = /* @__PURE__ */ new Set();
    for (let set3 of b)
      for (let i = 0; i < set3.chunk.length; i++) {
        let known = inA.get(set3.chunk[i]);
        if (known != null && (textDiff ? textDiff.mapPos(known) : known) == set3.chunkPos[i] && !(textDiff === null || textDiff === void 0 ? void 0 : textDiff.touchesRange(known, known + set3.chunk[i].length)))
          shared.add(set3.chunk[i]);
      }
    return shared;
  }
  var LayerCursor = class {
    constructor(layer, skip, minPoint, rank = 0) {
      this.layer = layer;
      this.skip = skip;
      this.minPoint = minPoint;
      this.rank = rank;
    }
    get startSide() {
      return this.value ? this.value.startSide : 0;
    }
    get endSide() {
      return this.value ? this.value.endSide : 0;
    }
    goto(pos, side = -1e9) {
      this.chunkIndex = this.rangeIndex = 0;
      this.gotoInner(pos, side, false);
      return this;
    }
    gotoInner(pos, side, forward) {
      while (this.chunkIndex < this.layer.chunk.length) {
        let next = this.layer.chunk[this.chunkIndex];
        if (!(this.skip && this.skip.has(next) || this.layer.chunkEnd(this.chunkIndex) < pos || next.maxPoint < this.minPoint))
          break;
        this.chunkIndex++;
        forward = false;
      }
      if (this.chunkIndex < this.layer.chunk.length) {
        let rangeIndex = this.layer.chunk[this.chunkIndex].findIndex(pos - this.layer.chunkPos[this.chunkIndex], side, true);
        if (!forward || this.rangeIndex < rangeIndex)
          this.setRangeIndex(rangeIndex);
      }
      this.next();
    }
    forward(pos, side) {
      if ((this.to - pos || this.endSide - side) < 0)
        this.gotoInner(pos, side, true);
    }
    next() {
      for (; ; ) {
        if (this.chunkIndex == this.layer.chunk.length) {
          this.from = this.to = 1e9;
          this.value = null;
          break;
        } else {
          let chunkPos = this.layer.chunkPos[this.chunkIndex], chunk = this.layer.chunk[this.chunkIndex];
          let from = chunkPos + chunk.from[this.rangeIndex];
          this.from = from;
          this.to = chunkPos + chunk.to[this.rangeIndex];
          this.value = chunk.value[this.rangeIndex];
          this.setRangeIndex(this.rangeIndex + 1);
          if (this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)
            break;
        }
      }
    }
    setRangeIndex(index3) {
      if (index3 == this.layer.chunk[this.chunkIndex].value.length) {
        this.chunkIndex++;
        if (this.skip) {
          while (this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]))
            this.chunkIndex++;
        }
        this.rangeIndex = 0;
      } else {
        this.rangeIndex = index3;
      }
    }
    nextChunk() {
      this.chunkIndex++;
      this.rangeIndex = 0;
      this.next();
    }
    compare(other) {
      return this.from - other.from || this.startSide - other.startSide || this.rank - other.rank || this.to - other.to || this.endSide - other.endSide;
    }
  };
  var HeapCursor = class {
    constructor(heap) {
      this.heap = heap;
    }
    static from(sets, skip = null, minPoint = -1) {
      let heap = [];
      for (let i = 0; i < sets.length; i++) {
        for (let cur = sets[i]; !cur.isEmpty; cur = cur.nextLayer) {
          if (cur.maxPoint >= minPoint)
            heap.push(new LayerCursor(cur, skip, minPoint, i));
        }
      }
      return heap.length == 1 ? heap[0] : new HeapCursor(heap);
    }
    get startSide() {
      return this.value ? this.value.startSide : 0;
    }
    goto(pos, side = -1e9) {
      for (let cur of this.heap)
        cur.goto(pos, side);
      for (let i = this.heap.length >> 1; i >= 0; i--)
        heapBubble(this.heap, i);
      this.next();
      return this;
    }
    forward(pos, side) {
      for (let cur of this.heap)
        cur.forward(pos, side);
      for (let i = this.heap.length >> 1; i >= 0; i--)
        heapBubble(this.heap, i);
      if ((this.to - pos || this.value.endSide - side) < 0)
        this.next();
    }
    next() {
      if (this.heap.length == 0) {
        this.from = this.to = 1e9;
        this.value = null;
        this.rank = -1;
      } else {
        let top3 = this.heap[0];
        this.from = top3.from;
        this.to = top3.to;
        this.value = top3.value;
        this.rank = top3.rank;
        if (top3.value)
          top3.next();
        heapBubble(this.heap, 0);
      }
    }
  };
  function heapBubble(heap, index3) {
    for (let cur = heap[index3]; ; ) {
      let childIndex = (index3 << 1) + 1;
      if (childIndex >= heap.length)
        break;
      let child = heap[childIndex];
      if (childIndex + 1 < heap.length && child.compare(heap[childIndex + 1]) >= 0) {
        child = heap[childIndex + 1];
        childIndex++;
      }
      if (cur.compare(child) < 0)
        break;
      heap[childIndex] = cur;
      heap[index3] = child;
      index3 = childIndex;
    }
  }
  var SpanCursor = class {
    constructor(sets, skip, minPoint) {
      this.minPoint = minPoint;
      this.active = [];
      this.activeTo = [];
      this.activeRank = [];
      this.minActive = -1;
      this.point = null;
      this.pointFrom = 0;
      this.pointRank = 0;
      this.to = -1e9;
      this.endSide = 0;
      this.openStart = -1;
      this.cursor = HeapCursor.from(sets, skip, minPoint);
    }
    goto(pos, side = -1e9) {
      this.cursor.goto(pos, side);
      this.active.length = this.activeTo.length = this.activeRank.length = 0;
      this.minActive = -1;
      this.to = pos;
      this.endSide = side;
      this.openStart = -1;
      this.next();
      return this;
    }
    forward(pos, side) {
      while (this.minActive > -1 && (this.activeTo[this.minActive] - pos || this.active[this.minActive].endSide - side) < 0)
        this.removeActive(this.minActive);
      this.cursor.forward(pos, side);
    }
    removeActive(index3) {
      remove2(this.active, index3);
      remove2(this.activeTo, index3);
      remove2(this.activeRank, index3);
      this.minActive = findMinIndex(this.active, this.activeTo);
    }
    addActive(trackOpen) {
      let i = 0, { value, to, rank } = this.cursor;
      while (i < this.activeRank.length && (rank - this.activeRank[i] || to - this.activeTo[i]) > 0)
        i++;
      insert(this.active, i, value);
      insert(this.activeTo, i, to);
      insert(this.activeRank, i, rank);
      if (trackOpen)
        insert(trackOpen, i, this.cursor.from);
      this.minActive = findMinIndex(this.active, this.activeTo);
    }
    next() {
      let from = this.to, wasPoint = this.point;
      this.point = null;
      let trackOpen = this.openStart < 0 ? [] : null;
      for (; ; ) {
        let a = this.minActive;
        if (a > -1 && (this.activeTo[a] - this.cursor.from || this.active[a].endSide - this.cursor.startSide) < 0) {
          if (this.activeTo[a] > from) {
            this.to = this.activeTo[a];
            this.endSide = this.active[a].endSide;
            break;
          }
          this.removeActive(a);
          if (trackOpen)
            remove2(trackOpen, a);
        } else if (!this.cursor.value) {
          this.to = this.endSide = 1e9;
          break;
        } else if (this.cursor.from > from) {
          this.to = this.cursor.from;
          this.endSide = this.cursor.startSide;
          break;
        } else {
          let nextVal = this.cursor.value;
          if (!nextVal.point) {
            this.addActive(trackOpen);
            this.cursor.next();
          } else if (wasPoint && this.cursor.to == this.to && this.cursor.from < this.cursor.to) {
            this.cursor.next();
          } else {
            this.point = nextVal;
            this.pointFrom = this.cursor.from;
            this.pointRank = this.cursor.rank;
            this.to = this.cursor.to;
            this.endSide = nextVal.endSide;
            this.cursor.next();
            this.forward(this.to, this.endSide);
            break;
          }
        }
      }
      if (trackOpen) {
        this.openStart = 0;
        for (let i = trackOpen.length - 1; i >= 0 && trackOpen[i] < from; i--)
          this.openStart++;
      }
    }
    activeForPoint(to) {
      if (!this.active.length)
        return this.active;
      let active = [];
      for (let i = this.active.length - 1; i >= 0; i--) {
        if (this.activeRank[i] < this.pointRank)
          break;
        if (this.activeTo[i] > to || this.activeTo[i] == to && this.active[i].endSide >= this.point.endSide)
          active.push(this.active[i]);
      }
      return active.reverse();
    }
    openEnd(to) {
      let open = 0;
      for (let i = this.activeTo.length - 1; i >= 0 && this.activeTo[i] > to; i--)
        open++;
      return open;
    }
  };
  function compare(a, startA, b, startB, length6, comparator) {
    a.goto(startA);
    b.goto(startB);
    let endB = startB + length6;
    let pos = startB, dPos = startB - startA;
    for (; ; ) {
      let diff = a.to + dPos - b.to || a.endSide - b.endSide;
      let end = diff < 0 ? a.to + dPos : b.to, clipEnd = Math.min(end, endB);
      if (a.point || b.point) {
        if (!(a.point && b.point && (a.point == b.point || a.point.eq(b.point)) && sameValues(a.activeForPoint(a.to), b.activeForPoint(b.to))))
          comparator.comparePoint(pos, clipEnd, a.point, b.point);
      } else {
        if (clipEnd > pos && !sameValues(a.active, b.active))
          comparator.compareRange(pos, clipEnd, a.active, b.active);
      }
      if (end > endB)
        break;
      pos = end;
      if (diff <= 0)
        a.next();
      if (diff >= 0)
        b.next();
    }
  }
  function sameValues(a, b) {
    if (a.length != b.length)
      return false;
    for (let i = 0; i < a.length; i++)
      if (a[i] != b[i] && !a[i].eq(b[i]))
        return false;
    return true;
  }
  function remove2(array2, index3) {
    for (let i = index3, e = array2.length - 1; i < e; i++)
      array2[i] = array2[i + 1];
    array2.pop();
  }
  function insert(array2, index3, value) {
    for (let i = array2.length - 1; i >= index3; i--)
      array2[i + 1] = array2[i];
    array2[index3] = value;
  }
  function findMinIndex(value, array2) {
    let found = -1, foundPos = 1e9;
    for (let i = 0; i < array2.length; i++)
      if ((array2[i] - foundPos || value[i].endSide - value[found].endSide) < 0) {
        found = i;
        foundPos = array2[i];
      }
    return found;
  }
  function countColumn(string4, tabSize, to = string4.length) {
    let n = 0;
    for (let i = 0; i < to; ) {
      if (string4.charCodeAt(i) == 9) {
        n += tabSize - n % tabSize;
        i++;
      } else {
        n++;
        i = findClusterBreak(string4, i);
      }
    }
    return n;
  }
  function findColumn(string4, col, tabSize, strict) {
    for (let i = 0, n = 0; ; ) {
      if (n >= col)
        return i;
      if (i == string4.length)
        break;
      n += string4.charCodeAt(i) == 9 ? tabSize - n % tabSize : 1;
      i = findClusterBreak(string4, i);
    }
    return strict === true ? -1 : string4.length;
  }

  // node_modules/style-mod/src/style-mod.js
  var C = "\u037C";
  var COUNT = typeof Symbol == "undefined" ? "__" + C : Symbol.for(C);
  var SET = typeof Symbol == "undefined" ? "__styleSet" + Math.floor(Math.random() * 1e8) : Symbol("styleSet");
  var top2 = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : {};
  var StyleModule = class {
    constructor(spec, options) {
      this.rules = [];
      let { finish } = options || {};
      function splitSelector(selector2) {
        return /^@/.test(selector2) ? [selector2] : selector2.split(/,\s*/);
      }
      function render(selectors, spec2, target, isKeyframes) {
        let local = [], isAt = /^@(\w+)\b/.exec(selectors[0]), keyframes = isAt && isAt[1] == "keyframes";
        if (isAt && spec2 == null)
          return target.push(selectors[0] + ";");
        for (let prop in spec2) {
          let value = spec2[prop];
          if (/&/.test(prop)) {
            render(
              prop.split(/,\s*/).map((part) => selectors.map((sel) => part.replace(/&/, sel))).reduce((a, b) => a.concat(b)),
              value,
              target
            );
          } else if (value && typeof value == "object") {
            if (!isAt)
              throw new RangeError("The value of a property (" + prop + ") should be a primitive value.");
            render(splitSelector(prop), value, local, keyframes);
          } else if (value != null) {
            local.push(prop.replace(/_.*/, "").replace(/[A-Z]/g, (l) => "-" + l.toLowerCase()) + ": " + value + ";");
          }
        }
        if (local.length || keyframes) {
          target.push((finish && !isAt && !isKeyframes ? selectors.map(finish) : selectors).join(", ") + " {" + local.join(" ") + "}");
        }
      }
      for (let prop in spec)
        render(splitSelector(prop), spec[prop], this.rules);
    }
    getRules() {
      return this.rules.join("\n");
    }
    static newName() {
      let id3 = top2[COUNT] || 1;
      top2[COUNT] = id3 + 1;
      return C + id3.toString(36);
    }
    static mount(root2, modules, options) {
      let set3 = root2[SET], nonce = options && options.nonce;
      if (!set3)
        set3 = new StyleSet(root2, nonce);
      else if (nonce)
        set3.setNonce(nonce);
      set3.mount(Array.isArray(modules) ? modules : [modules], root2);
    }
  };
  var adoptedSet = /* @__PURE__ */ new Map();
  var StyleSet = class {
    constructor(root2, nonce) {
      let doc2 = root2.ownerDocument || root2, win = doc2.defaultView;
      if (!root2.head && root2.adoptedStyleSheets && win.CSSStyleSheet) {
        let adopted = adoptedSet.get(doc2);
        if (adopted)
          return root2[SET] = adopted;
        this.sheet = new win.CSSStyleSheet();
        adoptedSet.set(doc2, this);
      } else {
        this.styleTag = doc2.createElement("style");
        if (nonce)
          this.styleTag.setAttribute("nonce", nonce);
      }
      this.modules = [];
      root2[SET] = this;
    }
    mount(modules, root2) {
      let sheet = this.sheet;
      let pos = 0, j = 0;
      for (let i = 0; i < modules.length; i++) {
        let mod = modules[i], index3 = this.modules.indexOf(mod);
        if (index3 < j && index3 > -1) {
          this.modules.splice(index3, 1);
          j--;
          index3 = -1;
        }
        if (index3 == -1) {
          this.modules.splice(j++, 0, mod);
          if (sheet)
            for (let k = 0; k < mod.rules.length; k++)
              sheet.insertRule(mod.rules[k], pos++);
        } else {
          while (j < index3)
            pos += this.modules[j++].rules.length;
          pos += mod.rules.length;
          j++;
        }
      }
      if (sheet) {
        if (root2.adoptedStyleSheets.indexOf(this.sheet) < 0)
          root2.adoptedStyleSheets = [this.sheet, ...root2.adoptedStyleSheets];
      } else {
        let text2 = "";
        for (let i = 0; i < this.modules.length; i++)
          text2 += this.modules[i].getRules() + "\n";
        this.styleTag.textContent = text2;
        let target = root2.head || root2;
        if (this.styleTag.parentNode != target)
          target.insertBefore(this.styleTag, target.firstChild);
      }
    }
    setNonce(nonce) {
      if (this.styleTag && this.styleTag.getAttribute("nonce") != nonce)
        this.styleTag.setAttribute("nonce", nonce);
    }
  };

  // node_modules/w3c-keyname/index.js
  var base = {
    8: "Backspace",
    9: "Tab",
    10: "Enter",
    12: "NumLock",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    44: "PrintScreen",
    45: "Insert",
    46: "Delete",
    59: ";",
    61: "=",
    91: "Meta",
    92: "Meta",
    106: "*",
    107: "+",
    108: ",",
    109: "-",
    110: ".",
    111: "/",
    144: "NumLock",
    145: "ScrollLock",
    160: "Shift",
    161: "Shift",
    162: "Control",
    163: "Control",
    164: "Alt",
    165: "Alt",
    173: "-",
    186: ";",
    187: "=",
    188: ",",
    189: "-",
    190: ".",
    191: "/",
    192: "`",
    219: "[",
    220: "\\",
    221: "]",
    222: "'"
  };
  var shift = {
    48: ")",
    49: "!",
    50: "@",
    51: "#",
    52: "$",
    53: "%",
    54: "^",
    55: "&",
    56: "*",
    57: "(",
    59: ":",
    61: "+",
    173: "_",
    186: ":",
    187: "+",
    188: "<",
    189: "_",
    190: ">",
    191: "?",
    192: "~",
    219: "{",
    220: "|",
    221: "}",
    222: '"'
  };
  var mac = typeof navigator != "undefined" && /Mac/.test(navigator.platform);
  var ie = typeof navigator != "undefined" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
  for (i = 0; i < 10; i++)
    base[48 + i] = base[96 + i] = String(i);
  var i;
  for (i = 1; i <= 24; i++)
    base[i + 111] = "F" + i;
  var i;
  for (i = 65; i <= 90; i++) {
    base[i] = String.fromCharCode(i + 32);
    shift[i] = String.fromCharCode(i);
  }
  var i;
  for (code in base)
    if (!shift.hasOwnProperty(code))
      shift[code] = base[code];
  var code;
  function keyName(event) {
    var ignoreKey = mac && event.metaKey && event.shiftKey && !event.ctrlKey && !event.altKey || ie && event.shiftKey && event.key && event.key.length == 1 || event.key == "Unidentified";
    var name3 = !ignoreKey && event.key || (event.shiftKey ? shift : base)[event.keyCode] || event.key || "Unidentified";
    if (name3 == "Esc")
      name3 = "Escape";
    if (name3 == "Del")
      name3 = "Delete";
    if (name3 == "Left")
      name3 = "ArrowLeft";
    if (name3 == "Up")
      name3 = "ArrowUp";
    if (name3 == "Right")
      name3 = "ArrowRight";
    if (name3 == "Down")
      name3 = "ArrowDown";
    return name3;
  }

  // node_modules/@codemirror/view/dist/index.js
  function getSelection(root2) {
    let target;
    if (root2.nodeType == 11) {
      target = root2.getSelection ? root2 : root2.ownerDocument;
    } else {
      target = root2;
    }
    return target.getSelection();
  }
  function contains(dom, node2) {
    return node2 ? dom == node2 || dom.contains(node2.nodeType != 1 ? node2.parentNode : node2) : false;
  }
  function deepActiveElement(doc2) {
    let elt = doc2.activeElement;
    while (elt && elt.shadowRoot)
      elt = elt.shadowRoot.activeElement;
    return elt;
  }
  function hasSelection(dom, selection2) {
    if (!selection2.anchorNode)
      return false;
    try {
      return contains(dom, selection2.anchorNode);
    } catch (_) {
      return false;
    }
  }
  function clientRectsFor(dom) {
    if (dom.nodeType == 3)
      return textRange(dom, 0, dom.nodeValue.length).getClientRects();
    else if (dom.nodeType == 1)
      return dom.getClientRects();
    else
      return [];
  }
  function isEquivalentPosition(node2, off, targetNode, targetOff) {
    return targetNode ? scanFor(node2, off, targetNode, targetOff, -1) || scanFor(node2, off, targetNode, targetOff, 1) : false;
  }
  function domIndex(node2) {
    for (var index3 = 0; ; index3++) {
      node2 = node2.previousSibling;
      if (!node2)
        return index3;
    }
  }
  function isBlockElement(node2) {
    return node2.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(node2.nodeName);
  }
  function scanFor(node2, off, targetNode, targetOff, dir) {
    for (; ; ) {
      if (node2 == targetNode && off == targetOff)
        return true;
      if (off == (dir < 0 ? 0 : maxOffset(node2))) {
        if (node2.nodeName == "DIV")
          return false;
        let parent = node2.parentNode;
        if (!parent || parent.nodeType != 1)
          return false;
        off = domIndex(node2) + (dir < 0 ? 0 : 1);
        node2 = parent;
      } else if (node2.nodeType == 1) {
        node2 = node2.childNodes[off + (dir < 0 ? -1 : 0)];
        if (node2.nodeType == 1 && node2.contentEditable == "false")
          return false;
        off = dir < 0 ? maxOffset(node2) : 0;
      } else {
        return false;
      }
    }
  }
  function maxOffset(node2) {
    return node2.nodeType == 3 ? node2.nodeValue.length : node2.childNodes.length;
  }
  function flattenRect(rect, left2) {
    let x2 = left2 ? rect.left : rect.right;
    return { left: x2, right: x2, top: rect.top, bottom: rect.bottom };
  }
  function windowRect(win) {
    let vp = win.visualViewport;
    if (vp)
      return {
        left: 0,
        right: vp.width,
        top: 0,
        bottom: vp.height
      };
    return {
      left: 0,
      right: win.innerWidth,
      top: 0,
      bottom: win.innerHeight
    };
  }
  function getScale(elt, rect) {
    let scaleX = rect.width / elt.offsetWidth;
    let scaleY = rect.height / elt.offsetHeight;
    if (scaleX > 0.995 && scaleX < 1.005 || !isFinite(scaleX) || Math.abs(rect.width - elt.offsetWidth) < 1)
      scaleX = 1;
    if (scaleY > 0.995 && scaleY < 1.005 || !isFinite(scaleY) || Math.abs(rect.height - elt.offsetHeight) < 1)
      scaleY = 1;
    return { scaleX, scaleY };
  }
  function scrollRectIntoView(dom, rect, side, x2, y2, xMargin, yMargin, ltr) {
    let doc2 = dom.ownerDocument, win = doc2.defaultView || window;
    for (let cur = dom, stop = false; cur && !stop; ) {
      if (cur.nodeType == 1) {
        let bounding, top3 = cur == doc2.body;
        let scaleX = 1, scaleY = 1;
        if (top3) {
          bounding = windowRect(win);
        } else {
          if (/^(fixed|sticky)$/.test(getComputedStyle(cur).position))
            stop = true;
          if (cur.scrollHeight <= cur.clientHeight && cur.scrollWidth <= cur.clientWidth) {
            cur = cur.assignedSlot || cur.parentNode;
            continue;
          }
          let rect2 = cur.getBoundingClientRect();
          ({ scaleX, scaleY } = getScale(cur, rect2));
          bounding = {
            left: rect2.left,
            right: rect2.left + cur.clientWidth * scaleX,
            top: rect2.top,
            bottom: rect2.top + cur.clientHeight * scaleY
          };
        }
        let moveX = 0, moveY = 0;
        if (y2 == "nearest") {
          if (rect.top < bounding.top) {
            moveY = -(bounding.top - rect.top + yMargin);
            if (side > 0 && rect.bottom > bounding.bottom + moveY)
              moveY = rect.bottom - bounding.bottom + moveY + yMargin;
          } else if (rect.bottom > bounding.bottom) {
            moveY = rect.bottom - bounding.bottom + yMargin;
            if (side < 0 && rect.top - moveY < bounding.top)
              moveY = -(bounding.top + moveY - rect.top + yMargin);
          }
        } else {
          let rectHeight = rect.bottom - rect.top, boundingHeight = bounding.bottom - bounding.top;
          let targetTop = y2 == "center" && rectHeight <= boundingHeight ? rect.top + rectHeight / 2 - boundingHeight / 2 : y2 == "start" || y2 == "center" && side < 0 ? rect.top - yMargin : rect.bottom - boundingHeight + yMargin;
          moveY = targetTop - bounding.top;
        }
        if (x2 == "nearest") {
          if (rect.left < bounding.left) {
            moveX = -(bounding.left - rect.left + xMargin);
            if (side > 0 && rect.right > bounding.right + moveX)
              moveX = rect.right - bounding.right + moveX + xMargin;
          } else if (rect.right > bounding.right) {
            moveX = rect.right - bounding.right + xMargin;
            if (side < 0 && rect.left < bounding.left + moveX)
              moveX = -(bounding.left + moveX - rect.left + xMargin);
          }
        } else {
          let targetLeft = x2 == "center" ? rect.left + (rect.right - rect.left) / 2 - (bounding.right - bounding.left) / 2 : x2 == "start" == ltr ? rect.left - xMargin : rect.right - (bounding.right - bounding.left) + xMargin;
          moveX = targetLeft - bounding.left;
        }
        if (moveX || moveY) {
          if (top3) {
            win.scrollBy(moveX, moveY);
          } else {
            let movedX = 0, movedY = 0;
            if (moveY) {
              let start2 = cur.scrollTop;
              cur.scrollTop += moveY / scaleY;
              movedY = (cur.scrollTop - start2) * scaleY;
            }
            if (moveX) {
              let start2 = cur.scrollLeft;
              cur.scrollLeft += moveX / scaleX;
              movedX = (cur.scrollLeft - start2) * scaleX;
            }
            rect = {
              left: rect.left - movedX,
              top: rect.top - movedY,
              right: rect.right - movedX,
              bottom: rect.bottom - movedY
            };
            if (movedX && Math.abs(movedX - moveX) < 1)
              x2 = "nearest";
            if (movedY && Math.abs(movedY - moveY) < 1)
              y2 = "nearest";
          }
        }
        if (top3)
          break;
        cur = cur.assignedSlot || cur.parentNode;
      } else if (cur.nodeType == 11) {
        cur = cur.host;
      } else {
        break;
      }
    }
  }
  function scrollableParents(dom) {
    let doc2 = dom.ownerDocument, x2, y2;
    for (let cur = dom.parentNode; cur; ) {
      if (cur == doc2.body || x2 && y2) {
        break;
      } else if (cur.nodeType == 1) {
        if (!y2 && cur.scrollHeight > cur.clientHeight)
          y2 = cur;
        if (!x2 && cur.scrollWidth > cur.clientWidth)
          x2 = cur;
        cur = cur.assignedSlot || cur.parentNode;
      } else if (cur.nodeType == 11) {
        cur = cur.host;
      } else {
        break;
      }
    }
    return { x: x2, y: y2 };
  }
  var DOMSelectionState = class {
    constructor() {
      this.anchorNode = null;
      this.anchorOffset = 0;
      this.focusNode = null;
      this.focusOffset = 0;
    }
    eq(domSel) {
      return this.anchorNode == domSel.anchorNode && this.anchorOffset == domSel.anchorOffset && this.focusNode == domSel.focusNode && this.focusOffset == domSel.focusOffset;
    }
    setRange(range4) {
      let { anchorNode, focusNode } = range4;
      this.set(anchorNode, Math.min(range4.anchorOffset, anchorNode ? maxOffset(anchorNode) : 0), focusNode, Math.min(range4.focusOffset, focusNode ? maxOffset(focusNode) : 0));
    }
    set(anchorNode, anchorOffset, focusNode, focusOffset) {
      this.anchorNode = anchorNode;
      this.anchorOffset = anchorOffset;
      this.focusNode = focusNode;
      this.focusOffset = focusOffset;
    }
  };
  var preventScrollSupported = null;
  function focusPreventScroll(dom) {
    if (dom.setActive)
      return dom.setActive();
    if (preventScrollSupported)
      return dom.focus(preventScrollSupported);
    let stack = [];
    for (let cur = dom; cur; cur = cur.parentNode) {
      stack.push(cur, cur.scrollTop, cur.scrollLeft);
      if (cur == cur.ownerDocument)
        break;
    }
    dom.focus(preventScrollSupported == null ? {
      get preventScroll() {
        preventScrollSupported = { preventScroll: true };
        return true;
      }
    } : void 0);
    if (!preventScrollSupported) {
      preventScrollSupported = false;
      for (let i = 0; i < stack.length; ) {
        let elt = stack[i++], top3 = stack[i++], left2 = stack[i++];
        if (elt.scrollTop != top3)
          elt.scrollTop = top3;
        if (elt.scrollLeft != left2)
          elt.scrollLeft = left2;
      }
    }
  }
  var scratchRange;
  function textRange(node2, from, to = from) {
    let range4 = scratchRange || (scratchRange = document.createRange());
    range4.setEnd(node2, to);
    range4.setStart(node2, from);
    return range4;
  }
  function dispatchKey(elt, name3, code, mods) {
    let options = { key: name3, code: name3, keyCode: code, which: code, cancelable: true };
    if (mods)
      ({ altKey: options.altKey, ctrlKey: options.ctrlKey, shiftKey: options.shiftKey, metaKey: options.metaKey } = mods);
    let down = new KeyboardEvent("keydown", options);
    down.synthetic = true;
    elt.dispatchEvent(down);
    let up = new KeyboardEvent("keyup", options);
    up.synthetic = true;
    elt.dispatchEvent(up);
    return down.defaultPrevented || up.defaultPrevented;
  }
  function getRoot(node2) {
    while (node2) {
      if (node2 && (node2.nodeType == 9 || node2.nodeType == 11 && node2.host))
        return node2;
      node2 = node2.assignedSlot || node2.parentNode;
    }
    return null;
  }
  function clearAttributes(node2) {
    while (node2.attributes.length)
      node2.removeAttributeNode(node2.attributes[0]);
  }
  function atElementStart(doc2, selection2) {
    let node2 = selection2.focusNode, offset = selection2.focusOffset;
    if (!node2 || selection2.anchorNode != node2 || selection2.anchorOffset != offset)
      return false;
    offset = Math.min(offset, maxOffset(node2));
    for (; ; ) {
      if (offset) {
        if (node2.nodeType != 1)
          return false;
        let prev = node2.childNodes[offset - 1];
        if (prev.contentEditable == "false")
          offset--;
        else {
          node2 = prev;
          offset = maxOffset(node2);
        }
      } else if (node2 == doc2) {
        return true;
      } else {
        offset = domIndex(node2);
        node2 = node2.parentNode;
      }
    }
  }
  function isScrolledToBottom(elt) {
    return elt.scrollTop > Math.max(1, elt.scrollHeight - elt.clientHeight - 4);
  }
  function textNodeBefore(startNode, startOffset) {
    for (let node2 = startNode, offset = startOffset; ; ) {
      if (node2.nodeType == 3 && offset > 0) {
        return { node: node2, offset };
      } else if (node2.nodeType == 1 && offset > 0) {
        if (node2.contentEditable == "false")
          return null;
        node2 = node2.childNodes[offset - 1];
        offset = maxOffset(node2);
      } else if (node2.parentNode && !isBlockElement(node2)) {
        offset = domIndex(node2);
        node2 = node2.parentNode;
      } else {
        return null;
      }
    }
  }
  function textNodeAfter(startNode, startOffset) {
    for (let node2 = startNode, offset = startOffset; ; ) {
      if (node2.nodeType == 3 && offset < node2.nodeValue.length) {
        return { node: node2, offset };
      } else if (node2.nodeType == 1 && offset < node2.childNodes.length) {
        if (node2.contentEditable == "false")
          return null;
        node2 = node2.childNodes[offset];
        offset = 0;
      } else if (node2.parentNode && !isBlockElement(node2)) {
        offset = domIndex(node2) + 1;
        node2 = node2.parentNode;
      } else {
        return null;
      }
    }
  }
  var DOMPos = class {
    constructor(node2, offset, precise = true) {
      this.node = node2;
      this.offset = offset;
      this.precise = precise;
    }
    static before(dom, precise) {
      return new DOMPos(dom.parentNode, domIndex(dom), precise);
    }
    static after(dom, precise) {
      return new DOMPos(dom.parentNode, domIndex(dom) + 1, precise);
    }
  };
  var noChildren = [];
  var ContentView = class {
    constructor() {
      this.parent = null;
      this.dom = null;
      this.flags = 2;
    }
    get overrideDOMText() {
      return null;
    }
    get posAtStart() {
      return this.parent ? this.parent.posBefore(this) : 0;
    }
    get posAtEnd() {
      return this.posAtStart + this.length;
    }
    posBefore(view2) {
      let pos = this.posAtStart;
      for (let child of this.children) {
        if (child == view2)
          return pos;
        pos += child.length + child.breakAfter;
      }
      throw new RangeError("Invalid child in posBefore");
    }
    posAfter(view2) {
      return this.posBefore(view2) + view2.length;
    }
    sync(view2, track) {
      if (this.flags & 2) {
        let parent = this.dom;
        let prev = null, next;
        for (let child of this.children) {
          if (child.flags & 7) {
            if (!child.dom && (next = prev ? prev.nextSibling : parent.firstChild)) {
              let contentView = ContentView.get(next);
              if (!contentView || !contentView.parent && contentView.canReuseDOM(child))
                child.reuseDOM(next);
            }
            child.sync(view2, track);
            child.flags &= ~7;
          }
          next = prev ? prev.nextSibling : parent.firstChild;
          if (track && !track.written && track.node == parent && next != child.dom)
            track.written = true;
          if (child.dom.parentNode == parent) {
            while (next && next != child.dom)
              next = rm$1(next);
          } else {
            parent.insertBefore(child.dom, next);
          }
          prev = child.dom;
        }
        next = prev ? prev.nextSibling : parent.firstChild;
        if (next && track && track.node == parent)
          track.written = true;
        while (next)
          next = rm$1(next);
      } else if (this.flags & 1) {
        for (let child of this.children)
          if (child.flags & 7) {
            child.sync(view2, track);
            child.flags &= ~7;
          }
      }
    }
    reuseDOM(_dom) {
    }
    localPosFromDOM(node2, offset) {
      let after;
      if (node2 == this.dom) {
        after = this.dom.childNodes[offset];
      } else {
        let bias = maxOffset(node2) == 0 ? 0 : offset == 0 ? -1 : 1;
        for (; ; ) {
          let parent = node2.parentNode;
          if (parent == this.dom)
            break;
          if (bias == 0 && parent.firstChild != parent.lastChild) {
            if (node2 == parent.firstChild)
              bias = -1;
            else
              bias = 1;
          }
          node2 = parent;
        }
        if (bias < 0)
          after = node2;
        else
          after = node2.nextSibling;
      }
      if (after == this.dom.firstChild)
        return 0;
      while (after && !ContentView.get(after))
        after = after.nextSibling;
      if (!after)
        return this.length;
      for (let i = 0, pos = 0; ; i++) {
        let child = this.children[i];
        if (child.dom == after)
          return pos;
        pos += child.length + child.breakAfter;
      }
    }
    domBoundsAround(from, to, offset = 0) {
      let fromI = -1, fromStart = -1, toI = -1, toEnd = -1;
      for (let i = 0, pos = offset, prevEnd = offset; i < this.children.length; i++) {
        let child = this.children[i], end = pos + child.length;
        if (pos < from && end > to)
          return child.domBoundsAround(from, to, pos);
        if (end >= from && fromI == -1) {
          fromI = i;
          fromStart = pos;
        }
        if (pos > to && child.dom.parentNode == this.dom) {
          toI = i;
          toEnd = prevEnd;
          break;
        }
        prevEnd = end;
        pos = end + child.breakAfter;
      }
      return {
        from: fromStart,
        to: toEnd < 0 ? offset + this.length : toEnd,
        startDOM: (fromI ? this.children[fromI - 1].dom.nextSibling : null) || this.dom.firstChild,
        endDOM: toI < this.children.length && toI >= 0 ? this.children[toI].dom : null
      };
    }
    markDirty(andParent = false) {
      this.flags |= 2;
      this.markParentsDirty(andParent);
    }
    markParentsDirty(childList) {
      for (let parent = this.parent; parent; parent = parent.parent) {
        if (childList)
          parent.flags |= 2;
        if (parent.flags & 1)
          return;
        parent.flags |= 1;
        childList = false;
      }
    }
    setParent(parent) {
      if (this.parent != parent) {
        this.parent = parent;
        if (this.flags & 7)
          this.markParentsDirty(true);
      }
    }
    setDOM(dom) {
      if (this.dom == dom)
        return;
      if (this.dom)
        this.dom.cmView = null;
      this.dom = dom;
      dom.cmView = this;
    }
    get rootView() {
      for (let v = this; ; ) {
        let parent = v.parent;
        if (!parent)
          return v;
        v = parent;
      }
    }
    replaceChildren(from, to, children2 = noChildren) {
      this.markDirty();
      for (let i = from; i < to; i++) {
        let child = this.children[i];
        if (child.parent == this && children2.indexOf(child) < 0)
          child.destroy();
      }
      this.children.splice(from, to - from, ...children2);
      for (let i = 0; i < children2.length; i++)
        children2[i].setParent(this);
    }
    ignoreMutation(_rec) {
      return false;
    }
    ignoreEvent(_event) {
      return false;
    }
    childCursor(pos = this.length) {
      return new ChildCursor(this.children, pos, this.children.length);
    }
    childPos(pos, bias = 1) {
      return this.childCursor().findPos(pos, bias);
    }
    toString() {
      let name3 = this.constructor.name.replace("View", "");
      return name3 + (this.children.length ? "(" + this.children.join() + ")" : this.length ? "[" + (name3 == "Text" ? this.text : this.length) + "]" : "") + (this.breakAfter ? "#" : "");
    }
    static get(node2) {
      return node2.cmView;
    }
    get isEditable() {
      return true;
    }
    get isWidget() {
      return false;
    }
    get isHidden() {
      return false;
    }
    merge(from, to, source2, hasStart, openStart, openEnd) {
      return false;
    }
    become(other) {
      return false;
    }
    canReuseDOM(other) {
      return other.constructor == this.constructor && !((this.flags | other.flags) & 8);
    }
    getSide() {
      return 0;
    }
    destroy() {
      for (let child of this.children)
        if (child.parent == this)
          child.destroy();
      this.parent = null;
    }
  };
  ContentView.prototype.breakAfter = 0;
  function rm$1(dom) {
    let next = dom.nextSibling;
    dom.parentNode.removeChild(dom);
    return next;
  }
  var ChildCursor = class {
    constructor(children2, pos, i) {
      this.children = children2;
      this.pos = pos;
      this.i = i;
      this.off = 0;
    }
    findPos(pos, bias = 1) {
      for (; ; ) {
        if (pos > this.pos || pos == this.pos && (bias > 0 || this.i == 0 || this.children[this.i - 1].breakAfter)) {
          this.off = pos - this.pos;
          return this;
        }
        let next = this.children[--this.i];
        this.pos -= next.length + next.breakAfter;
      }
    }
  };
  function replaceRange(parent, fromI, fromOff, toI, toOff, insert4, breakAtStart, openStart, openEnd) {
    let { children: children2 } = parent;
    let before = children2.length ? children2[fromI] : null;
    let last3 = insert4.length ? insert4[insert4.length - 1] : null;
    let breakAtEnd = last3 ? last3.breakAfter : breakAtStart;
    if (fromI == toI && before && !breakAtStart && !breakAtEnd && insert4.length < 2 && before.merge(fromOff, toOff, insert4.length ? last3 : null, fromOff == 0, openStart, openEnd))
      return;
    if (toI < children2.length) {
      let after = children2[toI];
      if (after && (toOff < after.length || after.breakAfter && (last3 === null || last3 === void 0 ? void 0 : last3.breakAfter))) {
        if (fromI == toI) {
          after = after.split(toOff);
          toOff = 0;
        }
        if (!breakAtEnd && last3 && after.merge(0, toOff, last3, true, 0, openEnd)) {
          insert4[insert4.length - 1] = after;
        } else {
          if (toOff || after.children.length && !after.children[0].length)
            after.merge(0, toOff, null, false, 0, openEnd);
          insert4.push(after);
        }
      } else if (after === null || after === void 0 ? void 0 : after.breakAfter) {
        if (last3)
          last3.breakAfter = 1;
        else
          breakAtStart = 1;
      }
      toI++;
    }
    if (before) {
      before.breakAfter = breakAtStart;
      if (fromOff > 0) {
        if (!breakAtStart && insert4.length && before.merge(fromOff, before.length, insert4[0], false, openStart, 0)) {
          before.breakAfter = insert4.shift().breakAfter;
        } else if (fromOff < before.length || before.children.length && before.children[before.children.length - 1].length == 0) {
          before.merge(fromOff, before.length, null, false, openStart, 0);
        }
        fromI++;
      }
    }
    while (fromI < toI && insert4.length) {
      if (children2[toI - 1].become(insert4[insert4.length - 1])) {
        toI--;
        insert4.pop();
        openEnd = insert4.length ? 0 : openStart;
      } else if (children2[fromI].become(insert4[0])) {
        fromI++;
        insert4.shift();
        openStart = insert4.length ? 0 : openEnd;
      } else {
        break;
      }
    }
    if (!insert4.length && fromI && toI < children2.length && !children2[fromI - 1].breakAfter && children2[toI].merge(0, 0, children2[fromI - 1], false, openStart, openEnd))
      fromI--;
    if (fromI < toI || insert4.length)
      parent.replaceChildren(fromI, toI, insert4);
  }
  function mergeChildrenInto(parent, from, to, insert4, openStart, openEnd) {
    let cur = parent.childCursor();
    let { i: toI, off: toOff } = cur.findPos(to, 1);
    let { i: fromI, off: fromOff } = cur.findPos(from, -1);
    let dLen = from - to;
    for (let view2 of insert4)
      dLen += view2.length;
    parent.length += dLen;
    replaceRange(parent, fromI, fromOff, toI, toOff, insert4, 0, openStart, openEnd);
  }
  var nav = typeof navigator != "undefined" ? navigator : { userAgent: "", vendor: "", platform: "" };
  var doc = typeof document != "undefined" ? document : { documentElement: { style: {} } };
  var ie_edge = /* @__PURE__ */ /Edge\/(\d+)/.exec(nav.userAgent);
  var ie_upto10 = /* @__PURE__ */ /MSIE \d/.test(nav.userAgent);
  var ie_11up = /* @__PURE__ */ /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(nav.userAgent);
  var ie2 = !!(ie_upto10 || ie_11up || ie_edge);
  var gecko = !ie2 && /* @__PURE__ */ /gecko\/(\d+)/i.test(nav.userAgent);
  var chrome = !ie2 && /* @__PURE__ */ /Chrome\/(\d+)/.exec(nav.userAgent);
  var webkit = "webkitFontSmoothing" in doc.documentElement.style;
  var safari = !ie2 && /* @__PURE__ */ /Apple Computer/.test(nav.vendor);
  var ios = safari && (/* @__PURE__ */ /Mobile\/\w+/.test(nav.userAgent) || nav.maxTouchPoints > 2);
  var browser = {
    mac: ios || /* @__PURE__ */ /Mac/.test(nav.platform),
    windows: /* @__PURE__ */ /Win/.test(nav.platform),
    linux: /* @__PURE__ */ /Linux|X11/.test(nav.platform),
    ie: ie2,
    ie_version: ie_upto10 ? doc.documentMode || 6 : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0,
    gecko,
    gecko_version: gecko ? +(/* @__PURE__ */ /Firefox\/(\d+)/.exec(nav.userAgent) || [0, 0])[1] : 0,
    chrome: !!chrome,
    chrome_version: chrome ? +chrome[1] : 0,
    ios,
    android: /* @__PURE__ */ /Android\b/.test(nav.userAgent),
    webkit,
    safari,
    webkit_version: webkit ? +(/* @__PURE__ */ /\bAppleWebKit\/(\d+)/.exec(nav.userAgent) || [0, 0])[1] : 0,
    tabSize: doc.documentElement.style.tabSize != null ? "tab-size" : "-moz-tab-size"
  };
  var MaxJoinLen = 256;
  var TextView = class extends ContentView {
    constructor(text2) {
      super();
      this.text = text2;
    }
    get length() {
      return this.text.length;
    }
    createDOM(textDOM) {
      this.setDOM(textDOM || document.createTextNode(this.text));
    }
    sync(view2, track) {
      if (!this.dom)
        this.createDOM();
      if (this.dom.nodeValue != this.text) {
        if (track && track.node == this.dom)
          track.written = true;
        this.dom.nodeValue = this.text;
      }
    }
    reuseDOM(dom) {
      if (dom.nodeType == 3)
        this.createDOM(dom);
    }
    merge(from, to, source2) {
      if (this.flags & 8 || source2 && (!(source2 instanceof TextView) || this.length - (to - from) + source2.length > MaxJoinLen || source2.flags & 8))
        return false;
      this.text = this.text.slice(0, from) + (source2 ? source2.text : "") + this.text.slice(to);
      this.markDirty();
      return true;
    }
    split(from) {
      let result = new TextView(this.text.slice(from));
      this.text = this.text.slice(0, from);
      this.markDirty();
      result.flags |= this.flags & 8;
      return result;
    }
    localPosFromDOM(node2, offset) {
      return node2 == this.dom ? offset : offset ? this.text.length : 0;
    }
    domAtPos(pos) {
      return new DOMPos(this.dom, pos);
    }
    domBoundsAround(_from, _to, offset) {
      return { from: offset, to: offset + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling };
    }
    coordsAt(pos, side) {
      return textCoords(this.dom, pos, side);
    }
  };
  var MarkView = class extends ContentView {
    constructor(mark, children2 = [], length6 = 0) {
      super();
      this.mark = mark;
      this.children = children2;
      this.length = length6;
      for (let ch of children2)
        ch.setParent(this);
    }
    setAttrs(dom) {
      clearAttributes(dom);
      if (this.mark.class)
        dom.className = this.mark.class;
      if (this.mark.attrs)
        for (let name3 in this.mark.attrs)
          dom.setAttribute(name3, this.mark.attrs[name3]);
      return dom;
    }
    canReuseDOM(other) {
      return super.canReuseDOM(other) && !((this.flags | other.flags) & 8);
    }
    reuseDOM(node2) {
      if (node2.nodeName == this.mark.tagName.toUpperCase()) {
        this.setDOM(node2);
        this.flags |= 4 | 2;
      }
    }
    sync(view2, track) {
      if (!this.dom)
        this.setDOM(this.setAttrs(document.createElement(this.mark.tagName)));
      else if (this.flags & 4)
        this.setAttrs(this.dom);
      super.sync(view2, track);
    }
    merge(from, to, source2, _hasStart, openStart, openEnd) {
      if (source2 && (!(source2 instanceof MarkView && source2.mark.eq(this.mark)) || from && openStart <= 0 || to < this.length && openEnd <= 0))
        return false;
      mergeChildrenInto(this, from, to, source2 ? source2.children.slice() : [], openStart - 1, openEnd - 1);
      this.markDirty();
      return true;
    }
    split(from) {
      let result = [], off = 0, detachFrom = -1, i = 0;
      for (let elt of this.children) {
        let end = off + elt.length;
        if (end > from)
          result.push(off < from ? elt.split(from - off) : elt);
        if (detachFrom < 0 && off >= from)
          detachFrom = i;
        off = end;
        i++;
      }
      let length6 = this.length - from;
      this.length = from;
      if (detachFrom > -1) {
        this.children.length = detachFrom;
        this.markDirty();
      }
      return new MarkView(this.mark, result, length6);
    }
    domAtPos(pos) {
      return inlineDOMAtPos(this, pos);
    }
    coordsAt(pos, side) {
      return coordsInChildren(this, pos, side);
    }
  };
  function textCoords(text2, pos, side) {
    let length6 = text2.nodeValue.length;
    if (pos > length6)
      pos = length6;
    let from = pos, to = pos, flatten2 = 0;
    if (pos == 0 && side < 0 || pos == length6 && side >= 0) {
      if (!(browser.chrome || browser.gecko)) {
        if (pos) {
          from--;
          flatten2 = 1;
        } else if (to < length6) {
          to++;
          flatten2 = -1;
        }
      }
    } else {
      if (side < 0)
        from--;
      else if (to < length6)
        to++;
    }
    let rects = textRange(text2, from, to).getClientRects();
    if (!rects.length)
      return null;
    let rect = rects[(flatten2 ? flatten2 < 0 : side >= 0) ? 0 : rects.length - 1];
    if (browser.safari && !flatten2 && rect.width == 0)
      rect = Array.prototype.find.call(rects, (r) => r.width) || rect;
    return flatten2 ? flattenRect(rect, flatten2 < 0) : rect || null;
  }
  var WidgetView = class extends ContentView {
    static create(widget, length6, side) {
      return new WidgetView(widget, length6, side);
    }
    constructor(widget, length6, side) {
      super();
      this.widget = widget;
      this.length = length6;
      this.side = side;
      this.prevWidget = null;
    }
    split(from) {
      let result = WidgetView.create(this.widget, this.length - from, this.side);
      this.length -= from;
      return result;
    }
    sync(view2) {
      if (!this.dom || !this.widget.updateDOM(this.dom, view2)) {
        if (this.dom && this.prevWidget)
          this.prevWidget.destroy(this.dom);
        this.prevWidget = null;
        this.setDOM(this.widget.toDOM(view2));
        if (!this.widget.editable)
          this.dom.contentEditable = "false";
      }
    }
    getSide() {
      return this.side;
    }
    merge(from, to, source2, hasStart, openStart, openEnd) {
      if (source2 && (!(source2 instanceof WidgetView) || !this.widget.compare(source2.widget) || from > 0 && openStart <= 0 || to < this.length && openEnd <= 0))
        return false;
      this.length = from + (source2 ? source2.length : 0) + (this.length - to);
      return true;
    }
    become(other) {
      if (other instanceof WidgetView && other.side == this.side && this.widget.constructor == other.widget.constructor) {
        if (!this.widget.compare(other.widget))
          this.markDirty(true);
        if (this.dom && !this.prevWidget)
          this.prevWidget = this.widget;
        this.widget = other.widget;
        this.length = other.length;
        return true;
      }
      return false;
    }
    ignoreMutation() {
      return true;
    }
    ignoreEvent(event) {
      return this.widget.ignoreEvent(event);
    }
    get overrideDOMText() {
      if (this.length == 0)
        return Text.empty;
      let top3 = this;
      while (top3.parent)
        top3 = top3.parent;
      let { view: view2 } = top3, text2 = view2 && view2.state.doc, start2 = this.posAtStart;
      return text2 ? text2.slice(start2, start2 + this.length) : Text.empty;
    }
    domAtPos(pos) {
      return (this.length ? pos == 0 : this.side > 0) ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);
    }
    domBoundsAround() {
      return null;
    }
    coordsAt(pos, side) {
      let custom = this.widget.coordsAt(this.dom, pos, side);
      if (custom)
        return custom;
      let rects = this.dom.getClientRects(), rect = null;
      if (!rects.length)
        return null;
      let fromBack = this.side ? this.side < 0 : pos > 0;
      for (let i = fromBack ? rects.length - 1 : 0; ; i += fromBack ? -1 : 1) {
        rect = rects[i];
        if (pos > 0 ? i == 0 : i == rects.length - 1 || rect.top < rect.bottom)
          break;
      }
      return flattenRect(rect, !fromBack);
    }
    get isEditable() {
      return false;
    }
    get isWidget() {
      return true;
    }
    get isHidden() {
      return this.widget.isHidden;
    }
    destroy() {
      super.destroy();
      if (this.dom)
        this.widget.destroy(this.dom);
    }
  };
  var WidgetBufferView = class extends ContentView {
    constructor(side) {
      super();
      this.side = side;
    }
    get length() {
      return 0;
    }
    merge() {
      return false;
    }
    become(other) {
      return other instanceof WidgetBufferView && other.side == this.side;
    }
    split() {
      return new WidgetBufferView(this.side);
    }
    sync() {
      if (!this.dom) {
        let dom = document.createElement("img");
        dom.className = "cm-widgetBuffer";
        dom.setAttribute("aria-hidden", "true");
        this.setDOM(dom);
      }
    }
    getSide() {
      return this.side;
    }
    domAtPos(pos) {
      return this.side > 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom);
    }
    localPosFromDOM() {
      return 0;
    }
    domBoundsAround() {
      return null;
    }
    coordsAt(pos) {
      return this.dom.getBoundingClientRect();
    }
    get overrideDOMText() {
      return Text.empty;
    }
    get isHidden() {
      return true;
    }
  };
  TextView.prototype.children = WidgetView.prototype.children = WidgetBufferView.prototype.children = noChildren;
  function inlineDOMAtPos(parent, pos) {
    let dom = parent.dom, { children: children2 } = parent, i = 0;
    for (let off = 0; i < children2.length; i++) {
      let child = children2[i], end = off + child.length;
      if (end == off && child.getSide() <= 0)
        continue;
      if (pos > off && pos < end && child.dom.parentNode == dom)
        return child.domAtPos(pos - off);
      if (pos <= off)
        break;
      off = end;
    }
    for (let j = i; j > 0; j--) {
      let prev = children2[j - 1];
      if (prev.dom.parentNode == dom)
        return prev.domAtPos(prev.length);
    }
    for (let j = i; j < children2.length; j++) {
      let next = children2[j];
      if (next.dom.parentNode == dom)
        return next.domAtPos(0);
    }
    return new DOMPos(dom, 0);
  }
  function joinInlineInto(parent, view2, open) {
    let last3, { children: children2 } = parent;
    if (open > 0 && view2 instanceof MarkView && children2.length && (last3 = children2[children2.length - 1]) instanceof MarkView && last3.mark.eq(view2.mark)) {
      joinInlineInto(last3, view2.children[0], open - 1);
    } else {
      children2.push(view2);
      view2.setParent(parent);
    }
    parent.length += view2.length;
  }
  function coordsInChildren(view2, pos, side) {
    let before = null, beforePos = -1, after = null, afterPos = -1;
    function scan(view3, pos2) {
      for (let i = 0, off = 0; i < view3.children.length && off <= pos2; i++) {
        let child = view3.children[i], end = off + child.length;
        if (end >= pos2) {
          if (child.children.length) {
            scan(child, pos2 - off);
          } else if ((!after || after.isHidden && side > 0) && (end > pos2 || off == end && child.getSide() > 0)) {
            after = child;
            afterPos = pos2 - off;
          } else if (off < pos2 || off == end && child.getSide() < 0 && !child.isHidden) {
            before = child;
            beforePos = pos2 - off;
          }
        }
        off = end;
      }
    }
    scan(view2, pos);
    let target = (side < 0 ? before : after) || before || after;
    if (target)
      return target.coordsAt(Math.max(0, target == before ? beforePos : afterPos), side);
    return fallbackRect(view2);
  }
  function fallbackRect(view2) {
    let last3 = view2.dom.lastChild;
    if (!last3)
      return view2.dom.getBoundingClientRect();
    let rects = clientRectsFor(last3);
    return rects[rects.length - 1] || null;
  }
  function combineAttrs(source2, target) {
    for (let name3 in source2) {
      if (name3 == "class" && target.class)
        target.class += " " + source2.class;
      else if (name3 == "style" && target.style)
        target.style += ";" + source2.style;
      else
        target[name3] = source2[name3];
    }
    return target;
  }
  var noAttrs = /* @__PURE__ */ Object.create(null);
  function attrsEq(a, b, ignore) {
    if (a == b)
      return true;
    if (!a)
      a = noAttrs;
    if (!b)
      b = noAttrs;
    let keysA = Object.keys(a), keysB = Object.keys(b);
    if (keysA.length - (ignore && keysA.indexOf(ignore) > -1 ? 1 : 0) != keysB.length - (ignore && keysB.indexOf(ignore) > -1 ? 1 : 0))
      return false;
    for (let key of keysA) {
      if (key != ignore && (keysB.indexOf(key) == -1 || a[key] !== b[key]))
        return false;
    }
    return true;
  }
  function updateAttrs(dom, prev, attrs2) {
    let changed = false;
    if (prev) {
      for (let name3 in prev)
        if (!(attrs2 && name3 in attrs2)) {
          changed = true;
          if (name3 == "style")
            dom.style.cssText = "";
          else
            dom.removeAttribute(name3);
        }
    }
    if (attrs2) {
      for (let name3 in attrs2)
        if (!(prev && prev[name3] == attrs2[name3])) {
          changed = true;
          if (name3 == "style")
            dom.style.cssText = attrs2[name3];
          else
            dom.setAttribute(name3, attrs2[name3]);
        }
    }
    return changed;
  }
  function getAttrs(dom) {
    let attrs2 = /* @__PURE__ */ Object.create(null);
    for (let i = 0; i < dom.attributes.length; i++) {
      let attr = dom.attributes[i];
      attrs2[attr.name] = attr.value;
    }
    return attrs2;
  }
  var WidgetType = class {
    eq(widget) {
      return false;
    }
    updateDOM(dom, view2) {
      return false;
    }
    compare(other) {
      return this == other || this.constructor == other.constructor && this.eq(other);
    }
    get estimatedHeight() {
      return -1;
    }
    get lineBreaks() {
      return 0;
    }
    ignoreEvent(event) {
      return true;
    }
    coordsAt(dom, pos, side) {
      return null;
    }
    get isHidden() {
      return false;
    }
    get editable() {
      return false;
    }
    destroy(dom) {
    }
  };
  var BlockType = /* @__PURE__ */ function(BlockType2) {
    BlockType2[BlockType2["Text"] = 0] = "Text";
    BlockType2[BlockType2["WidgetBefore"] = 1] = "WidgetBefore";
    BlockType2[BlockType2["WidgetAfter"] = 2] = "WidgetAfter";
    BlockType2[BlockType2["WidgetRange"] = 3] = "WidgetRange";
    return BlockType2;
  }(BlockType || (BlockType = {}));
  var Decoration = class extends RangeValue {
    constructor(startSide, endSide, widget, spec) {
      super();
      this.startSide = startSide;
      this.endSide = endSide;
      this.widget = widget;
      this.spec = spec;
    }
    get heightRelevant() {
      return false;
    }
    static mark(spec) {
      return new MarkDecoration(spec);
    }
    static widget(spec) {
      let side = Math.max(-1e4, Math.min(1e4, spec.side || 0)), block = !!spec.block;
      side += block && !spec.inlineOrder ? side > 0 ? 3e8 : -4e8 : side > 0 ? 1e8 : -1e8;
      return new PointDecoration(spec, side, side, block, spec.widget || null, false);
    }
    static replace(spec) {
      let block = !!spec.block, startSide, endSide;
      if (spec.isBlockGap) {
        startSide = -5e8;
        endSide = 4e8;
      } else {
        let { start: start2, end } = getInclusive(spec, block);
        startSide = (start2 ? block ? -3e8 : -1 : 5e8) - 1;
        endSide = (end ? block ? 2e8 : 1 : -6e8) + 1;
      }
      return new PointDecoration(spec, startSide, endSide, block, spec.widget || null, true);
    }
    static line(spec) {
      return new LineDecoration(spec);
    }
    static set(of, sort = false) {
      return RangeSet.of(of, sort);
    }
    hasHeight() {
      return this.widget ? this.widget.estimatedHeight > -1 : false;
    }
  };
  Decoration.none = RangeSet.empty;
  var MarkDecoration = class extends Decoration {
    constructor(spec) {
      let { start: start2, end } = getInclusive(spec);
      super(start2 ? -1 : 5e8, end ? 1 : -6e8, null, spec);
      this.tagName = spec.tagName || "span";
      this.class = spec.class || "";
      this.attrs = spec.attributes || null;
    }
    eq(other) {
      var _a2, _b;
      return this == other || other instanceof MarkDecoration && this.tagName == other.tagName && (this.class || ((_a2 = this.attrs) === null || _a2 === void 0 ? void 0 : _a2.class)) == (other.class || ((_b = other.attrs) === null || _b === void 0 ? void 0 : _b.class)) && attrsEq(this.attrs, other.attrs, "class");
    }
    range(from, to = from) {
      if (from >= to)
        throw new RangeError("Mark decorations may not be empty");
      return super.range(from, to);
    }
  };
  MarkDecoration.prototype.point = false;
  var LineDecoration = class extends Decoration {
    constructor(spec) {
      super(-2e8, -2e8, null, spec);
    }
    eq(other) {
      return other instanceof LineDecoration && this.spec.class == other.spec.class && attrsEq(this.spec.attributes, other.spec.attributes);
    }
    range(from, to = from) {
      if (to != from)
        throw new RangeError("Line decoration ranges must be zero-length");
      return super.range(from, to);
    }
  };
  LineDecoration.prototype.mapMode = MapMode.TrackBefore;
  LineDecoration.prototype.point = true;
  var PointDecoration = class extends Decoration {
    constructor(spec, startSide, endSide, block, widget, isReplace) {
      super(startSide, endSide, widget, spec);
      this.block = block;
      this.isReplace = isReplace;
      this.mapMode = !block ? MapMode.TrackDel : startSide <= 0 ? MapMode.TrackBefore : MapMode.TrackAfter;
    }
    get type() {
      return this.startSide != this.endSide ? BlockType.WidgetRange : this.startSide <= 0 ? BlockType.WidgetBefore : BlockType.WidgetAfter;
    }
    get heightRelevant() {
      return this.block || !!this.widget && (this.widget.estimatedHeight >= 5 || this.widget.lineBreaks > 0);
    }
    eq(other) {
      return other instanceof PointDecoration && widgetsEq(this.widget, other.widget) && this.block == other.block && this.startSide == other.startSide && this.endSide == other.endSide;
    }
    range(from, to = from) {
      if (this.isReplace && (from > to || from == to && this.startSide > 0 && this.endSide <= 0))
        throw new RangeError("Invalid range for replacement decoration");
      if (!this.isReplace && to != from)
        throw new RangeError("Widget decorations can only have zero-length ranges");
      return super.range(from, to);
    }
  };
  PointDecoration.prototype.point = true;
  function getInclusive(spec, block = false) {
    let { inclusiveStart: start2, inclusiveEnd: end } = spec;
    if (start2 == null)
      start2 = spec.inclusive;
    if (end == null)
      end = spec.inclusive;
    return { start: start2 !== null && start2 !== void 0 ? start2 : block, end: end !== null && end !== void 0 ? end : block };
  }
  function widgetsEq(a, b) {
    return a == b || !!(a && b && a.compare(b));
  }
  function addRange(from, to, ranges, margin = 0) {
    let last3 = ranges.length - 1;
    if (last3 >= 0 && ranges[last3] + margin >= from)
      ranges[last3] = Math.max(ranges[last3], to);
    else
      ranges.push(from, to);
  }
  var LineView = class extends ContentView {
    constructor() {
      super(...arguments);
      this.children = [];
      this.length = 0;
      this.prevAttrs = void 0;
      this.attrs = null;
      this.breakAfter = 0;
    }
    merge(from, to, source2, hasStart, openStart, openEnd) {
      if (source2) {
        if (!(source2 instanceof LineView))
          return false;
        if (!this.dom)
          source2.transferDOM(this);
      }
      if (hasStart)
        this.setDeco(source2 ? source2.attrs : null);
      mergeChildrenInto(this, from, to, source2 ? source2.children.slice() : [], openStart, openEnd);
      return true;
    }
    split(at) {
      let end = new LineView();
      end.breakAfter = this.breakAfter;
      if (this.length == 0)
        return end;
      let { i, off } = this.childPos(at);
      if (off) {
        end.append(this.children[i].split(off), 0);
        this.children[i].merge(off, this.children[i].length, null, false, 0, 0);
        i++;
      }
      for (let j = i; j < this.children.length; j++)
        end.append(this.children[j], 0);
      while (i > 0 && this.children[i - 1].length == 0)
        this.children[--i].destroy();
      this.children.length = i;
      this.markDirty();
      this.length = at;
      return end;
    }
    transferDOM(other) {
      if (!this.dom)
        return;
      this.markDirty();
      other.setDOM(this.dom);
      other.prevAttrs = this.prevAttrs === void 0 ? this.attrs : this.prevAttrs;
      this.prevAttrs = void 0;
      this.dom = null;
    }
    setDeco(attrs2) {
      if (!attrsEq(this.attrs, attrs2)) {
        if (this.dom) {
          this.prevAttrs = this.attrs;
          this.markDirty();
        }
        this.attrs = attrs2;
      }
    }
    append(child, openStart) {
      joinInlineInto(this, child, openStart);
    }
    addLineDeco(deco) {
      let attrs2 = deco.spec.attributes, cls = deco.spec.class;
      if (attrs2)
        this.attrs = combineAttrs(attrs2, this.attrs || {});
      if (cls)
        this.attrs = combineAttrs({ class: cls }, this.attrs || {});
    }
    domAtPos(pos) {
      return inlineDOMAtPos(this, pos);
    }
    reuseDOM(node2) {
      if (node2.nodeName == "DIV") {
        this.setDOM(node2);
        this.flags |= 4 | 2;
      }
    }
    sync(view2, track) {
      var _a2;
      if (!this.dom) {
        this.setDOM(document.createElement("div"));
        this.dom.className = "cm-line";
        this.prevAttrs = this.attrs ? null : void 0;
      } else if (this.flags & 4) {
        clearAttributes(this.dom);
        this.dom.className = "cm-line";
        this.prevAttrs = this.attrs ? null : void 0;
      }
      if (this.prevAttrs !== void 0) {
        updateAttrs(this.dom, this.prevAttrs, this.attrs);
        this.dom.classList.add("cm-line");
        this.prevAttrs = void 0;
      }
      super.sync(view2, track);
      let last3 = this.dom.lastChild;
      while (last3 && ContentView.get(last3) instanceof MarkView)
        last3 = last3.lastChild;
      if (!last3 || !this.length || last3.nodeName != "BR" && ((_a2 = ContentView.get(last3)) === null || _a2 === void 0 ? void 0 : _a2.isEditable) == false && (!browser.ios || !this.children.some((ch) => ch instanceof TextView))) {
        let hack = document.createElement("BR");
        hack.cmIgnore = true;
        this.dom.appendChild(hack);
      }
    }
    measureTextSize() {
      if (this.children.length == 0 || this.length > 20)
        return null;
      let totalWidth = 0, textHeight;
      for (let child of this.children) {
        if (!(child instanceof TextView) || /[^ -~]/.test(child.text))
          return null;
        let rects = clientRectsFor(child.dom);
        if (rects.length != 1)
          return null;
        totalWidth += rects[0].width;
        textHeight = rects[0].height;
      }
      return !totalWidth ? null : {
        lineHeight: this.dom.getBoundingClientRect().height,
        charWidth: totalWidth / this.length,
        textHeight
      };
    }
    coordsAt(pos, side) {
      let rect = coordsInChildren(this, pos, side);
      if (!this.children.length && rect && this.parent) {
        let { heightOracle } = this.parent.view.viewState, height = rect.bottom - rect.top;
        if (Math.abs(height - heightOracle.lineHeight) < 2 && heightOracle.textHeight < height) {
          let dist2 = (height - heightOracle.textHeight) / 2;
          return { top: rect.top + dist2, bottom: rect.bottom - dist2, left: rect.left, right: rect.left };
        }
      }
      return rect;
    }
    become(other) {
      return other instanceof LineView && this.children.length == 0 && other.children.length == 0 && attrsEq(this.attrs, other.attrs) && this.breakAfter == other.breakAfter;
    }
    covers() {
      return true;
    }
    static find(docView, pos) {
      for (let i = 0, off = 0; i < docView.children.length; i++) {
        let block = docView.children[i], end = off + block.length;
        if (end >= pos) {
          if (block instanceof LineView)
            return block;
          if (end > pos)
            break;
        }
        off = end + block.breakAfter;
      }
      return null;
    }
  };
  var BlockWidgetView = class extends ContentView {
    constructor(widget, length6, deco) {
      super();
      this.widget = widget;
      this.length = length6;
      this.deco = deco;
      this.breakAfter = 0;
      this.prevWidget = null;
    }
    merge(from, to, source2, _takeDeco, openStart, openEnd) {
      if (source2 && (!(source2 instanceof BlockWidgetView) || !this.widget.compare(source2.widget) || from > 0 && openStart <= 0 || to < this.length && openEnd <= 0))
        return false;
      this.length = from + (source2 ? source2.length : 0) + (this.length - to);
      return true;
    }
    domAtPos(pos) {
      return pos == 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);
    }
    split(at) {
      let len = this.length - at;
      this.length = at;
      let end = new BlockWidgetView(this.widget, len, this.deco);
      end.breakAfter = this.breakAfter;
      return end;
    }
    get children() {
      return noChildren;
    }
    sync(view2) {
      if (!this.dom || !this.widget.updateDOM(this.dom, view2)) {
        if (this.dom && this.prevWidget)
          this.prevWidget.destroy(this.dom);
        this.prevWidget = null;
        this.setDOM(this.widget.toDOM(view2));
        if (!this.widget.editable)
          this.dom.contentEditable = "false";
      }
    }
    get overrideDOMText() {
      return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : Text.empty;
    }
    domBoundsAround() {
      return null;
    }
    become(other) {
      if (other instanceof BlockWidgetView && other.widget.constructor == this.widget.constructor) {
        if (!other.widget.compare(this.widget))
          this.markDirty(true);
        if (this.dom && !this.prevWidget)
          this.prevWidget = this.widget;
        this.widget = other.widget;
        this.length = other.length;
        this.deco = other.deco;
        this.breakAfter = other.breakAfter;
        return true;
      }
      return false;
    }
    ignoreMutation() {
      return true;
    }
    ignoreEvent(event) {
      return this.widget.ignoreEvent(event);
    }
    get isEditable() {
      return false;
    }
    get isWidget() {
      return true;
    }
    coordsAt(pos, side) {
      let custom = this.widget.coordsAt(this.dom, pos, side);
      if (custom)
        return custom;
      if (this.widget instanceof BlockGapWidget)
        return null;
      return flattenRect(this.dom.getBoundingClientRect(), this.length ? pos == 0 : side <= 0);
    }
    destroy() {
      super.destroy();
      if (this.dom)
        this.widget.destroy(this.dom);
    }
    covers(side) {
      let { startSide, endSide } = this.deco;
      return startSide == endSide ? false : side < 0 ? startSide < 0 : endSide > 0;
    }
  };
  var BlockGapWidget = class extends WidgetType {
    constructor(height) {
      super();
      this.height = height;
    }
    toDOM() {
      let elt = document.createElement("div");
      elt.className = "cm-gap";
      this.updateDOM(elt);
      return elt;
    }
    eq(other) {
      return other.height == this.height;
    }
    updateDOM(elt) {
      elt.style.height = this.height + "px";
      return true;
    }
    get editable() {
      return true;
    }
    get estimatedHeight() {
      return this.height;
    }
    ignoreEvent() {
      return false;
    }
  };
  var ContentBuilder = class {
    constructor(doc2, pos, end, disallowBlockEffectsFor) {
      this.doc = doc2;
      this.pos = pos;
      this.end = end;
      this.disallowBlockEffectsFor = disallowBlockEffectsFor;
      this.content = [];
      this.curLine = null;
      this.breakAtStart = 0;
      this.pendingBuffer = 0;
      this.bufferMarks = [];
      this.atCursorPos = true;
      this.openStart = -1;
      this.openEnd = -1;
      this.text = "";
      this.textOff = 0;
      this.cursor = doc2.iter();
      this.skip = pos;
    }
    posCovered() {
      if (this.content.length == 0)
        return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;
      let last3 = this.content[this.content.length - 1];
      return !(last3.breakAfter || last3 instanceof BlockWidgetView && last3.deco.endSide < 0);
    }
    getLine() {
      if (!this.curLine) {
        this.content.push(this.curLine = new LineView());
        this.atCursorPos = true;
      }
      return this.curLine;
    }
    flushBuffer(active = this.bufferMarks) {
      if (this.pendingBuffer) {
        this.curLine.append(wrapMarks(new WidgetBufferView(-1), active), active.length);
        this.pendingBuffer = 0;
      }
    }
    addBlockWidget(view2) {
      this.flushBuffer();
      this.curLine = null;
      this.content.push(view2);
    }
    finish(openEnd) {
      if (this.pendingBuffer && openEnd <= this.bufferMarks.length)
        this.flushBuffer();
      else
        this.pendingBuffer = 0;
      if (!this.posCovered() && !(openEnd && this.content.length && this.content[this.content.length - 1] instanceof BlockWidgetView))
        this.getLine();
    }
    buildText(length6, active, openStart) {
      while (length6 > 0) {
        if (this.textOff == this.text.length) {
          let { value, lineBreak, done } = this.cursor.next(this.skip);
          this.skip = 0;
          if (done)
            throw new Error("Ran out of text content when drawing inline views");
          if (lineBreak) {
            if (!this.posCovered())
              this.getLine();
            if (this.content.length)
              this.content[this.content.length - 1].breakAfter = 1;
            else
              this.breakAtStart = 1;
            this.flushBuffer();
            this.curLine = null;
            this.atCursorPos = true;
            length6--;
            continue;
          } else {
            this.text = value;
            this.textOff = 0;
          }
        }
        let take4 = Math.min(this.text.length - this.textOff, length6, 512);
        this.flushBuffer(active.slice(active.length - openStart));
        this.getLine().append(wrapMarks(new TextView(this.text.slice(this.textOff, this.textOff + take4)), active), openStart);
        this.atCursorPos = true;
        this.textOff += take4;
        length6 -= take4;
        openStart = 0;
      }
    }
    span(from, to, active, openStart) {
      this.buildText(to - from, active, openStart);
      this.pos = to;
      if (this.openStart < 0)
        this.openStart = openStart;
    }
    point(from, to, deco, active, openStart, index3) {
      if (this.disallowBlockEffectsFor[index3] && deco instanceof PointDecoration) {
        if (deco.block)
          throw new RangeError("Block decorations may not be specified via plugins");
        if (to > this.doc.lineAt(this.pos).to)
          throw new RangeError("Decorations that replace line breaks may not be specified via plugins");
      }
      let len = to - from;
      if (deco instanceof PointDecoration) {
        if (deco.block) {
          if (deco.startSide > 0 && !this.posCovered())
            this.getLine();
          this.addBlockWidget(new BlockWidgetView(deco.widget || NullWidget.block, len, deco));
        } else {
          let view2 = WidgetView.create(deco.widget || NullWidget.inline, len, len ? 0 : deco.startSide);
          let cursorBefore = this.atCursorPos && !view2.isEditable && openStart <= active.length && (from < to || deco.startSide > 0);
          let cursorAfter = !view2.isEditable && (from < to || openStart > active.length || deco.startSide <= 0);
          let line2 = this.getLine();
          if (this.pendingBuffer == 2 && !cursorBefore && !view2.isEditable)
            this.pendingBuffer = 0;
          this.flushBuffer(active);
          if (cursorBefore) {
            line2.append(wrapMarks(new WidgetBufferView(1), active), openStart);
            openStart = active.length + Math.max(0, openStart - active.length);
          }
          line2.append(wrapMarks(view2, active), openStart);
          this.atCursorPos = cursorAfter;
          this.pendingBuffer = !cursorAfter ? 0 : from < to || openStart > active.length ? 1 : 2;
          if (this.pendingBuffer)
            this.bufferMarks = active.slice();
        }
      } else if (this.doc.lineAt(this.pos).from == this.pos) {
        this.getLine().addLineDeco(deco);
      }
      if (len) {
        if (this.textOff + len <= this.text.length) {
          this.textOff += len;
        } else {
          this.skip += len - (this.text.length - this.textOff);
          this.text = "";
          this.textOff = 0;
        }
        this.pos = to;
      }
      if (this.openStart < 0)
        this.openStart = openStart;
    }
    static build(text2, from, to, decorations2, dynamicDecorationMap) {
      let builder = new ContentBuilder(text2, from, to, dynamicDecorationMap);
      builder.openEnd = RangeSet.spans(decorations2, from, to, builder);
      if (builder.openStart < 0)
        builder.openStart = builder.openEnd;
      builder.finish(builder.openEnd);
      return builder;
    }
  };
  function wrapMarks(view2, active) {
    for (let mark of active)
      view2 = new MarkView(mark, [view2], view2.length);
    return view2;
  }
  var NullWidget = class extends WidgetType {
    constructor(tag) {
      super();
      this.tag = tag;
    }
    eq(other) {
      return other.tag == this.tag;
    }
    toDOM() {
      return document.createElement(this.tag);
    }
    updateDOM(elt) {
      return elt.nodeName.toLowerCase() == this.tag;
    }
    get isHidden() {
      return true;
    }
  };
  NullWidget.inline = /* @__PURE__ */ new NullWidget("span");
  NullWidget.block = /* @__PURE__ */ new NullWidget("div");
  var Direction = /* @__PURE__ */ function(Direction2) {
    Direction2[Direction2["LTR"] = 0] = "LTR";
    Direction2[Direction2["RTL"] = 1] = "RTL";
    return Direction2;
  }(Direction || (Direction = {}));
  var LTR = Direction.LTR;
  var RTL = Direction.RTL;
  function dec(str) {
    let result = [];
    for (let i = 0; i < str.length; i++)
      result.push(1 << +str[i]);
    return result;
  }
  var LowTypes = /* @__PURE__ */ dec("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008");
  var ArabicTypes = /* @__PURE__ */ dec("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333");
  var Brackets = /* @__PURE__ */ Object.create(null);
  var BracketStack = [];
  for (let p of ["()", "[]", "{}"]) {
    let l = /* @__PURE__ */ p.charCodeAt(0), r = /* @__PURE__ */ p.charCodeAt(1);
    Brackets[l] = r;
    Brackets[r] = -l;
  }
  function charType(ch) {
    return ch <= 247 ? LowTypes[ch] : 1424 <= ch && ch <= 1524 ? 2 : 1536 <= ch && ch <= 1785 ? ArabicTypes[ch - 1536] : 1774 <= ch && ch <= 2220 ? 4 : 8192 <= ch && ch <= 8204 ? 256 : 64336 <= ch && ch <= 65023 ? 4 : 1;
  }
  var BidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/;
  var BidiSpan = class {
    get dir() {
      return this.level % 2 ? RTL : LTR;
    }
    constructor(from, to, level) {
      this.from = from;
      this.to = to;
      this.level = level;
    }
    side(end, dir) {
      return this.dir == dir == end ? this.to : this.from;
    }
    forward(forward, dir) {
      return forward == (this.dir == dir);
    }
    static find(order, index3, level, assoc) {
      let maybe = -1;
      for (let i = 0; i < order.length; i++) {
        let span3 = order[i];
        if (span3.from <= index3 && span3.to >= index3) {
          if (span3.level == level)
            return i;
          if (maybe < 0 || (assoc != 0 ? assoc < 0 ? span3.from < index3 : span3.to > index3 : order[maybe].level > span3.level))
            maybe = i;
        }
      }
      if (maybe < 0)
        throw new RangeError("Index out of range");
      return maybe;
    }
  };
  function isolatesEq(a, b) {
    if (a.length != b.length)
      return false;
    for (let i = 0; i < a.length; i++) {
      let iA = a[i], iB = b[i];
      if (iA.from != iB.from || iA.to != iB.to || iA.direction != iB.direction || !isolatesEq(iA.inner, iB.inner))
        return false;
    }
    return true;
  }
  var types = [];
  function computeCharTypes(line2, rFrom, rTo, isolates, outerType) {
    for (let iI = 0; iI <= isolates.length; iI++) {
      let from = iI ? isolates[iI - 1].to : rFrom, to = iI < isolates.length ? isolates[iI].from : rTo;
      let prevType = iI ? 256 : outerType;
      for (let i = from, prev = prevType, prevStrong = prevType; i < to; i++) {
        let type2 = charType(line2.charCodeAt(i));
        if (type2 == 512)
          type2 = prev;
        else if (type2 == 8 && prevStrong == 4)
          type2 = 16;
        types[i] = type2 == 4 ? 2 : type2;
        if (type2 & 7)
          prevStrong = type2;
        prev = type2;
      }
      for (let i = from, prev = prevType, prevStrong = prevType; i < to; i++) {
        let type2 = types[i];
        if (type2 == 128) {
          if (i < to - 1 && prev == types[i + 1] && prev & 24)
            type2 = types[i] = prev;
          else
            types[i] = 256;
        } else if (type2 == 64) {
          let end = i + 1;
          while (end < to && types[end] == 64)
            end++;
          let replace4 = i && prev == 8 || end < rTo && types[end] == 8 ? prevStrong == 1 ? 1 : 8 : 256;
          for (let j = i; j < end; j++)
            types[j] = replace4;
          i = end - 1;
        } else if (type2 == 8 && prevStrong == 1) {
          types[i] = 1;
        }
        prev = type2;
        if (type2 & 7)
          prevStrong = type2;
      }
    }
  }
  function processBracketPairs(line2, rFrom, rTo, isolates, outerType) {
    let oppositeType = outerType == 1 ? 2 : 1;
    for (let iI = 0, sI = 0, context = 0; iI <= isolates.length; iI++) {
      let from = iI ? isolates[iI - 1].to : rFrom, to = iI < isolates.length ? isolates[iI].from : rTo;
      for (let i = from, ch, br, type2; i < to; i++) {
        if (br = Brackets[ch = line2.charCodeAt(i)]) {
          if (br < 0) {
            for (let sJ = sI - 3; sJ >= 0; sJ -= 3) {
              if (BracketStack[sJ + 1] == -br) {
                let flags = BracketStack[sJ + 2];
                let type3 = flags & 2 ? outerType : !(flags & 4) ? 0 : flags & 1 ? oppositeType : outerType;
                if (type3)
                  types[i] = types[BracketStack[sJ]] = type3;
                sI = sJ;
                break;
              }
            }
          } else if (BracketStack.length == 189) {
            break;
          } else {
            BracketStack[sI++] = i;
            BracketStack[sI++] = ch;
            BracketStack[sI++] = context;
          }
        } else if ((type2 = types[i]) == 2 || type2 == 1) {
          let embed = type2 == outerType;
          context = embed ? 0 : 1;
          for (let sJ = sI - 3; sJ >= 0; sJ -= 3) {
            let cur = BracketStack[sJ + 2];
            if (cur & 2)
              break;
            if (embed) {
              BracketStack[sJ + 2] |= 2;
            } else {
              if (cur & 4)
                break;
              BracketStack[sJ + 2] |= 4;
            }
          }
        }
      }
    }
  }
  function processNeutrals(rFrom, rTo, isolates, outerType) {
    for (let iI = 0, prev = outerType; iI <= isolates.length; iI++) {
      let from = iI ? isolates[iI - 1].to : rFrom, to = iI < isolates.length ? isolates[iI].from : rTo;
      for (let i = from; i < to; ) {
        let type2 = types[i];
        if (type2 == 256) {
          let end = i + 1;
          for (; ; ) {
            if (end == to) {
              if (iI == isolates.length)
                break;
              end = isolates[iI++].to;
              to = iI < isolates.length ? isolates[iI].from : rTo;
            } else if (types[end] == 256) {
              end++;
            } else {
              break;
            }
          }
          let beforeL = prev == 1;
          let afterL = (end < rTo ? types[end] : outerType) == 1;
          let replace4 = beforeL == afterL ? beforeL ? 1 : 2 : outerType;
          for (let j = end, jI = iI, fromJ = jI ? isolates[jI - 1].to : rFrom; j > i; ) {
            if (j == fromJ) {
              j = isolates[--jI].from;
              fromJ = jI ? isolates[jI - 1].to : rFrom;
            }
            types[--j] = replace4;
          }
          i = end;
        } else {
          prev = type2;
          i++;
        }
      }
    }
  }
  function emitSpans(line2, from, to, level, baseLevel, isolates, order) {
    let ourType = level % 2 ? 2 : 1;
    if (level % 2 == baseLevel % 2) {
      for (let iCh = from, iI = 0; iCh < to; ) {
        let sameDir = true, isNum = false;
        if (iI == isolates.length || iCh < isolates[iI].from) {
          let next = types[iCh];
          if (next != ourType) {
            sameDir = false;
            isNum = next == 16;
          }
        }
        let recurse = !sameDir && ourType == 1 ? [] : null;
        let localLevel = sameDir ? level : level + 1;
        let iScan = iCh;
        run:
          for (; ; ) {
            if (iI < isolates.length && iScan == isolates[iI].from) {
              if (isNum)
                break run;
              let iso = isolates[iI];
              if (!sameDir)
                for (let upto = iso.to, jI = iI + 1; ; ) {
                  if (upto == to)
                    break run;
                  if (jI < isolates.length && isolates[jI].from == upto)
                    upto = isolates[jI++].to;
                  else if (types[upto] == ourType)
                    break run;
                  else
                    break;
                }
              iI++;
              if (recurse) {
                recurse.push(iso);
              } else {
                if (iso.from > iCh)
                  order.push(new BidiSpan(iCh, iso.from, localLevel));
                let dirSwap = iso.direction == LTR != !(localLevel % 2);
                computeSectionOrder(line2, dirSwap ? level + 1 : level, baseLevel, iso.inner, iso.from, iso.to, order);
                iCh = iso.to;
              }
              iScan = iso.to;
            } else if (iScan == to || (sameDir ? types[iScan] != ourType : types[iScan] == ourType)) {
              break;
            } else {
              iScan++;
            }
          }
        if (recurse)
          emitSpans(line2, iCh, iScan, level + 1, baseLevel, recurse, order);
        else if (iCh < iScan)
          order.push(new BidiSpan(iCh, iScan, localLevel));
        iCh = iScan;
      }
    } else {
      for (let iCh = to, iI = isolates.length; iCh > from; ) {
        let sameDir = true, isNum = false;
        if (!iI || iCh > isolates[iI - 1].to) {
          let next = types[iCh - 1];
          if (next != ourType) {
            sameDir = false;
            isNum = next == 16;
          }
        }
        let recurse = !sameDir && ourType == 1 ? [] : null;
        let localLevel = sameDir ? level : level + 1;
        let iScan = iCh;
        run:
          for (; ; ) {
            if (iI && iScan == isolates[iI - 1].to) {
              if (isNum)
                break run;
              let iso = isolates[--iI];
              if (!sameDir)
                for (let upto = iso.from, jI = iI; ; ) {
                  if (upto == from)
                    break run;
                  if (jI && isolates[jI - 1].to == upto)
                    upto = isolates[--jI].from;
                  else if (types[upto - 1] == ourType)
                    break run;
                  else
                    break;
                }
              if (recurse) {
                recurse.push(iso);
              } else {
                if (iso.to < iCh)
                  order.push(new BidiSpan(iso.to, iCh, localLevel));
                let dirSwap = iso.direction == LTR != !(localLevel % 2);
                computeSectionOrder(line2, dirSwap ? level + 1 : level, baseLevel, iso.inner, iso.from, iso.to, order);
                iCh = iso.from;
              }
              iScan = iso.from;
            } else if (iScan == from || (sameDir ? types[iScan - 1] != ourType : types[iScan - 1] == ourType)) {
              break;
            } else {
              iScan--;
            }
          }
        if (recurse)
          emitSpans(line2, iScan, iCh, level + 1, baseLevel, recurse, order);
        else if (iScan < iCh)
          order.push(new BidiSpan(iScan, iCh, localLevel));
        iCh = iScan;
      }
    }
  }
  function computeSectionOrder(line2, level, baseLevel, isolates, from, to, order) {
    let outerType = level % 2 ? 2 : 1;
    computeCharTypes(line2, from, to, isolates, outerType);
    processBracketPairs(line2, from, to, isolates, outerType);
    processNeutrals(from, to, isolates, outerType);
    emitSpans(line2, from, to, level, baseLevel, isolates, order);
  }
  function computeOrder(line2, direction, isolates) {
    if (!line2)
      return [new BidiSpan(0, 0, direction == RTL ? 1 : 0)];
    if (direction == LTR && !isolates.length && !BidiRE.test(line2))
      return trivialOrder(line2.length);
    if (isolates.length)
      while (line2.length > types.length)
        types[types.length] = 256;
    let order = [], level = direction == LTR ? 0 : 1;
    computeSectionOrder(line2, level, level, isolates, 0, line2.length, order);
    return order;
  }
  function trivialOrder(length6) {
    return [new BidiSpan(0, length6, 0)];
  }
  var movedOver = "";
  function moveVisually(line2, order, dir, start2, forward) {
    var _a2;
    let startIndex = start2.head - line2.from;
    let spanI = BidiSpan.find(order, startIndex, (_a2 = start2.bidiLevel) !== null && _a2 !== void 0 ? _a2 : -1, start2.assoc);
    let span3 = order[spanI], spanEnd = span3.side(forward, dir);
    if (startIndex == spanEnd) {
      let nextI = spanI += forward ? 1 : -1;
      if (nextI < 0 || nextI >= order.length)
        return null;
      span3 = order[spanI = nextI];
      startIndex = span3.side(!forward, dir);
      spanEnd = span3.side(forward, dir);
    }
    let nextIndex = findClusterBreak(line2.text, startIndex, span3.forward(forward, dir));
    if (nextIndex < span3.from || nextIndex > span3.to)
      nextIndex = spanEnd;
    movedOver = line2.text.slice(Math.min(startIndex, nextIndex), Math.max(startIndex, nextIndex));
    let nextSpan = spanI == (forward ? order.length - 1 : 0) ? null : order[spanI + (forward ? 1 : -1)];
    if (nextSpan && nextIndex == spanEnd && nextSpan.level + (forward ? 0 : 1) < span3.level)
      return EditorSelection.cursor(nextSpan.side(!forward, dir) + line2.from, nextSpan.forward(forward, dir) ? 1 : -1, nextSpan.level);
    return EditorSelection.cursor(nextIndex + line2.from, span3.forward(forward, dir) ? -1 : 1, span3.level);
  }
  function autoDirection(text2, from, to) {
    for (let i = from; i < to; i++) {
      let type2 = charType(text2.charCodeAt(i));
      if (type2 == 1)
        return LTR;
      if (type2 == 2 || type2 == 4)
        return RTL;
    }
    return LTR;
  }
  var clickAddsSelectionRange = /* @__PURE__ */ Facet.define();
  var dragMovesSelection$1 = /* @__PURE__ */ Facet.define();
  var mouseSelectionStyle = /* @__PURE__ */ Facet.define();
  var exceptionSink = /* @__PURE__ */ Facet.define();
  var updateListener = /* @__PURE__ */ Facet.define();
  var inputHandler = /* @__PURE__ */ Facet.define();
  var focusChangeEffect = /* @__PURE__ */ Facet.define();
  var perLineTextDirection = /* @__PURE__ */ Facet.define({
    combine: (values3) => values3.some((x2) => x2)
  });
  var nativeSelectionHidden = /* @__PURE__ */ Facet.define({
    combine: (values3) => values3.some((x2) => x2)
  });
  var scrollHandler = /* @__PURE__ */ Facet.define();
  var ScrollTarget = class {
    constructor(range4, y2 = "nearest", x2 = "nearest", yMargin = 5, xMargin = 5, isSnapshot = false) {
      this.range = range4;
      this.y = y2;
      this.x = x2;
      this.yMargin = yMargin;
      this.xMargin = xMargin;
      this.isSnapshot = isSnapshot;
    }
    map(changes) {
      return changes.empty ? this : new ScrollTarget(this.range.map(changes), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
    }
    clip(state) {
      return this.range.to <= state.doc.length ? this : new ScrollTarget(EditorSelection.cursor(state.doc.length), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
    }
  };
  var scrollIntoView = /* @__PURE__ */ StateEffect.define({ map: (t2, ch) => t2.map(ch) });
  var setEditContextFormatting = /* @__PURE__ */ StateEffect.define();
  function logException(state, exception, context) {
    let handler = state.facet(exceptionSink);
    if (handler.length)
      handler[0](exception);
    else if (window.onerror)
      window.onerror(String(exception), context, void 0, void 0, exception);
    else if (context)
      console.error(context + ":", exception);
    else
      console.error(exception);
  }
  var editable = /* @__PURE__ */ Facet.define({ combine: (values3) => values3.length ? values3[0] : true });
  var nextPluginID = 0;
  var viewPlugin = /* @__PURE__ */ Facet.define();
  var ViewPlugin = class {
    constructor(id3, create2, domEventHandlers, domEventObservers, buildExtensions) {
      this.id = id3;
      this.create = create2;
      this.domEventHandlers = domEventHandlers;
      this.domEventObservers = domEventObservers;
      this.extension = buildExtensions(this);
    }
    static define(create2, spec) {
      const { eventHandlers, eventObservers, provide, decorations: deco } = spec || {};
      return new ViewPlugin(nextPluginID++, create2, eventHandlers, eventObservers, (plugin) => {
        let ext = [viewPlugin.of(plugin)];
        if (deco)
          ext.push(decorations.of((view2) => {
            let pluginInst = view2.plugin(plugin);
            return pluginInst ? deco(pluginInst) : Decoration.none;
          }));
        if (provide)
          ext.push(provide(plugin));
        return ext;
      });
    }
    static fromClass(cls, spec) {
      return ViewPlugin.define((view2) => new cls(view2), spec);
    }
  };
  var PluginInstance = class {
    constructor(spec) {
      this.spec = spec;
      this.mustUpdate = null;
      this.value = null;
    }
    update(view2) {
      if (!this.value) {
        if (this.spec) {
          try {
            this.value = this.spec.create(view2);
          } catch (e) {
            logException(view2.state, e, "CodeMirror plugin crashed");
            this.deactivate();
          }
        }
      } else if (this.mustUpdate) {
        let update3 = this.mustUpdate;
        this.mustUpdate = null;
        if (this.value.update) {
          try {
            this.value.update(update3);
          } catch (e) {
            logException(update3.state, e, "CodeMirror plugin crashed");
            if (this.value.destroy)
              try {
                this.value.destroy();
              } catch (_) {
              }
            this.deactivate();
          }
        }
      }
      return this;
    }
    destroy(view2) {
      var _a2;
      if ((_a2 = this.value) === null || _a2 === void 0 ? void 0 : _a2.destroy) {
        try {
          this.value.destroy();
        } catch (e) {
          logException(view2.state, e, "CodeMirror plugin crashed");
        }
      }
    }
    deactivate() {
      this.spec = this.value = null;
    }
  };
  var editorAttributes = /* @__PURE__ */ Facet.define();
  var contentAttributes = /* @__PURE__ */ Facet.define();
  var decorations = /* @__PURE__ */ Facet.define();
  var outerDecorations = /* @__PURE__ */ Facet.define();
  var atomicRanges = /* @__PURE__ */ Facet.define();
  var bidiIsolatedRanges = /* @__PURE__ */ Facet.define();
  function getIsolatedRanges(view2, line2) {
    let isolates = view2.state.facet(bidiIsolatedRanges);
    if (!isolates.length)
      return isolates;
    let sets = isolates.map((i) => i instanceof Function ? i(view2) : i);
    let result = [];
    RangeSet.spans(sets, line2.from, line2.to, {
      point() {
      },
      span(fromDoc, toDoc, active, open) {
        let from = fromDoc - line2.from, to = toDoc - line2.from;
        let level = result;
        for (let i = active.length - 1; i >= 0; i--, open--) {
          let direction = active[i].spec.bidiIsolate, update3;
          if (direction == null)
            direction = autoDirection(line2.text, from, to);
          if (open > 0 && level.length && (update3 = level[level.length - 1]).to == from && update3.direction == direction) {
            update3.to = to;
            level = update3.inner;
          } else {
            let add = { from, to, direction, inner: [] };
            level.push(add);
            level = add.inner;
          }
        }
      }
    });
    return result;
  }
  var scrollMargins = /* @__PURE__ */ Facet.define();
  function getScrollMargins(view2) {
    let left2 = 0, right2 = 0, top3 = 0, bottom2 = 0;
    for (let source2 of view2.state.facet(scrollMargins)) {
      let m = source2(view2);
      if (m) {
        if (m.left != null)
          left2 = Math.max(left2, m.left);
        if (m.right != null)
          right2 = Math.max(right2, m.right);
        if (m.top != null)
          top3 = Math.max(top3, m.top);
        if (m.bottom != null)
          bottom2 = Math.max(bottom2, m.bottom);
      }
    }
    return { left: left2, right: right2, top: top3, bottom: bottom2 };
  }
  var styleModule = /* @__PURE__ */ Facet.define();
  var ChangedRange = class {
    constructor(fromA, toA, fromB, toB) {
      this.fromA = fromA;
      this.toA = toA;
      this.fromB = fromB;
      this.toB = toB;
    }
    join(other) {
      return new ChangedRange(Math.min(this.fromA, other.fromA), Math.max(this.toA, other.toA), Math.min(this.fromB, other.fromB), Math.max(this.toB, other.toB));
    }
    addToSet(set3) {
      let i = set3.length, me = this;
      for (; i > 0; i--) {
        let range4 = set3[i - 1];
        if (range4.fromA > me.toA)
          continue;
        if (range4.toA < me.fromA)
          break;
        me = me.join(range4);
        set3.splice(i - 1, 1);
      }
      set3.splice(i, 0, me);
      return set3;
    }
    static extendWithRanges(diff, ranges) {
      if (ranges.length == 0)
        return diff;
      let result = [];
      for (let dI = 0, rI = 0, posA = 0, posB = 0; ; dI++) {
        let next = dI == diff.length ? null : diff[dI], off = posA - posB;
        let end = next ? next.fromB : 1e9;
        while (rI < ranges.length && ranges[rI] < end) {
          let from = ranges[rI], to = ranges[rI + 1];
          let fromB = Math.max(posB, from), toB = Math.min(end, to);
          if (fromB <= toB)
            new ChangedRange(fromB + off, toB + off, fromB, toB).addToSet(result);
          if (to > end)
            break;
          else
            rI += 2;
        }
        if (!next)
          return result;
        new ChangedRange(next.fromA, next.toA, next.fromB, next.toB).addToSet(result);
        posA = next.toA;
        posB = next.toB;
      }
    }
  };
  var ViewUpdate = class {
    constructor(view2, state, transactions) {
      this.view = view2;
      this.state = state;
      this.transactions = transactions;
      this.flags = 0;
      this.startState = view2.state;
      this.changes = ChangeSet.empty(this.startState.doc.length);
      for (let tr of transactions)
        this.changes = this.changes.compose(tr.changes);
      let changedRanges = [];
      this.changes.iterChangedRanges((fromA, toA, fromB, toB) => changedRanges.push(new ChangedRange(fromA, toA, fromB, toB)));
      this.changedRanges = changedRanges;
    }
    static create(view2, state, transactions) {
      return new ViewUpdate(view2, state, transactions);
    }
    get viewportChanged() {
      return (this.flags & 4) > 0;
    }
    get heightChanged() {
      return (this.flags & 2) > 0;
    }
    get geometryChanged() {
      return this.docChanged || (this.flags & (8 | 2)) > 0;
    }
    get focusChanged() {
      return (this.flags & 1) > 0;
    }
    get docChanged() {
      return !this.changes.empty;
    }
    get selectionSet() {
      return this.transactions.some((tr) => tr.selection);
    }
    get empty() {
      return this.flags == 0 && this.transactions.length == 0;
    }
  };
  var DocView = class extends ContentView {
    get length() {
      return this.view.state.doc.length;
    }
    constructor(view2) {
      super();
      this.view = view2;
      this.decorations = [];
      this.dynamicDecorationMap = [false];
      this.domChanged = null;
      this.hasComposition = null;
      this.markedForComposition = /* @__PURE__ */ new Set();
      this.editContextFormatting = Decoration.none;
      this.lastCompositionAfterCursor = false;
      this.minWidth = 0;
      this.minWidthFrom = 0;
      this.minWidthTo = 0;
      this.impreciseAnchor = null;
      this.impreciseHead = null;
      this.forceSelection = false;
      this.lastUpdate = Date.now();
      this.setDOM(view2.contentDOM);
      this.children = [new LineView()];
      this.children[0].setParent(this);
      this.updateDeco();
      this.updateInner([new ChangedRange(0, 0, 0, view2.state.doc.length)], 0, null);
    }
    update(update3) {
      var _a2;
      let changedRanges = update3.changedRanges;
      if (this.minWidth > 0 && changedRanges.length) {
        if (!changedRanges.every(({ fromA, toA }) => toA < this.minWidthFrom || fromA > this.minWidthTo)) {
          this.minWidth = this.minWidthFrom = this.minWidthTo = 0;
        } else {
          this.minWidthFrom = update3.changes.mapPos(this.minWidthFrom, 1);
          this.minWidthTo = update3.changes.mapPos(this.minWidthTo, 1);
        }
      }
      this.updateEditContextFormatting(update3);
      let readCompositionAt = -1;
      if (this.view.inputState.composing >= 0 && !this.view.observer.editContext) {
        if ((_a2 = this.domChanged) === null || _a2 === void 0 ? void 0 : _a2.newSel)
          readCompositionAt = this.domChanged.newSel.head;
        else if (!touchesComposition(update3.changes, this.hasComposition) && !update3.selectionSet)
          readCompositionAt = update3.state.selection.main.head;
      }
      let composition = readCompositionAt > -1 ? findCompositionRange(this.view, update3.changes, readCompositionAt) : null;
      this.domChanged = null;
      if (this.hasComposition) {
        this.markedForComposition.clear();
        let { from, to } = this.hasComposition;
        changedRanges = new ChangedRange(from, to, update3.changes.mapPos(from, -1), update3.changes.mapPos(to, 1)).addToSet(changedRanges.slice());
      }
      this.hasComposition = composition ? { from: composition.range.fromB, to: composition.range.toB } : null;
      if ((browser.ie || browser.chrome) && !composition && update3 && update3.state.doc.lines != update3.startState.doc.lines)
        this.forceSelection = true;
      let prevDeco = this.decorations, deco = this.updateDeco();
      let decoDiff = findChangedDeco(prevDeco, deco, update3.changes);
      changedRanges = ChangedRange.extendWithRanges(changedRanges, decoDiff);
      if (!(this.flags & 7) && changedRanges.length == 0) {
        return false;
      } else {
        this.updateInner(changedRanges, update3.startState.doc.length, composition);
        if (update3.transactions.length)
          this.lastUpdate = Date.now();
        return true;
      }
    }
    updateInner(changes, oldLength, composition) {
      this.view.viewState.mustMeasureContent = true;
      this.updateChildren(changes, oldLength, composition);
      let { observer } = this.view;
      observer.ignore(() => {
        this.dom.style.height = this.view.viewState.contentHeight / this.view.scaleY + "px";
        this.dom.style.flexBasis = this.minWidth ? this.minWidth + "px" : "";
        let track = browser.chrome || browser.ios ? { node: observer.selectionRange.focusNode, written: false } : void 0;
        this.sync(this.view, track);
        this.flags &= ~7;
        if (track && (track.written || observer.selectionRange.focusNode != track.node))
          this.forceSelection = true;
        this.dom.style.height = "";
      });
      this.markedForComposition.forEach((cView) => cView.flags &= ~8);
      let gaps = [];
      if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length) {
        for (let child of this.children)
          if (child instanceof BlockWidgetView && child.widget instanceof BlockGapWidget)
            gaps.push(child.dom);
      }
      observer.updateGaps(gaps);
    }
    updateChildren(changes, oldLength, composition) {
      let ranges = composition ? composition.range.addToSet(changes.slice()) : changes;
      let cursor = this.childCursor(oldLength);
      for (let i = ranges.length - 1; ; i--) {
        let next = i >= 0 ? ranges[i] : null;
        if (!next)
          break;
        let { fromA, toA, fromB, toB } = next, content2, breakAtStart, openStart, openEnd;
        if (composition && composition.range.fromB < toB && composition.range.toB > fromB) {
          let before = ContentBuilder.build(this.view.state.doc, fromB, composition.range.fromB, this.decorations, this.dynamicDecorationMap);
          let after = ContentBuilder.build(this.view.state.doc, composition.range.toB, toB, this.decorations, this.dynamicDecorationMap);
          breakAtStart = before.breakAtStart;
          openStart = before.openStart;
          openEnd = after.openEnd;
          let compLine = this.compositionView(composition);
          if (after.breakAtStart) {
            compLine.breakAfter = 1;
          } else if (after.content.length && compLine.merge(compLine.length, compLine.length, after.content[0], false, after.openStart, 0)) {
            compLine.breakAfter = after.content[0].breakAfter;
            after.content.shift();
          }
          if (before.content.length && compLine.merge(0, 0, before.content[before.content.length - 1], true, 0, before.openEnd)) {
            before.content.pop();
          }
          content2 = before.content.concat(compLine).concat(after.content);
        } else {
          ({ content: content2, breakAtStart, openStart, openEnd } = ContentBuilder.build(this.view.state.doc, fromB, toB, this.decorations, this.dynamicDecorationMap));
        }
        let { i: toI, off: toOff } = cursor.findPos(toA, 1);
        let { i: fromI, off: fromOff } = cursor.findPos(fromA, -1);
        replaceRange(this, fromI, fromOff, toI, toOff, content2, breakAtStart, openStart, openEnd);
      }
      if (composition)
        this.fixCompositionDOM(composition);
    }
    updateEditContextFormatting(update3) {
      this.editContextFormatting = this.editContextFormatting.map(update3.changes);
      for (let tr of update3.transactions)
        for (let effect of tr.effects)
          if (effect.is(setEditContextFormatting)) {
            this.editContextFormatting = effect.value;
          }
    }
    compositionView(composition) {
      let cur = new TextView(composition.text.nodeValue);
      cur.flags |= 8;
      for (let { deco } of composition.marks)
        cur = new MarkView(deco, [cur], cur.length);
      let line2 = new LineView();
      line2.append(cur, 0);
      return line2;
    }
    fixCompositionDOM(composition) {
      let fix = (dom, cView2) => {
        cView2.flags |= 8 | (cView2.children.some((c) => c.flags & 7) ? 1 : 0);
        this.markedForComposition.add(cView2);
        let prev = ContentView.get(dom);
        if (prev && prev != cView2)
          prev.dom = null;
        cView2.setDOM(dom);
      };
      let pos = this.childPos(composition.range.fromB, 1);
      let cView = this.children[pos.i];
      fix(composition.line, cView);
      for (let i = composition.marks.length - 1; i >= -1; i--) {
        pos = cView.childPos(pos.off, 1);
        cView = cView.children[pos.i];
        fix(i >= 0 ? composition.marks[i].node : composition.text, cView);
      }
    }
    updateSelection(mustRead = false, fromPointer = false) {
      if (mustRead || !this.view.observer.selectionRange.focusNode)
        this.view.observer.readSelectionRange();
      let activeElt = this.view.root.activeElement, focused = activeElt == this.dom;
      let selectionNotFocus = !focused && hasSelection(this.dom, this.view.observer.selectionRange) && !(activeElt && this.dom.contains(activeElt));
      if (!(focused || fromPointer || selectionNotFocus))
        return;
      let force2 = this.forceSelection;
      this.forceSelection = false;
      let main2 = this.view.state.selection.main;
      let anchor = this.moveToLine(this.domAtPos(main2.anchor));
      let head = main2.empty ? anchor : this.moveToLine(this.domAtPos(main2.head));
      if (browser.gecko && main2.empty && !this.hasComposition && betweenUneditable(anchor)) {
        let dummy = document.createTextNode("");
        this.view.observer.ignore(() => anchor.node.insertBefore(dummy, anchor.node.childNodes[anchor.offset] || null));
        anchor = head = new DOMPos(dummy, 0);
        force2 = true;
      }
      let domSel = this.view.observer.selectionRange;
      if (force2 || !domSel.focusNode || (!isEquivalentPosition(anchor.node, anchor.offset, domSel.anchorNode, domSel.anchorOffset) || !isEquivalentPosition(head.node, head.offset, domSel.focusNode, domSel.focusOffset)) && !this.suppressWidgetCursorChange(domSel, main2)) {
        this.view.observer.ignore(() => {
          if (browser.android && browser.chrome && this.dom.contains(domSel.focusNode) && inUneditable(domSel.focusNode, this.dom)) {
            this.dom.blur();
            this.dom.focus({ preventScroll: true });
          }
          let rawSel = getSelection(this.view.root);
          if (!rawSel)
            ;
          else if (main2.empty) {
            if (browser.gecko) {
              let nextTo = nextToUneditable(anchor.node, anchor.offset);
              if (nextTo && nextTo != (1 | 2)) {
                let text2 = (nextTo == 1 ? textNodeBefore : textNodeAfter)(anchor.node, anchor.offset);
                if (text2)
                  anchor = new DOMPos(text2.node, text2.offset);
              }
            }
            rawSel.collapse(anchor.node, anchor.offset);
            if (main2.bidiLevel != null && rawSel.caretBidiLevel !== void 0)
              rawSel.caretBidiLevel = main2.bidiLevel;
          } else if (rawSel.extend) {
            rawSel.collapse(anchor.node, anchor.offset);
            try {
              rawSel.extend(head.node, head.offset);
            } catch (_) {
            }
          } else {
            let range4 = document.createRange();
            if (main2.anchor > main2.head)
              [anchor, head] = [head, anchor];
            range4.setEnd(head.node, head.offset);
            range4.setStart(anchor.node, anchor.offset);
            rawSel.removeAllRanges();
            rawSel.addRange(range4);
          }
          if (selectionNotFocus && this.view.root.activeElement == this.dom) {
            this.dom.blur();
            if (activeElt)
              activeElt.focus();
          }
        });
        this.view.observer.setSelectionRange(anchor, head);
      }
      this.impreciseAnchor = anchor.precise ? null : new DOMPos(domSel.anchorNode, domSel.anchorOffset);
      this.impreciseHead = head.precise ? null : new DOMPos(domSel.focusNode, domSel.focusOffset);
    }
    suppressWidgetCursorChange(sel, cursor) {
      return this.hasComposition && cursor.empty && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset) && this.posFromDOM(sel.focusNode, sel.focusOffset) == cursor.head;
    }
    enforceCursorAssoc() {
      if (this.hasComposition)
        return;
      let { view: view2 } = this, cursor = view2.state.selection.main;
      let sel = getSelection(view2.root);
      let { anchorNode, anchorOffset } = view2.observer.selectionRange;
      if (!sel || !cursor.empty || !cursor.assoc || !sel.modify)
        return;
      let line2 = LineView.find(this, cursor.head);
      if (!line2)
        return;
      let lineStart = line2.posAtStart;
      if (cursor.head == lineStart || cursor.head == lineStart + line2.length)
        return;
      let before = this.coordsAt(cursor.head, -1), after = this.coordsAt(cursor.head, 1);
      if (!before || !after || before.bottom > after.top)
        return;
      let dom = this.domAtPos(cursor.head + cursor.assoc);
      sel.collapse(dom.node, dom.offset);
      sel.modify("move", cursor.assoc < 0 ? "forward" : "backward", "lineboundary");
      view2.observer.readSelectionRange();
      let newRange = view2.observer.selectionRange;
      if (view2.docView.posFromDOM(newRange.anchorNode, newRange.anchorOffset) != cursor.from)
        sel.collapse(anchorNode, anchorOffset);
    }
    moveToLine(pos) {
      let dom = this.dom, newPos;
      if (pos.node != dom)
        return pos;
      for (let i = pos.offset; !newPos && i < dom.childNodes.length; i++) {
        let view2 = ContentView.get(dom.childNodes[i]);
        if (view2 instanceof LineView)
          newPos = view2.domAtPos(0);
      }
      for (let i = pos.offset - 1; !newPos && i >= 0; i--) {
        let view2 = ContentView.get(dom.childNodes[i]);
        if (view2 instanceof LineView)
          newPos = view2.domAtPos(view2.length);
      }
      return newPos ? new DOMPos(newPos.node, newPos.offset, true) : pos;
    }
    nearest(dom) {
      for (let cur = dom; cur; ) {
        let domView = ContentView.get(cur);
        if (domView && domView.rootView == this)
          return domView;
        cur = cur.parentNode;
      }
      return null;
    }
    posFromDOM(node2, offset) {
      let view2 = this.nearest(node2);
      if (!view2)
        throw new RangeError("Trying to find position for a DOM position outside of the document");
      return view2.localPosFromDOM(node2, offset) + view2.posAtStart;
    }
    domAtPos(pos) {
      let { i, off } = this.childCursor().findPos(pos, -1);
      for (; i < this.children.length - 1; ) {
        let child = this.children[i];
        if (off < child.length || child instanceof LineView)
          break;
        i++;
        off = 0;
      }
      return this.children[i].domAtPos(off);
    }
    coordsAt(pos, side) {
      let best = null, bestPos = 0;
      for (let off = this.length, i = this.children.length - 1; i >= 0; i--) {
        let child = this.children[i], end = off - child.breakAfter, start2 = end - child.length;
        if (end < pos)
          break;
        if (start2 <= pos && (start2 < pos || child.covers(-1)) && (end > pos || child.covers(1)) && (!best || child instanceof LineView && !(best instanceof LineView && side >= 0))) {
          best = child;
          bestPos = start2;
        } else if (best && start2 == pos && end == pos && child instanceof BlockWidgetView && Math.abs(side) < 2) {
          if (child.deco.startSide < 0)
            break;
          else if (i)
            best = null;
        }
        off = start2;
      }
      return best ? best.coordsAt(pos - bestPos, side) : null;
    }
    coordsForChar(pos) {
      let { i, off } = this.childPos(pos, 1), child = this.children[i];
      if (!(child instanceof LineView))
        return null;
      while (child.children.length) {
        let { i: i2, off: childOff } = child.childPos(off, 1);
        for (; ; i2++) {
          if (i2 == child.children.length)
            return null;
          if ((child = child.children[i2]).length)
            break;
        }
        off = childOff;
      }
      if (!(child instanceof TextView))
        return null;
      let end = findClusterBreak(child.text, off);
      if (end == off)
        return null;
      let rects = textRange(child.dom, off, end).getClientRects();
      for (let i2 = 0; i2 < rects.length; i2++) {
        let rect = rects[i2];
        if (i2 == rects.length - 1 || rect.top < rect.bottom && rect.left < rect.right)
          return rect;
      }
      return null;
    }
    measureVisibleLineHeights(viewport) {
      let result = [], { from, to } = viewport;
      let contentWidth = this.view.contentDOM.clientWidth;
      let isWider = contentWidth > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1;
      let widest = -1, ltr = this.view.textDirection == Direction.LTR;
      for (let pos = 0, i = 0; i < this.children.length; i++) {
        let child = this.children[i], end = pos + child.length;
        if (end > to)
          break;
        if (pos >= from) {
          let childRect = child.dom.getBoundingClientRect();
          result.push(childRect.height);
          if (isWider) {
            let last3 = child.dom.lastChild;
            let rects = last3 ? clientRectsFor(last3) : [];
            if (rects.length) {
              let rect = rects[rects.length - 1];
              let width = ltr ? rect.right - childRect.left : childRect.right - rect.left;
              if (width > widest) {
                widest = width;
                this.minWidth = contentWidth;
                this.minWidthFrom = pos;
                this.minWidthTo = end;
              }
            }
          }
        }
        pos = end + child.breakAfter;
      }
      return result;
    }
    textDirectionAt(pos) {
      let { i } = this.childPos(pos, 1);
      return getComputedStyle(this.children[i].dom).direction == "rtl" ? Direction.RTL : Direction.LTR;
    }
    measureTextSize() {
      for (let child of this.children) {
        if (child instanceof LineView) {
          let measure = child.measureTextSize();
          if (measure)
            return measure;
        }
      }
      let dummy = document.createElement("div"), lineHeight, charWidth, textHeight;
      dummy.className = "cm-line";
      dummy.style.width = "99999px";
      dummy.style.position = "absolute";
      dummy.textContent = "abc def ghi jkl mno pqr stu";
      this.view.observer.ignore(() => {
        this.dom.appendChild(dummy);
        let rect = clientRectsFor(dummy.firstChild)[0];
        lineHeight = dummy.getBoundingClientRect().height;
        charWidth = rect ? rect.width / 27 : 7;
        textHeight = rect ? rect.height : lineHeight;
        dummy.remove();
      });
      return { lineHeight, charWidth, textHeight };
    }
    childCursor(pos = this.length) {
      let i = this.children.length;
      if (i)
        pos -= this.children[--i].length;
      return new ChildCursor(this.children, pos, i);
    }
    computeBlockGapDeco() {
      let deco = [], vs = this.view.viewState;
      for (let pos = 0, i = 0; ; i++) {
        let next = i == vs.viewports.length ? null : vs.viewports[i];
        let end = next ? next.from - 1 : this.length;
        if (end > pos) {
          let height = (vs.lineBlockAt(end).bottom - vs.lineBlockAt(pos).top) / this.view.scaleY;
          deco.push(Decoration.replace({
            widget: new BlockGapWidget(height),
            block: true,
            inclusive: true,
            isBlockGap: true
          }).range(pos, end));
        }
        if (!next)
          break;
        pos = next.to + 1;
      }
      return Decoration.set(deco);
    }
    updateDeco() {
      let i = 1;
      let allDeco = this.view.state.facet(decorations).map((d) => {
        let dynamic = this.dynamicDecorationMap[i++] = typeof d == "function";
        return dynamic ? d(this.view) : d;
      });
      let dynamicOuter = false, outerDeco = this.view.state.facet(outerDecorations).map((d, i2) => {
        let dynamic = typeof d == "function";
        if (dynamic)
          dynamicOuter = true;
        return dynamic ? d(this.view) : d;
      });
      if (outerDeco.length) {
        this.dynamicDecorationMap[i++] = dynamicOuter;
        allDeco.push(RangeSet.join(outerDeco));
      }
      this.decorations = [
        this.editContextFormatting,
        ...allDeco,
        this.computeBlockGapDeco(),
        this.view.viewState.lineGapDeco
      ];
      while (i < this.decorations.length)
        this.dynamicDecorationMap[i++] = false;
      return this.decorations;
    }
    scrollIntoView(target) {
      if (target.isSnapshot) {
        let ref = this.view.viewState.lineBlockAt(target.range.head);
        this.view.scrollDOM.scrollTop = ref.top - target.yMargin;
        this.view.scrollDOM.scrollLeft = target.xMargin;
        return;
      }
      for (let handler of this.view.state.facet(scrollHandler)) {
        try {
          if (handler(this.view, target.range, target))
            return true;
        } catch (e) {
          logException(this.view.state, e, "scroll handler");
        }
      }
      let { range: range4 } = target;
      let rect = this.coordsAt(range4.head, range4.empty ? range4.assoc : range4.head > range4.anchor ? -1 : 1), other;
      if (!rect)
        return;
      if (!range4.empty && (other = this.coordsAt(range4.anchor, range4.anchor > range4.head ? -1 : 1)))
        rect = {
          left: Math.min(rect.left, other.left),
          top: Math.min(rect.top, other.top),
          right: Math.max(rect.right, other.right),
          bottom: Math.max(rect.bottom, other.bottom)
        };
      let margins = getScrollMargins(this.view);
      let targetRect = {
        left: rect.left - margins.left,
        top: rect.top - margins.top,
        right: rect.right + margins.right,
        bottom: rect.bottom + margins.bottom
      };
      let { offsetWidth, offsetHeight } = this.view.scrollDOM;
      scrollRectIntoView(this.view.scrollDOM, targetRect, range4.head < range4.anchor ? -1 : 1, target.x, target.y, Math.max(Math.min(target.xMargin, offsetWidth), -offsetWidth), Math.max(Math.min(target.yMargin, offsetHeight), -offsetHeight), this.view.textDirection == Direction.LTR);
    }
  };
  function betweenUneditable(pos) {
    return pos.node.nodeType == 1 && pos.node.firstChild && (pos.offset == 0 || pos.node.childNodes[pos.offset - 1].contentEditable == "false") && (pos.offset == pos.node.childNodes.length || pos.node.childNodes[pos.offset].contentEditable == "false");
  }
  function findCompositionNode(view2, headPos) {
    let sel = view2.observer.selectionRange;
    if (!sel.focusNode)
      return null;
    let textBefore = textNodeBefore(sel.focusNode, sel.focusOffset);
    let textAfter = textNodeAfter(sel.focusNode, sel.focusOffset);
    let textNode = textBefore || textAfter;
    if (textAfter && textBefore && textAfter.node != textBefore.node) {
      let descAfter = ContentView.get(textAfter.node);
      if (!descAfter || descAfter instanceof TextView && descAfter.text != textAfter.node.nodeValue) {
        textNode = textAfter;
      } else if (view2.docView.lastCompositionAfterCursor) {
        let descBefore = ContentView.get(textBefore.node);
        if (!(!descBefore || descBefore instanceof TextView && descBefore.text != textBefore.node.nodeValue))
          textNode = textAfter;
      }
    }
    view2.docView.lastCompositionAfterCursor = textNode != textBefore;
    if (!textNode)
      return null;
    let from = headPos - textNode.offset;
    return { from, to: from + textNode.node.nodeValue.length, node: textNode.node };
  }
  function findCompositionRange(view2, changes, headPos) {
    let found = findCompositionNode(view2, headPos);
    if (!found)
      return null;
    let { node: textNode, from, to } = found, text2 = textNode.nodeValue;
    if (/[\n\r]/.test(text2))
      return null;
    if (view2.state.doc.sliceString(found.from, found.to) != text2)
      return null;
    let inv = changes.invertedDesc;
    let range4 = new ChangedRange(inv.mapPos(from), inv.mapPos(to), from, to);
    let marks2 = [];
    for (let parent = textNode.parentNode; ; parent = parent.parentNode) {
      let parentView = ContentView.get(parent);
      if (parentView instanceof MarkView)
        marks2.push({ node: parent, deco: parentView.mark });
      else if (parentView instanceof LineView || parent.nodeName == "DIV" && parent.parentNode == view2.contentDOM)
        return { range: range4, text: textNode, marks: marks2, line: parent };
      else if (parent != view2.contentDOM)
        marks2.push({ node: parent, deco: new MarkDecoration({
          inclusive: true,
          attributes: getAttrs(parent),
          tagName: parent.tagName.toLowerCase()
        }) });
      else
        return null;
    }
  }
  function nextToUneditable(node2, offset) {
    if (node2.nodeType != 1)
      return 0;
    return (offset && node2.childNodes[offset - 1].contentEditable == "false" ? 1 : 0) | (offset < node2.childNodes.length && node2.childNodes[offset].contentEditable == "false" ? 2 : 0);
  }
  var DecorationComparator$1 = class DecorationComparator {
    constructor() {
      this.changes = [];
    }
    compareRange(from, to) {
      addRange(from, to, this.changes);
    }
    comparePoint(from, to) {
      addRange(from, to, this.changes);
    }
  };
  function findChangedDeco(a, b, diff) {
    let comp = new DecorationComparator$1();
    RangeSet.compare(a, b, diff, comp);
    return comp.changes;
  }
  function inUneditable(node2, inside2) {
    for (let cur = node2; cur && cur != inside2; cur = cur.assignedSlot || cur.parentNode) {
      if (cur.nodeType == 1 && cur.contentEditable == "false") {
        return true;
      }
    }
    return false;
  }
  function touchesComposition(changes, composition) {
    let touched = false;
    if (composition)
      changes.iterChangedRanges((from, to) => {
        if (from < composition.to && to > composition.from)
          touched = true;
      });
    return touched;
  }
  function groupAt(state, pos, bias = 1) {
    let categorize = state.charCategorizer(pos);
    let line2 = state.doc.lineAt(pos), linePos = pos - line2.from;
    if (line2.length == 0)
      return EditorSelection.cursor(pos);
    if (linePos == 0)
      bias = 1;
    else if (linePos == line2.length)
      bias = -1;
    let from = linePos, to = linePos;
    if (bias < 0)
      from = findClusterBreak(line2.text, linePos, false);
    else
      to = findClusterBreak(line2.text, linePos);
    let cat = categorize(line2.text.slice(from, to));
    while (from > 0) {
      let prev = findClusterBreak(line2.text, from, false);
      if (categorize(line2.text.slice(prev, from)) != cat)
        break;
      from = prev;
    }
    while (to < line2.length) {
      let next = findClusterBreak(line2.text, to);
      if (categorize(line2.text.slice(to, next)) != cat)
        break;
      to = next;
    }
    return EditorSelection.range(from + line2.from, to + line2.from);
  }
  function getdx(x2, rect) {
    return rect.left > x2 ? rect.left - x2 : Math.max(0, x2 - rect.right);
  }
  function getdy(y2, rect) {
    return rect.top > y2 ? rect.top - y2 : Math.max(0, y2 - rect.bottom);
  }
  function yOverlap(a, b) {
    return a.top < b.bottom - 1 && a.bottom > b.top + 1;
  }
  function upTop(rect, top3) {
    return top3 < rect.top ? { top: top3, left: rect.left, right: rect.right, bottom: rect.bottom } : rect;
  }
  function upBot(rect, bottom2) {
    return bottom2 > rect.bottom ? { top: rect.top, left: rect.left, right: rect.right, bottom: bottom2 } : rect;
  }
  function domPosAtCoords(parent, x2, y2) {
    let closest, closestRect, closestX, closestY, closestOverlap = false;
    let above, below, aboveRect, belowRect;
    for (let child = parent.firstChild; child; child = child.nextSibling) {
      let rects = clientRectsFor(child);
      for (let i = 0; i < rects.length; i++) {
        let rect = rects[i];
        if (closestRect && yOverlap(closestRect, rect))
          rect = upTop(upBot(rect, closestRect.bottom), closestRect.top);
        let dx = getdx(x2, rect), dy = getdy(y2, rect);
        if (dx == 0 && dy == 0)
          return child.nodeType == 3 ? domPosInText(child, x2, y2) : domPosAtCoords(child, x2, y2);
        if (!closest || closestY > dy || closestY == dy && closestX > dx) {
          closest = child;
          closestRect = rect;
          closestX = dx;
          closestY = dy;
          let side = dy ? y2 < rect.top ? -1 : 1 : dx ? x2 < rect.left ? -1 : 1 : 0;
          closestOverlap = !side || (side > 0 ? i < rects.length - 1 : i > 0);
        }
        if (dx == 0) {
          if (y2 > rect.bottom && (!aboveRect || aboveRect.bottom < rect.bottom)) {
            above = child;
            aboveRect = rect;
          } else if (y2 < rect.top && (!belowRect || belowRect.top > rect.top)) {
            below = child;
            belowRect = rect;
          }
        } else if (aboveRect && yOverlap(aboveRect, rect)) {
          aboveRect = upBot(aboveRect, rect.bottom);
        } else if (belowRect && yOverlap(belowRect, rect)) {
          belowRect = upTop(belowRect, rect.top);
        }
      }
    }
    if (aboveRect && aboveRect.bottom >= y2) {
      closest = above;
      closestRect = aboveRect;
    } else if (belowRect && belowRect.top <= y2) {
      closest = below;
      closestRect = belowRect;
    }
    if (!closest)
      return { node: parent, offset: 0 };
    let clipX = Math.max(closestRect.left, Math.min(closestRect.right, x2));
    if (closest.nodeType == 3)
      return domPosInText(closest, clipX, y2);
    if (closestOverlap && closest.contentEditable != "false")
      return domPosAtCoords(closest, clipX, y2);
    let offset = Array.prototype.indexOf.call(parent.childNodes, closest) + (x2 >= (closestRect.left + closestRect.right) / 2 ? 1 : 0);
    return { node: parent, offset };
  }
  function domPosInText(node2, x2, y2) {
    let len = node2.nodeValue.length;
    let closestOffset = -1, closestDY = 1e9, generalSide = 0;
    for (let i = 0; i < len; i++) {
      let rects = textRange(node2, i, i + 1).getClientRects();
      for (let j = 0; j < rects.length; j++) {
        let rect = rects[j];
        if (rect.top == rect.bottom)
          continue;
        if (!generalSide)
          generalSide = x2 - rect.left;
        let dy = (rect.top > y2 ? rect.top - y2 : y2 - rect.bottom) - 1;
        if (rect.left - 1 <= x2 && rect.right + 1 >= x2 && dy < closestDY) {
          let right2 = x2 >= (rect.left + rect.right) / 2, after = right2;
          if (browser.chrome || browser.gecko) {
            let rectBefore = textRange(node2, i).getBoundingClientRect();
            if (rectBefore.left == rect.right)
              after = !right2;
          }
          if (dy <= 0)
            return { node: node2, offset: i + (after ? 1 : 0) };
          closestOffset = i + (after ? 1 : 0);
          closestDY = dy;
        }
      }
    }
    return { node: node2, offset: closestOffset > -1 ? closestOffset : generalSide > 0 ? node2.nodeValue.length : 0 };
  }
  function posAtCoords(view2, coords, precise, bias = -1) {
    var _a2, _b;
    let content2 = view2.contentDOM.getBoundingClientRect(), docTop = content2.top + view2.viewState.paddingTop;
    let block, { docHeight } = view2.viewState;
    let { x: x2, y: y2 } = coords, yOffset = y2 - docTop;
    if (yOffset < 0)
      return 0;
    if (yOffset > docHeight)
      return view2.state.doc.length;
    for (let halfLine = view2.viewState.heightOracle.textHeight / 2, bounced = false; ; ) {
      block = view2.elementAtHeight(yOffset);
      if (block.type == BlockType.Text)
        break;
      for (; ; ) {
        yOffset = bias > 0 ? block.bottom + halfLine : block.top - halfLine;
        if (yOffset >= 0 && yOffset <= docHeight)
          break;
        if (bounced)
          return precise ? null : 0;
        bounced = true;
        bias = -bias;
      }
    }
    y2 = docTop + yOffset;
    let lineStart = block.from;
    if (lineStart < view2.viewport.from)
      return view2.viewport.from == 0 ? 0 : precise ? null : posAtCoordsImprecise(view2, content2, block, x2, y2);
    if (lineStart > view2.viewport.to)
      return view2.viewport.to == view2.state.doc.length ? view2.state.doc.length : precise ? null : posAtCoordsImprecise(view2, content2, block, x2, y2);
    let doc2 = view2.dom.ownerDocument;
    let root2 = view2.root.elementFromPoint ? view2.root : doc2;
    let element = root2.elementFromPoint(x2, y2);
    if (element && !view2.contentDOM.contains(element))
      element = null;
    if (!element) {
      x2 = Math.max(content2.left + 1, Math.min(content2.right - 1, x2));
      element = root2.elementFromPoint(x2, y2);
      if (element && !view2.contentDOM.contains(element))
        element = null;
    }
    let node2, offset = -1;
    if (element && ((_a2 = view2.docView.nearest(element)) === null || _a2 === void 0 ? void 0 : _a2.isEditable) != false) {
      if (doc2.caretPositionFromPoint) {
        let pos = doc2.caretPositionFromPoint(x2, y2);
        if (pos)
          ({ offsetNode: node2, offset } = pos);
      } else if (doc2.caretRangeFromPoint) {
        let range4 = doc2.caretRangeFromPoint(x2, y2);
        if (range4) {
          ({ startContainer: node2, startOffset: offset } = range4);
          if (!view2.contentDOM.contains(node2) || browser.safari && isSuspiciousSafariCaretResult(node2, offset, x2) || browser.chrome && isSuspiciousChromeCaretResult(node2, offset, x2))
            node2 = void 0;
        }
      }
    }
    if (!node2 || !view2.docView.dom.contains(node2)) {
      let line2 = LineView.find(view2.docView, lineStart);
      if (!line2)
        return yOffset > block.top + block.height / 2 ? block.to : block.from;
      ({ node: node2, offset } = domPosAtCoords(line2.dom, x2, y2));
    }
    let nearest = view2.docView.nearest(node2);
    if (!nearest)
      return null;
    if (nearest.isWidget && ((_b = nearest.dom) === null || _b === void 0 ? void 0 : _b.nodeType) == 1) {
      let rect = nearest.dom.getBoundingClientRect();
      return coords.y < rect.top || coords.y <= rect.bottom && coords.x <= (rect.left + rect.right) / 2 ? nearest.posAtStart : nearest.posAtEnd;
    } else {
      return nearest.localPosFromDOM(node2, offset) + nearest.posAtStart;
    }
  }
  function posAtCoordsImprecise(view2, contentRect, block, x2, y2) {
    let into = Math.round((x2 - contentRect.left) * view2.defaultCharacterWidth);
    if (view2.lineWrapping && block.height > view2.defaultLineHeight * 1.5) {
      let textHeight = view2.viewState.heightOracle.textHeight;
      let line2 = Math.floor((y2 - block.top - (view2.defaultLineHeight - textHeight) * 0.5) / textHeight);
      into += line2 * view2.viewState.heightOracle.lineLength;
    }
    let content2 = view2.state.sliceDoc(block.from, block.to);
    return block.from + findColumn(content2, into, view2.state.tabSize);
  }
  function isSuspiciousSafariCaretResult(node2, offset, x2) {
    let len;
    if (node2.nodeType != 3 || offset != (len = node2.nodeValue.length))
      return false;
    for (let next = node2.nextSibling; next; next = next.nextSibling)
      if (next.nodeType != 1 || next.nodeName != "BR")
        return false;
    return textRange(node2, len - 1, len).getBoundingClientRect().left > x2;
  }
  function isSuspiciousChromeCaretResult(node2, offset, x2) {
    if (offset != 0)
      return false;
    for (let cur = node2; ; ) {
      let parent = cur.parentNode;
      if (!parent || parent.nodeType != 1 || parent.firstChild != cur)
        return false;
      if (parent.classList.contains("cm-line"))
        break;
      cur = parent;
    }
    let rect = node2.nodeType == 1 ? node2.getBoundingClientRect() : textRange(node2, 0, Math.max(node2.nodeValue.length, 1)).getBoundingClientRect();
    return x2 - rect.left > 5;
  }
  function blockAt(view2, pos) {
    let line2 = view2.lineBlockAt(pos);
    if (Array.isArray(line2.type))
      for (let l of line2.type) {
        if (l.to > pos || l.to == pos && (l.to == line2.to || l.type == BlockType.Text))
          return l;
      }
    return line2;
  }
  function moveToLineBoundary(view2, start2, forward, includeWrap) {
    let line2 = blockAt(view2, start2.head);
    let coords = !includeWrap || line2.type != BlockType.Text || !(view2.lineWrapping || line2.widgetLineBreaks) ? null : view2.coordsAtPos(start2.assoc < 0 && start2.head > line2.from ? start2.head - 1 : start2.head);
    if (coords) {
      let editorRect = view2.dom.getBoundingClientRect();
      let direction = view2.textDirectionAt(line2.from);
      let pos = view2.posAtCoords({
        x: forward == (direction == Direction.LTR) ? editorRect.right - 1 : editorRect.left + 1,
        y: (coords.top + coords.bottom) / 2
      });
      if (pos != null)
        return EditorSelection.cursor(pos, forward ? -1 : 1);
    }
    return EditorSelection.cursor(forward ? line2.to : line2.from, forward ? -1 : 1);
  }
  function moveByChar(view2, start2, forward, by) {
    let line2 = view2.state.doc.lineAt(start2.head), spans = view2.bidiSpans(line2);
    let direction = view2.textDirectionAt(line2.from);
    for (let cur = start2, check2 = null; ; ) {
      let next = moveVisually(line2, spans, direction, cur, forward), char2 = movedOver;
      if (!next) {
        if (line2.number == (forward ? view2.state.doc.lines : 1))
          return cur;
        char2 = "\n";
        line2 = view2.state.doc.line(line2.number + (forward ? 1 : -1));
        spans = view2.bidiSpans(line2);
        next = view2.visualLineSide(line2, !forward);
      }
      if (!check2) {
        if (!by)
          return next;
        check2 = by(char2);
      } else if (!check2(char2)) {
        return cur;
      }
      cur = next;
    }
  }
  function byGroup(view2, pos, start2) {
    let categorize = view2.state.charCategorizer(pos);
    let cat = categorize(start2);
    return (next) => {
      let nextCat = categorize(next);
      if (cat == CharCategory.Space)
        cat = nextCat;
      return cat == nextCat;
    };
  }
  function moveVertically(view2, start2, forward, distance) {
    let startPos = start2.head, dir = forward ? 1 : -1;
    if (startPos == (forward ? view2.state.doc.length : 0))
      return EditorSelection.cursor(startPos, start2.assoc);
    let goal = start2.goalColumn, startY;
    let rect = view2.contentDOM.getBoundingClientRect();
    let startCoords = view2.coordsAtPos(startPos, start2.assoc || -1), docTop = view2.documentTop;
    if (startCoords) {
      if (goal == null)
        goal = startCoords.left - rect.left;
      startY = dir < 0 ? startCoords.top : startCoords.bottom;
    } else {
      let line2 = view2.viewState.lineBlockAt(startPos);
      if (goal == null)
        goal = Math.min(rect.right - rect.left, view2.defaultCharacterWidth * (startPos - line2.from));
      startY = (dir < 0 ? line2.top : line2.bottom) + docTop;
    }
    let resolvedGoal = rect.left + goal;
    let dist2 = distance !== null && distance !== void 0 ? distance : view2.viewState.heightOracle.textHeight >> 1;
    for (let extra = 0; ; extra += 10) {
      let curY = startY + (dist2 + extra) * dir;
      let pos = posAtCoords(view2, { x: resolvedGoal, y: curY }, false, dir);
      if (curY < rect.top || curY > rect.bottom || (dir < 0 ? pos < startPos : pos > startPos)) {
        let charRect = view2.docView.coordsForChar(pos);
        let assoc = !charRect || curY < charRect.top ? -1 : 1;
        return EditorSelection.cursor(pos, assoc, void 0, goal);
      }
    }
  }
  function skipAtomicRanges(atoms, pos, bias) {
    for (; ; ) {
      let moved = 0;
      for (let set3 of atoms) {
        set3.between(pos - 1, pos + 1, (from, to, value) => {
          if (pos > from && pos < to) {
            let side = moved || bias || (pos - from < to - pos ? -1 : 1);
            pos = side < 0 ? from : to;
            moved = side;
          }
        });
      }
      if (!moved)
        return pos;
    }
  }
  function skipAtoms(view2, oldPos, pos) {
    let newPos = skipAtomicRanges(view2.state.facet(atomicRanges).map((f) => f(view2)), pos.from, oldPos.head > pos.from ? -1 : 1);
    return newPos == pos.from ? pos : EditorSelection.cursor(newPos, newPos < pos.from ? 1 : -1);
  }
  var LineBreakPlaceholder = "\uFFFF";
  var DOMReader = class {
    constructor(points, state) {
      this.points = points;
      this.text = "";
      this.lineSeparator = state.facet(EditorState.lineSeparator);
    }
    append(text2) {
      this.text += text2;
    }
    lineBreak() {
      this.text += LineBreakPlaceholder;
    }
    readRange(start2, end) {
      if (!start2)
        return this;
      let parent = start2.parentNode;
      for (let cur = start2; ; ) {
        this.findPointBefore(parent, cur);
        let oldLen = this.text.length;
        this.readNode(cur);
        let next = cur.nextSibling;
        if (next == end)
          break;
        let view2 = ContentView.get(cur), nextView = ContentView.get(next);
        if (view2 && nextView ? view2.breakAfter : (view2 ? view2.breakAfter : isBlockElement(cur)) || isBlockElement(next) && (cur.nodeName != "BR" || cur.cmIgnore) && this.text.length > oldLen)
          this.lineBreak();
        cur = next;
      }
      this.findPointBefore(parent, end);
      return this;
    }
    readTextNode(node2) {
      let text2 = node2.nodeValue;
      for (let point2 of this.points)
        if (point2.node == node2)
          point2.pos = this.text.length + Math.min(point2.offset, text2.length);
      for (let off = 0, re2 = this.lineSeparator ? null : /\r\n?|\n/g; ; ) {
        let nextBreak = -1, breakSize = 1, m;
        if (this.lineSeparator) {
          nextBreak = text2.indexOf(this.lineSeparator, off);
          breakSize = this.lineSeparator.length;
        } else if (m = re2.exec(text2)) {
          nextBreak = m.index;
          breakSize = m[0].length;
        }
        this.append(text2.slice(off, nextBreak < 0 ? text2.length : nextBreak));
        if (nextBreak < 0)
          break;
        this.lineBreak();
        if (breakSize > 1) {
          for (let point2 of this.points)
            if (point2.node == node2 && point2.pos > this.text.length)
              point2.pos -= breakSize - 1;
        }
        off = nextBreak + breakSize;
      }
    }
    readNode(node2) {
      if (node2.cmIgnore)
        return;
      let view2 = ContentView.get(node2);
      let fromView = view2 && view2.overrideDOMText;
      if (fromView != null) {
        this.findPointInside(node2, fromView.length);
        for (let i = fromView.iter(); !i.next().done; ) {
          if (i.lineBreak)
            this.lineBreak();
          else
            this.append(i.value);
        }
      } else if (node2.nodeType == 3) {
        this.readTextNode(node2);
      } else if (node2.nodeName == "BR") {
        if (node2.nextSibling)
          this.lineBreak();
      } else if (node2.nodeType == 1) {
        this.readRange(node2.firstChild, null);
      }
    }
    findPointBefore(node2, next) {
      for (let point2 of this.points)
        if (point2.node == node2 && node2.childNodes[point2.offset] == next)
          point2.pos = this.text.length;
    }
    findPointInside(node2, length6) {
      for (let point2 of this.points)
        if (node2.nodeType == 3 ? point2.node == node2 : node2.contains(point2.node))
          point2.pos = this.text.length + (isAtEnd(node2, point2.node, point2.offset) ? length6 : 0);
    }
  };
  function isAtEnd(parent, node2, offset) {
    for (; ; ) {
      if (!node2 || offset < maxOffset(node2))
        return false;
      if (node2 == parent)
        return true;
      offset = domIndex(node2) + 1;
      node2 = node2.parentNode;
    }
  }
  var DOMPoint = class {
    constructor(node2, offset) {
      this.node = node2;
      this.offset = offset;
      this.pos = -1;
    }
  };
  var DOMChange = class {
    constructor(view2, start2, end, typeOver) {
      this.typeOver = typeOver;
      this.bounds = null;
      this.text = "";
      this.domChanged = start2 > -1;
      let { impreciseHead: iHead, impreciseAnchor: iAnchor } = view2.docView;
      if (view2.state.readOnly && start2 > -1) {
        this.newSel = null;
      } else if (start2 > -1 && (this.bounds = view2.docView.domBoundsAround(start2, end, 0))) {
        let selPoints = iHead || iAnchor ? [] : selectionPoints(view2);
        let reader = new DOMReader(selPoints, view2.state);
        reader.readRange(this.bounds.startDOM, this.bounds.endDOM);
        this.text = reader.text;
        this.newSel = selectionFromPoints(selPoints, this.bounds.from);
      } else {
        let domSel = view2.observer.selectionRange;
        let head = iHead && iHead.node == domSel.focusNode && iHead.offset == domSel.focusOffset || !contains(view2.contentDOM, domSel.focusNode) ? view2.state.selection.main.head : view2.docView.posFromDOM(domSel.focusNode, domSel.focusOffset);
        let anchor = iAnchor && iAnchor.node == domSel.anchorNode && iAnchor.offset == domSel.anchorOffset || !contains(view2.contentDOM, domSel.anchorNode) ? view2.state.selection.main.anchor : view2.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset);
        let vp = view2.viewport;
        if ((browser.ios || browser.chrome) && view2.state.selection.main.empty && head != anchor && (vp.from > 0 || vp.to < view2.state.doc.length)) {
          let from = Math.min(head, anchor), to = Math.max(head, anchor);
          let offFrom = vp.from - from, offTo = vp.to - to;
          if ((offFrom == 0 || offFrom == 1 || from == 0) && (offTo == 0 || offTo == -1 || to == view2.state.doc.length)) {
            head = 0;
            anchor = view2.state.doc.length;
          }
        }
        this.newSel = EditorSelection.single(anchor, head);
      }
    }
  };
  function applyDOMChange(view2, domChange) {
    let change;
    let { newSel } = domChange, sel = view2.state.selection.main;
    let lastKey = view2.inputState.lastKeyTime > Date.now() - 100 ? view2.inputState.lastKeyCode : -1;
    if (domChange.bounds) {
      let { from, to } = domChange.bounds;
      let preferredPos = sel.from, preferredSide = null;
      if (lastKey === 8 || browser.android && domChange.text.length < to - from) {
        preferredPos = sel.to;
        preferredSide = "end";
      }
      let diff = findDiff(view2.state.doc.sliceString(from, to, LineBreakPlaceholder), domChange.text, preferredPos - from, preferredSide);
      if (diff) {
        if (browser.chrome && lastKey == 13 && diff.toB == diff.from + 2 && domChange.text.slice(diff.from, diff.toB) == LineBreakPlaceholder + LineBreakPlaceholder)
          diff.toB--;
        change = {
          from: from + diff.from,
          to: from + diff.toA,
          insert: Text.of(domChange.text.slice(diff.from, diff.toB).split(LineBreakPlaceholder))
        };
      }
    } else if (newSel && (!view2.hasFocus && view2.state.facet(editable) || newSel.main.eq(sel))) {
      newSel = null;
    }
    if (!change && !newSel)
      return false;
    if (!change && domChange.typeOver && !sel.empty && newSel && newSel.main.empty) {
      change = { from: sel.from, to: sel.to, insert: view2.state.doc.slice(sel.from, sel.to) };
    } else if (change && change.from >= sel.from && change.to <= sel.to && (change.from != sel.from || change.to != sel.to) && sel.to - sel.from - (change.to - change.from) <= 4) {
      change = {
        from: sel.from,
        to: sel.to,
        insert: view2.state.doc.slice(sel.from, change.from).append(change.insert).append(view2.state.doc.slice(change.to, sel.to))
      };
    } else if ((browser.mac || browser.android) && change && change.from == change.to && change.from == sel.head - 1 && /^\. ?$/.test(change.insert.toString()) && view2.contentDOM.getAttribute("autocorrect") == "off") {
      if (newSel && change.insert.length == 2)
        newSel = EditorSelection.single(newSel.main.anchor - 1, newSel.main.head - 1);
      change = { from: sel.from, to: sel.to, insert: Text.of([" "]) };
    } else if (browser.chrome && change && change.from == change.to && change.from == sel.head && change.insert.toString() == "\n " && view2.lineWrapping) {
      if (newSel)
        newSel = EditorSelection.single(newSel.main.anchor - 1, newSel.main.head - 1);
      change = { from: sel.from, to: sel.to, insert: Text.of([" "]) };
    }
    if (change) {
      return applyDOMChangeInner(view2, change, newSel, lastKey);
    } else if (newSel && !newSel.main.eq(sel)) {
      let scrollIntoView2 = false, userEvent = "select";
      if (view2.inputState.lastSelectionTime > Date.now() - 50) {
        if (view2.inputState.lastSelectionOrigin == "select")
          scrollIntoView2 = true;
        userEvent = view2.inputState.lastSelectionOrigin;
      }
      view2.dispatch({ selection: newSel, scrollIntoView: scrollIntoView2, userEvent });
      return true;
    } else {
      return false;
    }
  }
  function applyDOMChangeInner(view2, change, newSel, lastKey = -1) {
    if (browser.ios && view2.inputState.flushIOSKey(change))
      return true;
    let sel = view2.state.selection.main;
    if (browser.android && (change.to == sel.to && (change.from == sel.from || change.from == sel.from - 1 && view2.state.sliceDoc(change.from, sel.from) == " ") && change.insert.length == 1 && change.insert.lines == 2 && dispatchKey(view2.contentDOM, "Enter", 13) || (change.from == sel.from - 1 && change.to == sel.to && change.insert.length == 0 || lastKey == 8 && change.insert.length < change.to - change.from && change.to > sel.head) && dispatchKey(view2.contentDOM, "Backspace", 8) || change.from == sel.from && change.to == sel.to + 1 && change.insert.length == 0 && dispatchKey(view2.contentDOM, "Delete", 46)))
      return true;
    let text2 = change.insert.toString();
    if (view2.inputState.composing >= 0)
      view2.inputState.composing++;
    let defaultTr;
    let defaultInsert = () => defaultTr || (defaultTr = applyDefaultInsert(view2, change, newSel));
    if (!view2.state.facet(inputHandler).some((h) => h(view2, change.from, change.to, text2, defaultInsert)))
      view2.dispatch(defaultInsert());
    return true;
  }
  function applyDefaultInsert(view2, change, newSel) {
    let tr, startState2 = view2.state, sel = startState2.selection.main;
    if (change.from >= sel.from && change.to <= sel.to && change.to - change.from >= (sel.to - sel.from) / 3 && (!newSel || newSel.main.empty && newSel.main.from == change.from + change.insert.length) && view2.inputState.composing < 0) {
      let before = sel.from < change.from ? startState2.sliceDoc(sel.from, change.from) : "";
      let after = sel.to > change.to ? startState2.sliceDoc(change.to, sel.to) : "";
      tr = startState2.replaceSelection(view2.state.toText(before + change.insert.sliceString(0, void 0, view2.state.lineBreak) + after));
    } else {
      let changes = startState2.changes(change);
      let mainSel = newSel && newSel.main.to <= changes.newLength ? newSel.main : void 0;
      if (startState2.selection.ranges.length > 1 && view2.inputState.composing >= 0 && change.to <= sel.to && change.to >= sel.to - 10) {
        let replaced = view2.state.sliceDoc(change.from, change.to);
        let compositionRange, composition = newSel && findCompositionNode(view2, newSel.main.head);
        if (composition) {
          let dLen = change.insert.length - (change.to - change.from);
          compositionRange = { from: composition.from, to: composition.to - dLen };
        } else {
          compositionRange = view2.state.doc.lineAt(sel.head);
        }
        let offset = sel.to - change.to, size3 = sel.to - sel.from;
        tr = startState2.changeByRange((range4) => {
          if (range4.from == sel.from && range4.to == sel.to)
            return { changes, range: mainSel || range4.map(changes) };
          let to = range4.to - offset, from = to - replaced.length;
          if (range4.to - range4.from != size3 || view2.state.sliceDoc(from, to) != replaced || range4.to >= compositionRange.from && range4.from <= compositionRange.to)
            return { range: range4 };
          let rangeChanges = startState2.changes({ from, to, insert: change.insert }), selOff = range4.to - sel.to;
          return {
            changes: rangeChanges,
            range: !mainSel ? range4.map(rangeChanges) : EditorSelection.range(Math.max(0, mainSel.anchor + selOff), Math.max(0, mainSel.head + selOff))
          };
        });
      } else {
        tr = {
          changes,
          selection: mainSel && startState2.selection.replaceRange(mainSel)
        };
      }
    }
    let userEvent = "input.type";
    if (view2.composing || view2.inputState.compositionPendingChange && view2.inputState.compositionEndedAt > Date.now() - 50) {
      view2.inputState.compositionPendingChange = false;
      userEvent += ".compose";
      if (view2.inputState.compositionFirstChange) {
        userEvent += ".start";
        view2.inputState.compositionFirstChange = false;
      }
    }
    return startState2.update(tr, { userEvent, scrollIntoView: true });
  }
  function findDiff(a, b, preferredPos, preferredSide) {
    let minLen = Math.min(a.length, b.length);
    let from = 0;
    while (from < minLen && a.charCodeAt(from) == b.charCodeAt(from))
      from++;
    if (from == minLen && a.length == b.length)
      return null;
    let toA = a.length, toB = b.length;
    while (toA > 0 && toB > 0 && a.charCodeAt(toA - 1) == b.charCodeAt(toB - 1)) {
      toA--;
      toB--;
    }
    if (preferredSide == "end") {
      let adjust = Math.max(0, from - Math.min(toA, toB));
      preferredPos -= toA + adjust - from;
    }
    if (toA < from && a.length < b.length) {
      let move = preferredPos <= from && preferredPos >= toA ? from - preferredPos : 0;
      from -= move;
      toB = from + (toB - toA);
      toA = from;
    } else if (toB < from) {
      let move = preferredPos <= from && preferredPos >= toB ? from - preferredPos : 0;
      from -= move;
      toA = from + (toA - toB);
      toB = from;
    }
    return { from, toA, toB };
  }
  function selectionPoints(view2) {
    let result = [];
    if (view2.root.activeElement != view2.contentDOM)
      return result;
    let { anchorNode, anchorOffset, focusNode, focusOffset } = view2.observer.selectionRange;
    if (anchorNode) {
      result.push(new DOMPoint(anchorNode, anchorOffset));
      if (focusNode != anchorNode || focusOffset != anchorOffset)
        result.push(new DOMPoint(focusNode, focusOffset));
    }
    return result;
  }
  function selectionFromPoints(points, base2) {
    if (points.length == 0)
      return null;
    let anchor = points[0].pos, head = points.length == 2 ? points[1].pos : anchor;
    return anchor > -1 && head > -1 ? EditorSelection.single(anchor + base2, head + base2) : null;
  }
  var InputState = class {
    setSelectionOrigin(origin) {
      this.lastSelectionOrigin = origin;
      this.lastSelectionTime = Date.now();
    }
    constructor(view2) {
      this.view = view2;
      this.lastKeyCode = 0;
      this.lastKeyTime = 0;
      this.lastTouchTime = 0;
      this.lastFocusTime = 0;
      this.lastScrollTop = 0;
      this.lastScrollLeft = 0;
      this.pendingIOSKey = void 0;
      this.tabFocusMode = -1;
      this.lastSelectionOrigin = null;
      this.lastSelectionTime = 0;
      this.lastContextMenu = 0;
      this.scrollHandlers = [];
      this.handlers = /* @__PURE__ */ Object.create(null);
      this.composing = -1;
      this.compositionFirstChange = null;
      this.compositionEndedAt = 0;
      this.compositionPendingKey = false;
      this.compositionPendingChange = false;
      this.mouseSelection = null;
      this.draggedContent = null;
      this.handleEvent = this.handleEvent.bind(this);
      this.notifiedFocused = view2.hasFocus;
      if (browser.safari)
        view2.contentDOM.addEventListener("input", () => null);
      if (browser.gecko)
        firefoxCopyCutHack(view2.contentDOM.ownerDocument);
    }
    handleEvent(event) {
      if (!eventBelongsToEditor(this.view, event) || this.ignoreDuringComposition(event))
        return;
      if (event.type == "keydown" && this.keydown(event))
        return;
      this.runHandlers(event.type, event);
    }
    runHandlers(type2, event) {
      let handlers2 = this.handlers[type2];
      if (handlers2) {
        for (let observer of handlers2.observers)
          observer(this.view, event);
        for (let handler of handlers2.handlers) {
          if (event.defaultPrevented)
            break;
          if (handler(this.view, event)) {
            event.preventDefault();
            break;
          }
        }
      }
    }
    ensureHandlers(plugins) {
      let handlers2 = computeHandlers(plugins), prev = this.handlers, dom = this.view.contentDOM;
      for (let type2 in handlers2)
        if (type2 != "scroll") {
          let passive = !handlers2[type2].handlers.length;
          let exists = prev[type2];
          if (exists && passive != !exists.handlers.length) {
            dom.removeEventListener(type2, this.handleEvent);
            exists = null;
          }
          if (!exists)
            dom.addEventListener(type2, this.handleEvent, { passive });
        }
      for (let type2 in prev)
        if (type2 != "scroll" && !handlers2[type2])
          dom.removeEventListener(type2, this.handleEvent);
      this.handlers = handlers2;
    }
    keydown(event) {
      this.lastKeyCode = event.keyCode;
      this.lastKeyTime = Date.now();
      if (event.keyCode == 9 && this.tabFocusMode > -1 && (!this.tabFocusMode || Date.now() <= this.tabFocusMode))
        return true;
      if (this.tabFocusMode > 0 && event.keyCode != 27 && modifierCodes.indexOf(event.keyCode) < 0)
        this.tabFocusMode = -1;
      if (browser.android && browser.chrome && !event.synthetic && (event.keyCode == 13 || event.keyCode == 8)) {
        this.view.observer.delayAndroidKey(event.key, event.keyCode);
        return true;
      }
      let pending;
      if (browser.ios && !event.synthetic && !event.altKey && !event.metaKey && ((pending = PendingKeys.find((key) => key.keyCode == event.keyCode)) && !event.ctrlKey || EmacsyPendingKeys.indexOf(event.key) > -1 && event.ctrlKey && !event.shiftKey)) {
        this.pendingIOSKey = pending || event;
        setTimeout(() => this.flushIOSKey(), 250);
        return true;
      }
      if (event.keyCode != 229)
        this.view.observer.forceFlush();
      return false;
    }
    flushIOSKey(change) {
      let key = this.pendingIOSKey;
      if (!key)
        return false;
      if (key.key == "Enter" && change && change.from < change.to && /^\S+$/.test(change.insert.toString()))
        return false;
      this.pendingIOSKey = void 0;
      return dispatchKey(this.view.contentDOM, key.key, key.keyCode, key instanceof KeyboardEvent ? key : void 0);
    }
    ignoreDuringComposition(event) {
      if (!/^key/.test(event.type))
        return false;
      if (this.composing > 0)
        return true;
      if (browser.safari && !browser.ios && this.compositionPendingKey && Date.now() - this.compositionEndedAt < 100) {
        this.compositionPendingKey = false;
        return true;
      }
      return false;
    }
    startMouseSelection(mouseSelection) {
      if (this.mouseSelection)
        this.mouseSelection.destroy();
      this.mouseSelection = mouseSelection;
    }
    update(update3) {
      this.view.observer.update(update3);
      if (this.mouseSelection)
        this.mouseSelection.update(update3);
      if (this.draggedContent && update3.docChanged)
        this.draggedContent = this.draggedContent.map(update3.changes);
      if (update3.transactions.length)
        this.lastKeyCode = this.lastSelectionTime = 0;
    }
    destroy() {
      if (this.mouseSelection)
        this.mouseSelection.destroy();
    }
  };
  function bindHandler(plugin, handler) {
    return (view2, event) => {
      try {
        return handler.call(plugin, event, view2);
      } catch (e) {
        logException(view2.state, e);
      }
    };
  }
  function computeHandlers(plugins) {
    let result = /* @__PURE__ */ Object.create(null);
    function record2(type2) {
      return result[type2] || (result[type2] = { observers: [], handlers: [] });
    }
    for (let plugin of plugins) {
      let spec = plugin.spec;
      if (spec && spec.domEventHandlers)
        for (let type2 in spec.domEventHandlers) {
          let f = spec.domEventHandlers[type2];
          if (f)
            record2(type2).handlers.push(bindHandler(plugin.value, f));
        }
      if (spec && spec.domEventObservers)
        for (let type2 in spec.domEventObservers) {
          let f = spec.domEventObservers[type2];
          if (f)
            record2(type2).observers.push(bindHandler(plugin.value, f));
        }
    }
    for (let type2 in handlers)
      record2(type2).handlers.push(handlers[type2]);
    for (let type2 in observers)
      record2(type2).observers.push(observers[type2]);
    return result;
  }
  var PendingKeys = [
    { key: "Backspace", keyCode: 8, inputType: "deleteContentBackward" },
    { key: "Enter", keyCode: 13, inputType: "insertParagraph" },
    { key: "Enter", keyCode: 13, inputType: "insertLineBreak" },
    { key: "Delete", keyCode: 46, inputType: "deleteContentForward" }
  ];
  var EmacsyPendingKeys = "dthko";
  var modifierCodes = [16, 17, 18, 20, 91, 92, 224, 225];
  var dragScrollMargin = 6;
  function dragScrollSpeed(dist2) {
    return Math.max(0, dist2) * 0.7 + 8;
  }
  function dist(a, b) {
    return Math.max(Math.abs(a.clientX - b.clientX), Math.abs(a.clientY - b.clientY));
  }
  var MouseSelection = class {
    constructor(view2, startEvent, style, mustSelect) {
      this.view = view2;
      this.startEvent = startEvent;
      this.style = style;
      this.mustSelect = mustSelect;
      this.scrollSpeed = { x: 0, y: 0 };
      this.scrolling = -1;
      this.lastEvent = startEvent;
      this.scrollParents = scrollableParents(view2.contentDOM);
      this.atoms = view2.state.facet(atomicRanges).map((f) => f(view2));
      let doc2 = view2.contentDOM.ownerDocument;
      doc2.addEventListener("mousemove", this.move = this.move.bind(this));
      doc2.addEventListener("mouseup", this.up = this.up.bind(this));
      this.extend = startEvent.shiftKey;
      this.multiple = view2.state.facet(EditorState.allowMultipleSelections) && addsSelectionRange(view2, startEvent);
      this.dragging = isInPrimarySelection(view2, startEvent) && getClickType(startEvent) == 1 ? null : false;
    }
    start(event) {
      if (this.dragging === false)
        this.select(event);
    }
    move(event) {
      if (event.buttons == 0)
        return this.destroy();
      if (this.dragging || this.dragging == null && dist(this.startEvent, event) < 10)
        return;
      this.select(this.lastEvent = event);
      let sx = 0, sy = 0;
      let left2 = 0, top3 = 0, right2 = this.view.win.innerWidth, bottom2 = this.view.win.innerHeight;
      if (this.scrollParents.x)
        ({ left: left2, right: right2 } = this.scrollParents.x.getBoundingClientRect());
      if (this.scrollParents.y)
        ({ top: top3, bottom: bottom2 } = this.scrollParents.y.getBoundingClientRect());
      let margins = getScrollMargins(this.view);
      if (event.clientX - margins.left <= left2 + dragScrollMargin)
        sx = -dragScrollSpeed(left2 - event.clientX);
      else if (event.clientX + margins.right >= right2 - dragScrollMargin)
        sx = dragScrollSpeed(event.clientX - right2);
      if (event.clientY - margins.top <= top3 + dragScrollMargin)
        sy = -dragScrollSpeed(top3 - event.clientY);
      else if (event.clientY + margins.bottom >= bottom2 - dragScrollMargin)
        sy = dragScrollSpeed(event.clientY - bottom2);
      this.setScrollSpeed(sx, sy);
    }
    up(event) {
      if (this.dragging == null)
        this.select(this.lastEvent);
      if (!this.dragging)
        event.preventDefault();
      this.destroy();
    }
    destroy() {
      this.setScrollSpeed(0, 0);
      let doc2 = this.view.contentDOM.ownerDocument;
      doc2.removeEventListener("mousemove", this.move);
      doc2.removeEventListener("mouseup", this.up);
      this.view.inputState.mouseSelection = this.view.inputState.draggedContent = null;
    }
    setScrollSpeed(sx, sy) {
      this.scrollSpeed = { x: sx, y: sy };
      if (sx || sy) {
        if (this.scrolling < 0)
          this.scrolling = setInterval(() => this.scroll(), 50);
      } else if (this.scrolling > -1) {
        clearInterval(this.scrolling);
        this.scrolling = -1;
      }
    }
    scroll() {
      let { x: x2, y: y2 } = this.scrollSpeed;
      if (x2 && this.scrollParents.x) {
        this.scrollParents.x.scrollLeft += x2;
        x2 = 0;
      }
      if (y2 && this.scrollParents.y) {
        this.scrollParents.y.scrollTop += y2;
        y2 = 0;
      }
      if (x2 || y2)
        this.view.win.scrollBy(x2, y2);
      if (this.dragging === false)
        this.select(this.lastEvent);
    }
    skipAtoms(sel) {
      let ranges = null;
      for (let i = 0; i < sel.ranges.length; i++) {
        let range4 = sel.ranges[i], updated = null;
        if (range4.empty) {
          let pos = skipAtomicRanges(this.atoms, range4.from, 0);
          if (pos != range4.from)
            updated = EditorSelection.cursor(pos, -1);
        } else {
          let from = skipAtomicRanges(this.atoms, range4.from, -1);
          let to = skipAtomicRanges(this.atoms, range4.to, 1);
          if (from != range4.from || to != range4.to)
            updated = EditorSelection.range(range4.from == range4.anchor ? from : to, range4.from == range4.head ? from : to);
        }
        if (updated) {
          if (!ranges)
            ranges = sel.ranges.slice();
          ranges[i] = updated;
        }
      }
      return ranges ? EditorSelection.create(ranges, sel.mainIndex) : sel;
    }
    select(event) {
      let { view: view2 } = this, selection2 = this.skipAtoms(this.style.get(event, this.extend, this.multiple));
      if (this.mustSelect || !selection2.eq(view2.state.selection, this.dragging === false))
        this.view.dispatch({
          selection: selection2,
          userEvent: "select.pointer"
        });
      this.mustSelect = false;
    }
    update(update3) {
      if (update3.transactions.some((tr) => tr.isUserEvent("input.type")))
        this.destroy();
      else if (this.style.update(update3))
        setTimeout(() => this.select(this.lastEvent), 20);
    }
  };
  function addsSelectionRange(view2, event) {
    let facet = view2.state.facet(clickAddsSelectionRange);
    return facet.length ? facet[0](event) : browser.mac ? event.metaKey : event.ctrlKey;
  }
  function dragMovesSelection(view2, event) {
    let facet = view2.state.facet(dragMovesSelection$1);
    return facet.length ? facet[0](event) : browser.mac ? !event.altKey : !event.ctrlKey;
  }
  function isInPrimarySelection(view2, event) {
    let { main: main2 } = view2.state.selection;
    if (main2.empty)
      return false;
    let sel = getSelection(view2.root);
    if (!sel || sel.rangeCount == 0)
      return true;
    let rects = sel.getRangeAt(0).getClientRects();
    for (let i = 0; i < rects.length; i++) {
      let rect = rects[i];
      if (rect.left <= event.clientX && rect.right >= event.clientX && rect.top <= event.clientY && rect.bottom >= event.clientY)
        return true;
    }
    return false;
  }
  function eventBelongsToEditor(view2, event) {
    if (!event.bubbles)
      return true;
    if (event.defaultPrevented)
      return false;
    for (let node2 = event.target, cView; node2 != view2.contentDOM; node2 = node2.parentNode)
      if (!node2 || node2.nodeType == 11 || (cView = ContentView.get(node2)) && cView.ignoreEvent(event))
        return false;
    return true;
  }
  var handlers = /* @__PURE__ */ Object.create(null);
  var observers = /* @__PURE__ */ Object.create(null);
  var brokenClipboardAPI = browser.ie && browser.ie_version < 15 || browser.ios && browser.webkit_version < 604;
  function capturePaste(view2) {
    let parent = view2.dom.parentNode;
    if (!parent)
      return;
    let target = parent.appendChild(document.createElement("textarea"));
    target.style.cssText = "position: fixed; left: -10000px; top: 10px";
    target.focus();
    setTimeout(() => {
      view2.focus();
      target.remove();
      doPaste(view2, target.value);
    }, 50);
  }
  function doPaste(view2, input) {
    let { state } = view2, changes, i = 1, text2 = state.toText(input);
    let byLine = text2.lines == state.selection.ranges.length;
    let linewise = lastLinewiseCopy != null && state.selection.ranges.every((r) => r.empty) && lastLinewiseCopy == text2.toString();
    if (linewise) {
      let lastLine = -1;
      changes = state.changeByRange((range4) => {
        let line2 = state.doc.lineAt(range4.from);
        if (line2.from == lastLine)
          return { range: range4 };
        lastLine = line2.from;
        let insert4 = state.toText((byLine ? text2.line(i++).text : input) + state.lineBreak);
        return {
          changes: { from: line2.from, insert: insert4 },
          range: EditorSelection.cursor(range4.from + insert4.length)
        };
      });
    } else if (byLine) {
      changes = state.changeByRange((range4) => {
        let line2 = text2.line(i++);
        return {
          changes: { from: range4.from, to: range4.to, insert: line2.text },
          range: EditorSelection.cursor(range4.from + line2.length)
        };
      });
    } else {
      changes = state.replaceSelection(text2);
    }
    view2.dispatch(changes, {
      userEvent: "input.paste",
      scrollIntoView: true
    });
  }
  observers.scroll = (view2) => {
    view2.inputState.lastScrollTop = view2.scrollDOM.scrollTop;
    view2.inputState.lastScrollLeft = view2.scrollDOM.scrollLeft;
  };
  handlers.keydown = (view2, event) => {
    view2.inputState.setSelectionOrigin("select");
    if (event.keyCode == 27 && view2.inputState.tabFocusMode != 0)
      view2.inputState.tabFocusMode = Date.now() + 2e3;
    return false;
  };
  observers.touchstart = (view2, e) => {
    view2.inputState.lastTouchTime = Date.now();
    view2.inputState.setSelectionOrigin("select.pointer");
  };
  observers.touchmove = (view2) => {
    view2.inputState.setSelectionOrigin("select.pointer");
  };
  handlers.mousedown = (view2, event) => {
    view2.observer.flush();
    if (view2.inputState.lastTouchTime > Date.now() - 2e3)
      return false;
    let style = null;
    for (let makeStyle of view2.state.facet(mouseSelectionStyle)) {
      style = makeStyle(view2, event);
      if (style)
        break;
    }
    if (!style && event.button == 0)
      style = basicMouseSelection(view2, event);
    if (style) {
      let mustFocus = !view2.hasFocus;
      view2.inputState.startMouseSelection(new MouseSelection(view2, event, style, mustFocus));
      if (mustFocus)
        view2.observer.ignore(() => {
          focusPreventScroll(view2.contentDOM);
          let active = view2.root.activeElement;
          if (active && !active.contains(view2.contentDOM))
            active.blur();
        });
      let mouseSel = view2.inputState.mouseSelection;
      if (mouseSel) {
        mouseSel.start(event);
        return mouseSel.dragging === false;
      }
    }
    return false;
  };
  function rangeForClick(view2, pos, bias, type2) {
    if (type2 == 1) {
      return EditorSelection.cursor(pos, bias);
    } else if (type2 == 2) {
      return groupAt(view2.state, pos, bias);
    } else {
      let visual = LineView.find(view2.docView, pos), line2 = view2.state.doc.lineAt(visual ? visual.posAtEnd : pos);
      let from = visual ? visual.posAtStart : line2.from, to = visual ? visual.posAtEnd : line2.to;
      if (to < view2.state.doc.length && to == line2.to)
        to++;
      return EditorSelection.range(from, to);
    }
  }
  var inside = (x2, y2, rect) => y2 >= rect.top && y2 <= rect.bottom && x2 >= rect.left && x2 <= rect.right;
  function findPositionSide(view2, pos, x2, y2) {
    let line2 = LineView.find(view2.docView, pos);
    if (!line2)
      return 1;
    let off = pos - line2.posAtStart;
    if (off == 0)
      return 1;
    if (off == line2.length)
      return -1;
    let before = line2.coordsAt(off, -1);
    if (before && inside(x2, y2, before))
      return -1;
    let after = line2.coordsAt(off, 1);
    if (after && inside(x2, y2, after))
      return 1;
    return before && before.bottom >= y2 ? -1 : 1;
  }
  function queryPos(view2, event) {
    let pos = view2.posAtCoords({ x: event.clientX, y: event.clientY }, false);
    return { pos, bias: findPositionSide(view2, pos, event.clientX, event.clientY) };
  }
  var BadMouseDetail = browser.ie && browser.ie_version <= 11;
  var lastMouseDown = null;
  var lastMouseDownCount = 0;
  var lastMouseDownTime = 0;
  function getClickType(event) {
    if (!BadMouseDetail)
      return event.detail;
    let last3 = lastMouseDown, lastTime = lastMouseDownTime;
    lastMouseDown = event;
    lastMouseDownTime = Date.now();
    return lastMouseDownCount = !last3 || lastTime > Date.now() - 400 && Math.abs(last3.clientX - event.clientX) < 2 && Math.abs(last3.clientY - event.clientY) < 2 ? (lastMouseDownCount + 1) % 3 : 1;
  }
  function basicMouseSelection(view2, event) {
    let start2 = queryPos(view2, event), type2 = getClickType(event);
    let startSel = view2.state.selection;
    return {
      update(update3) {
        if (update3.docChanged) {
          start2.pos = update3.changes.mapPos(start2.pos);
          startSel = startSel.map(update3.changes);
        }
      },
      get(event2, extend4, multiple) {
        let cur = queryPos(view2, event2), removed;
        let range4 = rangeForClick(view2, cur.pos, cur.bias, type2);
        if (start2.pos != cur.pos && !extend4) {
          let startRange = rangeForClick(view2, start2.pos, start2.bias, type2);
          let from = Math.min(startRange.from, range4.from), to = Math.max(startRange.to, range4.to);
          range4 = from < range4.from ? EditorSelection.range(from, to) : EditorSelection.range(to, from);
        }
        if (extend4)
          return startSel.replaceRange(startSel.main.extend(range4.from, range4.to));
        else if (multiple && type2 == 1 && startSel.ranges.length > 1 && (removed = removeRangeAround(startSel, cur.pos)))
          return removed;
        else if (multiple)
          return startSel.addRange(range4);
        else
          return EditorSelection.create([range4]);
      }
    };
  }
  function removeRangeAround(sel, pos) {
    for (let i = 0; i < sel.ranges.length; i++) {
      let { from, to } = sel.ranges[i];
      if (from <= pos && to >= pos)
        return EditorSelection.create(sel.ranges.slice(0, i).concat(sel.ranges.slice(i + 1)), sel.mainIndex == i ? 0 : sel.mainIndex - (sel.mainIndex > i ? 1 : 0));
    }
    return null;
  }
  handlers.dragstart = (view2, event) => {
    let { selection: { main: range4 } } = view2.state;
    if (event.target.draggable) {
      let cView = view2.docView.nearest(event.target);
      if (cView && cView.isWidget) {
        let from = cView.posAtStart, to = from + cView.length;
        if (from >= range4.to || to <= range4.from)
          range4 = EditorSelection.range(from, to);
      }
    }
    let { inputState } = view2;
    if (inputState.mouseSelection)
      inputState.mouseSelection.dragging = true;
    inputState.draggedContent = range4;
    if (event.dataTransfer) {
      event.dataTransfer.setData("Text", view2.state.sliceDoc(range4.from, range4.to));
      event.dataTransfer.effectAllowed = "copyMove";
    }
    return false;
  };
  handlers.dragend = (view2) => {
    view2.inputState.draggedContent = null;
    return false;
  };
  function dropText(view2, event, text2, direct) {
    if (!text2)
      return;
    let dropPos = view2.posAtCoords({ x: event.clientX, y: event.clientY }, false);
    let { draggedContent } = view2.inputState;
    let del = direct && draggedContent && dragMovesSelection(view2, event) ? { from: draggedContent.from, to: draggedContent.to } : null;
    let ins = { from: dropPos, insert: text2 };
    let changes = view2.state.changes(del ? [del, ins] : ins);
    view2.focus();
    view2.dispatch({
      changes,
      selection: { anchor: changes.mapPos(dropPos, -1), head: changes.mapPos(dropPos, 1) },
      userEvent: del ? "move.drop" : "input.drop"
    });
    view2.inputState.draggedContent = null;
  }
  handlers.drop = (view2, event) => {
    if (!event.dataTransfer)
      return false;
    if (view2.state.readOnly)
      return true;
    let files = event.dataTransfer.files;
    if (files && files.length) {
      let text2 = Array(files.length), read2 = 0;
      let finishFile = () => {
        if (++read2 == files.length)
          dropText(view2, event, text2.filter((s) => s != null).join(view2.state.lineBreak), false);
      };
      for (let i = 0; i < files.length; i++) {
        let reader = new FileReader();
        reader.onerror = finishFile;
        reader.onload = () => {
          if (!/[\x00-\x08\x0e-\x1f]{2}/.test(reader.result))
            text2[i] = reader.result;
          finishFile();
        };
        reader.readAsText(files[i]);
      }
      return true;
    } else {
      let text2 = event.dataTransfer.getData("Text");
      if (text2) {
        dropText(view2, event, text2, true);
        return true;
      }
    }
    return false;
  };
  handlers.paste = (view2, event) => {
    if (view2.state.readOnly)
      return true;
    view2.observer.flush();
    let data = brokenClipboardAPI ? null : event.clipboardData;
    if (data) {
      doPaste(view2, data.getData("text/plain") || data.getData("text/uri-list"));
      return true;
    } else {
      capturePaste(view2);
      return false;
    }
  };
  function captureCopy(view2, text2) {
    let parent = view2.dom.parentNode;
    if (!parent)
      return;
    let target = parent.appendChild(document.createElement("textarea"));
    target.style.cssText = "position: fixed; left: -10000px; top: 10px";
    target.value = text2;
    target.focus();
    target.selectionEnd = text2.length;
    target.selectionStart = 0;
    setTimeout(() => {
      target.remove();
      view2.focus();
    }, 50);
  }
  function copiedRange(state) {
    let content2 = [], ranges = [], linewise = false;
    for (let range4 of state.selection.ranges)
      if (!range4.empty) {
        content2.push(state.sliceDoc(range4.from, range4.to));
        ranges.push(range4);
      }
    if (!content2.length) {
      let upto = -1;
      for (let { from } of state.selection.ranges) {
        let line2 = state.doc.lineAt(from);
        if (line2.number > upto) {
          content2.push(line2.text);
          ranges.push({ from: line2.from, to: Math.min(state.doc.length, line2.to + 1) });
        }
        upto = line2.number;
      }
      linewise = true;
    }
    return { text: content2.join(state.lineBreak), ranges, linewise };
  }
  var lastLinewiseCopy = null;
  handlers.copy = handlers.cut = (view2, event) => {
    let { text: text2, ranges, linewise } = copiedRange(view2.state);
    if (!text2 && !linewise)
      return false;
    lastLinewiseCopy = linewise ? text2 : null;
    if (event.type == "cut" && !view2.state.readOnly)
      view2.dispatch({
        changes: ranges,
        scrollIntoView: true,
        userEvent: "delete.cut"
      });
    let data = brokenClipboardAPI ? null : event.clipboardData;
    if (data) {
      data.clearData();
      data.setData("text/plain", text2);
      return true;
    } else {
      captureCopy(view2, text2);
      return false;
    }
  };
  var isFocusChange = /* @__PURE__ */ Annotation.define();
  function focusChangeTransaction(state, focus) {
    let effects = [];
    for (let getEffect of state.facet(focusChangeEffect)) {
      let effect = getEffect(state, focus);
      if (effect)
        effects.push(effect);
    }
    return effects ? state.update({ effects, annotations: isFocusChange.of(true) }) : null;
  }
  function updateForFocusChange(view2) {
    setTimeout(() => {
      let focus = view2.hasFocus;
      if (focus != view2.inputState.notifiedFocused) {
        let tr = focusChangeTransaction(view2.state, focus);
        if (tr)
          view2.dispatch(tr);
        else
          view2.update([]);
      }
    }, 10);
  }
  observers.focus = (view2) => {
    view2.inputState.lastFocusTime = Date.now();
    if (!view2.scrollDOM.scrollTop && (view2.inputState.lastScrollTop || view2.inputState.lastScrollLeft)) {
      view2.scrollDOM.scrollTop = view2.inputState.lastScrollTop;
      view2.scrollDOM.scrollLeft = view2.inputState.lastScrollLeft;
    }
    updateForFocusChange(view2);
  };
  observers.blur = (view2) => {
    view2.observer.clearSelectionRange();
    updateForFocusChange(view2);
  };
  observers.compositionstart = observers.compositionupdate = (view2) => {
    if (view2.observer.editContext)
      return;
    if (view2.inputState.compositionFirstChange == null)
      view2.inputState.compositionFirstChange = true;
    if (view2.inputState.composing < 0) {
      view2.inputState.composing = 0;
    }
  };
  observers.compositionend = (view2) => {
    if (view2.observer.editContext)
      return;
    view2.inputState.composing = -1;
    view2.inputState.compositionEndedAt = Date.now();
    view2.inputState.compositionPendingKey = true;
    view2.inputState.compositionPendingChange = view2.observer.pendingRecords().length > 0;
    view2.inputState.compositionFirstChange = null;
    if (browser.chrome && browser.android) {
      view2.observer.flushSoon();
    } else if (view2.inputState.compositionPendingChange) {
      Promise.resolve().then(() => view2.observer.flush());
    } else {
      setTimeout(() => {
        if (view2.inputState.composing < 0 && view2.docView.hasComposition)
          view2.update([]);
      }, 50);
    }
  };
  observers.contextmenu = (view2) => {
    view2.inputState.lastContextMenu = Date.now();
  };
  handlers.beforeinput = (view2, event) => {
    var _a2, _b;
    if (event.inputType == "insertReplacementText" && view2.observer.editContext) {
      let text2 = (_a2 = event.dataTransfer) === null || _a2 === void 0 ? void 0 : _a2.getData("text/plain"), ranges = event.getTargetRanges();
      if (text2 && ranges.length) {
        let r = ranges[0];
        let from = view2.posAtDOM(r.startContainer, r.startOffset), to = view2.posAtDOM(r.endContainer, r.endOffset);
        applyDOMChangeInner(view2, { from, to, insert: view2.state.toText(text2) }, null);
        return true;
      }
    }
    let pending;
    if (browser.chrome && browser.android && (pending = PendingKeys.find((key) => key.inputType == event.inputType))) {
      view2.observer.delayAndroidKey(pending.key, pending.keyCode);
      if (pending.key == "Backspace" || pending.key == "Delete") {
        let startViewHeight = ((_b = window.visualViewport) === null || _b === void 0 ? void 0 : _b.height) || 0;
        setTimeout(() => {
          var _a3;
          if ((((_a3 = window.visualViewport) === null || _a3 === void 0 ? void 0 : _a3.height) || 0) > startViewHeight + 10 && view2.hasFocus) {
            view2.contentDOM.blur();
            view2.focus();
          }
        }, 100);
      }
    }
    if (browser.ios && event.inputType == "deleteContentForward") {
      view2.observer.flushSoon();
    }
    if (browser.safari && event.inputType == "insertText" && view2.inputState.composing >= 0) {
      setTimeout(() => observers.compositionend(view2, event), 20);
    }
    return false;
  };
  var appliedFirefoxHack = /* @__PURE__ */ new Set();
  function firefoxCopyCutHack(doc2) {
    if (!appliedFirefoxHack.has(doc2)) {
      appliedFirefoxHack.add(doc2);
      doc2.addEventListener("copy", () => {
      });
      doc2.addEventListener("cut", () => {
      });
    }
  }
  var wrappingWhiteSpace = ["pre-wrap", "normal", "pre-line", "break-spaces"];
  var heightChangeFlag = false;
  function clearHeightChangeFlag() {
    heightChangeFlag = false;
  }
  var HeightOracle = class {
    constructor(lineWrapping) {
      this.lineWrapping = lineWrapping;
      this.doc = Text.empty;
      this.heightSamples = {};
      this.lineHeight = 14;
      this.charWidth = 7;
      this.textHeight = 14;
      this.lineLength = 30;
    }
    heightForGap(from, to) {
      let lines = this.doc.lineAt(to).number - this.doc.lineAt(from).number + 1;
      if (this.lineWrapping)
        lines += Math.max(0, Math.ceil((to - from - lines * this.lineLength * 0.5) / this.lineLength));
      return this.lineHeight * lines;
    }
    heightForLine(length6) {
      if (!this.lineWrapping)
        return this.lineHeight;
      let lines = 1 + Math.max(0, Math.ceil((length6 - this.lineLength) / (this.lineLength - 5)));
      return lines * this.lineHeight;
    }
    setDoc(doc2) {
      this.doc = doc2;
      return this;
    }
    mustRefreshForWrapping(whiteSpace) {
      return wrappingWhiteSpace.indexOf(whiteSpace) > -1 != this.lineWrapping;
    }
    mustRefreshForHeights(lineHeights) {
      let newHeight = false;
      for (let i = 0; i < lineHeights.length; i++) {
        let h = lineHeights[i];
        if (h < 0) {
          i++;
        } else if (!this.heightSamples[Math.floor(h * 10)]) {
          newHeight = true;
          this.heightSamples[Math.floor(h * 10)] = true;
        }
      }
      return newHeight;
    }
    refresh(whiteSpace, lineHeight, charWidth, textHeight, lineLength, knownHeights) {
      let lineWrapping = wrappingWhiteSpace.indexOf(whiteSpace) > -1;
      let changed = Math.round(lineHeight) != Math.round(this.lineHeight) || this.lineWrapping != lineWrapping;
      this.lineWrapping = lineWrapping;
      this.lineHeight = lineHeight;
      this.charWidth = charWidth;
      this.textHeight = textHeight;
      this.lineLength = lineLength;
      if (changed) {
        this.heightSamples = {};
        for (let i = 0; i < knownHeights.length; i++) {
          let h = knownHeights[i];
          if (h < 0)
            i++;
          else
            this.heightSamples[Math.floor(h * 10)] = true;
        }
      }
      return changed;
    }
  };
  var MeasuredHeights = class {
    constructor(from, heights) {
      this.from = from;
      this.heights = heights;
      this.index = 0;
    }
    get more() {
      return this.index < this.heights.length;
    }
  };
  var BlockInfo = class {
    constructor(from, length6, top3, height, _content) {
      this.from = from;
      this.length = length6;
      this.top = top3;
      this.height = height;
      this._content = _content;
    }
    get type() {
      return typeof this._content == "number" ? BlockType.Text : Array.isArray(this._content) ? this._content : this._content.type;
    }
    get to() {
      return this.from + this.length;
    }
    get bottom() {
      return this.top + this.height;
    }
    get widget() {
      return this._content instanceof PointDecoration ? this._content.widget : null;
    }
    get widgetLineBreaks() {
      return typeof this._content == "number" ? this._content : 0;
    }
    join(other) {
      let content2 = (Array.isArray(this._content) ? this._content : [this]).concat(Array.isArray(other._content) ? other._content : [other]);
      return new BlockInfo(this.from, this.length + other.length, this.top, this.height + other.height, content2);
    }
  };
  var QueryType = /* @__PURE__ */ function(QueryType2) {
    QueryType2[QueryType2["ByPos"] = 0] = "ByPos";
    QueryType2[QueryType2["ByHeight"] = 1] = "ByHeight";
    QueryType2[QueryType2["ByPosNoHeight"] = 2] = "ByPosNoHeight";
    return QueryType2;
  }(QueryType || (QueryType = {}));
  var Epsilon = 1e-3;
  var HeightMap = class {
    constructor(length6, height, flags = 2) {
      this.length = length6;
      this.height = height;
      this.flags = flags;
    }
    get outdated() {
      return (this.flags & 2) > 0;
    }
    set outdated(value) {
      this.flags = (value ? 2 : 0) | this.flags & ~2;
    }
    setHeight(height) {
      if (this.height != height) {
        if (Math.abs(this.height - height) > Epsilon)
          heightChangeFlag = true;
        this.height = height;
      }
    }
    replace(_from, _to, nodes) {
      return HeightMap.of(nodes);
    }
    decomposeLeft(_to, result) {
      result.push(this);
    }
    decomposeRight(_from, result) {
      result.push(this);
    }
    applyChanges(decorations2, oldDoc, oracle, changes) {
      let me = this, doc2 = oracle.doc;
      for (let i = changes.length - 1; i >= 0; i--) {
        let { fromA, toA, fromB, toB } = changes[i];
        let start2 = me.lineAt(fromA, QueryType.ByPosNoHeight, oracle.setDoc(oldDoc), 0, 0);
        let end = start2.to >= toA ? start2 : me.lineAt(toA, QueryType.ByPosNoHeight, oracle, 0, 0);
        toB += end.to - toA;
        toA = end.to;
        while (i > 0 && start2.from <= changes[i - 1].toA) {
          fromA = changes[i - 1].fromA;
          fromB = changes[i - 1].fromB;
          i--;
          if (fromA < start2.from)
            start2 = me.lineAt(fromA, QueryType.ByPosNoHeight, oracle, 0, 0);
        }
        fromB += start2.from - fromA;
        fromA = start2.from;
        let nodes = NodeBuilder.build(oracle.setDoc(doc2), decorations2, fromB, toB);
        me = replace(me, me.replace(fromA, toA, nodes));
      }
      return me.updateHeight(oracle, 0);
    }
    static empty() {
      return new HeightMapText(0, 0);
    }
    static of(nodes) {
      if (nodes.length == 1)
        return nodes[0];
      let i = 0, j = nodes.length, before = 0, after = 0;
      for (; ; ) {
        if (i == j) {
          if (before > after * 2) {
            let split3 = nodes[i - 1];
            if (split3.break)
              nodes.splice(--i, 1, split3.left, null, split3.right);
            else
              nodes.splice(--i, 1, split3.left, split3.right);
            j += 1 + split3.break;
            before -= split3.size;
          } else if (after > before * 2) {
            let split3 = nodes[j];
            if (split3.break)
              nodes.splice(j, 1, split3.left, null, split3.right);
            else
              nodes.splice(j, 1, split3.left, split3.right);
            j += 2 + split3.break;
            after -= split3.size;
          } else {
            break;
          }
        } else if (before < after) {
          let next = nodes[i++];
          if (next)
            before += next.size;
        } else {
          let next = nodes[--j];
          if (next)
            after += next.size;
        }
      }
      let brk = 0;
      if (nodes[i - 1] == null) {
        brk = 1;
        i--;
      } else if (nodes[i] == null) {
        brk = 1;
        j++;
      }
      return new HeightMapBranch(HeightMap.of(nodes.slice(0, i)), brk, HeightMap.of(nodes.slice(j)));
    }
  };
  function replace(old, val) {
    if (old == val)
      return old;
    if (old.constructor != val.constructor)
      heightChangeFlag = true;
    return val;
  }
  HeightMap.prototype.size = 1;
  var HeightMapBlock = class extends HeightMap {
    constructor(length6, height, deco) {
      super(length6, height);
      this.deco = deco;
    }
    blockAt(_height, _oracle, top3, offset) {
      return new BlockInfo(offset, this.length, top3, this.height, this.deco || 0);
    }
    lineAt(_value, _type, oracle, top3, offset) {
      return this.blockAt(0, oracle, top3, offset);
    }
    forEachLine(from, to, oracle, top3, offset, f) {
      if (from <= offset + this.length && to >= offset)
        f(this.blockAt(0, oracle, top3, offset));
    }
    updateHeight(oracle, offset = 0, _force = false, measured) {
      if (measured && measured.from <= offset && measured.more)
        this.setHeight(measured.heights[measured.index++]);
      this.outdated = false;
      return this;
    }
    toString() {
      return `block(${this.length})`;
    }
  };
  var HeightMapText = class extends HeightMapBlock {
    constructor(length6, height) {
      super(length6, height, null);
      this.collapsed = 0;
      this.widgetHeight = 0;
      this.breaks = 0;
    }
    blockAt(_height, _oracle, top3, offset) {
      return new BlockInfo(offset, this.length, top3, this.height, this.breaks);
    }
    replace(_from, _to, nodes) {
      let node2 = nodes[0];
      if (nodes.length == 1 && (node2 instanceof HeightMapText || node2 instanceof HeightMapGap && node2.flags & 4) && Math.abs(this.length - node2.length) < 10) {
        if (node2 instanceof HeightMapGap)
          node2 = new HeightMapText(node2.length, this.height);
        else
          node2.height = this.height;
        if (!this.outdated)
          node2.outdated = false;
        return node2;
      } else {
        return HeightMap.of(nodes);
      }
    }
    updateHeight(oracle, offset = 0, force2 = false, measured) {
      if (measured && measured.from <= offset && measured.more)
        this.setHeight(measured.heights[measured.index++]);
      else if (force2 || this.outdated)
        this.setHeight(Math.max(this.widgetHeight, oracle.heightForLine(this.length - this.collapsed)) + this.breaks * oracle.lineHeight);
      this.outdated = false;
      return this;
    }
    toString() {
      return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`;
    }
  };
  var HeightMapGap = class extends HeightMap {
    constructor(length6) {
      super(length6, 0);
    }
    heightMetrics(oracle, offset) {
      let firstLine = oracle.doc.lineAt(offset).number, lastLine = oracle.doc.lineAt(offset + this.length).number;
      let lines = lastLine - firstLine + 1;
      let perLine, perChar = 0;
      if (oracle.lineWrapping) {
        let totalPerLine = Math.min(this.height, oracle.lineHeight * lines);
        perLine = totalPerLine / lines;
        if (this.length > lines + 1)
          perChar = (this.height - totalPerLine) / (this.length - lines - 1);
      } else {
        perLine = this.height / lines;
      }
      return { firstLine, lastLine, perLine, perChar };
    }
    blockAt(height, oracle, top3, offset) {
      let { firstLine, lastLine, perLine, perChar } = this.heightMetrics(oracle, offset);
      if (oracle.lineWrapping) {
        let guess = offset + (height < oracle.lineHeight ? 0 : Math.round(Math.max(0, Math.min(1, (height - top3) / this.height)) * this.length));
        let line2 = oracle.doc.lineAt(guess), lineHeight = perLine + line2.length * perChar;
        let lineTop = Math.max(top3, height - lineHeight / 2);
        return new BlockInfo(line2.from, line2.length, lineTop, lineHeight, 0);
      } else {
        let line2 = Math.max(0, Math.min(lastLine - firstLine, Math.floor((height - top3) / perLine)));
        let { from, length: length6 } = oracle.doc.line(firstLine + line2);
        return new BlockInfo(from, length6, top3 + perLine * line2, perLine, 0);
      }
    }
    lineAt(value, type2, oracle, top3, offset) {
      if (type2 == QueryType.ByHeight)
        return this.blockAt(value, oracle, top3, offset);
      if (type2 == QueryType.ByPosNoHeight) {
        let { from, to } = oracle.doc.lineAt(value);
        return new BlockInfo(from, to - from, 0, 0, 0);
      }
      let { firstLine, perLine, perChar } = this.heightMetrics(oracle, offset);
      let line2 = oracle.doc.lineAt(value), lineHeight = perLine + line2.length * perChar;
      let linesAbove = line2.number - firstLine;
      let lineTop = top3 + perLine * linesAbove + perChar * (line2.from - offset - linesAbove);
      return new BlockInfo(line2.from, line2.length, Math.max(top3, Math.min(lineTop, top3 + this.height - lineHeight)), lineHeight, 0);
    }
    forEachLine(from, to, oracle, top3, offset, f) {
      from = Math.max(from, offset);
      to = Math.min(to, offset + this.length);
      let { firstLine, perLine, perChar } = this.heightMetrics(oracle, offset);
      for (let pos = from, lineTop = top3; pos <= to; ) {
        let line2 = oracle.doc.lineAt(pos);
        if (pos == from) {
          let linesAbove = line2.number - firstLine;
          lineTop += perLine * linesAbove + perChar * (from - offset - linesAbove);
        }
        let lineHeight = perLine + perChar * line2.length;
        f(new BlockInfo(line2.from, line2.length, lineTop, lineHeight, 0));
        lineTop += lineHeight;
        pos = line2.to + 1;
      }
    }
    replace(from, to, nodes) {
      let after = this.length - to;
      if (after > 0) {
        let last3 = nodes[nodes.length - 1];
        if (last3 instanceof HeightMapGap)
          nodes[nodes.length - 1] = new HeightMapGap(last3.length + after);
        else
          nodes.push(null, new HeightMapGap(after - 1));
      }
      if (from > 0) {
        let first = nodes[0];
        if (first instanceof HeightMapGap)
          nodes[0] = new HeightMapGap(from + first.length);
        else
          nodes.unshift(new HeightMapGap(from - 1), null);
      }
      return HeightMap.of(nodes);
    }
    decomposeLeft(to, result) {
      result.push(new HeightMapGap(to - 1), null);
    }
    decomposeRight(from, result) {
      result.push(null, new HeightMapGap(this.length - from - 1));
    }
    updateHeight(oracle, offset = 0, force2 = false, measured) {
      let end = offset + this.length;
      if (measured && measured.from <= offset + this.length && measured.more) {
        let nodes = [], pos = Math.max(offset, measured.from), singleHeight = -1;
        if (measured.from > offset)
          nodes.push(new HeightMapGap(measured.from - offset - 1).updateHeight(oracle, offset));
        while (pos <= end && measured.more) {
          let len = oracle.doc.lineAt(pos).length;
          if (nodes.length)
            nodes.push(null);
          let height = measured.heights[measured.index++];
          if (singleHeight == -1)
            singleHeight = height;
          else if (Math.abs(height - singleHeight) >= Epsilon)
            singleHeight = -2;
          let line2 = new HeightMapText(len, height);
          line2.outdated = false;
          nodes.push(line2);
          pos += len + 1;
        }
        if (pos <= end)
          nodes.push(null, new HeightMapGap(end - pos).updateHeight(oracle, pos));
        let result = HeightMap.of(nodes);
        if (singleHeight < 0 || Math.abs(result.height - this.height) >= Epsilon || Math.abs(singleHeight - this.heightMetrics(oracle, offset).perLine) >= Epsilon)
          heightChangeFlag = true;
        return replace(this, result);
      } else if (force2 || this.outdated) {
        this.setHeight(oracle.heightForGap(offset, offset + this.length));
        this.outdated = false;
      }
      return this;
    }
    toString() {
      return `gap(${this.length})`;
    }
  };
  var HeightMapBranch = class extends HeightMap {
    constructor(left2, brk, right2) {
      super(left2.length + brk + right2.length, left2.height + right2.height, brk | (left2.outdated || right2.outdated ? 2 : 0));
      this.left = left2;
      this.right = right2;
      this.size = left2.size + right2.size;
    }
    get break() {
      return this.flags & 1;
    }
    blockAt(height, oracle, top3, offset) {
      let mid = top3 + this.left.height;
      return height < mid ? this.left.blockAt(height, oracle, top3, offset) : this.right.blockAt(height, oracle, mid, offset + this.left.length + this.break);
    }
    lineAt(value, type2, oracle, top3, offset) {
      let rightTop = top3 + this.left.height, rightOffset = offset + this.left.length + this.break;
      let left2 = type2 == QueryType.ByHeight ? value < rightTop : value < rightOffset;
      let base2 = left2 ? this.left.lineAt(value, type2, oracle, top3, offset) : this.right.lineAt(value, type2, oracle, rightTop, rightOffset);
      if (this.break || (left2 ? base2.to < rightOffset : base2.from > rightOffset))
        return base2;
      let subQuery = type2 == QueryType.ByPosNoHeight ? QueryType.ByPosNoHeight : QueryType.ByPos;
      if (left2)
        return base2.join(this.right.lineAt(rightOffset, subQuery, oracle, rightTop, rightOffset));
      else
        return this.left.lineAt(rightOffset, subQuery, oracle, top3, offset).join(base2);
    }
    forEachLine(from, to, oracle, top3, offset, f) {
      let rightTop = top3 + this.left.height, rightOffset = offset + this.left.length + this.break;
      if (this.break) {
        if (from < rightOffset)
          this.left.forEachLine(from, to, oracle, top3, offset, f);
        if (to >= rightOffset)
          this.right.forEachLine(from, to, oracle, rightTop, rightOffset, f);
      } else {
        let mid = this.lineAt(rightOffset, QueryType.ByPos, oracle, top3, offset);
        if (from < mid.from)
          this.left.forEachLine(from, mid.from - 1, oracle, top3, offset, f);
        if (mid.to >= from && mid.from <= to)
          f(mid);
        if (to > mid.to)
          this.right.forEachLine(mid.to + 1, to, oracle, rightTop, rightOffset, f);
      }
    }
    replace(from, to, nodes) {
      let rightStart = this.left.length + this.break;
      if (to < rightStart)
        return this.balanced(this.left.replace(from, to, nodes), this.right);
      if (from > this.left.length)
        return this.balanced(this.left, this.right.replace(from - rightStart, to - rightStart, nodes));
      let result = [];
      if (from > 0)
        this.decomposeLeft(from, result);
      let left2 = result.length;
      for (let node2 of nodes)
        result.push(node2);
      if (from > 0)
        mergeGaps(result, left2 - 1);
      if (to < this.length) {
        let right2 = result.length;
        this.decomposeRight(to, result);
        mergeGaps(result, right2);
      }
      return HeightMap.of(result);
    }
    decomposeLeft(to, result) {
      let left2 = this.left.length;
      if (to <= left2)
        return this.left.decomposeLeft(to, result);
      result.push(this.left);
      if (this.break) {
        left2++;
        if (to >= left2)
          result.push(null);
      }
      if (to > left2)
        this.right.decomposeLeft(to - left2, result);
    }
    decomposeRight(from, result) {
      let left2 = this.left.length, right2 = left2 + this.break;
      if (from >= right2)
        return this.right.decomposeRight(from - right2, result);
      if (from < left2)
        this.left.decomposeRight(from, result);
      if (this.break && from < right2)
        result.push(null);
      result.push(this.right);
    }
    balanced(left2, right2) {
      if (left2.size > 2 * right2.size || right2.size > 2 * left2.size)
        return HeightMap.of(this.break ? [left2, null, right2] : [left2, right2]);
      this.left = replace(this.left, left2);
      this.right = replace(this.right, right2);
      this.setHeight(left2.height + right2.height);
      this.outdated = left2.outdated || right2.outdated;
      this.size = left2.size + right2.size;
      this.length = left2.length + this.break + right2.length;
      return this;
    }
    updateHeight(oracle, offset = 0, force2 = false, measured) {
      let { left: left2, right: right2 } = this, rightStart = offset + left2.length + this.break, rebalance = null;
      if (measured && measured.from <= offset + left2.length && measured.more)
        rebalance = left2 = left2.updateHeight(oracle, offset, force2, measured);
      else
        left2.updateHeight(oracle, offset, force2);
      if (measured && measured.from <= rightStart + right2.length && measured.more)
        rebalance = right2 = right2.updateHeight(oracle, rightStart, force2, measured);
      else
        right2.updateHeight(oracle, rightStart, force2);
      if (rebalance)
        return this.balanced(left2, right2);
      this.height = this.left.height + this.right.height;
      this.outdated = false;
      return this;
    }
    toString() {
      return this.left + (this.break ? " " : "-") + this.right;
    }
  };
  function mergeGaps(nodes, around) {
    let before, after;
    if (nodes[around] == null && (before = nodes[around - 1]) instanceof HeightMapGap && (after = nodes[around + 1]) instanceof HeightMapGap)
      nodes.splice(around - 1, 3, new HeightMapGap(before.length + 1 + after.length));
  }
  var relevantWidgetHeight = 5;
  var NodeBuilder = class {
    constructor(pos, oracle) {
      this.pos = pos;
      this.oracle = oracle;
      this.nodes = [];
      this.lineStart = -1;
      this.lineEnd = -1;
      this.covering = null;
      this.writtenTo = pos;
    }
    get isCovered() {
      return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
    }
    span(_from, to) {
      if (this.lineStart > -1) {
        let end = Math.min(to, this.lineEnd), last3 = this.nodes[this.nodes.length - 1];
        if (last3 instanceof HeightMapText)
          last3.length += end - this.pos;
        else if (end > this.pos || !this.isCovered)
          this.nodes.push(new HeightMapText(end - this.pos, -1));
        this.writtenTo = end;
        if (to > end) {
          this.nodes.push(null);
          this.writtenTo++;
          this.lineStart = -1;
        }
      }
      this.pos = to;
    }
    point(from, to, deco) {
      if (from < to || deco.heightRelevant) {
        let height = deco.widget ? deco.widget.estimatedHeight : 0;
        let breaks = deco.widget ? deco.widget.lineBreaks : 0;
        if (height < 0)
          height = this.oracle.lineHeight;
        let len = to - from;
        if (deco.block) {
          this.addBlock(new HeightMapBlock(len, height, deco));
        } else if (len || breaks || height >= relevantWidgetHeight) {
          this.addLineDeco(height, breaks, len);
        }
      } else if (to > from) {
        this.span(from, to);
      }
      if (this.lineEnd > -1 && this.lineEnd < this.pos)
        this.lineEnd = this.oracle.doc.lineAt(this.pos).to;
    }
    enterLine() {
      if (this.lineStart > -1)
        return;
      let { from, to } = this.oracle.doc.lineAt(this.pos);
      this.lineStart = from;
      this.lineEnd = to;
      if (this.writtenTo < from) {
        if (this.writtenTo < from - 1 || this.nodes[this.nodes.length - 1] == null)
          this.nodes.push(this.blankContent(this.writtenTo, from - 1));
        this.nodes.push(null);
      }
      if (this.pos > from)
        this.nodes.push(new HeightMapText(this.pos - from, -1));
      this.writtenTo = this.pos;
    }
    blankContent(from, to) {
      let gap = new HeightMapGap(to - from);
      if (this.oracle.doc.lineAt(from).to == to)
        gap.flags |= 4;
      return gap;
    }
    ensureLine() {
      this.enterLine();
      let last3 = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
      if (last3 instanceof HeightMapText)
        return last3;
      let line2 = new HeightMapText(0, -1);
      this.nodes.push(line2);
      return line2;
    }
    addBlock(block) {
      this.enterLine();
      let deco = block.deco;
      if (deco && deco.startSide > 0 && !this.isCovered)
        this.ensureLine();
      this.nodes.push(block);
      this.writtenTo = this.pos = this.pos + block.length;
      if (deco && deco.endSide > 0)
        this.covering = block;
    }
    addLineDeco(height, breaks, length6) {
      let line2 = this.ensureLine();
      line2.length += length6;
      line2.collapsed += length6;
      line2.widgetHeight = Math.max(line2.widgetHeight, height);
      line2.breaks += breaks;
      this.writtenTo = this.pos = this.pos + length6;
    }
    finish(from) {
      let last3 = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];
      if (this.lineStart > -1 && !(last3 instanceof HeightMapText) && !this.isCovered)
        this.nodes.push(new HeightMapText(0, -1));
      else if (this.writtenTo < this.pos || last3 == null)
        this.nodes.push(this.blankContent(this.writtenTo, this.pos));
      let pos = from;
      for (let node2 of this.nodes) {
        if (node2 instanceof HeightMapText)
          node2.updateHeight(this.oracle, pos);
        pos += node2 ? node2.length : 1;
      }
      return this.nodes;
    }
    static build(oracle, decorations2, from, to) {
      let builder = new NodeBuilder(from, oracle);
      RangeSet.spans(decorations2, from, to, builder, 0);
      return builder.finish(from);
    }
  };
  function heightRelevantDecoChanges(a, b, diff) {
    let comp = new DecorationComparator2();
    RangeSet.compare(a, b, diff, comp, 0);
    return comp.changes;
  }
  var DecorationComparator2 = class {
    constructor() {
      this.changes = [];
    }
    compareRange() {
    }
    comparePoint(from, to, a, b) {
      if (from < to || a && a.heightRelevant || b && b.heightRelevant)
        addRange(from, to, this.changes, 5);
    }
  };
  function visiblePixelRange(dom, paddingTop) {
    let rect = dom.getBoundingClientRect();
    let doc2 = dom.ownerDocument, win = doc2.defaultView || window;
    let left2 = Math.max(0, rect.left), right2 = Math.min(win.innerWidth, rect.right);
    let top3 = Math.max(0, rect.top), bottom2 = Math.min(win.innerHeight, rect.bottom);
    for (let parent = dom.parentNode; parent && parent != doc2.body; ) {
      if (parent.nodeType == 1) {
        let elt = parent;
        let style = window.getComputedStyle(elt);
        if ((elt.scrollHeight > elt.clientHeight || elt.scrollWidth > elt.clientWidth) && style.overflow != "visible") {
          let parentRect = elt.getBoundingClientRect();
          left2 = Math.max(left2, parentRect.left);
          right2 = Math.min(right2, parentRect.right);
          top3 = Math.max(top3, parentRect.top);
          bottom2 = Math.min(parent == dom.parentNode ? win.innerHeight : bottom2, parentRect.bottom);
        }
        parent = style.position == "absolute" || style.position == "fixed" ? elt.offsetParent : elt.parentNode;
      } else if (parent.nodeType == 11) {
        parent = parent.host;
      } else {
        break;
      }
    }
    return {
      left: left2 - rect.left,
      right: Math.max(left2, right2) - rect.left,
      top: top3 - (rect.top + paddingTop),
      bottom: Math.max(top3, bottom2) - (rect.top + paddingTop)
    };
  }
  function fullPixelRange(dom, paddingTop) {
    let rect = dom.getBoundingClientRect();
    return {
      left: 0,
      right: rect.right - rect.left,
      top: paddingTop,
      bottom: rect.bottom - (rect.top + paddingTop)
    };
  }
  var LineGap = class {
    constructor(from, to, size3) {
      this.from = from;
      this.to = to;
      this.size = size3;
    }
    static same(a, b) {
      if (a.length != b.length)
        return false;
      for (let i = 0; i < a.length; i++) {
        let gA = a[i], gB = b[i];
        if (gA.from != gB.from || gA.to != gB.to || gA.size != gB.size)
          return false;
      }
      return true;
    }
    draw(viewState, wrapping) {
      return Decoration.replace({
        widget: new LineGapWidget(this.size * (wrapping ? viewState.scaleY : viewState.scaleX), wrapping)
      }).range(this.from, this.to);
    }
  };
  var LineGapWidget = class extends WidgetType {
    constructor(size3, vertical) {
      super();
      this.size = size3;
      this.vertical = vertical;
    }
    eq(other) {
      return other.size == this.size && other.vertical == this.vertical;
    }
    toDOM() {
      let elt = document.createElement("div");
      if (this.vertical) {
        elt.style.height = this.size + "px";
      } else {
        elt.style.width = this.size + "px";
        elt.style.height = "2px";
        elt.style.display = "inline-block";
      }
      return elt;
    }
    get estimatedHeight() {
      return this.vertical ? this.size : -1;
    }
  };
  var ViewState = class {
    constructor(state) {
      this.state = state;
      this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 };
      this.inView = true;
      this.paddingTop = 0;
      this.paddingBottom = 0;
      this.contentDOMWidth = 0;
      this.contentDOMHeight = 0;
      this.editorHeight = 0;
      this.editorWidth = 0;
      this.scrollTop = 0;
      this.scrolledToBottom = false;
      this.scaleX = 1;
      this.scaleY = 1;
      this.scrollAnchorPos = 0;
      this.scrollAnchorHeight = -1;
      this.scaler = IdScaler;
      this.scrollTarget = null;
      this.printing = false;
      this.mustMeasureContent = true;
      this.defaultTextDirection = Direction.LTR;
      this.visibleRanges = [];
      this.mustEnforceCursorAssoc = false;
      let guessWrapping = state.facet(contentAttributes).some((v) => typeof v != "function" && v.class == "cm-lineWrapping");
      this.heightOracle = new HeightOracle(guessWrapping);
      this.stateDeco = state.facet(decorations).filter((d) => typeof d != "function");
      this.heightMap = HeightMap.empty().applyChanges(this.stateDeco, Text.empty, this.heightOracle.setDoc(state.doc), [new ChangedRange(0, 0, 0, state.doc.length)]);
      for (let i = 0; i < 2; i++) {
        this.viewport = this.getViewport(0, null);
        if (!this.updateForViewport())
          break;
      }
      this.updateViewportLines();
      this.lineGaps = this.ensureLineGaps([]);
      this.lineGapDeco = Decoration.set(this.lineGaps.map((gap) => gap.draw(this, false)));
      this.computeVisibleRanges();
    }
    updateForViewport() {
      let viewports = [this.viewport], { main: main2 } = this.state.selection;
      for (let i = 0; i <= 1; i++) {
        let pos = i ? main2.head : main2.anchor;
        if (!viewports.some(({ from, to }) => pos >= from && pos <= to)) {
          let { from, to } = this.lineBlockAt(pos);
          viewports.push(new Viewport(from, to));
        }
      }
      this.viewports = viewports.sort((a, b) => a.from - b.from);
      return this.updateScaler();
    }
    updateScaler() {
      let scaler = this.scaler;
      this.scaler = this.heightMap.height <= 7e6 ? IdScaler : new BigScaler(this.heightOracle, this.heightMap, this.viewports);
      return scaler.eq(this.scaler) ? 0 : 2;
    }
    updateViewportLines() {
      this.viewportLines = [];
      this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.heightOracle.setDoc(this.state.doc), 0, 0, (block) => {
        this.viewportLines.push(scaleBlock(block, this.scaler));
      });
    }
    update(update3, scrollTarget = null) {
      this.state = update3.state;
      let prevDeco = this.stateDeco;
      this.stateDeco = this.state.facet(decorations).filter((d) => typeof d != "function");
      let contentChanges = update3.changedRanges;
      let heightChanges = ChangedRange.extendWithRanges(contentChanges, heightRelevantDecoChanges(prevDeco, this.stateDeco, update3 ? update3.changes : ChangeSet.empty(this.state.doc.length)));
      let prevHeight = this.heightMap.height;
      let scrollAnchor = this.scrolledToBottom ? null : this.scrollAnchorAt(this.scrollTop);
      clearHeightChangeFlag();
      this.heightMap = this.heightMap.applyChanges(this.stateDeco, update3.startState.doc, this.heightOracle.setDoc(this.state.doc), heightChanges);
      if (this.heightMap.height != prevHeight || heightChangeFlag)
        update3.flags |= 2;
      if (scrollAnchor) {
        this.scrollAnchorPos = update3.changes.mapPos(scrollAnchor.from, -1);
        this.scrollAnchorHeight = scrollAnchor.top;
      } else {
        this.scrollAnchorPos = -1;
        this.scrollAnchorHeight = this.heightMap.height;
      }
      let viewport = heightChanges.length ? this.mapViewport(this.viewport, update3.changes) : this.viewport;
      if (scrollTarget && (scrollTarget.range.head < viewport.from || scrollTarget.range.head > viewport.to) || !this.viewportIsAppropriate(viewport))
        viewport = this.getViewport(0, scrollTarget);
      let viewportChange = viewport.from != this.viewport.from || viewport.to != this.viewport.to;
      this.viewport = viewport;
      update3.flags |= this.updateForViewport();
      if (viewportChange || !update3.changes.empty || update3.flags & 2)
        this.updateViewportLines();
      if (this.lineGaps.length || this.viewport.to - this.viewport.from > 2e3 << 1)
        this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, update3.changes)));
      update3.flags |= this.computeVisibleRanges();
      if (scrollTarget)
        this.scrollTarget = scrollTarget;
      if (!this.mustEnforceCursorAssoc && update3.selectionSet && update3.view.lineWrapping && update3.state.selection.main.empty && update3.state.selection.main.assoc && !update3.state.facet(nativeSelectionHidden))
        this.mustEnforceCursorAssoc = true;
    }
    measure(view2) {
      let dom = view2.contentDOM, style = window.getComputedStyle(dom);
      let oracle = this.heightOracle;
      let whiteSpace = style.whiteSpace;
      this.defaultTextDirection = style.direction == "rtl" ? Direction.RTL : Direction.LTR;
      let refresh = this.heightOracle.mustRefreshForWrapping(whiteSpace);
      let domRect = dom.getBoundingClientRect();
      let measureContent = refresh || this.mustMeasureContent || this.contentDOMHeight != domRect.height;
      this.contentDOMHeight = domRect.height;
      this.mustMeasureContent = false;
      let result = 0, bias = 0;
      if (domRect.width && domRect.height) {
        let { scaleX, scaleY } = getScale(dom, domRect);
        if (scaleX > 5e-3 && Math.abs(this.scaleX - scaleX) > 5e-3 || scaleY > 5e-3 && Math.abs(this.scaleY - scaleY) > 5e-3) {
          this.scaleX = scaleX;
          this.scaleY = scaleY;
          result |= 8;
          refresh = measureContent = true;
        }
      }
      let paddingTop = (parseInt(style.paddingTop) || 0) * this.scaleY;
      let paddingBottom = (parseInt(style.paddingBottom) || 0) * this.scaleY;
      if (this.paddingTop != paddingTop || this.paddingBottom != paddingBottom) {
        this.paddingTop = paddingTop;
        this.paddingBottom = paddingBottom;
        result |= 8 | 2;
      }
      if (this.editorWidth != view2.scrollDOM.clientWidth) {
        if (oracle.lineWrapping)
          measureContent = true;
        this.editorWidth = view2.scrollDOM.clientWidth;
        result |= 8;
      }
      let scrollTop = view2.scrollDOM.scrollTop * this.scaleY;
      if (this.scrollTop != scrollTop) {
        this.scrollAnchorHeight = -1;
        this.scrollTop = scrollTop;
      }
      this.scrolledToBottom = isScrolledToBottom(view2.scrollDOM);
      let pixelViewport = (this.printing ? fullPixelRange : visiblePixelRange)(dom, this.paddingTop);
      let dTop = pixelViewport.top - this.pixelViewport.top, dBottom = pixelViewport.bottom - this.pixelViewport.bottom;
      this.pixelViewport = pixelViewport;
      let inView = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
      if (inView != this.inView) {
        this.inView = inView;
        if (inView)
          measureContent = true;
      }
      if (!this.inView && !this.scrollTarget)
        return 0;
      let contentWidth = domRect.width;
      if (this.contentDOMWidth != contentWidth || this.editorHeight != view2.scrollDOM.clientHeight) {
        this.contentDOMWidth = domRect.width;
        this.editorHeight = view2.scrollDOM.clientHeight;
        result |= 8;
      }
      if (measureContent) {
        let lineHeights = view2.docView.measureVisibleLineHeights(this.viewport);
        if (oracle.mustRefreshForHeights(lineHeights))
          refresh = true;
        if (refresh || oracle.lineWrapping && Math.abs(contentWidth - this.contentDOMWidth) > oracle.charWidth) {
          let { lineHeight, charWidth, textHeight } = view2.docView.measureTextSize();
          refresh = lineHeight > 0 && oracle.refresh(whiteSpace, lineHeight, charWidth, textHeight, contentWidth / charWidth, lineHeights);
          if (refresh) {
            view2.docView.minWidth = 0;
            result |= 8;
          }
        }
        if (dTop > 0 && dBottom > 0)
          bias = Math.max(dTop, dBottom);
        else if (dTop < 0 && dBottom < 0)
          bias = Math.min(dTop, dBottom);
        clearHeightChangeFlag();
        for (let vp of this.viewports) {
          let heights = vp.from == this.viewport.from ? lineHeights : view2.docView.measureVisibleLineHeights(vp);
          this.heightMap = (refresh ? HeightMap.empty().applyChanges(this.stateDeco, Text.empty, this.heightOracle, [new ChangedRange(0, 0, 0, view2.state.doc.length)]) : this.heightMap).updateHeight(oracle, 0, refresh, new MeasuredHeights(vp.from, heights));
        }
        if (heightChangeFlag)
          result |= 2;
      }
      let viewportChange = !this.viewportIsAppropriate(this.viewport, bias) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);
      if (viewportChange) {
        if (result & 2)
          result |= this.updateScaler();
        this.viewport = this.getViewport(bias, this.scrollTarget);
        result |= this.updateForViewport();
      }
      if (result & 2 || viewportChange)
        this.updateViewportLines();
      if (this.lineGaps.length || this.viewport.to - this.viewport.from > 2e3 << 1)
        this.updateLineGaps(this.ensureLineGaps(refresh ? [] : this.lineGaps, view2));
      result |= this.computeVisibleRanges();
      if (this.mustEnforceCursorAssoc) {
        this.mustEnforceCursorAssoc = false;
        view2.docView.enforceCursorAssoc();
      }
      return result;
    }
    get visibleTop() {
      return this.scaler.fromDOM(this.pixelViewport.top);
    }
    get visibleBottom() {
      return this.scaler.fromDOM(this.pixelViewport.bottom);
    }
    getViewport(bias, scrollTarget) {
      let marginTop = 0.5 - Math.max(-0.5, Math.min(0.5, bias / 1e3 / 2));
      let map3 = this.heightMap, oracle = this.heightOracle;
      let { visibleTop, visibleBottom } = this;
      let viewport = new Viewport(map3.lineAt(visibleTop - marginTop * 1e3, QueryType.ByHeight, oracle, 0, 0).from, map3.lineAt(visibleBottom + (1 - marginTop) * 1e3, QueryType.ByHeight, oracle, 0, 0).to);
      if (scrollTarget) {
        let { head } = scrollTarget.range;
        if (head < viewport.from || head > viewport.to) {
          let viewHeight = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top);
          let block = map3.lineAt(head, QueryType.ByPos, oracle, 0, 0), topPos;
          if (scrollTarget.y == "center")
            topPos = (block.top + block.bottom) / 2 - viewHeight / 2;
          else if (scrollTarget.y == "start" || scrollTarget.y == "nearest" && head < viewport.from)
            topPos = block.top;
          else
            topPos = block.bottom - viewHeight;
          viewport = new Viewport(map3.lineAt(topPos - 1e3 / 2, QueryType.ByHeight, oracle, 0, 0).from, map3.lineAt(topPos + viewHeight + 1e3 / 2, QueryType.ByHeight, oracle, 0, 0).to);
        }
      }
      return viewport;
    }
    mapViewport(viewport, changes) {
      let from = changes.mapPos(viewport.from, -1), to = changes.mapPos(viewport.to, 1);
      return new Viewport(this.heightMap.lineAt(from, QueryType.ByPos, this.heightOracle, 0, 0).from, this.heightMap.lineAt(to, QueryType.ByPos, this.heightOracle, 0, 0).to);
    }
    viewportIsAppropriate({ from, to }, bias = 0) {
      if (!this.inView)
        return true;
      let { top: top3 } = this.heightMap.lineAt(from, QueryType.ByPos, this.heightOracle, 0, 0);
      let { bottom: bottom2 } = this.heightMap.lineAt(to, QueryType.ByPos, this.heightOracle, 0, 0);
      let { visibleTop, visibleBottom } = this;
      return (from == 0 || top3 <= visibleTop - Math.max(10, Math.min(-bias, 250))) && (to == this.state.doc.length || bottom2 >= visibleBottom + Math.max(10, Math.min(bias, 250))) && (top3 > visibleTop - 2 * 1e3 && bottom2 < visibleBottom + 2 * 1e3);
    }
    mapLineGaps(gaps, changes) {
      if (!gaps.length || changes.empty)
        return gaps;
      let mapped = [];
      for (let gap of gaps)
        if (!changes.touchesRange(gap.from, gap.to))
          mapped.push(new LineGap(changes.mapPos(gap.from), changes.mapPos(gap.to), gap.size));
      return mapped;
    }
    ensureLineGaps(current, mayMeasure) {
      let wrapping = this.heightOracle.lineWrapping;
      let margin = wrapping ? 1e4 : 2e3, halfMargin = margin >> 1, doubleMargin = margin << 1;
      if (this.defaultTextDirection != Direction.LTR && !wrapping)
        return [];
      let gaps = [];
      let addGap = (from, to, line2, structure) => {
        if (to - from < halfMargin)
          return;
        let sel = this.state.selection.main, avoid = [sel.from];
        if (!sel.empty)
          avoid.push(sel.to);
        for (let pos of avoid) {
          if (pos > from && pos < to) {
            addGap(from, pos - 10, line2, structure);
            addGap(pos + 10, to, line2, structure);
            return;
          }
        }
        let gap = find2(current, (gap2) => gap2.from >= line2.from && gap2.to <= line2.to && Math.abs(gap2.from - from) < halfMargin && Math.abs(gap2.to - to) < halfMargin && !avoid.some((pos) => gap2.from < pos && gap2.to > pos));
        if (!gap) {
          if (to < line2.to && mayMeasure && wrapping && mayMeasure.visibleRanges.some((r) => r.from <= to && r.to >= to)) {
            let lineStart = mayMeasure.moveToLineBoundary(EditorSelection.cursor(to), false, true).head;
            if (lineStart > from)
              to = lineStart;
          }
          gap = new LineGap(from, to, this.gapSize(line2, from, to, structure));
        }
        gaps.push(gap);
      };
      let checkLine = (line2) => {
        if (line2.length < doubleMargin || line2.type != BlockType.Text)
          return;
        let structure = lineStructure(line2.from, line2.to, this.stateDeco);
        if (structure.total < doubleMargin)
          return;
        let target = this.scrollTarget ? this.scrollTarget.range.head : null;
        let viewFrom, viewTo;
        if (wrapping) {
          let marginHeight = margin / this.heightOracle.lineLength * this.heightOracle.lineHeight;
          let top3, bot;
          if (target != null) {
            let targetFrac = findFraction(structure, target);
            let spaceFrac = ((this.visibleBottom - this.visibleTop) / 2 + marginHeight) / line2.height;
            top3 = targetFrac - spaceFrac;
            bot = targetFrac + spaceFrac;
          } else {
            top3 = (this.visibleTop - line2.top - marginHeight) / line2.height;
            bot = (this.visibleBottom - line2.top + marginHeight) / line2.height;
          }
          viewFrom = findPosition(structure, top3);
          viewTo = findPosition(structure, bot);
        } else {
          let totalWidth = structure.total * this.heightOracle.charWidth;
          let marginWidth = margin * this.heightOracle.charWidth;
          let left2, right2;
          if (target != null) {
            let targetFrac = findFraction(structure, target);
            let spaceFrac = ((this.pixelViewport.right - this.pixelViewport.left) / 2 + marginWidth) / totalWidth;
            left2 = targetFrac - spaceFrac;
            right2 = targetFrac + spaceFrac;
          } else {
            left2 = (this.pixelViewport.left - marginWidth) / totalWidth;
            right2 = (this.pixelViewport.right + marginWidth) / totalWidth;
          }
          viewFrom = findPosition(structure, left2);
          viewTo = findPosition(structure, right2);
        }
        if (viewFrom > line2.from)
          addGap(line2.from, viewFrom, line2, structure);
        if (viewTo < line2.to)
          addGap(viewTo, line2.to, line2, structure);
      };
      for (let line2 of this.viewportLines) {
        if (Array.isArray(line2.type))
          line2.type.forEach(checkLine);
        else
          checkLine(line2);
      }
      return gaps;
    }
    gapSize(line2, from, to, structure) {
      let fraction = findFraction(structure, to) - findFraction(structure, from);
      if (this.heightOracle.lineWrapping) {
        return line2.height * fraction;
      } else {
        return structure.total * this.heightOracle.charWidth * fraction;
      }
    }
    updateLineGaps(gaps) {
      if (!LineGap.same(gaps, this.lineGaps)) {
        this.lineGaps = gaps;
        this.lineGapDeco = Decoration.set(gaps.map((gap) => gap.draw(this, this.heightOracle.lineWrapping)));
      }
    }
    computeVisibleRanges() {
      let deco = this.stateDeco;
      if (this.lineGaps.length)
        deco = deco.concat(this.lineGapDeco);
      let ranges = [];
      RangeSet.spans(deco, this.viewport.from, this.viewport.to, {
        span(from, to) {
          ranges.push({ from, to });
        },
        point() {
        }
      }, 20);
      let changed = ranges.length != this.visibleRanges.length || this.visibleRanges.some((r, i) => r.from != ranges[i].from || r.to != ranges[i].to);
      this.visibleRanges = ranges;
      return changed ? 4 : 0;
    }
    lineBlockAt(pos) {
      return pos >= this.viewport.from && pos <= this.viewport.to && this.viewportLines.find((b) => b.from <= pos && b.to >= pos) || scaleBlock(this.heightMap.lineAt(pos, QueryType.ByPos, this.heightOracle, 0, 0), this.scaler);
    }
    lineBlockAtHeight(height) {
      return height >= this.viewportLines[0].top && height <= this.viewportLines[this.viewportLines.length - 1].bottom && this.viewportLines.find((l) => l.top <= height && l.bottom >= height) || scaleBlock(this.heightMap.lineAt(this.scaler.fromDOM(height), QueryType.ByHeight, this.heightOracle, 0, 0), this.scaler);
    }
    scrollAnchorAt(scrollTop) {
      let block = this.lineBlockAtHeight(scrollTop + 8);
      return block.from >= this.viewport.from || this.viewportLines[0].top - scrollTop > 200 ? block : this.viewportLines[0];
    }
    elementAtHeight(height) {
      return scaleBlock(this.heightMap.blockAt(this.scaler.fromDOM(height), this.heightOracle, 0, 0), this.scaler);
    }
    get docHeight() {
      return this.scaler.toDOM(this.heightMap.height);
    }
    get contentHeight() {
      return this.docHeight + this.paddingTop + this.paddingBottom;
    }
  };
  var Viewport = class {
    constructor(from, to) {
      this.from = from;
      this.to = to;
    }
  };
  function lineStructure(from, to, stateDeco) {
    let ranges = [], pos = from, total = 0;
    RangeSet.spans(stateDeco, from, to, {
      span() {
      },
      point(from2, to2) {
        if (from2 > pos) {
          ranges.push({ from: pos, to: from2 });
          total += from2 - pos;
        }
        pos = to2;
      }
    }, 20);
    if (pos < to) {
      ranges.push({ from: pos, to });
      total += to - pos;
    }
    return { total, ranges };
  }
  function findPosition({ total, ranges }, ratio) {
    if (ratio <= 0)
      return ranges[0].from;
    if (ratio >= 1)
      return ranges[ranges.length - 1].to;
    let dist2 = Math.floor(total * ratio);
    for (let i = 0; ; i++) {
      let { from, to } = ranges[i], size3 = to - from;
      if (dist2 <= size3)
        return from + dist2;
      dist2 -= size3;
    }
  }
  function findFraction(structure, pos) {
    let counted = 0;
    for (let { from, to } of structure.ranges) {
      if (pos <= to) {
        counted += pos - from;
        break;
      }
      counted += to - from;
    }
    return counted / structure.total;
  }
  function find2(array2, f) {
    for (let val of array2)
      if (f(val))
        return val;
    return void 0;
  }
  var IdScaler = {
    toDOM(n) {
      return n;
    },
    fromDOM(n) {
      return n;
    },
    scale: 1,
    eq(other) {
      return other == this;
    }
  };
  var BigScaler = class {
    constructor(oracle, heightMap, viewports) {
      let vpHeight = 0, base2 = 0, domBase = 0;
      this.viewports = viewports.map(({ from, to }) => {
        let top3 = heightMap.lineAt(from, QueryType.ByPos, oracle, 0, 0).top;
        let bottom2 = heightMap.lineAt(to, QueryType.ByPos, oracle, 0, 0).bottom;
        vpHeight += bottom2 - top3;
        return { from, to, top: top3, bottom: bottom2, domTop: 0, domBottom: 0 };
      });
      this.scale = (7e6 - vpHeight) / (heightMap.height - vpHeight);
      for (let obj of this.viewports) {
        obj.domTop = domBase + (obj.top - base2) * this.scale;
        domBase = obj.domBottom = obj.domTop + (obj.bottom - obj.top);
        base2 = obj.bottom;
      }
    }
    toDOM(n) {
      for (let i = 0, base2 = 0, domBase = 0; ; i++) {
        let vp = i < this.viewports.length ? this.viewports[i] : null;
        if (!vp || n < vp.top)
          return domBase + (n - base2) * this.scale;
        if (n <= vp.bottom)
          return vp.domTop + (n - vp.top);
        base2 = vp.bottom;
        domBase = vp.domBottom;
      }
    }
    fromDOM(n) {
      for (let i = 0, base2 = 0, domBase = 0; ; i++) {
        let vp = i < this.viewports.length ? this.viewports[i] : null;
        if (!vp || n < vp.domTop)
          return base2 + (n - domBase) / this.scale;
        if (n <= vp.domBottom)
          return vp.top + (n - vp.domTop);
        base2 = vp.bottom;
        domBase = vp.domBottom;
      }
    }
    eq(other) {
      if (!(other instanceof BigScaler))
        return false;
      return this.scale == other.scale && this.viewports.length == other.viewports.length && this.viewports.every((vp, i) => vp.from == other.viewports[i].from && vp.to == other.viewports[i].to);
    }
  };
  function scaleBlock(block, scaler) {
    if (scaler.scale == 1)
      return block;
    let bTop = scaler.toDOM(block.top), bBottom = scaler.toDOM(block.bottom);
    return new BlockInfo(block.from, block.length, bTop, bBottom - bTop, Array.isArray(block._content) ? block._content.map((b) => scaleBlock(b, scaler)) : block._content);
  }
  var theme = /* @__PURE__ */ Facet.define({ combine: (strs) => strs.join(" ") });
  var darkTheme = /* @__PURE__ */ Facet.define({ combine: (values3) => values3.indexOf(true) > -1 });
  var baseThemeID = /* @__PURE__ */ StyleModule.newName();
  var baseLightID = /* @__PURE__ */ StyleModule.newName();
  var baseDarkID = /* @__PURE__ */ StyleModule.newName();
  var lightDarkIDs = { "&light": "." + baseLightID, "&dark": "." + baseDarkID };
  function buildTheme(main2, spec, scopes) {
    return new StyleModule(spec, {
      finish(sel) {
        return /&/.test(sel) ? sel.replace(/&\w*/, (m) => {
          if (m == "&")
            return main2;
          if (!scopes || !scopes[m])
            throw new RangeError(`Unsupported selector: ${m}`);
          return scopes[m];
        }) : main2 + " " + sel;
      }
    });
  }
  var baseTheme$1 = /* @__PURE__ */ buildTheme("." + baseThemeID, {
    "&": {
      position: "relative !important",
      boxSizing: "border-box",
      "&.cm-focused": {
        outline: "1px dotted #212121"
      },
      display: "flex !important",
      flexDirection: "column"
    },
    ".cm-scroller": {
      display: "flex !important",
      alignItems: "flex-start !important",
      fontFamily: "monospace",
      lineHeight: 1.4,
      height: "100%",
      overflowX: "auto",
      position: "relative",
      zIndex: 0,
      overflowAnchor: "none"
    },
    ".cm-content": {
      margin: 0,
      flexGrow: 2,
      flexShrink: 0,
      display: "block",
      whiteSpace: "pre",
      wordWrap: "normal",
      boxSizing: "border-box",
      minHeight: "100%",
      padding: "4px 0",
      outline: "none",
      "&[contenteditable=true]": {
        WebkitUserModify: "read-write-plaintext-only"
      }
    },
    ".cm-lineWrapping": {
      whiteSpace_fallback: "pre-wrap",
      whiteSpace: "break-spaces",
      wordBreak: "break-word",
      overflowWrap: "anywhere",
      flexShrink: 1
    },
    "&light .cm-content": { caretColor: "black" },
    "&dark .cm-content": { caretColor: "white" },
    ".cm-line": {
      display: "block",
      padding: "0 2px 0 6px"
    },
    ".cm-layer": {
      position: "absolute",
      left: 0,
      top: 0,
      contain: "size style",
      "& > *": {
        position: "absolute"
      }
    },
    "&light .cm-selectionBackground": {
      background: "#d9d9d9"
    },
    "&dark .cm-selectionBackground": {
      background: "#222"
    },
    "&light.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
      background: "#d7d4f0"
    },
    "&dark.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
      background: "#233"
    },
    ".cm-cursorLayer": {
      pointerEvents: "none"
    },
    "&.cm-focused > .cm-scroller > .cm-cursorLayer": {
      animation: "steps(1) cm-blink 1.2s infinite"
    },
    "@keyframes cm-blink": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
    "@keyframes cm-blink2": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
    ".cm-cursor, .cm-dropCursor": {
      borderLeft: "1.2px solid black",
      marginLeft: "-0.6px",
      pointerEvents: "none"
    },
    ".cm-cursor": {
      display: "none"
    },
    "&dark .cm-cursor": {
      borderLeftColor: "#444"
    },
    ".cm-dropCursor": {
      position: "absolute"
    },
    "&.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor": {
      display: "block"
    },
    ".cm-iso": {
      unicodeBidi: "isolate"
    },
    ".cm-announced": {
      position: "fixed",
      top: "-10000px"
    },
    "@media print": {
      ".cm-announced": { display: "none" }
    },
    "&light .cm-activeLine": { backgroundColor: "#cceeff44" },
    "&dark .cm-activeLine": { backgroundColor: "#99eeff33" },
    "&light .cm-specialChar": { color: "red" },
    "&dark .cm-specialChar": { color: "#f78" },
    ".cm-gutters": {
      flexShrink: 0,
      display: "flex",
      height: "100%",
      boxSizing: "border-box",
      insetInlineStart: 0,
      zIndex: 200
    },
    "&light .cm-gutters": {
      backgroundColor: "#f5f5f5",
      color: "#6c6c6c",
      borderRight: "1px solid #ddd"
    },
    "&dark .cm-gutters": {
      backgroundColor: "#333338",
      color: "#ccc"
    },
    ".cm-gutter": {
      display: "flex !important",
      flexDirection: "column",
      flexShrink: 0,
      boxSizing: "border-box",
      minHeight: "100%",
      overflow: "hidden"
    },
    ".cm-gutterElement": {
      boxSizing: "border-box"
    },
    ".cm-lineNumbers .cm-gutterElement": {
      padding: "0 3px 0 5px",
      minWidth: "20px",
      textAlign: "right",
      whiteSpace: "nowrap"
    },
    "&light .cm-activeLineGutter": {
      backgroundColor: "#e2f2ff"
    },
    "&dark .cm-activeLineGutter": {
      backgroundColor: "#222227"
    },
    ".cm-panels": {
      boxSizing: "border-box",
      position: "sticky",
      left: 0,
      right: 0,
      zIndex: 300
    },
    "&light .cm-panels": {
      backgroundColor: "#f5f5f5",
      color: "black"
    },
    "&light .cm-panels-top": {
      borderBottom: "1px solid #ddd"
    },
    "&light .cm-panels-bottom": {
      borderTop: "1px solid #ddd"
    },
    "&dark .cm-panels": {
      backgroundColor: "#333338",
      color: "white"
    },
    ".cm-tab": {
      display: "inline-block",
      overflow: "hidden",
      verticalAlign: "bottom"
    },
    ".cm-widgetBuffer": {
      verticalAlign: "text-top",
      height: "1em",
      width: 0,
      display: "inline"
    },
    ".cm-placeholder": {
      color: "#888",
      display: "inline-block",
      verticalAlign: "top"
    },
    ".cm-highlightSpace:before": {
      content: "attr(data-display)",
      position: "absolute",
      pointerEvents: "none",
      color: "#888"
    },
    ".cm-highlightTab": {
      backgroundImage: `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="20"><path stroke="%23888" stroke-width="1" fill="none" d="M1 10H196L190 5M190 15L196 10M197 4L197 16"/></svg>')`,
      backgroundSize: "auto 100%",
      backgroundPosition: "right 90%",
      backgroundRepeat: "no-repeat"
    },
    ".cm-trailingSpace": {
      backgroundColor: "#ff332255"
    },
    ".cm-button": {
      verticalAlign: "middle",
      color: "inherit",
      fontSize: "70%",
      padding: ".2em 1em",
      borderRadius: "1px"
    },
    "&light .cm-button": {
      backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
      border: "1px solid #888",
      "&:active": {
        backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)"
      }
    },
    "&dark .cm-button": {
      backgroundImage: "linear-gradient(#393939, #111)",
      border: "1px solid #888",
      "&:active": {
        backgroundImage: "linear-gradient(#111, #333)"
      }
    },
    ".cm-textfield": {
      verticalAlign: "middle",
      color: "inherit",
      fontSize: "70%",
      border: "1px solid silver",
      padding: ".2em .5em"
    },
    "&light .cm-textfield": {
      backgroundColor: "white"
    },
    "&dark .cm-textfield": {
      border: "1px solid #555",
      backgroundColor: "inherit"
    }
  }, lightDarkIDs);
  var observeOptions = {
    childList: true,
    characterData: true,
    subtree: true,
    attributes: true,
    characterDataOldValue: true
  };
  var useCharData = browser.ie && browser.ie_version <= 11;
  var DOMObserver = class {
    constructor(view2) {
      this.view = view2;
      this.active = false;
      this.editContext = null;
      this.selectionRange = new DOMSelectionState();
      this.selectionChanged = false;
      this.delayedFlush = -1;
      this.resizeTimeout = -1;
      this.queue = [];
      this.delayedAndroidKey = null;
      this.flushingAndroidKey = -1;
      this.lastChange = 0;
      this.scrollTargets = [];
      this.intersection = null;
      this.resizeScroll = null;
      this.intersecting = false;
      this.gapIntersection = null;
      this.gaps = [];
      this.printQuery = null;
      this.parentCheck = -1;
      this.dom = view2.contentDOM;
      this.observer = new MutationObserver((mutations) => {
        for (let mut of mutations)
          this.queue.push(mut);
        if ((browser.ie && browser.ie_version <= 11 || browser.ios && view2.composing) && mutations.some((m) => m.type == "childList" && m.removedNodes.length || m.type == "characterData" && m.oldValue.length > m.target.nodeValue.length))
          this.flushSoon();
        else
          this.flush();
      });
      if (window.EditContext && view2.constructor.EDIT_CONTEXT !== false && !(browser.chrome && browser.chrome_version < 126)) {
        this.editContext = new EditContextManager(view2);
        if (view2.state.facet(editable))
          view2.contentDOM.editContext = this.editContext.editContext;
      }
      if (useCharData)
        this.onCharData = (event) => {
          this.queue.push({
            target: event.target,
            type: "characterData",
            oldValue: event.prevValue
          });
          this.flushSoon();
        };
      this.onSelectionChange = this.onSelectionChange.bind(this);
      this.onResize = this.onResize.bind(this);
      this.onPrint = this.onPrint.bind(this);
      this.onScroll = this.onScroll.bind(this);
      if (window.matchMedia)
        this.printQuery = window.matchMedia("print");
      if (typeof ResizeObserver == "function") {
        this.resizeScroll = new ResizeObserver(() => {
          var _a2;
          if (((_a2 = this.view.docView) === null || _a2 === void 0 ? void 0 : _a2.lastUpdate) < Date.now() - 75)
            this.onResize();
        });
        this.resizeScroll.observe(view2.scrollDOM);
      }
      this.addWindowListeners(this.win = view2.win);
      this.start();
      if (typeof IntersectionObserver == "function") {
        this.intersection = new IntersectionObserver((entries) => {
          if (this.parentCheck < 0)
            this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1e3);
          if (entries.length > 0 && entries[entries.length - 1].intersectionRatio > 0 != this.intersecting) {
            this.intersecting = !this.intersecting;
            if (this.intersecting != this.view.inView)
              this.onScrollChanged(document.createEvent("Event"));
          }
        }, { threshold: [0, 1e-3] });
        this.intersection.observe(this.dom);
        this.gapIntersection = new IntersectionObserver((entries) => {
          if (entries.length > 0 && entries[entries.length - 1].intersectionRatio > 0)
            this.onScrollChanged(document.createEvent("Event"));
        }, {});
      }
      this.listenForScroll();
      this.readSelectionRange();
    }
    onScrollChanged(e) {
      this.view.inputState.runHandlers("scroll", e);
      if (this.intersecting)
        this.view.measure();
    }
    onScroll(e) {
      if (this.intersecting)
        this.flush(false);
      if (this.editContext)
        this.view.requestMeasure(this.editContext.measureReq);
      this.onScrollChanged(e);
    }
    onResize() {
      if (this.resizeTimeout < 0)
        this.resizeTimeout = setTimeout(() => {
          this.resizeTimeout = -1;
          this.view.requestMeasure();
        }, 50);
    }
    onPrint(event) {
      if ((event.type == "change" || !event.type) && !event.matches)
        return;
      this.view.viewState.printing = true;
      this.view.measure();
      setTimeout(() => {
        this.view.viewState.printing = false;
        this.view.requestMeasure();
      }, 500);
    }
    updateGaps(gaps) {
      if (this.gapIntersection && (gaps.length != this.gaps.length || this.gaps.some((g, i) => g != gaps[i]))) {
        this.gapIntersection.disconnect();
        for (let gap of gaps)
          this.gapIntersection.observe(gap);
        this.gaps = gaps;
      }
    }
    onSelectionChange(event) {
      let wasChanged = this.selectionChanged;
      if (!this.readSelectionRange() || this.delayedAndroidKey)
        return;
      let { view: view2 } = this, sel = this.selectionRange;
      if (view2.state.facet(editable) ? view2.root.activeElement != this.dom : !hasSelection(view2.dom, sel))
        return;
      let context = sel.anchorNode && view2.docView.nearest(sel.anchorNode);
      if (context && context.ignoreEvent(event)) {
        if (!wasChanged)
          this.selectionChanged = false;
        return;
      }
      if ((browser.ie && browser.ie_version <= 11 || browser.android && browser.chrome) && !view2.state.selection.main.empty && sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset))
        this.flushSoon();
      else
        this.flush(false);
    }
    readSelectionRange() {
      let { view: view2 } = this;
      let selection2 = getSelection(view2.root);
      if (!selection2)
        return false;
      let range4 = browser.safari && view2.root.nodeType == 11 && deepActiveElement(this.dom.ownerDocument) == this.dom && safariSelectionRangeHack(this.view, selection2) || selection2;
      if (!range4 || this.selectionRange.eq(range4))
        return false;
      let local = hasSelection(this.dom, range4);
      if (local && !this.selectionChanged && view2.inputState.lastFocusTime > Date.now() - 200 && view2.inputState.lastTouchTime < Date.now() - 300 && atElementStart(this.dom, range4)) {
        this.view.inputState.lastFocusTime = 0;
        view2.docView.updateSelection();
        return false;
      }
      this.selectionRange.setRange(range4);
      if (local)
        this.selectionChanged = true;
      return true;
    }
    setSelectionRange(anchor, head) {
      this.selectionRange.set(anchor.node, anchor.offset, head.node, head.offset);
      this.selectionChanged = false;
    }
    clearSelectionRange() {
      this.selectionRange.set(null, 0, null, 0);
    }
    listenForScroll() {
      this.parentCheck = -1;
      let i = 0, changed = null;
      for (let dom = this.dom; dom; ) {
        if (dom.nodeType == 1) {
          if (!changed && i < this.scrollTargets.length && this.scrollTargets[i] == dom)
            i++;
          else if (!changed)
            changed = this.scrollTargets.slice(0, i);
          if (changed)
            changed.push(dom);
          dom = dom.assignedSlot || dom.parentNode;
        } else if (dom.nodeType == 11) {
          dom = dom.host;
        } else {
          break;
        }
      }
      if (i < this.scrollTargets.length && !changed)
        changed = this.scrollTargets.slice(0, i);
      if (changed) {
        for (let dom of this.scrollTargets)
          dom.removeEventListener("scroll", this.onScroll);
        for (let dom of this.scrollTargets = changed)
          dom.addEventListener("scroll", this.onScroll);
      }
    }
    ignore(f) {
      if (!this.active)
        return f();
      try {
        this.stop();
        return f();
      } finally {
        this.start();
        this.clear();
      }
    }
    start() {
      if (this.active)
        return;
      this.observer.observe(this.dom, observeOptions);
      if (useCharData)
        this.dom.addEventListener("DOMCharacterDataModified", this.onCharData);
      this.active = true;
    }
    stop() {
      if (!this.active)
        return;
      this.active = false;
      this.observer.disconnect();
      if (useCharData)
        this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData);
    }
    clear() {
      this.processRecords();
      this.queue.length = 0;
      this.selectionChanged = false;
    }
    delayAndroidKey(key, keyCode) {
      var _a2;
      if (!this.delayedAndroidKey) {
        let flush = () => {
          let key2 = this.delayedAndroidKey;
          if (key2) {
            this.clearDelayedAndroidKey();
            this.view.inputState.lastKeyCode = key2.keyCode;
            this.view.inputState.lastKeyTime = Date.now();
            let flushed = this.flush();
            if (!flushed && key2.force)
              dispatchKey(this.dom, key2.key, key2.keyCode);
          }
        };
        this.flushingAndroidKey = this.view.win.requestAnimationFrame(flush);
      }
      if (!this.delayedAndroidKey || key == "Enter")
        this.delayedAndroidKey = {
          key,
          keyCode,
          force: this.lastChange < Date.now() - 50 || !!((_a2 = this.delayedAndroidKey) === null || _a2 === void 0 ? void 0 : _a2.force)
        };
    }
    clearDelayedAndroidKey() {
      this.win.cancelAnimationFrame(this.flushingAndroidKey);
      this.delayedAndroidKey = null;
      this.flushingAndroidKey = -1;
    }
    flushSoon() {
      if (this.delayedFlush < 0)
        this.delayedFlush = this.view.win.requestAnimationFrame(() => {
          this.delayedFlush = -1;
          this.flush();
        });
    }
    forceFlush() {
      if (this.delayedFlush >= 0) {
        this.view.win.cancelAnimationFrame(this.delayedFlush);
        this.delayedFlush = -1;
      }
      this.flush();
    }
    pendingRecords() {
      for (let mut of this.observer.takeRecords())
        this.queue.push(mut);
      return this.queue;
    }
    processRecords() {
      let records = this.pendingRecords();
      if (records.length)
        this.queue = [];
      let from = -1, to = -1, typeOver = false;
      for (let record2 of records) {
        let range4 = this.readMutation(record2);
        if (!range4)
          continue;
        if (range4.typeOver)
          typeOver = true;
        if (from == -1) {
          ({ from, to } = range4);
        } else {
          from = Math.min(range4.from, from);
          to = Math.max(range4.to, to);
        }
      }
      return { from, to, typeOver };
    }
    readChange() {
      let { from, to, typeOver } = this.processRecords();
      let newSel = this.selectionChanged && hasSelection(this.dom, this.selectionRange);
      if (from < 0 && !newSel)
        return null;
      if (from > -1)
        this.lastChange = Date.now();
      this.view.inputState.lastFocusTime = 0;
      this.selectionChanged = false;
      let change = new DOMChange(this.view, from, to, typeOver);
      this.view.docView.domChanged = { newSel: change.newSel ? change.newSel.main : null };
      return change;
    }
    flush(readSelection = true) {
      if (this.delayedFlush >= 0 || this.delayedAndroidKey)
        return false;
      if (readSelection)
        this.readSelectionRange();
      let domChange = this.readChange();
      if (!domChange) {
        this.view.requestMeasure();
        return false;
      }
      let startState2 = this.view.state;
      let handled = applyDOMChange(this.view, domChange);
      if (this.view.state == startState2 && (domChange.domChanged || domChange.newSel && !domChange.newSel.main.eq(this.view.state.selection.main)))
        this.view.update([]);
      return handled;
    }
    readMutation(rec) {
      let cView = this.view.docView.nearest(rec.target);
      if (!cView || cView.ignoreMutation(rec))
        return null;
      cView.markDirty(rec.type == "attributes");
      if (rec.type == "attributes")
        cView.flags |= 4;
      if (rec.type == "childList") {
        let childBefore = findChild(cView, rec.previousSibling || rec.target.previousSibling, -1);
        let childAfter = findChild(cView, rec.nextSibling || rec.target.nextSibling, 1);
        return {
          from: childBefore ? cView.posAfter(childBefore) : cView.posAtStart,
          to: childAfter ? cView.posBefore(childAfter) : cView.posAtEnd,
          typeOver: false
        };
      } else if (rec.type == "characterData") {
        return { from: cView.posAtStart, to: cView.posAtEnd, typeOver: rec.target.nodeValue == rec.oldValue };
      } else {
        return null;
      }
    }
    setWindow(win) {
      if (win != this.win) {
        this.removeWindowListeners(this.win);
        this.win = win;
        this.addWindowListeners(this.win);
      }
    }
    addWindowListeners(win) {
      win.addEventListener("resize", this.onResize);
      if (this.printQuery) {
        if (this.printQuery.addEventListener)
          this.printQuery.addEventListener("change", this.onPrint);
        else
          this.printQuery.addListener(this.onPrint);
      } else
        win.addEventListener("beforeprint", this.onPrint);
      win.addEventListener("scroll", this.onScroll);
      win.document.addEventListener("selectionchange", this.onSelectionChange);
    }
    removeWindowListeners(win) {
      win.removeEventListener("scroll", this.onScroll);
      win.removeEventListener("resize", this.onResize);
      if (this.printQuery) {
        if (this.printQuery.removeEventListener)
          this.printQuery.removeEventListener("change", this.onPrint);
        else
          this.printQuery.removeListener(this.onPrint);
      } else
        win.removeEventListener("beforeprint", this.onPrint);
      win.document.removeEventListener("selectionchange", this.onSelectionChange);
    }
    update(update3) {
      if (this.editContext) {
        this.editContext.update(update3);
        if (update3.startState.facet(editable) != update3.state.facet(editable))
          update3.view.contentDOM.editContext = update3.state.facet(editable) ? this.editContext.editContext : null;
      }
    }
    destroy() {
      var _a2, _b, _c;
      this.stop();
      (_a2 = this.intersection) === null || _a2 === void 0 ? void 0 : _a2.disconnect();
      (_b = this.gapIntersection) === null || _b === void 0 ? void 0 : _b.disconnect();
      (_c = this.resizeScroll) === null || _c === void 0 ? void 0 : _c.disconnect();
      for (let dom of this.scrollTargets)
        dom.removeEventListener("scroll", this.onScroll);
      this.removeWindowListeners(this.win);
      clearTimeout(this.parentCheck);
      clearTimeout(this.resizeTimeout);
      this.win.cancelAnimationFrame(this.delayedFlush);
      this.win.cancelAnimationFrame(this.flushingAndroidKey);
      if (this.editContext) {
        this.view.contentDOM.editContext = null;
        this.editContext.destroy();
      }
    }
  };
  function findChild(cView, dom, dir) {
    while (dom) {
      let curView = ContentView.get(dom);
      if (curView && curView.parent == cView)
        return curView;
      let parent = dom.parentNode;
      dom = parent != cView.dom ? parent : dir > 0 ? dom.nextSibling : dom.previousSibling;
    }
    return null;
  }
  function buildSelectionRangeFromRange(view2, range4) {
    let anchorNode = range4.startContainer, anchorOffset = range4.startOffset;
    let focusNode = range4.endContainer, focusOffset = range4.endOffset;
    let curAnchor = view2.docView.domAtPos(view2.state.selection.main.anchor);
    if (isEquivalentPosition(curAnchor.node, curAnchor.offset, focusNode, focusOffset))
      [anchorNode, anchorOffset, focusNode, focusOffset] = [focusNode, focusOffset, anchorNode, anchorOffset];
    return { anchorNode, anchorOffset, focusNode, focusOffset };
  }
  function safariSelectionRangeHack(view2, selection2) {
    if (selection2.getComposedRanges) {
      let range4 = selection2.getComposedRanges(view2.root)[0];
      if (range4)
        return buildSelectionRangeFromRange(view2, range4);
    }
    let found = null;
    function read2(event) {
      event.preventDefault();
      event.stopImmediatePropagation();
      found = event.getTargetRanges()[0];
    }
    view2.contentDOM.addEventListener("beforeinput", read2, true);
    view2.dom.ownerDocument.execCommand("indent");
    view2.contentDOM.removeEventListener("beforeinput", read2, true);
    return found ? buildSelectionRangeFromRange(view2, found) : null;
  }
  var EditContextManager = class {
    constructor(view2) {
      this.from = 0;
      this.to = 0;
      this.pendingContextChange = null;
      this.handlers = /* @__PURE__ */ Object.create(null);
      this.resetRange(view2.state);
      let context = this.editContext = new window.EditContext({
        text: view2.state.doc.sliceString(this.from, this.to),
        selectionStart: this.toContextPos(Math.max(this.from, Math.min(this.to, view2.state.selection.main.anchor))),
        selectionEnd: this.toContextPos(view2.state.selection.main.head)
      });
      this.handlers.textupdate = (e) => {
        let { anchor } = view2.state.selection.main;
        let change = {
          from: this.toEditorPos(e.updateRangeStart),
          to: this.toEditorPos(e.updateRangeEnd),
          insert: Text.of(e.text.split("\n"))
        };
        if (change.from == this.from && anchor < this.from)
          change.from = anchor;
        else if (change.to == this.to && anchor > this.to)
          change.to = anchor;
        if (change.from == change.to && !change.insert.length)
          return;
        this.pendingContextChange = change;
        if (!view2.state.readOnly)
          applyDOMChangeInner(view2, change, EditorSelection.single(this.toEditorPos(e.selectionStart), this.toEditorPos(e.selectionEnd)));
        if (this.pendingContextChange) {
          this.revertPending(view2.state);
          this.setSelection(view2.state);
        }
      };
      this.handlers.characterboundsupdate = (e) => {
        let rects = [], prev = null;
        for (let i = this.toEditorPos(e.rangeStart), end = this.toEditorPos(e.rangeEnd); i < end; i++) {
          let rect = view2.coordsForChar(i);
          prev = rect && new DOMRect(rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top) || prev || new DOMRect();
          rects.push(prev);
        }
        context.updateCharacterBounds(e.rangeStart, rects);
      };
      this.handlers.textformatupdate = (e) => {
        let deco = [];
        for (let format2 of e.getTextFormats()) {
          let lineStyle = format2.underlineStyle, thickness = format2.underlineThickness;
          if (lineStyle != "None" && thickness != "None") {
            let style = `text-decoration: underline ${lineStyle == "Dashed" ? "dashed " : lineStyle == "Squiggle" ? "wavy " : ""}${thickness == "Thin" ? 1 : 2}px`;
            deco.push(Decoration.mark({ attributes: { style } }).range(this.toEditorPos(format2.rangeStart), this.toEditorPos(format2.rangeEnd)));
          }
        }
        view2.dispatch({ effects: setEditContextFormatting.of(Decoration.set(deco)) });
      };
      this.handlers.compositionstart = () => {
        if (view2.inputState.composing < 0) {
          view2.inputState.composing = 0;
          view2.inputState.compositionFirstChange = true;
        }
      };
      this.handlers.compositionend = () => {
        view2.inputState.composing = -1;
        view2.inputState.compositionFirstChange = null;
      };
      for (let event in this.handlers)
        context.addEventListener(event, this.handlers[event]);
      this.measureReq = { read: (view3) => {
        this.editContext.updateControlBounds(view3.contentDOM.getBoundingClientRect());
        let sel = getSelection(view3.root);
        if (sel && sel.rangeCount)
          this.editContext.updateSelectionBounds(sel.getRangeAt(0).getBoundingClientRect());
      } };
    }
    applyEdits(update3) {
      let off = 0, abort = false, pending = this.pendingContextChange;
      update3.changes.iterChanges((fromA, toA, _fromB, _toB, insert4) => {
        if (abort)
          return;
        let dLen = insert4.length - (toA - fromA);
        if (pending && toA >= pending.to) {
          if (pending.from == fromA && pending.to == toA && pending.insert.eq(insert4)) {
            pending = this.pendingContextChange = null;
            off += dLen;
            this.to += dLen;
            return;
          } else {
            pending = null;
            this.revertPending(update3.state);
          }
        }
        fromA += off;
        toA += off;
        if (toA <= this.from) {
          this.from += dLen;
          this.to += dLen;
        } else if (fromA < this.to) {
          if (fromA < this.from || toA > this.to || this.to - this.from + insert4.length > 3e4) {
            abort = true;
            return;
          }
          this.editContext.updateText(this.toContextPos(fromA), this.toContextPos(toA), insert4.toString());
          this.to += dLen;
        }
        off += dLen;
      });
      if (pending && !abort)
        this.revertPending(update3.state);
      return !abort;
    }
    update(update3) {
      let reverted = this.pendingContextChange;
      if (!this.applyEdits(update3) || !this.rangeIsValid(update3.state)) {
        this.pendingContextChange = null;
        this.resetRange(update3.state);
        this.editContext.updateText(0, this.editContext.text.length, update3.state.doc.sliceString(this.from, this.to));
        this.setSelection(update3.state);
      } else if (update3.docChanged || update3.selectionSet || reverted) {
        this.setSelection(update3.state);
      }
      if (update3.geometryChanged || update3.docChanged || update3.selectionSet)
        update3.view.requestMeasure(this.measureReq);
    }
    resetRange(state) {
      let { head } = state.selection.main;
      this.from = Math.max(0, head - 1e4);
      this.to = Math.min(state.doc.length, head + 1e4);
    }
    revertPending(state) {
      let pending = this.pendingContextChange;
      this.pendingContextChange = null;
      this.editContext.updateText(this.toContextPos(pending.from), this.toContextPos(pending.from + pending.insert.length), state.doc.sliceString(pending.from, pending.to));
    }
    setSelection(state) {
      let { main: main2 } = state.selection;
      let start2 = this.toContextPos(Math.max(this.from, Math.min(this.to, main2.anchor)));
      let end = this.toContextPos(main2.head);
      if (this.editContext.selectionStart != start2 || this.editContext.selectionEnd != end)
        this.editContext.updateSelection(start2, end);
    }
    rangeIsValid(state) {
      let { head } = state.selection.main;
      return !(this.from > 0 && head - this.from < 500 || this.to < state.doc.length && this.to - head < 500 || this.to - this.from > 1e4 * 3);
    }
    toEditorPos(contextPos) {
      return contextPos + this.from;
    }
    toContextPos(editorPos) {
      return editorPos - this.from;
    }
    destroy() {
      for (let event in this.handlers)
        this.editContext.removeEventListener(event, this.handlers[event]);
    }
  };
  var EditorView = class {
    get state() {
      return this.viewState.state;
    }
    get viewport() {
      return this.viewState.viewport;
    }
    get visibleRanges() {
      return this.viewState.visibleRanges;
    }
    get inView() {
      return this.viewState.inView;
    }
    get composing() {
      return this.inputState.composing > 0;
    }
    get compositionStarted() {
      return this.inputState.composing >= 0;
    }
    get root() {
      return this._root;
    }
    get win() {
      return this.dom.ownerDocument.defaultView || window;
    }
    constructor(config = {}) {
      var _a2;
      this.plugins = [];
      this.pluginMap = /* @__PURE__ */ new Map();
      this.editorAttrs = {};
      this.contentAttrs = {};
      this.bidiCache = [];
      this.destroyed = false;
      this.updateState = 2;
      this.measureScheduled = -1;
      this.measureRequests = [];
      this.contentDOM = document.createElement("div");
      this.scrollDOM = document.createElement("div");
      this.scrollDOM.tabIndex = -1;
      this.scrollDOM.className = "cm-scroller";
      this.scrollDOM.appendChild(this.contentDOM);
      this.announceDOM = document.createElement("div");
      this.announceDOM.className = "cm-announced";
      this.announceDOM.setAttribute("aria-live", "polite");
      this.dom = document.createElement("div");
      this.dom.appendChild(this.announceDOM);
      this.dom.appendChild(this.scrollDOM);
      if (config.parent)
        config.parent.appendChild(this.dom);
      let { dispatch: dispatch3 } = config;
      this.dispatchTransactions = config.dispatchTransactions || dispatch3 && ((trs) => trs.forEach((tr) => dispatch3(tr, this))) || ((trs) => this.update(trs));
      this.dispatch = this.dispatch.bind(this);
      this._root = config.root || getRoot(config.parent) || document;
      this.viewState = new ViewState(config.state || EditorState.create(config));
      if (config.scrollTo && config.scrollTo.is(scrollIntoView))
        this.viewState.scrollTarget = config.scrollTo.value.clip(this.viewState.state);
      this.plugins = this.state.facet(viewPlugin).map((spec) => new PluginInstance(spec));
      for (let plugin of this.plugins)
        plugin.update(this);
      this.observer = new DOMObserver(this);
      this.inputState = new InputState(this);
      this.inputState.ensureHandlers(this.plugins);
      this.docView = new DocView(this);
      this.mountStyles();
      this.updateAttrs();
      this.updateState = 0;
      this.requestMeasure();
      if ((_a2 = document.fonts) === null || _a2 === void 0 ? void 0 : _a2.ready)
        document.fonts.ready.then(() => this.requestMeasure());
    }
    dispatch(...input) {
      let trs = input.length == 1 && input[0] instanceof Transaction ? input : input.length == 1 && Array.isArray(input[0]) ? input[0] : [this.state.update(...input)];
      this.dispatchTransactions(trs, this);
    }
    update(transactions) {
      if (this.updateState != 0)
        throw new Error("Calls to EditorView.update are not allowed while an update is in progress");
      let redrawn = false, attrsChanged = false, update3;
      let state = this.state;
      for (let tr of transactions) {
        if (tr.startState != state)
          throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
        state = tr.state;
      }
      if (this.destroyed) {
        this.viewState.state = state;
        return;
      }
      let focus = this.hasFocus, focusFlag = 0, dispatchFocus = null;
      if (transactions.some((tr) => tr.annotation(isFocusChange))) {
        this.inputState.notifiedFocused = focus;
        focusFlag = 1;
      } else if (focus != this.inputState.notifiedFocused) {
        this.inputState.notifiedFocused = focus;
        dispatchFocus = focusChangeTransaction(state, focus);
        if (!dispatchFocus)
          focusFlag = 1;
      }
      let pendingKey = this.observer.delayedAndroidKey, domChange = null;
      if (pendingKey) {
        this.observer.clearDelayedAndroidKey();
        domChange = this.observer.readChange();
        if (domChange && !this.state.doc.eq(state.doc) || !this.state.selection.eq(state.selection))
          domChange = null;
      } else {
        this.observer.clear();
      }
      if (state.facet(EditorState.phrases) != this.state.facet(EditorState.phrases))
        return this.setState(state);
      update3 = ViewUpdate.create(this, state, transactions);
      update3.flags |= focusFlag;
      let scrollTarget = this.viewState.scrollTarget;
      try {
        this.updateState = 2;
        for (let tr of transactions) {
          if (scrollTarget)
            scrollTarget = scrollTarget.map(tr.changes);
          if (tr.scrollIntoView) {
            let { main: main2 } = tr.state.selection;
            scrollTarget = new ScrollTarget(main2.empty ? main2 : EditorSelection.cursor(main2.head, main2.head > main2.anchor ? -1 : 1));
          }
          for (let e of tr.effects)
            if (e.is(scrollIntoView))
              scrollTarget = e.value.clip(this.state);
        }
        this.viewState.update(update3, scrollTarget);
        this.bidiCache = CachedOrder.update(this.bidiCache, update3.changes);
        if (!update3.empty) {
          this.updatePlugins(update3);
          this.inputState.update(update3);
        }
        redrawn = this.docView.update(update3);
        if (this.state.facet(styleModule) != this.styleModules)
          this.mountStyles();
        attrsChanged = this.updateAttrs();
        this.showAnnouncements(transactions);
        this.docView.updateSelection(redrawn, transactions.some((tr) => tr.isUserEvent("select.pointer")));
      } finally {
        this.updateState = 0;
      }
      if (update3.startState.facet(theme) != update3.state.facet(theme))
        this.viewState.mustMeasureContent = true;
      if (redrawn || attrsChanged || scrollTarget || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent)
        this.requestMeasure();
      if (redrawn)
        this.docViewUpdate();
      if (!update3.empty)
        for (let listener of this.state.facet(updateListener)) {
          try {
            listener(update3);
          } catch (e) {
            logException(this.state, e, "update listener");
          }
        }
      if (dispatchFocus || domChange)
        Promise.resolve().then(() => {
          if (dispatchFocus && this.state == dispatchFocus.startState)
            this.dispatch(dispatchFocus);
          if (domChange) {
            if (!applyDOMChange(this, domChange) && pendingKey.force)
              dispatchKey(this.contentDOM, pendingKey.key, pendingKey.keyCode);
          }
        });
    }
    setState(newState) {
      if (this.updateState != 0)
        throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");
      if (this.destroyed) {
        this.viewState.state = newState;
        return;
      }
      this.updateState = 2;
      let hadFocus = this.hasFocus;
      try {
        for (let plugin of this.plugins)
          plugin.destroy(this);
        this.viewState = new ViewState(newState);
        this.plugins = newState.facet(viewPlugin).map((spec) => new PluginInstance(spec));
        this.pluginMap.clear();
        for (let plugin of this.plugins)
          plugin.update(this);
        this.docView.destroy();
        this.docView = new DocView(this);
        this.inputState.ensureHandlers(this.plugins);
        this.mountStyles();
        this.updateAttrs();
        this.bidiCache = [];
      } finally {
        this.updateState = 0;
      }
      if (hadFocus)
        this.focus();
      this.requestMeasure();
    }
    updatePlugins(update3) {
      let prevSpecs = update3.startState.facet(viewPlugin), specs = update3.state.facet(viewPlugin);
      if (prevSpecs != specs) {
        let newPlugins = [];
        for (let spec of specs) {
          let found = prevSpecs.indexOf(spec);
          if (found < 0) {
            newPlugins.push(new PluginInstance(spec));
          } else {
            let plugin = this.plugins[found];
            plugin.mustUpdate = update3;
            newPlugins.push(plugin);
          }
        }
        for (let plugin of this.plugins)
          if (plugin.mustUpdate != update3)
            plugin.destroy(this);
        this.plugins = newPlugins;
        this.pluginMap.clear();
      } else {
        for (let p of this.plugins)
          p.mustUpdate = update3;
      }
      for (let i = 0; i < this.plugins.length; i++)
        this.plugins[i].update(this);
      if (prevSpecs != specs)
        this.inputState.ensureHandlers(this.plugins);
    }
    docViewUpdate() {
      for (let plugin of this.plugins) {
        let val = plugin.value;
        if (val && val.docViewUpdate) {
          try {
            val.docViewUpdate(this);
          } catch (e) {
            logException(this.state, e, "doc view update listener");
          }
        }
      }
    }
    measure(flush = true) {
      if (this.destroyed)
        return;
      if (this.measureScheduled > -1)
        this.win.cancelAnimationFrame(this.measureScheduled);
      if (this.observer.delayedAndroidKey) {
        this.measureScheduled = -1;
        this.requestMeasure();
        return;
      }
      this.measureScheduled = 0;
      if (flush)
        this.observer.forceFlush();
      let updated = null;
      let sDOM = this.scrollDOM, scrollTop = sDOM.scrollTop * this.scaleY;
      let { scrollAnchorPos, scrollAnchorHeight } = this.viewState;
      if (Math.abs(scrollTop - this.viewState.scrollTop) > 1)
        scrollAnchorHeight = -1;
      this.viewState.scrollAnchorHeight = -1;
      try {
        for (let i = 0; ; i++) {
          if (scrollAnchorHeight < 0) {
            if (isScrolledToBottom(sDOM)) {
              scrollAnchorPos = -1;
              scrollAnchorHeight = this.viewState.heightMap.height;
            } else {
              let block = this.viewState.scrollAnchorAt(scrollTop);
              scrollAnchorPos = block.from;
              scrollAnchorHeight = block.top;
            }
          }
          this.updateState = 1;
          let changed = this.viewState.measure(this);
          if (!changed && !this.measureRequests.length && this.viewState.scrollTarget == null)
            break;
          if (i > 5) {
            console.warn(this.measureRequests.length ? "Measure loop restarted more than 5 times" : "Viewport failed to stabilize");
            break;
          }
          let measuring = [];
          if (!(changed & 4))
            [this.measureRequests, measuring] = [measuring, this.measureRequests];
          let measured = measuring.map((m) => {
            try {
              return m.read(this);
            } catch (e) {
              logException(this.state, e);
              return BadMeasure;
            }
          });
          let update3 = ViewUpdate.create(this, this.state, []), redrawn = false;
          update3.flags |= changed;
          if (!updated)
            updated = update3;
          else
            updated.flags |= changed;
          this.updateState = 2;
          if (!update3.empty) {
            this.updatePlugins(update3);
            this.inputState.update(update3);
            this.updateAttrs();
            redrawn = this.docView.update(update3);
            if (redrawn)
              this.docViewUpdate();
          }
          for (let i2 = 0; i2 < measuring.length; i2++)
            if (measured[i2] != BadMeasure) {
              try {
                let m = measuring[i2];
                if (m.write)
                  m.write(measured[i2], this);
              } catch (e) {
                logException(this.state, e);
              }
            }
          if (redrawn)
            this.docView.updateSelection(true);
          if (!update3.viewportChanged && this.measureRequests.length == 0) {
            if (this.viewState.editorHeight) {
              if (this.viewState.scrollTarget) {
                this.docView.scrollIntoView(this.viewState.scrollTarget);
                this.viewState.scrollTarget = null;
                scrollAnchorHeight = -1;
                continue;
              } else {
                let newAnchorHeight = scrollAnchorPos < 0 ? this.viewState.heightMap.height : this.viewState.lineBlockAt(scrollAnchorPos).top;
                let diff = newAnchorHeight - scrollAnchorHeight;
                if (diff > 1 || diff < -1) {
                  scrollTop = scrollTop + diff;
                  sDOM.scrollTop = scrollTop / this.scaleY;
                  scrollAnchorHeight = -1;
                  continue;
                }
              }
            }
            break;
          }
        }
      } finally {
        this.updateState = 0;
        this.measureScheduled = -1;
      }
      if (updated && !updated.empty)
        for (let listener of this.state.facet(updateListener))
          listener(updated);
    }
    get themeClasses() {
      return baseThemeID + " " + (this.state.facet(darkTheme) ? baseDarkID : baseLightID) + " " + this.state.facet(theme);
    }
    updateAttrs() {
      let editorAttrs = attrsFromFacet(this, editorAttributes, {
        class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses
      });
      let contentAttrs = {
        spellcheck: "false",
        autocorrect: "off",
        autocapitalize: "off",
        translate: "no",
        contenteditable: !this.state.facet(editable) ? "false" : "true",
        class: "cm-content",
        style: `${browser.tabSize}: ${this.state.tabSize}`,
        role: "textbox",
        "aria-multiline": "true"
      };
      if (this.state.readOnly)
        contentAttrs["aria-readonly"] = "true";
      attrsFromFacet(this, contentAttributes, contentAttrs);
      let changed = this.observer.ignore(() => {
        let changedContent = updateAttrs(this.contentDOM, this.contentAttrs, contentAttrs);
        let changedEditor = updateAttrs(this.dom, this.editorAttrs, editorAttrs);
        return changedContent || changedEditor;
      });
      this.editorAttrs = editorAttrs;
      this.contentAttrs = contentAttrs;
      return changed;
    }
    showAnnouncements(trs) {
      let first = true;
      for (let tr of trs)
        for (let effect of tr.effects)
          if (effect.is(EditorView.announce)) {
            if (first)
              this.announceDOM.textContent = "";
            first = false;
            let div = this.announceDOM.appendChild(document.createElement("div"));
            div.textContent = effect.value;
          }
    }
    mountStyles() {
      this.styleModules = this.state.facet(styleModule);
      let nonce = this.state.facet(EditorView.cspNonce);
      StyleModule.mount(this.root, this.styleModules.concat(baseTheme$1).reverse(), nonce ? { nonce } : void 0);
    }
    readMeasured() {
      if (this.updateState == 2)
        throw new Error("Reading the editor layout isn't allowed during an update");
      if (this.updateState == 0 && this.measureScheduled > -1)
        this.measure(false);
    }
    requestMeasure(request2) {
      if (this.measureScheduled < 0)
        this.measureScheduled = this.win.requestAnimationFrame(() => this.measure());
      if (request2) {
        if (this.measureRequests.indexOf(request2) > -1)
          return;
        if (request2.key != null)
          for (let i = 0; i < this.measureRequests.length; i++) {
            if (this.measureRequests[i].key === request2.key) {
              this.measureRequests[i] = request2;
              return;
            }
          }
        this.measureRequests.push(request2);
      }
    }
    plugin(plugin) {
      let known = this.pluginMap.get(plugin);
      if (known === void 0 || known && known.spec != plugin)
        this.pluginMap.set(plugin, known = this.plugins.find((p) => p.spec == plugin) || null);
      return known && known.update(this).value;
    }
    get documentTop() {
      return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;
    }
    get documentPadding() {
      return { top: this.viewState.paddingTop, bottom: this.viewState.paddingBottom };
    }
    get scaleX() {
      return this.viewState.scaleX;
    }
    get scaleY() {
      return this.viewState.scaleY;
    }
    elementAtHeight(height) {
      this.readMeasured();
      return this.viewState.elementAtHeight(height);
    }
    lineBlockAtHeight(height) {
      this.readMeasured();
      return this.viewState.lineBlockAtHeight(height);
    }
    get viewportLineBlocks() {
      return this.viewState.viewportLines;
    }
    lineBlockAt(pos) {
      return this.viewState.lineBlockAt(pos);
    }
    get contentHeight() {
      return this.viewState.contentHeight;
    }
    moveByChar(start2, forward, by) {
      return skipAtoms(this, start2, moveByChar(this, start2, forward, by));
    }
    moveByGroup(start2, forward) {
      return skipAtoms(this, start2, moveByChar(this, start2, forward, (initial) => byGroup(this, start2.head, initial)));
    }
    visualLineSide(line2, end) {
      let order = this.bidiSpans(line2), dir = this.textDirectionAt(line2.from);
      let span3 = order[end ? order.length - 1 : 0];
      return EditorSelection.cursor(span3.side(end, dir) + line2.from, span3.forward(!end, dir) ? 1 : -1);
    }
    moveToLineBoundary(start2, forward, includeWrap = true) {
      return moveToLineBoundary(this, start2, forward, includeWrap);
    }
    moveVertically(start2, forward, distance) {
      return skipAtoms(this, start2, moveVertically(this, start2, forward, distance));
    }
    domAtPos(pos) {
      return this.docView.domAtPos(pos);
    }
    posAtDOM(node2, offset = 0) {
      return this.docView.posFromDOM(node2, offset);
    }
    posAtCoords(coords, precise = true) {
      this.readMeasured();
      return posAtCoords(this, coords, precise);
    }
    coordsAtPos(pos, side = 1) {
      this.readMeasured();
      let rect = this.docView.coordsAt(pos, side);
      if (!rect || rect.left == rect.right)
        return rect;
      let line2 = this.state.doc.lineAt(pos), order = this.bidiSpans(line2);
      let span3 = order[BidiSpan.find(order, pos - line2.from, -1, side)];
      return flattenRect(rect, span3.dir == Direction.LTR == side > 0);
    }
    coordsForChar(pos) {
      this.readMeasured();
      return this.docView.coordsForChar(pos);
    }
    get defaultCharacterWidth() {
      return this.viewState.heightOracle.charWidth;
    }
    get defaultLineHeight() {
      return this.viewState.heightOracle.lineHeight;
    }
    get textDirection() {
      return this.viewState.defaultTextDirection;
    }
    textDirectionAt(pos) {
      let perLine = this.state.facet(perLineTextDirection);
      if (!perLine || pos < this.viewport.from || pos > this.viewport.to)
        return this.textDirection;
      this.readMeasured();
      return this.docView.textDirectionAt(pos);
    }
    get lineWrapping() {
      return this.viewState.heightOracle.lineWrapping;
    }
    bidiSpans(line2) {
      if (line2.length > MaxBidiLine)
        return trivialOrder(line2.length);
      let dir = this.textDirectionAt(line2.from), isolates;
      for (let entry of this.bidiCache) {
        if (entry.from == line2.from && entry.dir == dir && (entry.fresh || isolatesEq(entry.isolates, isolates = getIsolatedRanges(this, line2))))
          return entry.order;
      }
      if (!isolates)
        isolates = getIsolatedRanges(this, line2);
      let order = computeOrder(line2.text, dir, isolates);
      this.bidiCache.push(new CachedOrder(line2.from, line2.to, dir, isolates, true, order));
      return order;
    }
    get hasFocus() {
      var _a2;
      return (this.dom.ownerDocument.hasFocus() || browser.safari && ((_a2 = this.inputState) === null || _a2 === void 0 ? void 0 : _a2.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM;
    }
    focus() {
      this.observer.ignore(() => {
        focusPreventScroll(this.contentDOM);
        this.docView.updateSelection();
      });
    }
    setRoot(root2) {
      if (this._root != root2) {
        this._root = root2;
        this.observer.setWindow((root2.nodeType == 9 ? root2 : root2.ownerDocument).defaultView || window);
        this.mountStyles();
      }
    }
    destroy() {
      if (this.root.activeElement == this.contentDOM)
        this.contentDOM.blur();
      for (let plugin of this.plugins)
        plugin.destroy(this);
      this.plugins = [];
      this.inputState.destroy();
      this.docView.destroy();
      this.dom.remove();
      this.observer.destroy();
      if (this.measureScheduled > -1)
        this.win.cancelAnimationFrame(this.measureScheduled);
      this.destroyed = true;
    }
    static scrollIntoView(pos, options = {}) {
      return scrollIntoView.of(new ScrollTarget(typeof pos == "number" ? EditorSelection.cursor(pos) : pos, options.y, options.x, options.yMargin, options.xMargin));
    }
    scrollSnapshot() {
      let { scrollTop, scrollLeft } = this.scrollDOM;
      let ref = this.viewState.scrollAnchorAt(scrollTop);
      return scrollIntoView.of(new ScrollTarget(EditorSelection.cursor(ref.from), "start", "start", ref.top - scrollTop, scrollLeft, true));
    }
    setTabFocusMode(to) {
      if (to == null)
        this.inputState.tabFocusMode = this.inputState.tabFocusMode < 0 ? 0 : -1;
      else if (typeof to == "boolean")
        this.inputState.tabFocusMode = to ? 0 : -1;
      else if (this.inputState.tabFocusMode != 0)
        this.inputState.tabFocusMode = Date.now() + to;
    }
    static domEventHandlers(handlers2) {
      return ViewPlugin.define(() => ({}), { eventHandlers: handlers2 });
    }
    static domEventObservers(observers2) {
      return ViewPlugin.define(() => ({}), { eventObservers: observers2 });
    }
    static theme(spec, options) {
      let prefix = StyleModule.newName();
      let result = [theme.of(prefix), styleModule.of(buildTheme(`.${prefix}`, spec))];
      if (options && options.dark)
        result.push(darkTheme.of(true));
      return result;
    }
    static baseTheme(spec) {
      return Prec.lowest(styleModule.of(buildTheme("." + baseThemeID, spec, lightDarkIDs)));
    }
    static findFromDOM(dom) {
      var _a2;
      let content2 = dom.querySelector(".cm-content");
      let cView = content2 && ContentView.get(content2) || ContentView.get(dom);
      return ((_a2 = cView === null || cView === void 0 ? void 0 : cView.rootView) === null || _a2 === void 0 ? void 0 : _a2.view) || null;
    }
  };
  EditorView.styleModule = styleModule;
  EditorView.inputHandler = inputHandler;
  EditorView.scrollHandler = scrollHandler;
  EditorView.focusChangeEffect = focusChangeEffect;
  EditorView.perLineTextDirection = perLineTextDirection;
  EditorView.exceptionSink = exceptionSink;
  EditorView.updateListener = updateListener;
  EditorView.editable = editable;
  EditorView.mouseSelectionStyle = mouseSelectionStyle;
  EditorView.dragMovesSelection = dragMovesSelection$1;
  EditorView.clickAddsSelectionRange = clickAddsSelectionRange;
  EditorView.decorations = decorations;
  EditorView.outerDecorations = outerDecorations;
  EditorView.atomicRanges = atomicRanges;
  EditorView.bidiIsolatedRanges = bidiIsolatedRanges;
  EditorView.scrollMargins = scrollMargins;
  EditorView.darkTheme = darkTheme;
  EditorView.cspNonce = /* @__PURE__ */ Facet.define({ combine: (values3) => values3.length ? values3[0] : "" });
  EditorView.contentAttributes = contentAttributes;
  EditorView.editorAttributes = editorAttributes;
  EditorView.lineWrapping = /* @__PURE__ */ EditorView.contentAttributes.of({ "class": "cm-lineWrapping" });
  EditorView.announce = /* @__PURE__ */ StateEffect.define();
  var MaxBidiLine = 4096;
  var BadMeasure = {};
  var CachedOrder = class {
    constructor(from, to, dir, isolates, fresh, order) {
      this.from = from;
      this.to = to;
      this.dir = dir;
      this.isolates = isolates;
      this.fresh = fresh;
      this.order = order;
    }
    static update(cache, changes) {
      if (changes.empty && !cache.some((c) => c.fresh))
        return cache;
      let result = [], lastDir = cache.length ? cache[cache.length - 1].dir : Direction.LTR;
      for (let i = Math.max(0, cache.length - 10); i < cache.length; i++) {
        let entry = cache[i];
        if (entry.dir == lastDir && !changes.touchesRange(entry.from, entry.to))
          result.push(new CachedOrder(changes.mapPos(entry.from, 1), changes.mapPos(entry.to, -1), entry.dir, entry.isolates, false, entry.order));
      }
      return result;
    }
  };
  function attrsFromFacet(view2, facet, base2) {
    for (let sources = view2.state.facet(facet), i = sources.length - 1; i >= 0; i--) {
      let source2 = sources[i], value = typeof source2 == "function" ? source2(view2) : source2;
      if (value)
        combineAttrs(value, base2);
    }
    return base2;
  }
  var currentPlatform = browser.mac ? "mac" : browser.windows ? "win" : browser.linux ? "linux" : "key";
  function normalizeKeyName(name3, platform) {
    const parts = name3.split(/-(?!$)/);
    let result = parts[parts.length - 1];
    if (result == "Space")
      result = " ";
    let alt2, ctrl, shift2, meta2;
    for (let i = 0; i < parts.length - 1; ++i) {
      const mod = parts[i];
      if (/^(cmd|meta|m)$/i.test(mod))
        meta2 = true;
      else if (/^a(lt)?$/i.test(mod))
        alt2 = true;
      else if (/^(c|ctrl|control)$/i.test(mod))
        ctrl = true;
      else if (/^s(hift)?$/i.test(mod))
        shift2 = true;
      else if (/^mod$/i.test(mod)) {
        if (platform == "mac")
          meta2 = true;
        else
          ctrl = true;
      } else
        throw new Error("Unrecognized modifier name: " + mod);
    }
    if (alt2)
      result = "Alt-" + result;
    if (ctrl)
      result = "Ctrl-" + result;
    if (meta2)
      result = "Meta-" + result;
    if (shift2)
      result = "Shift-" + result;
    return result;
  }
  function modifiers(name3, event, shift2) {
    if (event.altKey)
      name3 = "Alt-" + name3;
    if (event.ctrlKey)
      name3 = "Ctrl-" + name3;
    if (event.metaKey)
      name3 = "Meta-" + name3;
    if (shift2 !== false && event.shiftKey)
      name3 = "Shift-" + name3;
    return name3;
  }
  var handleKeyEvents = /* @__PURE__ */ Prec.default(/* @__PURE__ */ EditorView.domEventHandlers({
    keydown(event, view2) {
      return runHandlers(getKeymap(view2.state), event, view2, "editor");
    }
  }));
  var keymap = /* @__PURE__ */ Facet.define({ enables: handleKeyEvents });
  var Keymaps = /* @__PURE__ */ new WeakMap();
  function getKeymap(state) {
    let bindings = state.facet(keymap);
    let map3 = Keymaps.get(bindings);
    if (!map3)
      Keymaps.set(bindings, map3 = buildKeymap(bindings.reduce((a, b) => a.concat(b), [])));
    return map3;
  }
  var storedPrefix = null;
  var PrefixTimeout = 4e3;
  function buildKeymap(bindings, platform = currentPlatform) {
    let bound = /* @__PURE__ */ Object.create(null);
    let isPrefix = /* @__PURE__ */ Object.create(null);
    let checkPrefix = (name3, is) => {
      let current = isPrefix[name3];
      if (current == null)
        isPrefix[name3] = is;
      else if (current != is)
        throw new Error("Key binding " + name3 + " is used both as a regular binding and as a multi-stroke prefix");
    };
    let add = (scope, key, command2, preventDefault2, stopPropagation2) => {
      var _a2, _b;
      let scopeObj = bound[scope] || (bound[scope] = /* @__PURE__ */ Object.create(null));
      let parts = key.split(/ (?!$)/).map((k) => normalizeKeyName(k, platform));
      for (let i = 1; i < parts.length; i++) {
        let prefix = parts.slice(0, i).join(" ");
        checkPrefix(prefix, true);
        if (!scopeObj[prefix])
          scopeObj[prefix] = {
            preventDefault: true,
            stopPropagation: false,
            run: [(view2) => {
              let ourObj = storedPrefix = { view: view2, prefix, scope };
              setTimeout(() => {
                if (storedPrefix == ourObj)
                  storedPrefix = null;
              }, PrefixTimeout);
              return true;
            }]
          };
      }
      let full = parts.join(" ");
      checkPrefix(full, false);
      let binding2 = scopeObj[full] || (scopeObj[full] = {
        preventDefault: false,
        stopPropagation: false,
        run: ((_b = (_a2 = scopeObj._any) === null || _a2 === void 0 ? void 0 : _a2.run) === null || _b === void 0 ? void 0 : _b.slice()) || []
      });
      if (command2)
        binding2.run.push(command2);
      if (preventDefault2)
        binding2.preventDefault = true;
      if (stopPropagation2)
        binding2.stopPropagation = true;
    };
    for (let b of bindings) {
      let scopes = b.scope ? b.scope.split(" ") : ["editor"];
      if (b.any)
        for (let scope of scopes) {
          let scopeObj = bound[scope] || (bound[scope] = /* @__PURE__ */ Object.create(null));
          if (!scopeObj._any)
            scopeObj._any = { preventDefault: false, stopPropagation: false, run: [] };
          let { any: any2 } = b;
          for (let key in scopeObj)
            scopeObj[key].run.push((view2) => any2(view2, currentKeyEvent));
        }
      let name3 = b[platform] || b.key;
      if (!name3)
        continue;
      for (let scope of scopes) {
        add(scope, name3, b.run, b.preventDefault, b.stopPropagation);
        if (b.shift)
          add(scope, "Shift-" + name3, b.shift, b.preventDefault, b.stopPropagation);
      }
    }
    return bound;
  }
  var currentKeyEvent = null;
  function runHandlers(map3, event, view2, scope) {
    currentKeyEvent = event;
    let name3 = keyName(event);
    let charCode = codePointAt(name3, 0), isChar = codePointSize(charCode) == name3.length && name3 != " ";
    let prefix = "", handled = false, prevented = false, stopPropagation2 = false;
    if (storedPrefix && storedPrefix.view == view2 && storedPrefix.scope == scope) {
      prefix = storedPrefix.prefix + " ";
      if (modifierCodes.indexOf(event.keyCode) < 0) {
        prevented = true;
        storedPrefix = null;
      }
    }
    let ran = /* @__PURE__ */ new Set();
    let runFor = (binding2) => {
      if (binding2) {
        for (let cmd of binding2.run)
          if (!ran.has(cmd)) {
            ran.add(cmd);
            if (cmd(view2)) {
              if (binding2.stopPropagation)
                stopPropagation2 = true;
              return true;
            }
          }
        if (binding2.preventDefault) {
          if (binding2.stopPropagation)
            stopPropagation2 = true;
          prevented = true;
        }
      }
      return false;
    };
    let scopeObj = map3[scope], baseName, shiftName;
    if (scopeObj) {
      if (runFor(scopeObj[prefix + modifiers(name3, event, !isChar)])) {
        handled = true;
      } else if (isChar && (event.altKey || event.metaKey || event.ctrlKey) && !(browser.windows && event.ctrlKey && event.altKey) && (baseName = base[event.keyCode]) && baseName != name3) {
        if (runFor(scopeObj[prefix + modifiers(baseName, event, true)])) {
          handled = true;
        } else if (event.shiftKey && (shiftName = shift[event.keyCode]) != name3 && shiftName != baseName && runFor(scopeObj[prefix + modifiers(shiftName, event, false)])) {
          handled = true;
        }
      } else if (isChar && event.shiftKey && runFor(scopeObj[prefix + modifiers(name3, event, true)])) {
        handled = true;
      }
      if (!handled && runFor(scopeObj._any))
        handled = true;
    }
    if (prevented)
      handled = true;
    if (handled && stopPropagation2)
      event.stopPropagation();
    currentKeyEvent = null;
    return handled;
  }
  var CanHidePrimary = !browser.ios;
  var themeSpec = {
    ".cm-line": {
      "& ::selection, &::selection": { backgroundColor: "transparent !important" }
    },
    ".cm-content": {
      "& :focus": {
        caretColor: "initial !important",
        "&::selection, & ::selection": {
          backgroundColor: "Highlight !important"
        }
      }
    }
  };
  if (CanHidePrimary)
    themeSpec[".cm-line"].caretColor = themeSpec[".cm-content"].caretColor = "transparent !important";
  var UnicodeRegexpSupport = /x/.unicode != null ? "gu" : "g";
  var baseTheme = /* @__PURE__ */ EditorView.baseTheme({
    ".cm-tooltip": {
      zIndex: 100,
      boxSizing: "border-box"
    },
    "&light .cm-tooltip": {
      border: "1px solid #bbb",
      backgroundColor: "#f5f5f5"
    },
    "&light .cm-tooltip-section:not(:first-child)": {
      borderTop: "1px solid #bbb"
    },
    "&dark .cm-tooltip": {
      backgroundColor: "#333338",
      color: "white"
    },
    ".cm-tooltip-arrow": {
      height: `${7}px`,
      width: `${7 * 2}px`,
      position: "absolute",
      zIndex: -1,
      overflow: "hidden",
      "&:before, &:after": {
        content: "''",
        position: "absolute",
        width: 0,
        height: 0,
        borderLeft: `${7}px solid transparent`,
        borderRight: `${7}px solid transparent`
      },
      ".cm-tooltip-above &": {
        bottom: `-${7}px`,
        "&:before": {
          borderTop: `${7}px solid #bbb`
        },
        "&:after": {
          borderTop: `${7}px solid #f5f5f5`,
          bottom: "1px"
        }
      },
      ".cm-tooltip-below &": {
        top: `-${7}px`,
        "&:before": {
          borderBottom: `${7}px solid #bbb`
        },
        "&:after": {
          borderBottom: `${7}px solid #f5f5f5`,
          top: "1px"
        }
      }
    },
    "&dark .cm-tooltip .cm-tooltip-arrow": {
      "&:before": {
        borderTopColor: "#333338",
        borderBottomColor: "#333338"
      },
      "&:after": {
        borderTopColor: "transparent",
        borderBottomColor: "transparent"
      }
    }
  });
  var GutterMarker = class extends RangeValue {
    compare(other) {
      return this == other || this.constructor == other.constructor && this.eq(other);
    }
    eq(other) {
      return false;
    }
    destroy(dom) {
    }
  };
  GutterMarker.prototype.elementClass = "";
  GutterMarker.prototype.toDOM = void 0;
  GutterMarker.prototype.mapMode = MapMode.TrackBefore;
  GutterMarker.prototype.startSide = GutterMarker.prototype.endSide = -1;
  GutterMarker.prototype.point = true;

  // node_modules/@lezer/common/dist/index.js
  var DefaultBufferLength = 1024;
  var nextPropID = 0;
  var Range2 = class {
    constructor(from, to) {
      this.from = from;
      this.to = to;
    }
  };
  var NodeProp = class {
    constructor(config = {}) {
      this.id = nextPropID++;
      this.perNode = !!config.perNode;
      this.deserialize = config.deserialize || (() => {
        throw new Error("This node type doesn't define a deserialize function");
      });
    }
    add(match4) {
      if (this.perNode)
        throw new RangeError("Can't add per-node props to node types");
      if (typeof match4 != "function")
        match4 = NodeType.match(match4);
      return (type2) => {
        let result = match4(type2);
        return result === void 0 ? null : [this, result];
      };
    }
  };
  NodeProp.closedBy = new NodeProp({ deserialize: (str) => str.split(" ") });
  NodeProp.openedBy = new NodeProp({ deserialize: (str) => str.split(" ") });
  NodeProp.group = new NodeProp({ deserialize: (str) => str.split(" ") });
  NodeProp.isolate = new NodeProp({ deserialize: (value) => {
    if (value && value != "rtl" && value != "ltr" && value != "auto")
      throw new RangeError("Invalid value for isolate: " + value);
    return value || "auto";
  } });
  NodeProp.contextHash = new NodeProp({ perNode: true });
  NodeProp.lookAhead = new NodeProp({ perNode: true });
  NodeProp.mounted = new NodeProp({ perNode: true });
  var MountedTree = class {
    constructor(tree, overlay, parser) {
      this.tree = tree;
      this.overlay = overlay;
      this.parser = parser;
    }
    static get(tree) {
      return tree && tree.props && tree.props[NodeProp.mounted.id];
    }
  };
  var noProps = /* @__PURE__ */ Object.create(null);
  var NodeType = class {
    constructor(name3, props, id3, flags = 0) {
      this.name = name3;
      this.props = props;
      this.id = id3;
      this.flags = flags;
    }
    static define(spec) {
      let props = spec.props && spec.props.length ? /* @__PURE__ */ Object.create(null) : noProps;
      let flags = (spec.top ? 1 : 0) | (spec.skipped ? 2 : 0) | (spec.error ? 4 : 0) | (spec.name == null ? 8 : 0);
      let type2 = new NodeType(spec.name || "", props, spec.id, flags);
      if (spec.props)
        for (let src of spec.props) {
          if (!Array.isArray(src))
            src = src(type2);
          if (src) {
            if (src[0].perNode)
              throw new RangeError("Can't store a per-node prop on a node type");
            props[src[0].id] = src[1];
          }
        }
      return type2;
    }
    prop(prop) {
      return this.props[prop.id];
    }
    get isTop() {
      return (this.flags & 1) > 0;
    }
    get isSkipped() {
      return (this.flags & 2) > 0;
    }
    get isError() {
      return (this.flags & 4) > 0;
    }
    get isAnonymous() {
      return (this.flags & 8) > 0;
    }
    is(name3) {
      if (typeof name3 == "string") {
        if (this.name == name3)
          return true;
        let group3 = this.prop(NodeProp.group);
        return group3 ? group3.indexOf(name3) > -1 : false;
      }
      return this.id == name3;
    }
    static match(map3) {
      let direct = /* @__PURE__ */ Object.create(null);
      for (let prop in map3)
        for (let name3 of prop.split(" "))
          direct[name3] = map3[prop];
      return (node2) => {
        for (let groups = node2.prop(NodeProp.group), i = -1; i < (groups ? groups.length : 0); i++) {
          let found = direct[i < 0 ? node2.name : groups[i]];
          if (found)
            return found;
        }
      };
    }
  };
  NodeType.none = new NodeType("", /* @__PURE__ */ Object.create(null), 0, 8);
  var CachedNode = /* @__PURE__ */ new WeakMap();
  var CachedInnerNode = /* @__PURE__ */ new WeakMap();
  var IterMode;
  (function(IterMode2) {
    IterMode2[IterMode2["ExcludeBuffers"] = 1] = "ExcludeBuffers";
    IterMode2[IterMode2["IncludeAnonymous"] = 2] = "IncludeAnonymous";
    IterMode2[IterMode2["IgnoreMounts"] = 4] = "IgnoreMounts";
    IterMode2[IterMode2["IgnoreOverlays"] = 8] = "IgnoreOverlays";
  })(IterMode || (IterMode = {}));
  var Tree = class {
    constructor(type2, children2, positions, length6, props) {
      this.type = type2;
      this.children = children2;
      this.positions = positions;
      this.length = length6;
      this.props = null;
      if (props && props.length) {
        this.props = /* @__PURE__ */ Object.create(null);
        for (let [prop, value] of props)
          this.props[typeof prop == "number" ? prop : prop.id] = value;
      }
    }
    toString() {
      let mounted = MountedTree.get(this);
      if (mounted && !mounted.overlay)
        return mounted.tree.toString();
      let children2 = "";
      for (let ch of this.children) {
        let str = ch.toString();
        if (str) {
          if (children2)
            children2 += ",";
          children2 += str;
        }
      }
      return !this.type.name ? children2 : (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (children2.length ? "(" + children2 + ")" : "");
    }
    cursor(mode = 0) {
      return new TreeCursor(this.topNode, mode);
    }
    cursorAt(pos, side = 0, mode = 0) {
      let scope = CachedNode.get(this) || this.topNode;
      let cursor = new TreeCursor(scope);
      cursor.moveTo(pos, side);
      CachedNode.set(this, cursor._tree);
      return cursor;
    }
    get topNode() {
      return new TreeNode(this, 0, 0, null);
    }
    resolve(pos, side = 0) {
      let node2 = resolveNode(CachedNode.get(this) || this.topNode, pos, side, false);
      CachedNode.set(this, node2);
      return node2;
    }
    resolveInner(pos, side = 0) {
      let node2 = resolveNode(CachedInnerNode.get(this) || this.topNode, pos, side, true);
      CachedInnerNode.set(this, node2);
      return node2;
    }
    resolveStack(pos, side = 0) {
      return stackIterator(this, pos, side);
    }
    iterate(spec) {
      let { enter, leave, from = 0, to = this.length } = spec;
      let mode = spec.mode || 0, anon2 = (mode & IterMode.IncludeAnonymous) > 0;
      for (let c = this.cursor(mode | IterMode.IncludeAnonymous); ; ) {
        let entered = false;
        if (c.from <= to && c.to >= from && (!anon2 && c.type.isAnonymous || enter(c) !== false)) {
          if (c.firstChild())
            continue;
          entered = true;
        }
        for (; ; ) {
          if (entered && leave && (anon2 || !c.type.isAnonymous))
            leave(c);
          if (c.nextSibling())
            break;
          if (!c.parent())
            return;
          entered = true;
        }
      }
    }
    prop(prop) {
      return !prop.perNode ? this.type.prop(prop) : this.props ? this.props[prop.id] : void 0;
    }
    get propValues() {
      let result = [];
      if (this.props)
        for (let id3 in this.props)
          result.push([+id3, this.props[id3]]);
      return result;
    }
    balance(config = {}) {
      return this.children.length <= 8 ? this : balanceRange(NodeType.none, this.children, this.positions, 0, this.children.length, 0, this.length, (children2, positions, length6) => new Tree(this.type, children2, positions, length6, this.propValues), config.makeTree || ((children2, positions, length6) => new Tree(NodeType.none, children2, positions, length6)));
    }
    static build(data) {
      return buildTree(data);
    }
  };
  Tree.empty = new Tree(NodeType.none, [], [], 0);
  var FlatBufferCursor = class {
    constructor(buffer, index3) {
      this.buffer = buffer;
      this.index = index3;
    }
    get id() {
      return this.buffer[this.index - 4];
    }
    get start() {
      return this.buffer[this.index - 3];
    }
    get end() {
      return this.buffer[this.index - 2];
    }
    get size() {
      return this.buffer[this.index - 1];
    }
    get pos() {
      return this.index;
    }
    next() {
      this.index -= 4;
    }
    fork() {
      return new FlatBufferCursor(this.buffer, this.index);
    }
  };
  var TreeBuffer = class {
    constructor(buffer, length6, set3) {
      this.buffer = buffer;
      this.length = length6;
      this.set = set3;
    }
    get type() {
      return NodeType.none;
    }
    toString() {
      let result = [];
      for (let index3 = 0; index3 < this.buffer.length; ) {
        result.push(this.childString(index3));
        index3 = this.buffer[index3 + 3];
      }
      return result.join(",");
    }
    childString(index3) {
      let id3 = this.buffer[index3], endIndex = this.buffer[index3 + 3];
      let type2 = this.set.types[id3], result = type2.name;
      if (/\W/.test(result) && !type2.isError)
        result = JSON.stringify(result);
      index3 += 4;
      if (endIndex == index3)
        return result;
      let children2 = [];
      while (index3 < endIndex) {
        children2.push(this.childString(index3));
        index3 = this.buffer[index3 + 3];
      }
      return result + "(" + children2.join(",") + ")";
    }
    findChild(startIndex, endIndex, dir, pos, side) {
      let { buffer } = this, pick = -1;
      for (let i = startIndex; i != endIndex; i = buffer[i + 3]) {
        if (checkSide(side, pos, buffer[i + 1], buffer[i + 2])) {
          pick = i;
          if (dir > 0)
            break;
        }
      }
      return pick;
    }
    slice(startI, endI, from) {
      let b = this.buffer;
      let copy2 = new Uint16Array(endI - startI), len = 0;
      for (let i = startI, j = 0; i < endI; ) {
        copy2[j++] = b[i++];
        copy2[j++] = b[i++] - from;
        let to = copy2[j++] = b[i++] - from;
        copy2[j++] = b[i++] - startI;
        len = Math.max(len, to);
      }
      return new TreeBuffer(copy2, len, this.set);
    }
  };
  function checkSide(side, pos, from, to) {
    switch (side) {
      case -2:
        return from < pos;
      case -1:
        return to >= pos && from < pos;
      case 0:
        return from < pos && to > pos;
      case 1:
        return from <= pos && to > pos;
      case 2:
        return to > pos;
      case 4:
        return true;
    }
  }
  function resolveNode(node2, pos, side, overlays) {
    var _a2;
    while (node2.from == node2.to || (side < 1 ? node2.from >= pos : node2.from > pos) || (side > -1 ? node2.to <= pos : node2.to < pos)) {
      let parent = !overlays && node2 instanceof TreeNode && node2.index < 0 ? null : node2.parent;
      if (!parent)
        return node2;
      node2 = parent;
    }
    let mode = overlays ? 0 : IterMode.IgnoreOverlays;
    if (overlays)
      for (let scan = node2, parent = scan.parent; parent; scan = parent, parent = scan.parent) {
        if (scan instanceof TreeNode && scan.index < 0 && ((_a2 = parent.enter(pos, side, mode)) === null || _a2 === void 0 ? void 0 : _a2.from) != scan.from)
          node2 = parent;
      }
    for (; ; ) {
      let inner = node2.enter(pos, side, mode);
      if (!inner)
        return node2;
      node2 = inner;
    }
  }
  var BaseNode = class {
    cursor(mode = 0) {
      return new TreeCursor(this, mode);
    }
    getChild(type2, before = null, after = null) {
      let r = getChildren(this, type2, before, after);
      return r.length ? r[0] : null;
    }
    getChildren(type2, before = null, after = null) {
      return getChildren(this, type2, before, after);
    }
    resolve(pos, side = 0) {
      return resolveNode(this, pos, side, false);
    }
    resolveInner(pos, side = 0) {
      return resolveNode(this, pos, side, true);
    }
    matchContext(context) {
      return matchNodeContext(this, context);
    }
    enterUnfinishedNodesBefore(pos) {
      let scan = this.childBefore(pos), node2 = this;
      while (scan) {
        let last3 = scan.lastChild;
        if (!last3 || last3.to != scan.to)
          break;
        if (last3.type.isError && last3.from == last3.to) {
          node2 = scan;
          scan = last3.prevSibling;
        } else {
          scan = last3;
        }
      }
      return node2;
    }
    get node() {
      return this;
    }
    get next() {
      return this.parent;
    }
  };
  var TreeNode = class extends BaseNode {
    constructor(_tree, from, index3, _parent) {
      super();
      this._tree = _tree;
      this.from = from;
      this.index = index3;
      this._parent = _parent;
    }
    get type() {
      return this._tree.type;
    }
    get name() {
      return this._tree.type.name;
    }
    get to() {
      return this.from + this._tree.length;
    }
    nextChild(i, dir, pos, side, mode = 0) {
      for (let parent = this; ; ) {
        for (let { children: children2, positions } = parent._tree, e = dir > 0 ? children2.length : -1; i != e; i += dir) {
          let next = children2[i], start2 = positions[i] + parent.from;
          if (!checkSide(side, pos, start2, start2 + next.length))
            continue;
          if (next instanceof TreeBuffer) {
            if (mode & IterMode.ExcludeBuffers)
              continue;
            let index3 = next.findChild(0, next.buffer.length, dir, pos - start2, side);
            if (index3 > -1)
              return new BufferNode(new BufferContext(parent, next, i, start2), null, index3);
          } else if (mode & IterMode.IncludeAnonymous || (!next.type.isAnonymous || hasChild(next))) {
            let mounted;
            if (!(mode & IterMode.IgnoreMounts) && (mounted = MountedTree.get(next)) && !mounted.overlay)
              return new TreeNode(mounted.tree, start2, i, parent);
            let inner = new TreeNode(next, start2, i, parent);
            return mode & IterMode.IncludeAnonymous || !inner.type.isAnonymous ? inner : inner.nextChild(dir < 0 ? next.children.length - 1 : 0, dir, pos, side);
          }
        }
        if (mode & IterMode.IncludeAnonymous || !parent.type.isAnonymous)
          return null;
        if (parent.index >= 0)
          i = parent.index + dir;
        else
          i = dir < 0 ? -1 : parent._parent._tree.children.length;
        parent = parent._parent;
        if (!parent)
          return null;
      }
    }
    get firstChild() {
      return this.nextChild(0, 1, 0, 4);
    }
    get lastChild() {
      return this.nextChild(this._tree.children.length - 1, -1, 0, 4);
    }
    childAfter(pos) {
      return this.nextChild(0, 1, pos, 2);
    }
    childBefore(pos) {
      return this.nextChild(this._tree.children.length - 1, -1, pos, -2);
    }
    enter(pos, side, mode = 0) {
      let mounted;
      if (!(mode & IterMode.IgnoreOverlays) && (mounted = MountedTree.get(this._tree)) && mounted.overlay) {
        let rPos = pos - this.from;
        for (let { from, to } of mounted.overlay) {
          if ((side > 0 ? from <= rPos : from < rPos) && (side < 0 ? to >= rPos : to > rPos))
            return new TreeNode(mounted.tree, mounted.overlay[0].from + this.from, -1, this);
        }
      }
      return this.nextChild(0, 1, pos, side, mode);
    }
    nextSignificantParent() {
      let val = this;
      while (val.type.isAnonymous && val._parent)
        val = val._parent;
      return val;
    }
    get parent() {
      return this._parent ? this._parent.nextSignificantParent() : null;
    }
    get nextSibling() {
      return this._parent && this.index >= 0 ? this._parent.nextChild(this.index + 1, 1, 0, 4) : null;
    }
    get prevSibling() {
      return this._parent && this.index >= 0 ? this._parent.nextChild(this.index - 1, -1, 0, 4) : null;
    }
    get tree() {
      return this._tree;
    }
    toTree() {
      return this._tree;
    }
    toString() {
      return this._tree.toString();
    }
  };
  function getChildren(node2, type2, before, after) {
    let cur = node2.cursor(), result = [];
    if (!cur.firstChild())
      return result;
    if (before != null)
      for (let found = false; !found; ) {
        found = cur.type.is(before);
        if (!cur.nextSibling())
          return result;
      }
    for (; ; ) {
      if (after != null && cur.type.is(after))
        return result;
      if (cur.type.is(type2))
        result.push(cur.node);
      if (!cur.nextSibling())
        return after == null ? result : [];
    }
  }
  function matchNodeContext(node2, context, i = context.length - 1) {
    for (let p = node2.parent; i >= 0; p = p.parent) {
      if (!p)
        return false;
      if (!p.type.isAnonymous) {
        if (context[i] && context[i] != p.name)
          return false;
        i--;
      }
    }
    return true;
  }
  var BufferContext = class {
    constructor(parent, buffer, index3, start2) {
      this.parent = parent;
      this.buffer = buffer;
      this.index = index3;
      this.start = start2;
    }
  };
  var BufferNode = class extends BaseNode {
    get name() {
      return this.type.name;
    }
    get from() {
      return this.context.start + this.context.buffer.buffer[this.index + 1];
    }
    get to() {
      return this.context.start + this.context.buffer.buffer[this.index + 2];
    }
    constructor(context, _parent, index3) {
      super();
      this.context = context;
      this._parent = _parent;
      this.index = index3;
      this.type = context.buffer.set.types[context.buffer.buffer[index3]];
    }
    child(dir, pos, side) {
      let { buffer } = this.context;
      let index3 = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.context.start, side);
      return index3 < 0 ? null : new BufferNode(this.context, this, index3);
    }
    get firstChild() {
      return this.child(1, 0, 4);
    }
    get lastChild() {
      return this.child(-1, 0, 4);
    }
    childAfter(pos) {
      return this.child(1, pos, 2);
    }
    childBefore(pos) {
      return this.child(-1, pos, -2);
    }
    enter(pos, side, mode = 0) {
      if (mode & IterMode.ExcludeBuffers)
        return null;
      let { buffer } = this.context;
      let index3 = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], side > 0 ? 1 : -1, pos - this.context.start, side);
      return index3 < 0 ? null : new BufferNode(this.context, this, index3);
    }
    get parent() {
      return this._parent || this.context.parent.nextSignificantParent();
    }
    externalSibling(dir) {
      return this._parent ? null : this.context.parent.nextChild(this.context.index + dir, dir, 0, 4);
    }
    get nextSibling() {
      let { buffer } = this.context;
      let after = buffer.buffer[this.index + 3];
      if (after < (this._parent ? buffer.buffer[this._parent.index + 3] : buffer.buffer.length))
        return new BufferNode(this.context, this._parent, after);
      return this.externalSibling(1);
    }
    get prevSibling() {
      let { buffer } = this.context;
      let parentStart = this._parent ? this._parent.index + 4 : 0;
      if (this.index == parentStart)
        return this.externalSibling(-1);
      return new BufferNode(this.context, this._parent, buffer.findChild(parentStart, this.index, -1, 0, 4));
    }
    get tree() {
      return null;
    }
    toTree() {
      let children2 = [], positions = [];
      let { buffer } = this.context;
      let startI = this.index + 4, endI = buffer.buffer[this.index + 3];
      if (endI > startI) {
        let from = buffer.buffer[this.index + 1];
        children2.push(buffer.slice(startI, endI, from));
        positions.push(0);
      }
      return new Tree(this.type, children2, positions, this.to - this.from);
    }
    toString() {
      return this.context.buffer.childString(this.index);
    }
  };
  function iterStack(heads) {
    if (!heads.length)
      return null;
    let pick = 0, picked = heads[0];
    for (let i = 1; i < heads.length; i++) {
      let node2 = heads[i];
      if (node2.from > picked.from || node2.to < picked.to) {
        picked = node2;
        pick = i;
      }
    }
    let next = picked instanceof TreeNode && picked.index < 0 ? null : picked.parent;
    let newHeads = heads.slice();
    if (next)
      newHeads[pick] = next;
    else
      newHeads.splice(pick, 1);
    return new StackIterator(newHeads, picked);
  }
  var StackIterator = class {
    constructor(heads, node2) {
      this.heads = heads;
      this.node = node2;
    }
    get next() {
      return iterStack(this.heads);
    }
  };
  function stackIterator(tree, pos, side) {
    let inner = tree.resolveInner(pos, side), layers = null;
    for (let scan = inner instanceof TreeNode ? inner : inner.context.parent; scan; scan = scan.parent) {
      if (scan.index < 0) {
        let parent = scan.parent;
        (layers || (layers = [inner])).push(parent.resolve(pos, side));
        scan = parent;
      } else {
        let mount = MountedTree.get(scan.tree);
        if (mount && mount.overlay && mount.overlay[0].from <= pos && mount.overlay[mount.overlay.length - 1].to >= pos) {
          let root2 = new TreeNode(mount.tree, mount.overlay[0].from + scan.from, -1, scan);
          (layers || (layers = [inner])).push(resolveNode(root2, pos, side, false));
        }
      }
    }
    return layers ? iterStack(layers) : inner;
  }
  var TreeCursor = class {
    get name() {
      return this.type.name;
    }
    constructor(node2, mode = 0) {
      this.mode = mode;
      this.buffer = null;
      this.stack = [];
      this.index = 0;
      this.bufferNode = null;
      if (node2 instanceof TreeNode) {
        this.yieldNode(node2);
      } else {
        this._tree = node2.context.parent;
        this.buffer = node2.context;
        for (let n = node2._parent; n; n = n._parent)
          this.stack.unshift(n.index);
        this.bufferNode = node2;
        this.yieldBuf(node2.index);
      }
    }
    yieldNode(node2) {
      if (!node2)
        return false;
      this._tree = node2;
      this.type = node2.type;
      this.from = node2.from;
      this.to = node2.to;
      return true;
    }
    yieldBuf(index3, type2) {
      this.index = index3;
      let { start: start2, buffer } = this.buffer;
      this.type = type2 || buffer.set.types[buffer.buffer[index3]];
      this.from = start2 + buffer.buffer[index3 + 1];
      this.to = start2 + buffer.buffer[index3 + 2];
      return true;
    }
    yield(node2) {
      if (!node2)
        return false;
      if (node2 instanceof TreeNode) {
        this.buffer = null;
        return this.yieldNode(node2);
      }
      this.buffer = node2.context;
      return this.yieldBuf(node2.index, node2.type);
    }
    toString() {
      return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
    }
    enterChild(dir, pos, side) {
      if (!this.buffer)
        return this.yield(this._tree.nextChild(dir < 0 ? this._tree._tree.children.length - 1 : 0, dir, pos, side, this.mode));
      let { buffer } = this.buffer;
      let index3 = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.buffer.start, side);
      if (index3 < 0)
        return false;
      this.stack.push(this.index);
      return this.yieldBuf(index3);
    }
    firstChild() {
      return this.enterChild(1, 0, 4);
    }
    lastChild() {
      return this.enterChild(-1, 0, 4);
    }
    childAfter(pos) {
      return this.enterChild(1, pos, 2);
    }
    childBefore(pos) {
      return this.enterChild(-1, pos, -2);
    }
    enter(pos, side, mode = this.mode) {
      if (!this.buffer)
        return this.yield(this._tree.enter(pos, side, mode));
      return mode & IterMode.ExcludeBuffers ? false : this.enterChild(1, pos, side);
    }
    parent() {
      if (!this.buffer)
        return this.yieldNode(this.mode & IterMode.IncludeAnonymous ? this._tree._parent : this._tree.parent);
      if (this.stack.length)
        return this.yieldBuf(this.stack.pop());
      let parent = this.mode & IterMode.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
      this.buffer = null;
      return this.yieldNode(parent);
    }
    sibling(dir) {
      if (!this.buffer)
        return !this._tree._parent ? false : this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + dir, dir, 0, 4, this.mode));
      let { buffer } = this.buffer, d = this.stack.length - 1;
      if (dir < 0) {
        let parentStart = d < 0 ? 0 : this.stack[d] + 4;
        if (this.index != parentStart)
          return this.yieldBuf(buffer.findChild(parentStart, this.index, -1, 0, 4));
      } else {
        let after = buffer.buffer[this.index + 3];
        if (after < (d < 0 ? buffer.buffer.length : buffer.buffer[this.stack[d] + 3]))
          return this.yieldBuf(after);
      }
      return d < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + dir, dir, 0, 4, this.mode)) : false;
    }
    nextSibling() {
      return this.sibling(1);
    }
    prevSibling() {
      return this.sibling(-1);
    }
    atLastNode(dir) {
      let index3, parent, { buffer } = this;
      if (buffer) {
        if (dir > 0) {
          if (this.index < buffer.buffer.buffer.length)
            return false;
        } else {
          for (let i = 0; i < this.index; i++)
            if (buffer.buffer.buffer[i + 3] < this.index)
              return false;
        }
        ({ index: index3, parent } = buffer);
      } else {
        ({ index: index3, _parent: parent } = this._tree);
      }
      for (; parent; { index: index3, _parent: parent } = parent) {
        if (index3 > -1)
          for (let i = index3 + dir, e = dir < 0 ? -1 : parent._tree.children.length; i != e; i += dir) {
            let child = parent._tree.children[i];
            if (this.mode & IterMode.IncludeAnonymous || child instanceof TreeBuffer || !child.type.isAnonymous || hasChild(child))
              return false;
          }
      }
      return true;
    }
    move(dir, enter) {
      if (enter && this.enterChild(dir, 0, 4))
        return true;
      for (; ; ) {
        if (this.sibling(dir))
          return true;
        if (this.atLastNode(dir) || !this.parent())
          return false;
      }
    }
    next(enter = true) {
      return this.move(1, enter);
    }
    prev(enter = true) {
      return this.move(-1, enter);
    }
    moveTo(pos, side = 0) {
      while (this.from == this.to || (side < 1 ? this.from >= pos : this.from > pos) || (side > -1 ? this.to <= pos : this.to < pos))
        if (!this.parent())
          break;
      while (this.enterChild(1, pos, side)) {
      }
      return this;
    }
    get node() {
      if (!this.buffer)
        return this._tree;
      let cache = this.bufferNode, result = null, depth = 0;
      if (cache && cache.context == this.buffer) {
        scan:
          for (let index3 = this.index, d = this.stack.length; d >= 0; ) {
            for (let c = cache; c; c = c._parent)
              if (c.index == index3) {
                if (index3 == this.index)
                  return c;
                result = c;
                depth = d + 1;
                break scan;
              }
            index3 = this.stack[--d];
          }
      }
      for (let i = depth; i < this.stack.length; i++)
        result = new BufferNode(this.buffer, result, this.stack[i]);
      return this.bufferNode = new BufferNode(this.buffer, result, this.index);
    }
    get tree() {
      return this.buffer ? null : this._tree._tree;
    }
    iterate(enter, leave) {
      for (let depth = 0; ; ) {
        let mustLeave = false;
        if (this.type.isAnonymous || enter(this) !== false) {
          if (this.firstChild()) {
            depth++;
            continue;
          }
          if (!this.type.isAnonymous)
            mustLeave = true;
        }
        for (; ; ) {
          if (mustLeave && leave)
            leave(this);
          mustLeave = this.type.isAnonymous;
          if (this.nextSibling())
            break;
          if (!depth)
            return;
          this.parent();
          depth--;
          mustLeave = true;
        }
      }
    }
    matchContext(context) {
      if (!this.buffer)
        return matchNodeContext(this.node, context);
      let { buffer } = this.buffer, { types: types2 } = buffer.set;
      for (let i = context.length - 1, d = this.stack.length - 1; i >= 0; d--) {
        if (d < 0)
          return matchNodeContext(this.node, context, i);
        let type2 = types2[buffer.buffer[this.stack[d]]];
        if (!type2.isAnonymous) {
          if (context[i] && context[i] != type2.name)
            return false;
          i--;
        }
      }
      return true;
    }
  };
  function hasChild(tree) {
    return tree.children.some((ch) => ch instanceof TreeBuffer || !ch.type.isAnonymous || hasChild(ch));
  }
  function buildTree(data) {
    var _a2;
    let { buffer, nodeSet, maxBufferLength = DefaultBufferLength, reused = [], minRepeatType = nodeSet.types.length } = data;
    let cursor = Array.isArray(buffer) ? new FlatBufferCursor(buffer, buffer.length) : buffer;
    let types2 = nodeSet.types;
    let contextHash = 0, lookAhead = 0;
    function takeNode(parentStart, minPos, children3, positions2, inRepeat, depth) {
      let { id: id3, start: start2, end, size: size3 } = cursor;
      let lookAheadAtStart = lookAhead;
      while (size3 < 0) {
        cursor.next();
        if (size3 == -1) {
          let node3 = reused[id3];
          children3.push(node3);
          positions2.push(start2 - parentStart);
          return;
        } else if (size3 == -3) {
          contextHash = id3;
          return;
        } else if (size3 == -4) {
          lookAhead = id3;
          return;
        } else {
          throw new RangeError(`Unrecognized record size: ${size3}`);
        }
      }
      let type2 = types2[id3], node2, buffer2;
      let startPos = start2 - parentStart;
      if (end - start2 <= maxBufferLength && (buffer2 = findBufferSize(cursor.pos - minPos, inRepeat))) {
        let data2 = new Uint16Array(buffer2.size - buffer2.skip);
        let endPos = cursor.pos - buffer2.size, index3 = data2.length;
        while (cursor.pos > endPos)
          index3 = copyToBuffer(buffer2.start, data2, index3);
        node2 = new TreeBuffer(data2, end - buffer2.start, nodeSet);
        startPos = buffer2.start - parentStart;
      } else {
        let endPos = cursor.pos - size3;
        cursor.next();
        let localChildren = [], localPositions = [];
        let localInRepeat = id3 >= minRepeatType ? id3 : -1;
        let lastGroup = 0, lastEnd = end;
        while (cursor.pos > endPos) {
          if (localInRepeat >= 0 && cursor.id == localInRepeat && cursor.size >= 0) {
            if (cursor.end <= lastEnd - maxBufferLength) {
              makeRepeatLeaf(localChildren, localPositions, start2, lastGroup, cursor.end, lastEnd, localInRepeat, lookAheadAtStart);
              lastGroup = localChildren.length;
              lastEnd = cursor.end;
            }
            cursor.next();
          } else if (depth > 2500) {
            takeFlatNode(start2, endPos, localChildren, localPositions);
          } else {
            takeNode(start2, endPos, localChildren, localPositions, localInRepeat, depth + 1);
          }
        }
        if (localInRepeat >= 0 && lastGroup > 0 && lastGroup < localChildren.length)
          makeRepeatLeaf(localChildren, localPositions, start2, lastGroup, start2, lastEnd, localInRepeat, lookAheadAtStart);
        localChildren.reverse();
        localPositions.reverse();
        if (localInRepeat > -1 && lastGroup > 0) {
          let make = makeBalanced(type2);
          node2 = balanceRange(type2, localChildren, localPositions, 0, localChildren.length, 0, end - start2, make, make);
        } else {
          node2 = makeTree(type2, localChildren, localPositions, end - start2, lookAheadAtStart - end);
        }
      }
      children3.push(node2);
      positions2.push(startPos);
    }
    function takeFlatNode(parentStart, minPos, children3, positions2) {
      let nodes = [];
      let nodeCount = 0, stopAt = -1;
      while (cursor.pos > minPos) {
        let { id: id3, start: start2, end, size: size3 } = cursor;
        if (size3 > 4) {
          cursor.next();
        } else if (stopAt > -1 && start2 < stopAt) {
          break;
        } else {
          if (stopAt < 0)
            stopAt = end - maxBufferLength;
          nodes.push(id3, start2, end);
          nodeCount++;
          cursor.next();
        }
      }
      if (nodeCount) {
        let buffer2 = new Uint16Array(nodeCount * 4);
        let start2 = nodes[nodes.length - 2];
        for (let i = nodes.length - 3, j = 0; i >= 0; i -= 3) {
          buffer2[j++] = nodes[i];
          buffer2[j++] = nodes[i + 1] - start2;
          buffer2[j++] = nodes[i + 2] - start2;
          buffer2[j++] = j;
        }
        children3.push(new TreeBuffer(buffer2, nodes[2] - start2, nodeSet));
        positions2.push(start2 - parentStart);
      }
    }
    function makeBalanced(type2) {
      return (children3, positions2, length7) => {
        let lookAhead2 = 0, lastI = children3.length - 1, last3, lookAheadProp;
        if (lastI >= 0 && (last3 = children3[lastI]) instanceof Tree) {
          if (!lastI && last3.type == type2 && last3.length == length7)
            return last3;
          if (lookAheadProp = last3.prop(NodeProp.lookAhead))
            lookAhead2 = positions2[lastI] + last3.length + lookAheadProp;
        }
        return makeTree(type2, children3, positions2, length7, lookAhead2);
      };
    }
    function makeRepeatLeaf(children3, positions2, base2, i, from, to, type2, lookAhead2) {
      let localChildren = [], localPositions = [];
      while (children3.length > i) {
        localChildren.push(children3.pop());
        localPositions.push(positions2.pop() + base2 - from);
      }
      children3.push(makeTree(nodeSet.types[type2], localChildren, localPositions, to - from, lookAhead2 - to));
      positions2.push(from - base2);
    }
    function makeTree(type2, children3, positions2, length7, lookAhead2 = 0, props) {
      if (contextHash) {
        let pair = [NodeProp.contextHash, contextHash];
        props = props ? [pair].concat(props) : [pair];
      }
      if (lookAhead2 > 25) {
        let pair = [NodeProp.lookAhead, lookAhead2];
        props = props ? [pair].concat(props) : [pair];
      }
      return new Tree(type2, children3, positions2, length7, props);
    }
    function findBufferSize(maxSize, inRepeat) {
      let fork = cursor.fork();
      let size3 = 0, start2 = 0, skip = 0, minStart = fork.end - maxBufferLength;
      let result = { size: 0, start: 0, skip: 0 };
      scan:
        for (let minPos = fork.pos - maxSize; fork.pos > minPos; ) {
          let nodeSize2 = fork.size;
          if (fork.id == inRepeat && nodeSize2 >= 0) {
            result.size = size3;
            result.start = start2;
            result.skip = skip;
            skip += 4;
            size3 += 4;
            fork.next();
            continue;
          }
          let startPos = fork.pos - nodeSize2;
          if (nodeSize2 < 0 || startPos < minPos || fork.start < minStart)
            break;
          let localSkipped = fork.id >= minRepeatType ? 4 : 0;
          let nodeStart = fork.start;
          fork.next();
          while (fork.pos > startPos) {
            if (fork.size < 0) {
              if (fork.size == -3)
                localSkipped += 4;
              else
                break scan;
            } else if (fork.id >= minRepeatType) {
              localSkipped += 4;
            }
            fork.next();
          }
          start2 = nodeStart;
          size3 += nodeSize2;
          skip += localSkipped;
        }
      if (inRepeat < 0 || size3 == maxSize) {
        result.size = size3;
        result.start = start2;
        result.skip = skip;
      }
      return result.size > 4 ? result : void 0;
    }
    function copyToBuffer(bufferStart, buffer2, index3) {
      let { id: id3, start: start2, end, size: size3 } = cursor;
      cursor.next();
      if (size3 >= 0 && id3 < minRepeatType) {
        let startIndex = index3;
        if (size3 > 4) {
          let endPos = cursor.pos - (size3 - 4);
          while (cursor.pos > endPos)
            index3 = copyToBuffer(bufferStart, buffer2, index3);
        }
        buffer2[--index3] = startIndex;
        buffer2[--index3] = end - bufferStart;
        buffer2[--index3] = start2 - bufferStart;
        buffer2[--index3] = id3;
      } else if (size3 == -3) {
        contextHash = id3;
      } else if (size3 == -4) {
        lookAhead = id3;
      }
      return index3;
    }
    let children2 = [], positions = [];
    while (cursor.pos > 0)
      takeNode(data.start || 0, data.bufferStart || 0, children2, positions, -1, 0);
    let length6 = (_a2 = data.length) !== null && _a2 !== void 0 ? _a2 : children2.length ? positions[0] + children2[0].length : 0;
    return new Tree(types2[data.topID], children2.reverse(), positions.reverse(), length6);
  }
  var nodeSizeCache = /* @__PURE__ */ new WeakMap();
  function nodeSize(balanceType, node2) {
    if (!balanceType.isAnonymous || node2 instanceof TreeBuffer || node2.type != balanceType)
      return 1;
    let size3 = nodeSizeCache.get(node2);
    if (size3 == null) {
      size3 = 1;
      for (let child of node2.children) {
        if (child.type != balanceType || !(child instanceof Tree)) {
          size3 = 1;
          break;
        }
        size3 += nodeSize(balanceType, child);
      }
      nodeSizeCache.set(node2, size3);
    }
    return size3;
  }
  function balanceRange(balanceType, children2, positions, from, to, start2, length6, mkTop, mkTree) {
    let total = 0;
    for (let i = from; i < to; i++)
      total += nodeSize(balanceType, children2[i]);
    let maxChild = Math.ceil(total * 1.5 / 8);
    let localChildren = [], localPositions = [];
    function divide2(children3, positions2, from2, to2, offset) {
      for (let i = from2; i < to2; ) {
        let groupFrom = i, groupStart = positions2[i], groupSize = nodeSize(balanceType, children3[i]);
        i++;
        for (; i < to2; i++) {
          let nextSize = nodeSize(balanceType, children3[i]);
          if (groupSize + nextSize >= maxChild)
            break;
          groupSize += nextSize;
        }
        if (i == groupFrom + 1) {
          if (groupSize > maxChild) {
            let only = children3[groupFrom];
            divide2(only.children, only.positions, 0, only.children.length, positions2[groupFrom] + offset);
            continue;
          }
          localChildren.push(children3[groupFrom]);
        } else {
          let length7 = positions2[i - 1] + children3[i - 1].length - groupStart;
          localChildren.push(balanceRange(balanceType, children3, positions2, groupFrom, i, groupStart, length7, null, mkTree));
        }
        localPositions.push(groupStart + offset - start2);
      }
    }
    divide2(children2, positions, from, to, 0);
    return (mkTop || mkTree)(localChildren, localPositions, length6);
  }
  var TreeFragment = class {
    constructor(from, to, tree, offset, openStart = false, openEnd = false) {
      this.from = from;
      this.to = to;
      this.tree = tree;
      this.offset = offset;
      this.open = (openStart ? 1 : 0) | (openEnd ? 2 : 0);
    }
    get openStart() {
      return (this.open & 1) > 0;
    }
    get openEnd() {
      return (this.open & 2) > 0;
    }
    static addTree(tree, fragments = [], partial = false) {
      let result = [new TreeFragment(0, tree.length, tree, 0, false, partial)];
      for (let f of fragments)
        if (f.to > tree.length)
          result.push(f);
      return result;
    }
    static applyChanges(fragments, changes, minGap = 128) {
      if (!changes.length)
        return fragments;
      let result = [];
      let fI = 1, nextF = fragments.length ? fragments[0] : null;
      for (let cI = 0, pos = 0, off = 0; ; cI++) {
        let nextC = cI < changes.length ? changes[cI] : null;
        let nextPos = nextC ? nextC.fromA : 1e9;
        if (nextPos - pos >= minGap)
          while (nextF && nextF.from < nextPos) {
            let cut = nextF;
            if (pos >= cut.from || nextPos <= cut.to || off) {
              let fFrom = Math.max(cut.from, pos) - off, fTo = Math.min(cut.to, nextPos) - off;
              cut = fFrom >= fTo ? null : new TreeFragment(fFrom, fTo, cut.tree, cut.offset + off, cI > 0, !!nextC);
            }
            if (cut)
              result.push(cut);
            if (nextF.to > nextPos)
              break;
            nextF = fI < fragments.length ? fragments[fI++] : null;
          }
        if (!nextC)
          break;
        pos = nextC.toA;
        off = nextC.toA - nextC.toB;
      }
      return result;
    }
  };
  var Parser = class {
    startParse(input, fragments, ranges) {
      if (typeof input == "string")
        input = new StringInput(input);
      ranges = !ranges ? [new Range2(0, input.length)] : ranges.length ? ranges.map((r) => new Range2(r.from, r.to)) : [new Range2(0, 0)];
      return this.createParse(input, fragments || [], ranges);
    }
    parse(input, fragments, ranges) {
      let parse2 = this.startParse(input, fragments, ranges);
      for (; ; ) {
        let done = parse2.advance();
        if (done)
          return done;
      }
    }
  };
  var StringInput = class {
    constructor(string4) {
      this.string = string4;
    }
    get length() {
      return this.string.length;
    }
    chunk(from) {
      return this.string.slice(from);
    }
    get lineChunks() {
      return false;
    }
    read(from, to) {
      return this.string.slice(from, to);
    }
  };
  var stoppedInner = new NodeProp({ perNode: true });

  // node_modules/@lezer/highlight/dist/index.js
  var nextTagID = 0;
  var Tag = class {
    constructor(name3, set3, base2, modified) {
      this.name = name3;
      this.set = set3;
      this.base = base2;
      this.modified = modified;
      this.id = nextTagID++;
    }
    toString() {
      let { name: name3 } = this;
      for (let mod of this.modified)
        if (mod.name)
          name3 = `${mod.name}(${name3})`;
      return name3;
    }
    static define(nameOrParent, parent) {
      let name3 = typeof nameOrParent == "string" ? nameOrParent : "?";
      if (nameOrParent instanceof Tag)
        parent = nameOrParent;
      if (parent === null || parent === void 0 ? void 0 : parent.base)
        throw new Error("Can not derive from a modified tag");
      let tag = new Tag(name3, [], null, []);
      tag.set.push(tag);
      if (parent)
        for (let t2 of parent.set)
          tag.set.push(t2);
      return tag;
    }
    static defineModifier(name3) {
      let mod = new Modifier(name3);
      return (tag) => {
        if (tag.modified.indexOf(mod) > -1)
          return tag;
        return Modifier.get(tag.base || tag, tag.modified.concat(mod).sort((a, b) => a.id - b.id));
      };
    }
  };
  var nextModifierID = 0;
  var Modifier = class {
    constructor(name3) {
      this.name = name3;
      this.instances = [];
      this.id = nextModifierID++;
    }
    static get(base2, mods) {
      if (!mods.length)
        return base2;
      let exists = mods[0].instances.find((t2) => t2.base == base2 && sameArray2(mods, t2.modified));
      if (exists)
        return exists;
      let set3 = [], tag = new Tag(base2.name, set3, base2, mods);
      for (let m of mods)
        m.instances.push(tag);
      let configs = powerSet(mods);
      for (let parent of base2.set)
        if (!parent.modified.length)
          for (let config of configs)
            set3.push(Modifier.get(parent, config));
      return tag;
    }
  };
  function sameArray2(a, b) {
    return a.length == b.length && a.every((x2, i) => x2 == b[i]);
  }
  function powerSet(array2) {
    let sets = [[]];
    for (let i = 0; i < array2.length; i++) {
      for (let j = 0, e = sets.length; j < e; j++) {
        sets.push(sets[j].concat(array2[i]));
      }
    }
    return sets.sort((a, b) => b.length - a.length);
  }
  function styleTags(spec) {
    let byName = /* @__PURE__ */ Object.create(null);
    for (let prop in spec) {
      let tags2 = spec[prop];
      if (!Array.isArray(tags2))
        tags2 = [tags2];
      for (let part of prop.split(" "))
        if (part) {
          let pieces = [], mode = 2, rest = part;
          for (let pos = 0; ; ) {
            if (rest == "..." && pos > 0 && pos + 3 == part.length) {
              mode = 1;
              break;
            }
            let m = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(rest);
            if (!m)
              throw new RangeError("Invalid path: " + part);
            pieces.push(m[0] == "*" ? "" : m[0][0] == '"' ? JSON.parse(m[0]) : m[0]);
            pos += m[0].length;
            if (pos == part.length)
              break;
            let next = part[pos++];
            if (pos == part.length && next == "!") {
              mode = 0;
              break;
            }
            if (next != "/")
              throw new RangeError("Invalid path: " + part);
            rest = part.slice(pos);
          }
          let last3 = pieces.length - 1, inner = pieces[last3];
          if (!inner)
            throw new RangeError("Invalid path: " + part);
          let rule = new Rule(tags2, mode, last3 > 0 ? pieces.slice(0, last3) : null);
          byName[inner] = rule.sort(byName[inner]);
        }
    }
    return ruleNodeProp.add(byName);
  }
  var ruleNodeProp = new NodeProp();
  var Rule = class {
    constructor(tags2, mode, context, next) {
      this.tags = tags2;
      this.mode = mode;
      this.context = context;
      this.next = next;
    }
    get opaque() {
      return this.mode == 0;
    }
    get inherit() {
      return this.mode == 1;
    }
    sort(other) {
      if (!other || other.depth < this.depth) {
        this.next = other;
        return this;
      }
      other.next = this.sort(other.next);
      return other;
    }
    get depth() {
      return this.context ? this.context.length : 0;
    }
  };
  Rule.empty = new Rule([], 2, null);
  function tagHighlighter(tags2, options) {
    let map3 = /* @__PURE__ */ Object.create(null);
    for (let style of tags2) {
      if (!Array.isArray(style.tag))
        map3[style.tag.id] = style.class;
      else
        for (let tag of style.tag)
          map3[tag.id] = style.class;
    }
    let { scope, all: all2 = null } = options || {};
    return {
      style: (tags3) => {
        let cls = all2;
        for (let tag of tags3) {
          for (let sub of tag.set) {
            let tagClass = map3[sub.id];
            if (tagClass) {
              cls = cls ? cls + " " + tagClass : tagClass;
              break;
            }
          }
        }
        return cls;
      },
      scope
    };
  }
  var t = Tag.define;
  var comment = t();
  var name = t();
  var typeName = t(name);
  var propertyName = t(name);
  var literal = t();
  var string = t(literal);
  var number4 = t(literal);
  var content = t();
  var heading = t(content);
  var keyword = t();
  var operator = t();
  var punctuation = t();
  var bracket = t(punctuation);
  var meta = t();
  var tags = {
    comment,
    lineComment: t(comment),
    blockComment: t(comment),
    docComment: t(comment),
    name,
    variableName: t(name),
    typeName,
    tagName: t(typeName),
    propertyName,
    attributeName: t(propertyName),
    className: t(name),
    labelName: t(name),
    namespace: t(name),
    macroName: t(name),
    literal,
    string,
    docString: t(string),
    character: t(string),
    attributeValue: t(string),
    number: number4,
    integer: t(number4),
    float: t(number4),
    bool: t(literal),
    regexp: t(literal),
    escape: t(literal),
    color: t(literal),
    url: t(literal),
    keyword,
    self: t(keyword),
    null: t(keyword),
    atom: t(keyword),
    unit: t(keyword),
    modifier: t(keyword),
    operatorKeyword: t(keyword),
    controlKeyword: t(keyword),
    definitionKeyword: t(keyword),
    moduleKeyword: t(keyword),
    operator,
    derefOperator: t(operator),
    arithmeticOperator: t(operator),
    logicOperator: t(operator),
    bitwiseOperator: t(operator),
    compareOperator: t(operator),
    updateOperator: t(operator),
    definitionOperator: t(operator),
    typeOperator: t(operator),
    controlOperator: t(operator),
    punctuation,
    separator: t(punctuation),
    bracket,
    angleBracket: t(bracket),
    squareBracket: t(bracket),
    paren: t(bracket),
    brace: t(bracket),
    content,
    heading,
    heading1: t(heading),
    heading2: t(heading),
    heading3: t(heading),
    heading4: t(heading),
    heading5: t(heading),
    heading6: t(heading),
    contentSeparator: t(content),
    list: t(content),
    quote: t(content),
    emphasis: t(content),
    strong: t(content),
    link: t(content),
    monospace: t(content),
    strikethrough: t(content),
    inserted: t(),
    deleted: t(),
    changed: t(),
    invalid: t(),
    meta,
    documentMeta: t(meta),
    annotation: t(meta),
    processingInstruction: t(meta),
    definition: Tag.defineModifier("definition"),
    constant: Tag.defineModifier("constant"),
    function: Tag.defineModifier("function"),
    standard: Tag.defineModifier("standard"),
    local: Tag.defineModifier("local"),
    special: Tag.defineModifier("special")
  };
  for (let name3 in tags) {
    let val = tags[name3];
    if (val instanceof Tag)
      val.name = name3;
  }
  var classHighlighter = tagHighlighter([
    { tag: tags.link, class: "tok-link" },
    { tag: tags.heading, class: "tok-heading" },
    { tag: tags.emphasis, class: "tok-emphasis" },
    { tag: tags.strong, class: "tok-strong" },
    { tag: tags.keyword, class: "tok-keyword" },
    { tag: tags.atom, class: "tok-atom" },
    { tag: tags.bool, class: "tok-bool" },
    { tag: tags.url, class: "tok-url" },
    { tag: tags.labelName, class: "tok-labelName" },
    { tag: tags.inserted, class: "tok-inserted" },
    { tag: tags.deleted, class: "tok-deleted" },
    { tag: tags.literal, class: "tok-literal" },
    { tag: tags.string, class: "tok-string" },
    { tag: tags.number, class: "tok-number" },
    { tag: [tags.regexp, tags.escape, tags.special(tags.string)], class: "tok-string2" },
    { tag: tags.variableName, class: "tok-variableName" },
    { tag: tags.local(tags.variableName), class: "tok-variableName tok-local" },
    { tag: tags.definition(tags.variableName), class: "tok-variableName tok-definition" },
    { tag: tags.special(tags.variableName), class: "tok-variableName2" },
    { tag: tags.definition(tags.propertyName), class: "tok-propertyName tok-definition" },
    { tag: tags.typeName, class: "tok-typeName" },
    { tag: tags.namespace, class: "tok-namespace" },
    { tag: tags.className, class: "tok-className" },
    { tag: tags.macroName, class: "tok-macroName" },
    { tag: tags.propertyName, class: "tok-propertyName" },
    { tag: tags.operator, class: "tok-operator" },
    { tag: tags.comment, class: "tok-comment" },
    { tag: tags.meta, class: "tok-meta" },
    { tag: tags.invalid, class: "tok-invalid" },
    { tag: tags.punctuation, class: "tok-punctuation" }
  ]);

  // node_modules/@codemirror/language/dist/index.js
  var _a;
  var languageDataProp = /* @__PURE__ */ new NodeProp();
  var sublanguageProp = /* @__PURE__ */ new NodeProp();
  var Language = class {
    constructor(data, parser, extraExtensions = [], name3 = "") {
      this.data = data;
      this.name = name3;
      if (!EditorState.prototype.hasOwnProperty("tree"))
        Object.defineProperty(EditorState.prototype, "tree", { get() {
          return syntaxTree(this);
        } });
      this.parser = parser;
      this.extension = [
        language.of(this),
        EditorState.languageData.of((state, pos, side) => {
          let top3 = topNodeAt(state, pos, side), data2 = top3.type.prop(languageDataProp);
          if (!data2)
            return [];
          let base2 = state.facet(data2), sub = top3.type.prop(sublanguageProp);
          if (sub) {
            let innerNode = top3.resolve(pos - top3.from, side);
            for (let sublang of sub)
              if (sublang.test(innerNode, state)) {
                let data3 = state.facet(sublang.facet);
                return sublang.type == "replace" ? data3 : data3.concat(base2);
              }
          }
          return base2;
        })
      ].concat(extraExtensions);
    }
    isActiveAt(state, pos, side = -1) {
      return topNodeAt(state, pos, side).type.prop(languageDataProp) == this.data;
    }
    findRegions(state) {
      let lang = state.facet(language);
      if ((lang === null || lang === void 0 ? void 0 : lang.data) == this.data)
        return [{ from: 0, to: state.doc.length }];
      if (!lang || !lang.allowsNesting)
        return [];
      let result = [];
      let explore = (tree, from) => {
        if (tree.prop(languageDataProp) == this.data) {
          result.push({ from, to: from + tree.length });
          return;
        }
        let mount = tree.prop(NodeProp.mounted);
        if (mount) {
          if (mount.tree.prop(languageDataProp) == this.data) {
            if (mount.overlay)
              for (let r of mount.overlay)
                result.push({ from: r.from + from, to: r.to + from });
            else
              result.push({ from, to: from + tree.length });
            return;
          } else if (mount.overlay) {
            let size3 = result.length;
            explore(mount.tree, mount.overlay[0].from + from);
            if (result.length > size3)
              return;
          }
        }
        for (let i = 0; i < tree.children.length; i++) {
          let ch = tree.children[i];
          if (ch instanceof Tree)
            explore(ch, tree.positions[i] + from);
        }
      };
      explore(syntaxTree(state), 0);
      return result;
    }
    get allowsNesting() {
      return true;
    }
  };
  Language.setState = /* @__PURE__ */ StateEffect.define();
  function topNodeAt(state, pos, side) {
    let topLang = state.facet(language), tree = syntaxTree(state).topNode;
    if (!topLang || topLang.allowsNesting) {
      for (let node2 = tree; node2; node2 = node2.enter(pos, side, IterMode.ExcludeBuffers))
        if (node2.type.isTop)
          tree = node2;
    }
    return tree;
  }
  function syntaxTree(state) {
    let field3 = state.field(Language.state, false);
    return field3 ? field3.tree : Tree.empty;
  }
  var DocInput = class {
    constructor(doc2) {
      this.doc = doc2;
      this.cursorPos = 0;
      this.string = "";
      this.cursor = doc2.iter();
    }
    get length() {
      return this.doc.length;
    }
    syncTo(pos) {
      this.string = this.cursor.next(pos - this.cursorPos).value;
      this.cursorPos = pos + this.string.length;
      return this.cursorPos - this.string.length;
    }
    chunk(pos) {
      this.syncTo(pos);
      return this.string;
    }
    get lineChunks() {
      return true;
    }
    read(from, to) {
      let stringStart = this.cursorPos - this.string.length;
      if (from < stringStart || to >= this.cursorPos)
        return this.doc.sliceString(from, to);
      else
        return this.string.slice(from - stringStart, to - stringStart);
    }
  };
  var currentContext = null;
  var ParseContext = class {
    constructor(parser, state, fragments = [], tree, treeLen, viewport, skipped, scheduleOn) {
      this.parser = parser;
      this.state = state;
      this.fragments = fragments;
      this.tree = tree;
      this.treeLen = treeLen;
      this.viewport = viewport;
      this.skipped = skipped;
      this.scheduleOn = scheduleOn;
      this.parse = null;
      this.tempSkipped = [];
    }
    static create(parser, state, viewport) {
      return new ParseContext(parser, state, [], Tree.empty, 0, viewport, [], null);
    }
    startParse() {
      return this.parser.startParse(new DocInput(this.state.doc), this.fragments);
    }
    work(until, upto) {
      if (upto != null && upto >= this.state.doc.length)
        upto = void 0;
      if (this.tree != Tree.empty && this.isDone(upto !== null && upto !== void 0 ? upto : this.state.doc.length)) {
        this.takeTree();
        return true;
      }
      return this.withContext(() => {
        var _a2;
        if (typeof until == "number") {
          let endTime = Date.now() + until;
          until = () => Date.now() > endTime;
        }
        if (!this.parse)
          this.parse = this.startParse();
        if (upto != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > upto) && upto < this.state.doc.length)
          this.parse.stopAt(upto);
        for (; ; ) {
          let done = this.parse.advance();
          if (done) {
            this.fragments = this.withoutTempSkipped(TreeFragment.addTree(done, this.fragments, this.parse.stoppedAt != null));
            this.treeLen = (_a2 = this.parse.stoppedAt) !== null && _a2 !== void 0 ? _a2 : this.state.doc.length;
            this.tree = done;
            this.parse = null;
            if (this.treeLen < (upto !== null && upto !== void 0 ? upto : this.state.doc.length))
              this.parse = this.startParse();
            else
              return true;
          }
          if (until())
            return false;
        }
      });
    }
    takeTree() {
      let pos, tree;
      if (this.parse && (pos = this.parse.parsedPos) >= this.treeLen) {
        if (this.parse.stoppedAt == null || this.parse.stoppedAt > pos)
          this.parse.stopAt(pos);
        this.withContext(() => {
          while (!(tree = this.parse.advance())) {
          }
        });
        this.treeLen = pos;
        this.tree = tree;
        this.fragments = this.withoutTempSkipped(TreeFragment.addTree(this.tree, this.fragments, true));
        this.parse = null;
      }
    }
    withContext(f) {
      let prev = currentContext;
      currentContext = this;
      try {
        return f();
      } finally {
        currentContext = prev;
      }
    }
    withoutTempSkipped(fragments) {
      for (let r; r = this.tempSkipped.pop(); )
        fragments = cutFragments(fragments, r.from, r.to);
      return fragments;
    }
    changes(changes, newState) {
      let { fragments, tree, treeLen, viewport, skipped } = this;
      this.takeTree();
      if (!changes.empty) {
        let ranges = [];
        changes.iterChangedRanges((fromA, toA, fromB, toB) => ranges.push({ fromA, toA, fromB, toB }));
        fragments = TreeFragment.applyChanges(fragments, ranges);
        tree = Tree.empty;
        treeLen = 0;
        viewport = { from: changes.mapPos(viewport.from, -1), to: changes.mapPos(viewport.to, 1) };
        if (this.skipped.length) {
          skipped = [];
          for (let r of this.skipped) {
            let from = changes.mapPos(r.from, 1), to = changes.mapPos(r.to, -1);
            if (from < to)
              skipped.push({ from, to });
          }
        }
      }
      return new ParseContext(this.parser, newState, fragments, tree, treeLen, viewport, skipped, this.scheduleOn);
    }
    updateViewport(viewport) {
      if (this.viewport.from == viewport.from && this.viewport.to == viewport.to)
        return false;
      this.viewport = viewport;
      let startLen = this.skipped.length;
      for (let i = 0; i < this.skipped.length; i++) {
        let { from, to } = this.skipped[i];
        if (from < viewport.to && to > viewport.from) {
          this.fragments = cutFragments(this.fragments, from, to);
          this.skipped.splice(i--, 1);
        }
      }
      if (this.skipped.length >= startLen)
        return false;
      this.reset();
      return true;
    }
    reset() {
      if (this.parse) {
        this.takeTree();
        this.parse = null;
      }
    }
    skipUntilInView(from, to) {
      this.skipped.push({ from, to });
    }
    static getSkippingParser(until) {
      return new class extends Parser {
        createParse(input, fragments, ranges) {
          let from = ranges[0].from, to = ranges[ranges.length - 1].to;
          let parser = {
            parsedPos: from,
            advance() {
              let cx = currentContext;
              if (cx) {
                for (let r of ranges)
                  cx.tempSkipped.push(r);
                if (until)
                  cx.scheduleOn = cx.scheduleOn ? Promise.all([cx.scheduleOn, until]) : until;
              }
              this.parsedPos = to;
              return new Tree(NodeType.none, [], [], to - from);
            },
            stoppedAt: null,
            stopAt() {
            }
          };
          return parser;
        }
      }();
    }
    isDone(upto) {
      upto = Math.min(upto, this.state.doc.length);
      let frags = this.fragments;
      return this.treeLen >= upto && frags.length && frags[0].from == 0 && frags[0].to >= upto;
    }
    static get() {
      return currentContext;
    }
  };
  function cutFragments(fragments, from, to) {
    return TreeFragment.applyChanges(fragments, [{ fromA: from, toA: to, fromB: from, toB: to }]);
  }
  var LanguageState = class {
    constructor(context) {
      this.context = context;
      this.tree = context.tree;
    }
    apply(tr) {
      if (!tr.docChanged && this.tree == this.context.tree)
        return this;
      let newCx = this.context.changes(tr.changes, tr.state);
      let upto = this.context.treeLen == tr.startState.doc.length ? void 0 : Math.max(tr.changes.mapPos(this.context.treeLen), newCx.viewport.to);
      if (!newCx.work(20, upto))
        newCx.takeTree();
      return new LanguageState(newCx);
    }
    static init(state) {
      let vpTo = Math.min(3e3, state.doc.length);
      let parseState = ParseContext.create(state.facet(language).parser, state, { from: 0, to: vpTo });
      if (!parseState.work(20, vpTo))
        parseState.takeTree();
      return new LanguageState(parseState);
    }
  };
  Language.state = /* @__PURE__ */ StateField.define({
    create: LanguageState.init,
    update(value, tr) {
      for (let e of tr.effects)
        if (e.is(Language.setState))
          return e.value;
      if (tr.startState.facet(language) != tr.state.facet(language))
        return LanguageState.init(tr.state);
      return value.apply(tr);
    }
  });
  var requestIdle = (callback) => {
    let timeout2 = setTimeout(() => callback(), 500);
    return () => clearTimeout(timeout2);
  };
  if (typeof requestIdleCallback != "undefined")
    requestIdle = (callback) => {
      let idle = -1, timeout2 = setTimeout(() => {
        idle = requestIdleCallback(callback, { timeout: 500 - 100 });
      }, 100);
      return () => idle < 0 ? clearTimeout(timeout2) : cancelIdleCallback(idle);
    };
  var isInputPending = typeof navigator != "undefined" && ((_a = navigator.scheduling) === null || _a === void 0 ? void 0 : _a.isInputPending) ? () => navigator.scheduling.isInputPending() : null;
  var parseWorker = /* @__PURE__ */ ViewPlugin.fromClass(class ParseWorker {
    constructor(view2) {
      this.view = view2;
      this.working = null;
      this.workScheduled = 0;
      this.chunkEnd = -1;
      this.chunkBudget = -1;
      this.work = this.work.bind(this);
      this.scheduleWork();
    }
    update(update3) {
      let cx = this.view.state.field(Language.state).context;
      if (cx.updateViewport(update3.view.viewport) || this.view.viewport.to > cx.treeLen)
        this.scheduleWork();
      if (update3.docChanged || update3.selectionSet) {
        if (this.view.hasFocus)
          this.chunkBudget += 50;
        this.scheduleWork();
      }
      this.checkAsyncSchedule(cx);
    }
    scheduleWork() {
      if (this.working)
        return;
      let { state } = this.view, field3 = state.field(Language.state);
      if (field3.tree != field3.context.tree || !field3.context.isDone(state.doc.length))
        this.working = requestIdle(this.work);
    }
    work(deadline) {
      this.working = null;
      let now3 = Date.now();
      if (this.chunkEnd < now3 && (this.chunkEnd < 0 || this.view.hasFocus)) {
        this.chunkEnd = now3 + 3e4;
        this.chunkBudget = 3e3;
      }
      if (this.chunkBudget <= 0)
        return;
      let { state, viewport: { to: vpTo } } = this.view, field3 = state.field(Language.state);
      if (field3.tree == field3.context.tree && field3.context.isDone(vpTo + 1e5))
        return;
      let endTime = Date.now() + Math.min(this.chunkBudget, 100, deadline && !isInputPending ? Math.max(25, deadline.timeRemaining() - 5) : 1e9);
      let viewportFirst = field3.context.treeLen < vpTo && state.doc.length > vpTo + 1e3;
      let done = field3.context.work(() => {
        return isInputPending && isInputPending() || Date.now() > endTime;
      }, vpTo + (viewportFirst ? 0 : 1e5));
      this.chunkBudget -= Date.now() - now3;
      if (done || this.chunkBudget <= 0) {
        field3.context.takeTree();
        this.view.dispatch({ effects: Language.setState.of(new LanguageState(field3.context)) });
      }
      if (this.chunkBudget > 0 && !(done && !viewportFirst))
        this.scheduleWork();
      this.checkAsyncSchedule(field3.context);
    }
    checkAsyncSchedule(cx) {
      if (cx.scheduleOn) {
        this.workScheduled++;
        cx.scheduleOn.then(() => this.scheduleWork()).catch((err) => logException(this.view.state, err)).then(() => this.workScheduled--);
        cx.scheduleOn = null;
      }
    }
    destroy() {
      if (this.working)
        this.working();
    }
    isWorking() {
      return !!(this.working || this.workScheduled > 0);
    }
  }, {
    eventHandlers: { focus() {
      this.scheduleWork();
    } }
  });
  var language = /* @__PURE__ */ Facet.define({
    combine(languages) {
      return languages.length ? languages[0] : null;
    },
    enables: (language2) => [
      Language.state,
      parseWorker,
      EditorView.contentAttributes.compute([language2], (state) => {
        let lang = state.facet(language2);
        return lang && lang.name ? { "data-language": lang.name } : {};
      })
    ]
  });
  var indentService = /* @__PURE__ */ Facet.define();
  var indentUnit = /* @__PURE__ */ Facet.define({
    combine: (values3) => {
      if (!values3.length)
        return "  ";
      let unit2 = values3[0];
      if (!unit2 || /\S/.test(unit2) || Array.from(unit2).some((e) => e != unit2[0]))
        throw new Error("Invalid indent unit: " + JSON.stringify(values3[0]));
      return unit2;
    }
  });
  function getIndentUnit(state) {
    let unit2 = state.facet(indentUnit);
    return unit2.charCodeAt(0) == 9 ? state.tabSize * unit2.length : unit2.length;
  }
  function indentString(state, cols) {
    let result = "", ts = state.tabSize, ch = state.facet(indentUnit)[0];
    if (ch == "	") {
      while (cols >= ts) {
        result += "	";
        cols -= ts;
      }
      ch = " ";
    }
    for (let i = 0; i < cols; i++)
      result += ch;
    return result;
  }
  function getIndentation(context, pos) {
    if (context instanceof EditorState)
      context = new IndentContext(context);
    for (let service of context.state.facet(indentService)) {
      let result = service(context, pos);
      if (result !== void 0)
        return result;
    }
    let tree = syntaxTree(context.state);
    return tree.length >= pos ? syntaxIndentation(context, tree, pos) : null;
  }
  var IndentContext = class {
    constructor(state, options = {}) {
      this.state = state;
      this.options = options;
      this.unit = getIndentUnit(state);
    }
    lineAt(pos, bias = 1) {
      let line2 = this.state.doc.lineAt(pos);
      let { simulateBreak, simulateDoubleBreak } = this.options;
      if (simulateBreak != null && simulateBreak >= line2.from && simulateBreak <= line2.to) {
        if (simulateDoubleBreak && simulateBreak == pos)
          return { text: "", from: pos };
        else if (bias < 0 ? simulateBreak < pos : simulateBreak <= pos)
          return { text: line2.text.slice(simulateBreak - line2.from), from: simulateBreak };
        else
          return { text: line2.text.slice(0, simulateBreak - line2.from), from: line2.from };
      }
      return line2;
    }
    textAfterPos(pos, bias = 1) {
      if (this.options.simulateDoubleBreak && pos == this.options.simulateBreak)
        return "";
      let { text: text2, from } = this.lineAt(pos, bias);
      return text2.slice(pos - from, Math.min(text2.length, pos + 100 - from));
    }
    column(pos, bias = 1) {
      let { text: text2, from } = this.lineAt(pos, bias);
      let result = this.countColumn(text2, pos - from);
      let override = this.options.overrideIndentation ? this.options.overrideIndentation(from) : -1;
      if (override > -1)
        result += override - this.countColumn(text2, text2.search(/\S|$/));
      return result;
    }
    countColumn(line2, pos = line2.length) {
      return countColumn(line2, this.state.tabSize, pos);
    }
    lineIndent(pos, bias = 1) {
      let { text: text2, from } = this.lineAt(pos, bias);
      let override = this.options.overrideIndentation;
      if (override) {
        let overriden = override(from);
        if (overriden > -1)
          return overriden;
      }
      return this.countColumn(text2, text2.search(/\S|$/));
    }
    get simulatedBreak() {
      return this.options.simulateBreak || null;
    }
  };
  var indentNodeProp = /* @__PURE__ */ new NodeProp();
  function syntaxIndentation(cx, ast, pos) {
    let stack = ast.resolveStack(pos);
    let inner = stack.node.enterUnfinishedNodesBefore(pos);
    if (inner != stack.node) {
      let add = [];
      for (let cur = inner; cur != stack.node; cur = cur.parent)
        add.push(cur);
      for (let i = add.length - 1; i >= 0; i--)
        stack = { node: add[i], next: stack };
    }
    return indentFor(stack, cx, pos);
  }
  function indentFor(stack, cx, pos) {
    for (let cur = stack; cur; cur = cur.next) {
      let strategy = indentStrategy(cur.node);
      if (strategy)
        return strategy(TreeIndentContext.create(cx, pos, cur));
    }
    return 0;
  }
  function ignoreClosed(cx) {
    return cx.pos == cx.options.simulateBreak && cx.options.simulateDoubleBreak;
  }
  function indentStrategy(tree) {
    let strategy = tree.type.prop(indentNodeProp);
    if (strategy)
      return strategy;
    let first = tree.firstChild, close;
    if (first && (close = first.type.prop(NodeProp.closedBy))) {
      let last3 = tree.lastChild, closed = last3 && close.indexOf(last3.name) > -1;
      return (cx) => delimitedStrategy(cx, true, 1, void 0, closed && !ignoreClosed(cx) ? last3.from : void 0);
    }
    return tree.parent == null ? topIndent : null;
  }
  function topIndent() {
    return 0;
  }
  var TreeIndentContext = class extends IndentContext {
    constructor(base2, pos, context) {
      super(base2.state, base2.options);
      this.base = base2;
      this.pos = pos;
      this.context = context;
    }
    get node() {
      return this.context.node;
    }
    static create(base2, pos, context) {
      return new TreeIndentContext(base2, pos, context);
    }
    get textAfter() {
      return this.textAfterPos(this.pos);
    }
    get baseIndent() {
      return this.baseIndentFor(this.node);
    }
    baseIndentFor(node2) {
      let line2 = this.state.doc.lineAt(node2.from);
      for (; ; ) {
        let atBreak = node2.resolve(line2.from);
        while (atBreak.parent && atBreak.parent.from == atBreak.from)
          atBreak = atBreak.parent;
        if (isParent(atBreak, node2))
          break;
        line2 = this.state.doc.lineAt(atBreak.from);
      }
      return this.lineIndent(line2.from);
    }
    continue() {
      return indentFor(this.context.next, this.base, this.pos);
    }
  };
  function isParent(parent, of) {
    for (let cur = of; cur; cur = cur.parent)
      if (parent == cur)
        return true;
    return false;
  }
  function bracketedAligned(context) {
    let tree = context.node;
    let openToken = tree.childAfter(tree.from), last3 = tree.lastChild;
    if (!openToken)
      return null;
    let sim = context.options.simulateBreak;
    let openLine = context.state.doc.lineAt(openToken.from);
    let lineEnd = sim == null || sim <= openLine.from ? openLine.to : Math.min(openLine.to, sim);
    for (let pos = openToken.to; ; ) {
      let next = tree.childAfter(pos);
      if (!next || next == last3)
        return null;
      if (!next.type.isSkipped)
        return next.from < lineEnd ? openToken : null;
      pos = next.to;
    }
  }
  function delimitedStrategy(context, align, units, closing, closedAt) {
    let after = context.textAfter, space2 = after.match(/^\s*/)[0].length;
    let closed = closing && after.slice(space2, space2 + closing.length) == closing || closedAt == context.pos + space2;
    let aligned = align ? bracketedAligned(context) : null;
    if (aligned)
      return closed ? context.column(aligned.from) : context.column(aligned.to);
    return context.baseIndent + (closed ? 0 : context.unit * units);
  }
  var HighlightStyle = class {
    constructor(specs, options) {
      this.specs = specs;
      let modSpec;
      function def(spec) {
        let cls = StyleModule.newName();
        (modSpec || (modSpec = /* @__PURE__ */ Object.create(null)))["." + cls] = spec;
        return cls;
      }
      const all2 = typeof options.all == "string" ? options.all : options.all ? def(options.all) : void 0;
      const scopeOpt = options.scope;
      this.scope = scopeOpt instanceof Language ? (type2) => type2.prop(languageDataProp) == scopeOpt.data : scopeOpt ? (type2) => type2 == scopeOpt : void 0;
      this.style = tagHighlighter(specs.map((style) => ({
        tag: style.tag,
        class: style.class || def(Object.assign({}, style, { tag: null }))
      })), {
        all: all2
      }).style;
      this.module = modSpec ? new StyleModule(modSpec) : null;
      this.themeType = options.themeType;
    }
    static define(specs, options) {
      return new HighlightStyle(specs, options || {});
    }
  };
  var defaultHighlightStyle = /* @__PURE__ */ HighlightStyle.define([
    {
      tag: tags.meta,
      color: "#404740"
    },
    {
      tag: tags.link,
      textDecoration: "underline"
    },
    {
      tag: tags.heading,
      textDecoration: "underline",
      fontWeight: "bold"
    },
    {
      tag: tags.emphasis,
      fontStyle: "italic"
    },
    {
      tag: tags.strong,
      fontWeight: "bold"
    },
    {
      tag: tags.strikethrough,
      textDecoration: "line-through"
    },
    {
      tag: tags.keyword,
      color: "#708"
    },
    {
      tag: [tags.atom, tags.bool, tags.url, tags.contentSeparator, tags.labelName],
      color: "#219"
    },
    {
      tag: [tags.literal, tags.inserted],
      color: "#164"
    },
    {
      tag: [tags.string, tags.deleted],
      color: "#a11"
    },
    {
      tag: [tags.regexp, tags.escape, /* @__PURE__ */ tags.special(tags.string)],
      color: "#e40"
    },
    {
      tag: /* @__PURE__ */ tags.definition(tags.variableName),
      color: "#00f"
    },
    {
      tag: /* @__PURE__ */ tags.local(tags.variableName),
      color: "#30a"
    },
    {
      tag: [tags.typeName, tags.namespace],
      color: "#085"
    },
    {
      tag: tags.className,
      color: "#167"
    },
    {
      tag: [/* @__PURE__ */ tags.special(tags.variableName), tags.macroName],
      color: "#256"
    },
    {
      tag: /* @__PURE__ */ tags.definition(tags.propertyName),
      color: "#00c"
    },
    {
      tag: tags.comment,
      color: "#940"
    },
    {
      tag: tags.invalid,
      color: "#f00"
    }
  ]);
  var DefaultScanDist = 1e4;
  var DefaultBrackets = "()[]{}";
  var bracketMatchingHandle = /* @__PURE__ */ new NodeProp();
  function matchingNodes(node2, dir, brackets2) {
    let byProp = node2.prop(dir < 0 ? NodeProp.openedBy : NodeProp.closedBy);
    if (byProp)
      return byProp;
    if (node2.name.length == 1) {
      let index3 = brackets2.indexOf(node2.name);
      if (index3 > -1 && index3 % 2 == (dir < 0 ? 1 : 0))
        return [brackets2[index3 + dir]];
    }
    return null;
  }
  function findHandle(node2) {
    let hasHandle = node2.type.prop(bracketMatchingHandle);
    return hasHandle ? hasHandle(node2.node) : node2;
  }
  function matchBrackets(state, pos, dir, config = {}) {
    let maxScanDistance = config.maxScanDistance || DefaultScanDist, brackets2 = config.brackets || DefaultBrackets;
    let tree = syntaxTree(state), node2 = tree.resolveInner(pos, dir);
    for (let cur = node2; cur; cur = cur.parent) {
      let matches = matchingNodes(cur.type, dir, brackets2);
      if (matches && cur.from < cur.to) {
        let handle = findHandle(cur);
        if (handle && (dir > 0 ? pos >= handle.from && pos < handle.to : pos > handle.from && pos <= handle.to))
          return matchMarkedBrackets(state, pos, dir, cur, handle, matches, brackets2);
      }
    }
    return matchPlainBrackets(state, pos, dir, tree, node2.type, maxScanDistance, brackets2);
  }
  function matchMarkedBrackets(_state, _pos, dir, token2, handle, matching, brackets2) {
    let parent = token2.parent, firstToken = { from: handle.from, to: handle.to };
    let depth = 0, cursor = parent === null || parent === void 0 ? void 0 : parent.cursor();
    if (cursor && (dir < 0 ? cursor.childBefore(token2.from) : cursor.childAfter(token2.to)))
      do {
        if (dir < 0 ? cursor.to <= token2.from : cursor.from >= token2.to) {
          if (depth == 0 && matching.indexOf(cursor.type.name) > -1 && cursor.from < cursor.to) {
            let endHandle = findHandle(cursor);
            return { start: firstToken, end: endHandle ? { from: endHandle.from, to: endHandle.to } : void 0, matched: true };
          } else if (matchingNodes(cursor.type, dir, brackets2)) {
            depth++;
          } else if (matchingNodes(cursor.type, -dir, brackets2)) {
            if (depth == 0) {
              let endHandle = findHandle(cursor);
              return {
                start: firstToken,
                end: endHandle && endHandle.from < endHandle.to ? { from: endHandle.from, to: endHandle.to } : void 0,
                matched: false
              };
            }
            depth--;
          }
        }
      } while (dir < 0 ? cursor.prevSibling() : cursor.nextSibling());
    return { start: firstToken, matched: false };
  }
  function matchPlainBrackets(state, pos, dir, tree, tokenType, maxScanDistance, brackets2) {
    let startCh = dir < 0 ? state.sliceDoc(pos - 1, pos) : state.sliceDoc(pos, pos + 1);
    let bracket2 = brackets2.indexOf(startCh);
    if (bracket2 < 0 || bracket2 % 2 == 0 != dir > 0)
      return null;
    let startToken = { from: dir < 0 ? pos - 1 : pos, to: dir > 0 ? pos + 1 : pos };
    let iter = state.doc.iterRange(pos, dir > 0 ? state.doc.length : 0), depth = 0;
    for (let distance = 0; !iter.next().done && distance <= maxScanDistance; ) {
      let text2 = iter.value;
      if (dir < 0)
        distance += text2.length;
      let basePos = pos + distance * dir;
      for (let pos2 = dir > 0 ? 0 : text2.length - 1, end = dir > 0 ? text2.length : -1; pos2 != end; pos2 += dir) {
        let found = brackets2.indexOf(text2[pos2]);
        if (found < 0 || tree.resolveInner(basePos + pos2, 1).type != tokenType)
          continue;
        if (found % 2 == 0 == dir > 0) {
          depth++;
        } else if (depth == 1) {
          return { start: startToken, end: { from: basePos + pos2, to: basePos + pos2 + 1 }, matched: found >> 1 == bracket2 >> 1 };
        } else {
          depth--;
        }
      }
      if (dir > 0)
        distance += text2.length;
    }
    return iter.done ? { start: startToken, matched: false } : null;
  }
  var noTokens = /* @__PURE__ */ Object.create(null);
  var typeArray = [NodeType.none];
  var warned = [];
  var byTag = /* @__PURE__ */ Object.create(null);
  var defaultTable = /* @__PURE__ */ Object.create(null);
  for (let [legacyName, name3] of [
    ["variable", "variableName"],
    ["variable-2", "variableName.special"],
    ["string-2", "string.special"],
    ["def", "variableName.definition"],
    ["tag", "tagName"],
    ["attribute", "attributeName"],
    ["type", "typeName"],
    ["builtin", "variableName.standard"],
    ["qualifier", "modifier"],
    ["error", "invalid"],
    ["header", "heading"],
    ["property", "propertyName"]
  ])
    defaultTable[legacyName] = /* @__PURE__ */ createTokenType(noTokens, name3);
  function warnForPart(part, msg) {
    if (warned.indexOf(part) > -1)
      return;
    warned.push(part);
    console.warn(msg);
  }
  function createTokenType(extra, tagStr) {
    let tags$1 = [];
    for (let name4 of tagStr.split(" ")) {
      let found = [];
      for (let part of name4.split(".")) {
        let value = extra[part] || tags[part];
        if (!value) {
          warnForPart(part, `Unknown highlighting tag ${part}`);
        } else if (typeof value == "function") {
          if (!found.length)
            warnForPart(part, `Modifier ${part} used at start of tag`);
          else
            found = found.map(value);
        } else {
          if (found.length)
            warnForPart(part, `Tag ${part} used as modifier`);
          else
            found = Array.isArray(value) ? value : [value];
        }
      }
      for (let tag of found)
        tags$1.push(tag);
    }
    if (!tags$1.length)
      return 0;
    let name3 = tagStr.replace(/ /g, "_"), key = name3 + " " + tags$1.map((t2) => t2.id);
    let known = byTag[key];
    if (known)
      return known.id;
    let type2 = byTag[key] = NodeType.define({
      id: typeArray.length,
      name: name3,
      props: [styleTags({ [name3]: tags$1 })]
    });
    typeArray.push(type2);
    return type2.id;
  }
  var marks = {
    rtl: /* @__PURE__ */ Decoration.mark({ class: "cm-iso", inclusive: true, attributes: { dir: "rtl" }, bidiIsolate: Direction.RTL }),
    ltr: /* @__PURE__ */ Decoration.mark({ class: "cm-iso", inclusive: true, attributes: { dir: "ltr" }, bidiIsolate: Direction.LTR }),
    auto: /* @__PURE__ */ Decoration.mark({ class: "cm-iso", inclusive: true, attributes: { dir: "auto" }, bidiIsolate: null })
  };

  // node_modules/@codemirror/commands/dist/index.js
  var toggleComment = (target) => {
    let { state } = target, line2 = state.doc.lineAt(state.selection.main.from), config = getConfig(target.state, line2.from);
    return config.line ? toggleLineComment(target) : config.block ? toggleBlockCommentByLine(target) : false;
  };
  function command(f, option) {
    return ({ state, dispatch: dispatch3 }) => {
      if (state.readOnly)
        return false;
      let tr = f(option, state);
      if (!tr)
        return false;
      dispatch3(state.update(tr));
      return true;
    };
  }
  var toggleLineComment = /* @__PURE__ */ command(changeLineComment, 0);
  var toggleBlockComment = /* @__PURE__ */ command(changeBlockComment, 0);
  var toggleBlockCommentByLine = /* @__PURE__ */ command((o, s) => changeBlockComment(o, s, selectedLineRanges(s)), 0);
  function getConfig(state, pos) {
    let data = state.languageDataAt("commentTokens", pos);
    return data.length ? data[0] : {};
  }
  var SearchMargin = 50;
  function findBlockComment(state, { open, close }, from, to) {
    let textBefore = state.sliceDoc(from - SearchMargin, from);
    let textAfter = state.sliceDoc(to, to + SearchMargin);
    let spaceBefore = /\s*$/.exec(textBefore)[0].length, spaceAfter = /^\s*/.exec(textAfter)[0].length;
    let beforeOff = textBefore.length - spaceBefore;
    if (textBefore.slice(beforeOff - open.length, beforeOff) == open && textAfter.slice(spaceAfter, spaceAfter + close.length) == close) {
      return {
        open: { pos: from - spaceBefore, margin: spaceBefore && 1 },
        close: { pos: to + spaceAfter, margin: spaceAfter && 1 }
      };
    }
    let startText, endText;
    if (to - from <= 2 * SearchMargin) {
      startText = endText = state.sliceDoc(from, to);
    } else {
      startText = state.sliceDoc(from, from + SearchMargin);
      endText = state.sliceDoc(to - SearchMargin, to);
    }
    let startSpace = /^\s*/.exec(startText)[0].length, endSpace = /\s*$/.exec(endText)[0].length;
    let endOff = endText.length - endSpace - close.length;
    if (startText.slice(startSpace, startSpace + open.length) == open && endText.slice(endOff, endOff + close.length) == close) {
      return {
        open: {
          pos: from + startSpace + open.length,
          margin: /\s/.test(startText.charAt(startSpace + open.length)) ? 1 : 0
        },
        close: {
          pos: to - endSpace - close.length,
          margin: /\s/.test(endText.charAt(endOff - 1)) ? 1 : 0
        }
      };
    }
    return null;
  }
  function selectedLineRanges(state) {
    let ranges = [];
    for (let r of state.selection.ranges) {
      let fromLine = state.doc.lineAt(r.from);
      let toLine = r.to <= fromLine.to ? fromLine : state.doc.lineAt(r.to);
      let last3 = ranges.length - 1;
      if (last3 >= 0 && ranges[last3].to > fromLine.from)
        ranges[last3].to = toLine.to;
      else
        ranges.push({ from: fromLine.from + /^\s*/.exec(fromLine.text)[0].length, to: toLine.to });
    }
    return ranges;
  }
  function changeBlockComment(option, state, ranges = state.selection.ranges) {
    let tokens = ranges.map((r) => getConfig(state, r.from).block);
    if (!tokens.every((c) => c))
      return null;
    let comments = ranges.map((r, i) => findBlockComment(state, tokens[i], r.from, r.to));
    if (option != 2 && !comments.every((c) => c)) {
      return { changes: state.changes(ranges.map((range4, i) => {
        if (comments[i])
          return [];
        return [{ from: range4.from, insert: tokens[i].open + " " }, { from: range4.to, insert: " " + tokens[i].close }];
      })) };
    } else if (option != 1 && comments.some((c) => c)) {
      let changes = [];
      for (let i = 0, comment2; i < comments.length; i++)
        if (comment2 = comments[i]) {
          let token2 = tokens[i], { open, close } = comment2;
          changes.push({ from: open.pos - token2.open.length, to: open.pos + open.margin }, { from: close.pos - close.margin, to: close.pos + token2.close.length });
        }
      return { changes };
    }
    return null;
  }
  function changeLineComment(option, state, ranges = state.selection.ranges) {
    let lines = [];
    let prevLine = -1;
    for (let { from, to } of ranges) {
      let startI = lines.length, minIndent = 1e9;
      let token2 = getConfig(state, from).line;
      if (!token2)
        continue;
      for (let pos = from; pos <= to; ) {
        let line2 = state.doc.lineAt(pos);
        if (line2.from > prevLine && (from == to || to > line2.from)) {
          prevLine = line2.from;
          let indent = /^\s*/.exec(line2.text)[0].length;
          let empty4 = indent == line2.length;
          let comment2 = line2.text.slice(indent, indent + token2.length) == token2 ? indent : -1;
          if (indent < line2.text.length && indent < minIndent)
            minIndent = indent;
          lines.push({ line: line2, comment: comment2, token: token2, indent, empty: empty4, single: false });
        }
        pos = line2.to + 1;
      }
      if (minIndent < 1e9) {
        for (let i = startI; i < lines.length; i++)
          if (lines[i].indent < lines[i].line.text.length)
            lines[i].indent = minIndent;
      }
      if (lines.length == startI + 1)
        lines[startI].single = true;
    }
    if (option != 2 && lines.some((l) => l.comment < 0 && (!l.empty || l.single))) {
      let changes = [];
      for (let { line: line2, token: token2, indent, empty: empty4, single } of lines)
        if (single || !empty4)
          changes.push({ from: line2.from + indent, insert: token2 + " " });
      let changeSet = state.changes(changes);
      return { changes: changeSet, selection: state.selection.map(changeSet, 1) };
    } else if (option != 1 && lines.some((l) => l.comment >= 0)) {
      let changes = [];
      for (let { line: line2, comment: comment2, token: token2 } of lines)
        if (comment2 >= 0) {
          let from = line2.from + comment2, to = from + token2.length;
          if (line2.text[to - line2.from] == " ")
            to++;
          changes.push({ from, to });
        }
      return { changes };
    }
    return null;
  }
  var fromHistory = /* @__PURE__ */ Annotation.define();
  var invertedEffects = /* @__PURE__ */ Facet.define();
  var HistEvent = class {
    constructor(changes, effects, mapped, startSelection, selectionsAfter) {
      this.changes = changes;
      this.effects = effects;
      this.mapped = mapped;
      this.startSelection = startSelection;
      this.selectionsAfter = selectionsAfter;
    }
    setSelAfter(after) {
      return new HistEvent(this.changes, this.effects, this.mapped, this.startSelection, after);
    }
    toJSON() {
      var _a2, _b, _c;
      return {
        changes: (_a2 = this.changes) === null || _a2 === void 0 ? void 0 : _a2.toJSON(),
        mapped: (_b = this.mapped) === null || _b === void 0 ? void 0 : _b.toJSON(),
        startSelection: (_c = this.startSelection) === null || _c === void 0 ? void 0 : _c.toJSON(),
        selectionsAfter: this.selectionsAfter.map((s) => s.toJSON())
      };
    }
    static fromJSON(json) {
      return new HistEvent(json.changes && ChangeSet.fromJSON(json.changes), [], json.mapped && ChangeDesc.fromJSON(json.mapped), json.startSelection && EditorSelection.fromJSON(json.startSelection), json.selectionsAfter.map(EditorSelection.fromJSON));
    }
    static fromTransaction(tr, selection2) {
      let effects = none3;
      for (let invert of tr.startState.facet(invertedEffects)) {
        let result = invert(tr);
        if (result.length)
          effects = effects.concat(result);
      }
      if (!effects.length && tr.changes.empty)
        return null;
      return new HistEvent(tr.changes.invert(tr.startState.doc), effects, void 0, selection2 || tr.startState.selection, none3);
    }
    static selection(selections) {
      return new HistEvent(void 0, none3, void 0, void 0, selections);
    }
  };
  function updateBranch(branch, to, maxLen, newEvent) {
    let start2 = to + 1 > maxLen + 20 ? to - maxLen - 1 : 0;
    let newBranch = branch.slice(start2, to);
    newBranch.push(newEvent);
    return newBranch;
  }
  function isAdjacent(a, b) {
    let ranges = [], isAdjacent2 = false;
    a.iterChangedRanges((f, t2) => ranges.push(f, t2));
    b.iterChangedRanges((_f, _t, f, t2) => {
      for (let i = 0; i < ranges.length; ) {
        let from = ranges[i++], to = ranges[i++];
        if (t2 >= from && f <= to)
          isAdjacent2 = true;
      }
    });
    return isAdjacent2;
  }
  function eqSelectionShape(a, b) {
    return a.ranges.length == b.ranges.length && a.ranges.filter((r, i) => r.empty != b.ranges[i].empty).length === 0;
  }
  function conc(a, b) {
    return !a.length ? b : !b.length ? a : a.concat(b);
  }
  var none3 = [];
  var MaxSelectionsPerEvent = 200;
  function addSelection(branch, selection2) {
    if (!branch.length) {
      return [HistEvent.selection([selection2])];
    } else {
      let lastEvent = branch[branch.length - 1];
      let sels = lastEvent.selectionsAfter.slice(Math.max(0, lastEvent.selectionsAfter.length - MaxSelectionsPerEvent));
      if (sels.length && sels[sels.length - 1].eq(selection2))
        return branch;
      sels.push(selection2);
      return updateBranch(branch, branch.length - 1, 1e9, lastEvent.setSelAfter(sels));
    }
  }
  function popSelection(branch) {
    let last3 = branch[branch.length - 1];
    let newBranch = branch.slice();
    newBranch[branch.length - 1] = last3.setSelAfter(last3.selectionsAfter.slice(0, last3.selectionsAfter.length - 1));
    return newBranch;
  }
  function addMappingToBranch(branch, mapping) {
    if (!branch.length)
      return branch;
    let length6 = branch.length, selections = none3;
    while (length6) {
      let event = mapEvent(branch[length6 - 1], mapping, selections);
      if (event.changes && !event.changes.empty || event.effects.length) {
        let result = branch.slice(0, length6);
        result[length6 - 1] = event;
        return result;
      } else {
        mapping = event.mapped;
        length6--;
        selections = event.selectionsAfter;
      }
    }
    return selections.length ? [HistEvent.selection(selections)] : none3;
  }
  function mapEvent(event, mapping, extraSelections) {
    let selections = conc(event.selectionsAfter.length ? event.selectionsAfter.map((s) => s.map(mapping)) : none3, extraSelections);
    if (!event.changes)
      return HistEvent.selection(selections);
    let mappedChanges = event.changes.map(mapping), before = mapping.mapDesc(event.changes, true);
    let fullMapping = event.mapped ? event.mapped.composeDesc(before) : before;
    return new HistEvent(mappedChanges, StateEffect.mapEffects(event.effects, mapping), fullMapping, event.startSelection.map(before), selections);
  }
  var joinableUserEvent = /^(input\.type|delete)($|\.)/;
  var HistoryState = class {
    constructor(done, undone, prevTime = 0, prevUserEvent = void 0) {
      this.done = done;
      this.undone = undone;
      this.prevTime = prevTime;
      this.prevUserEvent = prevUserEvent;
    }
    isolate() {
      return this.prevTime ? new HistoryState(this.done, this.undone) : this;
    }
    addChanges(event, time2, userEvent, config, tr) {
      let done = this.done, lastEvent = done[done.length - 1];
      if (lastEvent && lastEvent.changes && !lastEvent.changes.empty && event.changes && (!userEvent || joinableUserEvent.test(userEvent)) && (!lastEvent.selectionsAfter.length && time2 - this.prevTime < config.newGroupDelay && config.joinToEvent(tr, isAdjacent(lastEvent.changes, event.changes)) || userEvent == "input.type.compose")) {
        done = updateBranch(done, done.length - 1, config.minDepth, new HistEvent(event.changes.compose(lastEvent.changes), conc(event.effects, lastEvent.effects), lastEvent.mapped, lastEvent.startSelection, none3));
      } else {
        done = updateBranch(done, done.length, config.minDepth, event);
      }
      return new HistoryState(done, none3, time2, userEvent);
    }
    addSelection(selection2, time2, userEvent, newGroupDelay) {
      let last3 = this.done.length ? this.done[this.done.length - 1].selectionsAfter : none3;
      if (last3.length > 0 && time2 - this.prevTime < newGroupDelay && userEvent == this.prevUserEvent && userEvent && /^select($|\.)/.test(userEvent) && eqSelectionShape(last3[last3.length - 1], selection2))
        return this;
      return new HistoryState(addSelection(this.done, selection2), this.undone, time2, userEvent);
    }
    addMapping(mapping) {
      return new HistoryState(addMappingToBranch(this.done, mapping), addMappingToBranch(this.undone, mapping), this.prevTime, this.prevUserEvent);
    }
    pop(side, state, onlySelection) {
      let branch = side == 0 ? this.done : this.undone;
      if (branch.length == 0)
        return null;
      let event = branch[branch.length - 1], selection2 = event.selectionsAfter[0] || state.selection;
      if (onlySelection && event.selectionsAfter.length) {
        return state.update({
          selection: event.selectionsAfter[event.selectionsAfter.length - 1],
          annotations: fromHistory.of({ side, rest: popSelection(branch), selection: selection2 }),
          userEvent: side == 0 ? "select.undo" : "select.redo",
          scrollIntoView: true
        });
      } else if (!event.changes) {
        return null;
      } else {
        let rest = branch.length == 1 ? none3 : branch.slice(0, branch.length - 1);
        if (event.mapped)
          rest = addMappingToBranch(rest, event.mapped);
        return state.update({
          changes: event.changes,
          selection: event.startSelection,
          effects: event.effects,
          annotations: fromHistory.of({ side, rest, selection: selection2 }),
          filter: false,
          userEvent: side == 0 ? "undo" : "redo",
          scrollIntoView: true
        });
      }
    }
  };
  HistoryState.empty = /* @__PURE__ */ new HistoryState(none3, none3);
  function updateSel(sel, by) {
    return EditorSelection.create(sel.ranges.map(by), sel.mainIndex);
  }
  function setSel(state, selection2) {
    return state.update({ selection: selection2, scrollIntoView: true, userEvent: "select" });
  }
  function moveSel({ state, dispatch: dispatch3 }, how) {
    let selection2 = updateSel(state.selection, how);
    if (selection2.eq(state.selection, true))
      return false;
    dispatch3(setSel(state, selection2));
    return true;
  }
  function rangeEnd(range4, forward) {
    return EditorSelection.cursor(forward ? range4.to : range4.from);
  }
  function cursorByChar(view2, forward) {
    return moveSel(view2, (range4) => range4.empty ? view2.moveByChar(range4, forward) : rangeEnd(range4, forward));
  }
  function ltrAtCursor(view2) {
    return view2.textDirectionAt(view2.state.selection.main.head) == Direction.LTR;
  }
  var cursorCharLeft = (view2) => cursorByChar(view2, !ltrAtCursor(view2));
  var cursorCharRight = (view2) => cursorByChar(view2, ltrAtCursor(view2));
  function cursorByGroup(view2, forward) {
    return moveSel(view2, (range4) => range4.empty ? view2.moveByGroup(range4, forward) : rangeEnd(range4, forward));
  }
  var cursorGroupLeft = (view2) => cursorByGroup(view2, !ltrAtCursor(view2));
  var cursorGroupRight = (view2) => cursorByGroup(view2, ltrAtCursor(view2));
  var segmenter = typeof Intl != "undefined" && Intl.Segmenter ? /* @__PURE__ */ new Intl.Segmenter(void 0, { granularity: "word" }) : null;
  function interestingNode(state, node2, bracketProp) {
    if (node2.type.prop(bracketProp))
      return true;
    let len = node2.to - node2.from;
    return len && (len > 2 || /[^\s,.;:]/.test(state.sliceDoc(node2.from, node2.to))) || node2.firstChild;
  }
  function moveBySyntax(state, start2, forward) {
    let pos = syntaxTree(state).resolveInner(start2.head);
    let bracketProp = forward ? NodeProp.closedBy : NodeProp.openedBy;
    for (let at = start2.head; ; ) {
      let next = forward ? pos.childAfter(at) : pos.childBefore(at);
      if (!next)
        break;
      if (interestingNode(state, next, bracketProp))
        pos = next;
      else
        at = forward ? next.to : next.from;
    }
    let bracket2 = pos.type.prop(bracketProp), match4, newPos;
    if (bracket2 && (match4 = forward ? matchBrackets(state, pos.from, 1) : matchBrackets(state, pos.to, -1)) && match4.matched)
      newPos = forward ? match4.end.to : match4.end.from;
    else
      newPos = forward ? pos.to : pos.from;
    return EditorSelection.cursor(newPos, forward ? -1 : 1);
  }
  var cursorSyntaxLeft = (view2) => moveSel(view2, (range4) => moveBySyntax(view2.state, range4, !ltrAtCursor(view2)));
  var cursorSyntaxRight = (view2) => moveSel(view2, (range4) => moveBySyntax(view2.state, range4, ltrAtCursor(view2)));
  function cursorByLine(view2, forward) {
    return moveSel(view2, (range4) => {
      if (!range4.empty)
        return rangeEnd(range4, forward);
      let moved = view2.moveVertically(range4, forward);
      return moved.head != range4.head ? moved : view2.moveToLineBoundary(range4, forward);
    });
  }
  var cursorLineUp = (view2) => cursorByLine(view2, false);
  var cursorLineDown = (view2) => cursorByLine(view2, true);
  function pageInfo(view2) {
    let selfScroll = view2.scrollDOM.clientHeight < view2.scrollDOM.scrollHeight - 2;
    let marginTop = 0, marginBottom = 0, height;
    if (selfScroll) {
      for (let source2 of view2.state.facet(EditorView.scrollMargins)) {
        let margins = source2(view2);
        if (margins === null || margins === void 0 ? void 0 : margins.top)
          marginTop = Math.max(margins === null || margins === void 0 ? void 0 : margins.top, marginTop);
        if (margins === null || margins === void 0 ? void 0 : margins.bottom)
          marginBottom = Math.max(margins === null || margins === void 0 ? void 0 : margins.bottom, marginBottom);
      }
      height = view2.scrollDOM.clientHeight - marginTop - marginBottom;
    } else {
      height = (view2.dom.ownerDocument.defaultView || window).innerHeight;
    }
    return {
      marginTop,
      marginBottom,
      selfScroll,
      height: Math.max(view2.defaultLineHeight, height - 5)
    };
  }
  function cursorByPage(view2, forward) {
    let page = pageInfo(view2);
    let { state } = view2, selection2 = updateSel(state.selection, (range4) => {
      return range4.empty ? view2.moveVertically(range4, forward, page.height) : rangeEnd(range4, forward);
    });
    if (selection2.eq(state.selection))
      return false;
    let effect;
    if (page.selfScroll) {
      let startPos = view2.coordsAtPos(state.selection.main.head);
      let scrollRect = view2.scrollDOM.getBoundingClientRect();
      let scrollTop = scrollRect.top + page.marginTop, scrollBottom = scrollRect.bottom - page.marginBottom;
      if (startPos && startPos.top > scrollTop && startPos.bottom < scrollBottom)
        effect = EditorView.scrollIntoView(selection2.main.head, { y: "start", yMargin: startPos.top - scrollTop });
    }
    view2.dispatch(setSel(state, selection2), { effects: effect });
    return true;
  }
  var cursorPageUp = (view2) => cursorByPage(view2, false);
  var cursorPageDown = (view2) => cursorByPage(view2, true);
  function moveByLineBoundary(view2, start2, forward) {
    let line2 = view2.lineBlockAt(start2.head), moved = view2.moveToLineBoundary(start2, forward);
    if (moved.head == start2.head && moved.head != (forward ? line2.to : line2.from))
      moved = view2.moveToLineBoundary(start2, forward, false);
    if (!forward && moved.head == line2.from && line2.length) {
      let space2 = /^\s*/.exec(view2.state.sliceDoc(line2.from, Math.min(line2.from + 100, line2.to)))[0].length;
      if (space2 && start2.head != line2.from + space2)
        moved = EditorSelection.cursor(line2.from + space2);
    }
    return moved;
  }
  var cursorLineBoundaryForward = (view2) => moveSel(view2, (range4) => moveByLineBoundary(view2, range4, true));
  var cursorLineBoundaryBackward = (view2) => moveSel(view2, (range4) => moveByLineBoundary(view2, range4, false));
  var cursorLineBoundaryLeft = (view2) => moveSel(view2, (range4) => moveByLineBoundary(view2, range4, !ltrAtCursor(view2)));
  var cursorLineBoundaryRight = (view2) => moveSel(view2, (range4) => moveByLineBoundary(view2, range4, ltrAtCursor(view2)));
  var cursorLineStart = (view2) => moveSel(view2, (range4) => EditorSelection.cursor(view2.lineBlockAt(range4.head).from, 1));
  var cursorLineEnd = (view2) => moveSel(view2, (range4) => EditorSelection.cursor(view2.lineBlockAt(range4.head).to, -1));
  function toMatchingBracket(state, dispatch3, extend4) {
    let found = false, selection2 = updateSel(state.selection, (range4) => {
      let matching = matchBrackets(state, range4.head, -1) || matchBrackets(state, range4.head, 1) || range4.head > 0 && matchBrackets(state, range4.head - 1, 1) || range4.head < state.doc.length && matchBrackets(state, range4.head + 1, -1);
      if (!matching || !matching.end)
        return range4;
      found = true;
      let head = matching.start.from == range4.head ? matching.end.to : matching.end.from;
      return extend4 ? EditorSelection.range(range4.anchor, head) : EditorSelection.cursor(head);
    });
    if (!found)
      return false;
    dispatch3(setSel(state, selection2));
    return true;
  }
  var cursorMatchingBracket = ({ state, dispatch: dispatch3 }) => toMatchingBracket(state, dispatch3, false);
  function extendSel(view2, how) {
    let selection2 = updateSel(view2.state.selection, (range4) => {
      let head = how(range4);
      return EditorSelection.range(range4.anchor, head.head, head.goalColumn, head.bidiLevel || void 0);
    });
    if (selection2.eq(view2.state.selection))
      return false;
    view2.dispatch(setSel(view2.state, selection2));
    return true;
  }
  function selectByChar(view2, forward) {
    return extendSel(view2, (range4) => view2.moveByChar(range4, forward));
  }
  var selectCharLeft = (view2) => selectByChar(view2, !ltrAtCursor(view2));
  var selectCharRight = (view2) => selectByChar(view2, ltrAtCursor(view2));
  function selectByGroup(view2, forward) {
    return extendSel(view2, (range4) => view2.moveByGroup(range4, forward));
  }
  var selectGroupLeft = (view2) => selectByGroup(view2, !ltrAtCursor(view2));
  var selectGroupRight = (view2) => selectByGroup(view2, ltrAtCursor(view2));
  var selectSyntaxLeft = (view2) => extendSel(view2, (range4) => moveBySyntax(view2.state, range4, !ltrAtCursor(view2)));
  var selectSyntaxRight = (view2) => extendSel(view2, (range4) => moveBySyntax(view2.state, range4, ltrAtCursor(view2)));
  function selectByLine(view2, forward) {
    return extendSel(view2, (range4) => view2.moveVertically(range4, forward));
  }
  var selectLineUp = (view2) => selectByLine(view2, false);
  var selectLineDown = (view2) => selectByLine(view2, true);
  function selectByPage(view2, forward) {
    return extendSel(view2, (range4) => view2.moveVertically(range4, forward, pageInfo(view2).height));
  }
  var selectPageUp = (view2) => selectByPage(view2, false);
  var selectPageDown = (view2) => selectByPage(view2, true);
  var selectLineBoundaryForward = (view2) => extendSel(view2, (range4) => moveByLineBoundary(view2, range4, true));
  var selectLineBoundaryBackward = (view2) => extendSel(view2, (range4) => moveByLineBoundary(view2, range4, false));
  var selectLineBoundaryLeft = (view2) => extendSel(view2, (range4) => moveByLineBoundary(view2, range4, !ltrAtCursor(view2)));
  var selectLineBoundaryRight = (view2) => extendSel(view2, (range4) => moveByLineBoundary(view2, range4, ltrAtCursor(view2)));
  var selectLineStart = (view2) => extendSel(view2, (range4) => EditorSelection.cursor(view2.lineBlockAt(range4.head).from));
  var selectLineEnd = (view2) => extendSel(view2, (range4) => EditorSelection.cursor(view2.lineBlockAt(range4.head).to));
  var cursorDocStart = ({ state, dispatch: dispatch3 }) => {
    dispatch3(setSel(state, { anchor: 0 }));
    return true;
  };
  var cursorDocEnd = ({ state, dispatch: dispatch3 }) => {
    dispatch3(setSel(state, { anchor: state.doc.length }));
    return true;
  };
  var selectDocStart = ({ state, dispatch: dispatch3 }) => {
    dispatch3(setSel(state, { anchor: state.selection.main.anchor, head: 0 }));
    return true;
  };
  var selectDocEnd = ({ state, dispatch: dispatch3 }) => {
    dispatch3(setSel(state, { anchor: state.selection.main.anchor, head: state.doc.length }));
    return true;
  };
  var selectAll = ({ state, dispatch: dispatch3 }) => {
    dispatch3(state.update({ selection: { anchor: 0, head: state.doc.length }, userEvent: "select" }));
    return true;
  };
  var selectLine = ({ state, dispatch: dispatch3 }) => {
    let ranges = selectedLineBlocks(state).map(({ from, to }) => EditorSelection.range(from, Math.min(to + 1, state.doc.length)));
    dispatch3(state.update({ selection: EditorSelection.create(ranges), userEvent: "select" }));
    return true;
  };
  var selectParentSyntax = ({ state, dispatch: dispatch3 }) => {
    let selection2 = updateSel(state.selection, (range4) => {
      var _a2;
      let stack = syntaxTree(state).resolveStack(range4.from, 1);
      for (let cur = stack; cur; cur = cur.next) {
        let { node: node2 } = cur;
        if ((node2.from < range4.from && node2.to >= range4.to || node2.to > range4.to && node2.from <= range4.from) && ((_a2 = node2.parent) === null || _a2 === void 0 ? void 0 : _a2.parent))
          return EditorSelection.range(node2.to, node2.from);
      }
      return range4;
    });
    dispatch3(setSel(state, selection2));
    return true;
  };
  var simplifySelection = ({ state, dispatch: dispatch3 }) => {
    let cur = state.selection, selection2 = null;
    if (cur.ranges.length > 1)
      selection2 = EditorSelection.create([cur.main]);
    else if (!cur.main.empty)
      selection2 = EditorSelection.create([EditorSelection.cursor(cur.main.head)]);
    if (!selection2)
      return false;
    dispatch3(setSel(state, selection2));
    return true;
  };
  function deleteBy(target, by) {
    if (target.state.readOnly)
      return false;
    let event = "delete.selection", { state } = target;
    let changes = state.changeByRange((range4) => {
      let { from, to } = range4;
      if (from == to) {
        let towards = by(range4);
        if (towards < from) {
          event = "delete.backward";
          towards = skipAtomic(target, towards, false);
        } else if (towards > from) {
          event = "delete.forward";
          towards = skipAtomic(target, towards, true);
        }
        from = Math.min(from, towards);
        to = Math.max(to, towards);
      } else {
        from = skipAtomic(target, from, false);
        to = skipAtomic(target, to, true);
      }
      return from == to ? { range: range4 } : { changes: { from, to }, range: EditorSelection.cursor(from, from < range4.head ? -1 : 1) };
    });
    if (changes.changes.empty)
      return false;
    target.dispatch(state.update(changes, {
      scrollIntoView: true,
      userEvent: event,
      effects: event == "delete.selection" ? EditorView.announce.of(state.phrase("Selection deleted")) : void 0
    }));
    return true;
  }
  function skipAtomic(target, pos, forward) {
    if (target instanceof EditorView)
      for (let ranges of target.state.facet(EditorView.atomicRanges).map((f) => f(target)))
        ranges.between(pos, pos, (from, to) => {
          if (from < pos && to > pos)
            pos = forward ? to : from;
        });
    return pos;
  }
  var deleteByChar = (target, forward, byIndentUnit) => deleteBy(target, (range4) => {
    let pos = range4.from, { state } = target, line2 = state.doc.lineAt(pos), before, targetPos;
    if (byIndentUnit && !forward && pos > line2.from && pos < line2.from + 200 && !/[^ \t]/.test(before = line2.text.slice(0, pos - line2.from))) {
      if (before[before.length - 1] == "	")
        return pos - 1;
      let col = countColumn(before, state.tabSize), drop3 = col % getIndentUnit(state) || getIndentUnit(state);
      for (let i = 0; i < drop3 && before[before.length - 1 - i] == " "; i++)
        pos--;
      targetPos = pos;
    } else {
      targetPos = findClusterBreak(line2.text, pos - line2.from, forward, forward) + line2.from;
      if (targetPos == pos && line2.number != (forward ? state.doc.lines : 1))
        targetPos += forward ? 1 : -1;
      else if (!forward && /[\ufe00-\ufe0f]/.test(line2.text.slice(targetPos - line2.from, pos - line2.from)))
        targetPos = findClusterBreak(line2.text, targetPos - line2.from, false, false) + line2.from;
    }
    return targetPos;
  });
  var deleteCharBackward = (view2) => deleteByChar(view2, false, true);
  var deleteCharForward = (view2) => deleteByChar(view2, true, false);
  var deleteByGroup = (target, forward) => deleteBy(target, (range4) => {
    let pos = range4.head, { state } = target, line2 = state.doc.lineAt(pos);
    let categorize = state.charCategorizer(pos);
    for (let cat = null; ; ) {
      if (pos == (forward ? line2.to : line2.from)) {
        if (pos == range4.head && line2.number != (forward ? state.doc.lines : 1))
          pos += forward ? 1 : -1;
        break;
      }
      let next = findClusterBreak(line2.text, pos - line2.from, forward) + line2.from;
      let nextChar = line2.text.slice(Math.min(pos, next) - line2.from, Math.max(pos, next) - line2.from);
      let nextCat = categorize(nextChar);
      if (cat != null && nextCat != cat)
        break;
      if (nextChar != " " || pos != range4.head)
        cat = nextCat;
      pos = next;
    }
    return pos;
  });
  var deleteGroupBackward = (target) => deleteByGroup(target, false);
  var deleteGroupForward = (target) => deleteByGroup(target, true);
  var deleteToLineEnd = (view2) => deleteBy(view2, (range4) => {
    let lineEnd = view2.lineBlockAt(range4.head).to;
    return range4.head < lineEnd ? lineEnd : Math.min(view2.state.doc.length, range4.head + 1);
  });
  var deleteLineBoundaryBackward = (view2) => deleteBy(view2, (range4) => {
    let lineStart = view2.moveToLineBoundary(range4, false).head;
    return range4.head > lineStart ? lineStart : Math.max(0, range4.head - 1);
  });
  var deleteLineBoundaryForward = (view2) => deleteBy(view2, (range4) => {
    let lineStart = view2.moveToLineBoundary(range4, true).head;
    return range4.head < lineStart ? lineStart : Math.min(view2.state.doc.length, range4.head + 1);
  });
  var splitLine = ({ state, dispatch: dispatch3 }) => {
    if (state.readOnly)
      return false;
    let changes = state.changeByRange((range4) => {
      return {
        changes: { from: range4.from, to: range4.to, insert: Text.of(["", ""]) },
        range: EditorSelection.cursor(range4.from)
      };
    });
    dispatch3(state.update(changes, { scrollIntoView: true, userEvent: "input" }));
    return true;
  };
  var transposeChars = ({ state, dispatch: dispatch3 }) => {
    if (state.readOnly)
      return false;
    let changes = state.changeByRange((range4) => {
      if (!range4.empty || range4.from == 0 || range4.from == state.doc.length)
        return { range: range4 };
      let pos = range4.from, line2 = state.doc.lineAt(pos);
      let from = pos == line2.from ? pos - 1 : findClusterBreak(line2.text, pos - line2.from, false) + line2.from;
      let to = pos == line2.to ? pos + 1 : findClusterBreak(line2.text, pos - line2.from, true) + line2.from;
      return {
        changes: { from, to, insert: state.doc.slice(pos, to).append(state.doc.slice(from, pos)) },
        range: EditorSelection.cursor(to)
      };
    });
    if (changes.changes.empty)
      return false;
    dispatch3(state.update(changes, { scrollIntoView: true, userEvent: "move.character" }));
    return true;
  };
  function selectedLineBlocks(state) {
    let blocks = [], upto = -1;
    for (let range4 of state.selection.ranges) {
      let startLine = state.doc.lineAt(range4.from), endLine = state.doc.lineAt(range4.to);
      if (!range4.empty && range4.to == endLine.from)
        endLine = state.doc.lineAt(range4.to - 1);
      if (upto >= startLine.number) {
        let prev = blocks[blocks.length - 1];
        prev.to = endLine.to;
        prev.ranges.push(range4);
      } else {
        blocks.push({ from: startLine.from, to: endLine.to, ranges: [range4] });
      }
      upto = endLine.number + 1;
    }
    return blocks;
  }
  function moveLine(state, dispatch3, forward) {
    if (state.readOnly)
      return false;
    let changes = [], ranges = [];
    for (let block of selectedLineBlocks(state)) {
      if (forward ? block.to == state.doc.length : block.from == 0)
        continue;
      let nextLine = state.doc.lineAt(forward ? block.to + 1 : block.from - 1);
      let size3 = nextLine.length + 1;
      if (forward) {
        changes.push({ from: block.to, to: nextLine.to }, { from: block.from, insert: nextLine.text + state.lineBreak });
        for (let r of block.ranges)
          ranges.push(EditorSelection.range(Math.min(state.doc.length, r.anchor + size3), Math.min(state.doc.length, r.head + size3)));
      } else {
        changes.push({ from: nextLine.from, to: block.from }, { from: block.to, insert: state.lineBreak + nextLine.text });
        for (let r of block.ranges)
          ranges.push(EditorSelection.range(r.anchor - size3, r.head - size3));
      }
    }
    if (!changes.length)
      return false;
    dispatch3(state.update({
      changes,
      scrollIntoView: true,
      selection: EditorSelection.create(ranges, state.selection.mainIndex),
      userEvent: "move.line"
    }));
    return true;
  }
  var moveLineUp = ({ state, dispatch: dispatch3 }) => moveLine(state, dispatch3, false);
  var moveLineDown = ({ state, dispatch: dispatch3 }) => moveLine(state, dispatch3, true);
  function copyLine(state, dispatch3, forward) {
    if (state.readOnly)
      return false;
    let changes = [];
    for (let block of selectedLineBlocks(state)) {
      if (forward)
        changes.push({ from: block.from, insert: state.doc.slice(block.from, block.to) + state.lineBreak });
      else
        changes.push({ from: block.to, insert: state.lineBreak + state.doc.slice(block.from, block.to) });
    }
    dispatch3(state.update({ changes, scrollIntoView: true, userEvent: "input.copyline" }));
    return true;
  }
  var copyLineUp = ({ state, dispatch: dispatch3 }) => copyLine(state, dispatch3, false);
  var copyLineDown = ({ state, dispatch: dispatch3 }) => copyLine(state, dispatch3, true);
  var deleteLine = (view2) => {
    if (view2.state.readOnly)
      return false;
    let { state } = view2, changes = state.changes(selectedLineBlocks(state).map(({ from, to }) => {
      if (from > 0)
        from--;
      else if (to < state.doc.length)
        to++;
      return { from, to };
    }));
    let selection2 = updateSel(state.selection, (range4) => {
      let dist2 = void 0;
      if (view2.lineWrapping) {
        let block = view2.lineBlockAt(range4.head), pos = view2.coordsAtPos(range4.head, range4.assoc || 1);
        if (pos)
          dist2 = block.bottom + view2.documentTop - pos.bottom + view2.defaultLineHeight / 2;
      }
      return view2.moveVertically(range4, true, dist2);
    }).map(changes);
    view2.dispatch({ changes, selection: selection2, scrollIntoView: true, userEvent: "delete.line" });
    return true;
  };
  function isBetweenBrackets(state, pos) {
    if (/\(\)|\[\]|\{\}/.test(state.sliceDoc(pos - 1, pos + 1)))
      return { from: pos, to: pos };
    let context = syntaxTree(state).resolveInner(pos);
    let before = context.childBefore(pos), after = context.childAfter(pos), closedBy;
    if (before && after && before.to <= pos && after.from >= pos && (closedBy = before.type.prop(NodeProp.closedBy)) && closedBy.indexOf(after.name) > -1 && state.doc.lineAt(before.to).from == state.doc.lineAt(after.from).from && !/\S/.test(state.sliceDoc(before.to, after.from)))
      return { from: before.to, to: after.from };
    return null;
  }
  var insertNewlineAndIndent = /* @__PURE__ */ newlineAndIndent(false);
  var insertBlankLine = /* @__PURE__ */ newlineAndIndent(true);
  function newlineAndIndent(atEof) {
    return ({ state, dispatch: dispatch3 }) => {
      if (state.readOnly)
        return false;
      let changes = state.changeByRange((range4) => {
        let { from, to } = range4, line2 = state.doc.lineAt(from);
        let explode = !atEof && from == to && isBetweenBrackets(state, from);
        if (atEof)
          from = to = (to <= line2.to ? line2 : state.doc.lineAt(to)).to;
        let cx = new IndentContext(state, { simulateBreak: from, simulateDoubleBreak: !!explode });
        let indent = getIndentation(cx, from);
        if (indent == null)
          indent = countColumn(/^\s*/.exec(state.doc.lineAt(from).text)[0], state.tabSize);
        while (to < line2.to && /\s/.test(line2.text[to - line2.from]))
          to++;
        if (explode)
          ({ from, to } = explode);
        else if (from > line2.from && from < line2.from + 100 && !/\S/.test(line2.text.slice(0, from)))
          from = line2.from;
        let insert4 = ["", indentString(state, indent)];
        if (explode)
          insert4.push(indentString(state, cx.lineIndent(line2.from, -1)));
        return {
          changes: { from, to, insert: Text.of(insert4) },
          range: EditorSelection.cursor(from + 1 + insert4[1].length)
        };
      });
      dispatch3(state.update(changes, { scrollIntoView: true, userEvent: "input" }));
      return true;
    };
  }
  function changeBySelectedLine(state, f) {
    let atLine = -1;
    return state.changeByRange((range4) => {
      let changes = [];
      for (let pos = range4.from; pos <= range4.to; ) {
        let line2 = state.doc.lineAt(pos);
        if (line2.number > atLine && (range4.empty || range4.to > line2.from)) {
          f(line2, changes, range4);
          atLine = line2.number;
        }
        pos = line2.to + 1;
      }
      let changeSet = state.changes(changes);
      return {
        changes,
        range: EditorSelection.range(changeSet.mapPos(range4.anchor, 1), changeSet.mapPos(range4.head, 1))
      };
    });
  }
  var indentSelection = ({ state, dispatch: dispatch3 }) => {
    if (state.readOnly)
      return false;
    let updated = /* @__PURE__ */ Object.create(null);
    let context = new IndentContext(state, { overrideIndentation: (start2) => {
      let found = updated[start2];
      return found == null ? -1 : found;
    } });
    let changes = changeBySelectedLine(state, (line2, changes2, range4) => {
      let indent = getIndentation(context, line2.from);
      if (indent == null)
        return;
      if (!/\S/.test(line2.text))
        indent = 0;
      let cur = /^\s*/.exec(line2.text)[0];
      let norm = indentString(state, indent);
      if (cur != norm || range4.from < line2.from + cur.length) {
        updated[line2.from] = indent;
        changes2.push({ from: line2.from, to: line2.from + cur.length, insert: norm });
      }
    });
    if (!changes.changes.empty)
      dispatch3(state.update(changes, { userEvent: "indent" }));
    return true;
  };
  var indentMore = ({ state, dispatch: dispatch3 }) => {
    if (state.readOnly)
      return false;
    dispatch3(state.update(changeBySelectedLine(state, (line2, changes) => {
      changes.push({ from: line2.from, insert: state.facet(indentUnit) });
    }), { userEvent: "input.indent" }));
    return true;
  };
  var indentLess = ({ state, dispatch: dispatch3 }) => {
    if (state.readOnly)
      return false;
    dispatch3(state.update(changeBySelectedLine(state, (line2, changes) => {
      let space2 = /^\s*/.exec(line2.text)[0];
      if (!space2)
        return;
      let col = countColumn(space2, state.tabSize), keep = 0;
      let insert4 = indentString(state, Math.max(0, col - getIndentUnit(state)));
      while (keep < space2.length && keep < insert4.length && space2.charCodeAt(keep) == insert4.charCodeAt(keep))
        keep++;
      changes.push({ from: line2.from + keep, to: line2.from + space2.length, insert: insert4.slice(keep) });
    }), { userEvent: "delete.dedent" }));
    return true;
  };
  var toggleTabFocusMode = (view2) => {
    view2.setTabFocusMode();
    return true;
  };
  var emacsStyleKeymap = [
    { key: "Ctrl-b", run: cursorCharLeft, shift: selectCharLeft, preventDefault: true },
    { key: "Ctrl-f", run: cursorCharRight, shift: selectCharRight },
    { key: "Ctrl-p", run: cursorLineUp, shift: selectLineUp },
    { key: "Ctrl-n", run: cursorLineDown, shift: selectLineDown },
    { key: "Ctrl-a", run: cursorLineStart, shift: selectLineStart },
    { key: "Ctrl-e", run: cursorLineEnd, shift: selectLineEnd },
    { key: "Ctrl-d", run: deleteCharForward },
    { key: "Ctrl-h", run: deleteCharBackward },
    { key: "Ctrl-k", run: deleteToLineEnd },
    { key: "Ctrl-Alt-h", run: deleteGroupBackward },
    { key: "Ctrl-o", run: splitLine },
    { key: "Ctrl-t", run: transposeChars },
    { key: "Ctrl-v", run: cursorPageDown }
  ];
  var standardKeymap = /* @__PURE__ */ [
    { key: "ArrowLeft", run: cursorCharLeft, shift: selectCharLeft, preventDefault: true },
    { key: "Mod-ArrowLeft", mac: "Alt-ArrowLeft", run: cursorGroupLeft, shift: selectGroupLeft, preventDefault: true },
    { mac: "Cmd-ArrowLeft", run: cursorLineBoundaryLeft, shift: selectLineBoundaryLeft, preventDefault: true },
    { key: "ArrowRight", run: cursorCharRight, shift: selectCharRight, preventDefault: true },
    { key: "Mod-ArrowRight", mac: "Alt-ArrowRight", run: cursorGroupRight, shift: selectGroupRight, preventDefault: true },
    { mac: "Cmd-ArrowRight", run: cursorLineBoundaryRight, shift: selectLineBoundaryRight, preventDefault: true },
    { key: "ArrowUp", run: cursorLineUp, shift: selectLineUp, preventDefault: true },
    { mac: "Cmd-ArrowUp", run: cursorDocStart, shift: selectDocStart },
    { mac: "Ctrl-ArrowUp", run: cursorPageUp, shift: selectPageUp },
    { key: "ArrowDown", run: cursorLineDown, shift: selectLineDown, preventDefault: true },
    { mac: "Cmd-ArrowDown", run: cursorDocEnd, shift: selectDocEnd },
    { mac: "Ctrl-ArrowDown", run: cursorPageDown, shift: selectPageDown },
    { key: "PageUp", run: cursorPageUp, shift: selectPageUp },
    { key: "PageDown", run: cursorPageDown, shift: selectPageDown },
    { key: "Home", run: cursorLineBoundaryBackward, shift: selectLineBoundaryBackward, preventDefault: true },
    { key: "Mod-Home", run: cursorDocStart, shift: selectDocStart },
    { key: "End", run: cursorLineBoundaryForward, shift: selectLineBoundaryForward, preventDefault: true },
    { key: "Mod-End", run: cursorDocEnd, shift: selectDocEnd },
    { key: "Enter", run: insertNewlineAndIndent },
    { key: "Mod-a", run: selectAll },
    { key: "Backspace", run: deleteCharBackward, shift: deleteCharBackward },
    { key: "Delete", run: deleteCharForward },
    { key: "Mod-Backspace", mac: "Alt-Backspace", run: deleteGroupBackward },
    { key: "Mod-Delete", mac: "Alt-Delete", run: deleteGroupForward },
    { mac: "Mod-Backspace", run: deleteLineBoundaryBackward },
    { mac: "Mod-Delete", run: deleteLineBoundaryForward }
  ].concat(/* @__PURE__ */ emacsStyleKeymap.map((b) => ({ mac: b.key, run: b.run, shift: b.shift })));
  var defaultKeymap = /* @__PURE__ */ [
    { key: "Alt-ArrowLeft", mac: "Ctrl-ArrowLeft", run: cursorSyntaxLeft, shift: selectSyntaxLeft },
    { key: "Alt-ArrowRight", mac: "Ctrl-ArrowRight", run: cursorSyntaxRight, shift: selectSyntaxRight },
    { key: "Alt-ArrowUp", run: moveLineUp },
    { key: "Shift-Alt-ArrowUp", run: copyLineUp },
    { key: "Alt-ArrowDown", run: moveLineDown },
    { key: "Shift-Alt-ArrowDown", run: copyLineDown },
    { key: "Escape", run: simplifySelection },
    { key: "Mod-Enter", run: insertBlankLine },
    { key: "Alt-l", mac: "Ctrl-l", run: selectLine },
    { key: "Mod-i", run: selectParentSyntax, preventDefault: true },
    { key: "Mod-[", run: indentLess },
    { key: "Mod-]", run: indentMore },
    { key: "Mod-Alt-\\", run: indentSelection },
    { key: "Shift-Mod-k", run: deleteLine },
    { key: "Shift-Mod-\\", run: cursorMatchingBracket },
    { key: "Mod-/", run: toggleComment },
    { key: "Alt-A", run: toggleBlockComment },
    { key: "Ctrl-m", mac: "Shift-Alt-m", run: toggleTabFocusMode }
  ].concat(standardKeymap);

  // output-es/App.CodeMirror/foreign.js
  function curry2(f) {
    return (x1) => (x2) => f(x1, x2);
  }
  var startState = EditorState.create({
    doc: "",
    extensions: [keymap.of(defaultKeymap), EditorView.editable.of(false)]
  });
  function replaceSelection_(editorState, str) {
    return editorState.replaceSelection(str);
  }
  function dispatch_(editorView, tr) {
    return () => {
      editorView.dispatch(tr);
    };
  }
  function update_(editorState, specs) {
    return () => {
      return editorState.update(...specs);
    };
  }
  var dispatch2 = curry2(dispatch_);
  var replaceSelection = curry2(replaceSelection_);
  var update = curry2(update_);

  // output-es/Control.Semigroupoid/index.js
  var semigroupoidFn = { compose: (f) => (g) => (x2) => f(g(x2)) };

  // output-es/Control.Category/index.js
  var categoryFn = { identity: (x2) => x2, Semigroupoid0: () => semigroupoidFn };

  // output-es/Data.Function/index.js
  var $$const = (a) => (v) => a;
  var applyFlipped = (x2) => (f) => f(x2);
  var apply = (f) => (x2) => f(x2);

  // output-es/Type.Proxy/index.js
  var $$$Proxy = () => ({ tag: "Proxy" });
  var $$Proxy = /* @__PURE__ */ $$$Proxy();

  // output-es/Data.Functor/foreign.js
  var arrayMap = function(f) {
    return function(arr) {
      var l = arr.length;
      var result = new Array(l);
      for (var i = 0; i < l; i++) {
        result[i] = f(arr[i]);
      }
      return result;
    };
  };

  // output-es/Data.Functor/index.js
  var functorArray = { map: arrayMap };

  // output-es/Control.Apply/index.js
  var identity4 = (x2) => x2;

  // output-es/Control.Bind/foreign.js
  var arrayBind = function(arr) {
    return function(f) {
      var result = [];
      for (var i = 0, l = arr.length; i < l; i++) {
        Array.prototype.push.apply(result, f(arr[i]));
      }
      return result;
    };
  };

  // output-es/Control.Bind/index.js
  var identity5 = (x2) => x2;

  // output-es/Data.Show/foreign.js
  var showIntImpl = function(n) {
    return n.toString();
  };
  var showNumberImpl = function(n) {
    var str = n.toString();
    return isNaN(str + ".0") ? str : str + ".0";
  };
  var showCharImpl = function(c) {
    var code = c.charCodeAt(0);
    if (code < 32 || code === 127) {
      switch (c) {
        case "\x07":
          return "'\\a'";
        case "\b":
          return "'\\b'";
        case "\f":
          return "'\\f'";
        case "\n":
          return "'\\n'";
        case "\r":
          return "'\\r'";
        case "	":
          return "'\\t'";
        case "\v":
          return "'\\v'";
      }
      return "'\\" + code.toString(10) + "'";
    }
    return c === "'" || c === "\\" ? "'\\" + c + "'" : "'" + c + "'";
  };
  var showStringImpl = function(s) {
    var l = s.length;
    return '"' + s.replace(
      /[\0-\x1F\x7F"\\]/g,
      function(c, i) {
        switch (c) {
          case '"':
          case "\\":
            return "\\" + c;
          case "\x07":
            return "\\a";
          case "\b":
            return "\\b";
          case "\f":
            return "\\f";
          case "\n":
            return "\\n";
          case "\r":
            return "\\r";
          case "	":
            return "\\t";
          case "\v":
            return "\\v";
        }
        var k = i + 1;
        var empty4 = k < l && s[k] >= "0" && s[k] <= "9" ? "\\&" : "";
        return "\\" + c.charCodeAt(0).toString(10) + empty4;
      }
    ) + '"';
  };
  var showArrayImpl = function(f) {
    return function(xs) {
      var ss = [];
      for (var i = 0, l = xs.length; i < l; i++) {
        ss[i] = f(xs[i]);
      }
      return "[" + ss.join(",") + "]";
    };
  };

  // output-es/Data.Show/index.js
  var showString = { show: showStringImpl };
  var showNumber = { show: showNumberImpl };
  var showInt = { show: showIntImpl };
  var showBoolean = {
    show: (v) => {
      if (v) {
        return "true";
      }
      return "false";
    }
  };

  // output-es/Data.Generic.Rep/index.js
  var $NoArguments = () => ({ tag: "NoArguments" });
  var $Product = (_1, _2) => ({ tag: "Product", _1, _2 });
  var $Sum = (tag, _1) => ({ tag, _1 });
  var NoArguments = /* @__PURE__ */ $NoArguments();

  // output-es/Data.Ordering/index.js
  var $Ordering = (tag) => tag;
  var LT = /* @__PURE__ */ $Ordering("LT");
  var GT = /* @__PURE__ */ $Ordering("GT");
  var EQ = /* @__PURE__ */ $Ordering("EQ");

  // output-es/Data.Maybe/index.js
  var $Maybe = (tag, _1) => ({ tag, _1 });
  var Nothing = /* @__PURE__ */ $Maybe("Nothing");
  var Just = (value0) => $Maybe("Just", value0);
  var isNothing = (v2) => {
    if (v2.tag === "Nothing") {
      return true;
    }
    if (v2.tag === "Just") {
      return false;
    }
    fail();
  };
  var functorMaybe = {
    map: (v) => (v1) => {
      if (v1.tag === "Just") {
        return $Maybe("Just", v(v1._1));
      }
      return Nothing;
    }
  };
  var applyMaybe = {
    apply: (v) => (v1) => {
      if (v.tag === "Just") {
        if (v1.tag === "Just") {
          return $Maybe("Just", v._1(v1._1));
        }
        return Nothing;
      }
      if (v.tag === "Nothing") {
        return Nothing;
      }
      fail();
    },
    Functor0: () => functorMaybe
  };
  var applicativeMaybe = { pure: Just, Apply0: () => applyMaybe };

  // output-es/Data.Either/index.js
  var $Either = (tag, _1) => ({ tag, _1 });
  var Left = (value0) => $Either("Left", value0);
  var Right = (value0) => $Either("Right", value0);
  var functorEither = {
    map: (f) => (m) => {
      if (m.tag === "Left") {
        return $Either("Left", m._1);
      }
      if (m.tag === "Right") {
        return $Either("Right", f(m._1));
      }
      fail();
    }
  };
  var choose = (dictAlt) => {
    const $0 = dictAlt.Functor0();
    return (a) => (b) => dictAlt.alt($0.map(Left)(a))($0.map(Right)(b));
  };

  // output-es/Data.Identity/index.js
  var Identity = (x2) => x2;
  var functorIdentity = { map: (f) => (m) => f(m) };
  var applyIdentity = { apply: (v) => (v1) => v(v1), Functor0: () => functorIdentity };
  var bindIdentity = { bind: (v) => (f) => f(v), Apply0: () => applyIdentity };
  var applicativeIdentity = { pure: Identity, Apply0: () => applyIdentity };
  var monadIdentity = { Applicative0: () => applicativeIdentity, Bind1: () => bindIdentity };

  // output-es/Effect/foreign.js
  var pureE = function(a) {
    return function() {
      return a;
    };
  };
  var bindE = function(a) {
    return function(f) {
      return function() {
        return f(a())();
      };
    };
  };

  // output-es/Effect/index.js
  var monadEffect = { Applicative0: () => applicativeEffect, Bind1: () => bindEffect };
  var bindEffect = { bind: bindE, Apply0: () => applyEffect };
  var applyEffect = {
    apply: (f) => (a) => () => {
      const f$p = f();
      const a$p = a();
      return applicativeEffect.pure(f$p(a$p))();
    },
    Functor0: () => functorEffect
  };
  var applicativeEffect = { pure: pureE, Apply0: () => applyEffect };
  var functorEffect = {
    map: (f) => (a) => () => {
      const a$p = a();
      return f(a$p);
    }
  };

  // output-es/Control.Monad.Rec.Class/index.js
  var $Step = (tag, _1) => ({ tag, _1 });
  var Loop = (value0) => $Step("Loop", value0);
  var monadRecIdentity = {
    tailRecM: (f) => {
      const go = (go$a0$copy) => {
        let go$a0 = go$a0$copy, go$c = true, go$r;
        while (go$c) {
          const v = go$a0;
          if (v.tag === "Loop") {
            go$a0 = f(v._1);
            continue;
          }
          if (v.tag === "Done") {
            go$c = false;
            go$r = v._1;
            continue;
          }
          fail();
        }
        return go$r;
      };
      return (x2) => go(f(x2));
    },
    Monad0: () => monadIdentity
  };

  // output-es/Control.Monad.ST.Internal/foreign.js
  var map_ = function(f) {
    return function(a) {
      return function() {
        return f(a());
      };
    };
  };
  var pure_ = function(a) {
    return function() {
      return a;
    };
  };
  var bind_ = function(a) {
    return function(f) {
      return function() {
        return f(a())();
      };
    };
  };

  // output-es/Control.Monad.ST.Internal/index.js
  var functorST = { map: map_ };
  var monadST = { Applicative0: () => applicativeST, Bind1: () => bindST };
  var bindST = { bind: bind_, Apply0: () => applyST };
  var applyST = {
    apply: (f) => (a) => () => {
      const f$p = f();
      const a$p = a();
      return applicativeST.pure(f$p(a$p))();
    },
    Functor0: () => functorST
  };
  var applicativeST = { pure: pure_, Apply0: () => applyST };
  var monadRecST = {
    tailRecM: (f) => (a) => {
      const $0 = f(a);
      return () => {
        const $1 = $0();
        let r = $1;
        while ((() => {
          const $22 = r;
          return $22.tag === "Loop";
        })()) {
          const v = r;
          if (v.tag === "Loop") {
            const e = f(v._1)();
            r = e;
            continue;
          }
          if (v.tag === "Done") {
            continue;
          }
          fail();
        }
        const $2 = r;
        if ($2.tag === "Done") {
          return $2._1;
        }
        fail();
      };
    },
    Monad0: () => monadST
  };

  // output-es/Control.Monad.ST.Uncurried/foreign.js
  var runSTFn2 = function runSTFn22(fn) {
    return function(a) {
      return function(b) {
        return function() {
          return fn(a, b);
        };
      };
    };
  };

  // output-es/Data.Array.ST/foreign.js
  var pushAllImpl = function(as, xs) {
    return xs.push.apply(xs, as);
  };
  var sortByImpl = function() {
    function mergeFromTo(compare2, fromOrdering, xs1, xs2, from, to) {
      var mid;
      var i;
      var j;
      var k;
      var x2;
      var y2;
      var c;
      mid = from + (to - from >> 1);
      if (mid - from > 1)
        mergeFromTo(compare2, fromOrdering, xs2, xs1, from, mid);
      if (to - mid > 1)
        mergeFromTo(compare2, fromOrdering, xs2, xs1, mid, to);
      i = from;
      j = mid;
      k = from;
      while (i < mid && j < to) {
        x2 = xs2[i];
        y2 = xs2[j];
        c = fromOrdering(compare2(x2)(y2));
        if (c > 0) {
          xs1[k++] = y2;
          ++j;
        } else {
          xs1[k++] = x2;
          ++i;
        }
      }
      while (i < mid) {
        xs1[k++] = xs2[i++];
      }
      while (j < to) {
        xs1[k++] = xs2[j++];
      }
    }
    return function(compare2, fromOrdering, xs) {
      if (xs.length < 2)
        return xs;
      mergeFromTo(compare2, fromOrdering, xs, xs.slice(0), 0, xs.length);
      return xs;
    };
  }();

  // output-es/Data.Array.ST/index.js
  var push = (a) => runSTFn2(pushAllImpl)([a]);

  // output-es/Data.Foldable/foreign.js
  var foldrArray = function(f) {
    return function(init5) {
      return function(xs) {
        var acc = init5;
        var len = xs.length;
        for (var i = len - 1; i >= 0; i--) {
          acc = f(xs[i])(acc);
        }
        return acc;
      };
    };
  };
  var foldlArray = function(f) {
    return function(init5) {
      return function(xs) {
        var acc = init5;
        var len = xs.length;
        for (var i = 0; i < len; i++) {
          acc = f(acc)(xs[i]);
        }
        return acc;
      };
    };
  };

  // output-es/Data.Foldable/index.js
  var identity6 = (x2) => x2;
  var monoidEndo = /* @__PURE__ */ (() => {
    const semigroupEndo1 = { append: (v) => (v1) => (x2) => v(v1(x2)) };
    return { mempty: (x2) => x2, Semigroup0: () => semigroupEndo1 };
  })();
  var traverse_ = (dictApplicative) => {
    const $0 = dictApplicative.Apply0();
    return (dictFoldable) => (f) => dictFoldable.foldr((x2) => {
      const $1 = f(x2);
      return (b) => $0.apply($0.Functor0().map((v) => identity4)($1))(b);
    })(dictApplicative.pure());
  };
  var for_ = (dictApplicative) => {
    const traverse_1 = traverse_(dictApplicative);
    return (dictFoldable) => {
      const $0 = traverse_1(dictFoldable);
      return (b) => (a) => $0(a)(b);
    };
  };
  var foldableTuple = { foldr: (f) => (z) => (v) => f(v._2)(z), foldl: (f) => (z) => (v) => f(z)(v._2), foldMap: (dictMonoid) => (f) => (v) => f(v._2) };
  var foldableArray = {
    foldr: foldrArray,
    foldl: foldlArray,
    foldMap: (dictMonoid) => {
      const mempty5 = dictMonoid.mempty;
      return (f) => foldableArray.foldr((x2) => (acc) => dictMonoid.Semigroup0().append(f(x2))(acc))(mempty5);
    }
  };
  var foldrDefault = (dictFoldable) => {
    const foldMap2 = dictFoldable.foldMap(monoidEndo);
    return (c) => (u) => (xs) => foldMap2((x2) => c(x2))(xs)(u);
  };

  // output-es/Data.Tuple/index.js
  var $Tuple = (_1, _2) => ({ tag: "Tuple", _1, _2 });
  var Tuple = (value0) => (value1) => $Tuple(value0, value1);
  var swap = (v) => $Tuple(v._2, v._1);
  var snd = (v) => v._2;
  var functorTuple = { map: (f) => (m) => $Tuple(m._1, f(m._2)) };
  var fst = (v) => v._1;
  var ordTuple = (dictOrd) => {
    const $0 = dictOrd.Eq0();
    return (dictOrd1) => {
      const $1 = dictOrd1.Eq0();
      const eqTuple2 = { eq: (x2) => (y2) => $0.eq(x2._1)(y2._1) && $1.eq(x2._2)(y2._2) };
      return {
        compare: (x2) => (y2) => {
          const v = dictOrd.compare(x2._1)(y2._1);
          if (v === "LT") {
            return LT;
          }
          if (v === "GT") {
            return GT;
          }
          return dictOrd1.compare(x2._2)(y2._2);
        },
        Eq0: () => eqTuple2
      };
    };
  };

  // output-es/Data.FunctorWithIndex/foreign.js
  var mapWithIndexArray = function(f) {
    return function(xs) {
      var l = xs.length;
      var result = Array(l);
      for (var i = 0; i < l; i++) {
        result[i] = f(i)(xs[i]);
      }
      return result;
    };
  };

  // output-es/Data.Eq/foreign.js
  var refEq = function(r1) {
    return function(r2) {
      return r1 === r2;
    };
  };
  var eqIntImpl = refEq;
  var eqNumberImpl = refEq;
  var eqCharImpl = refEq;
  var eqStringImpl = refEq;

  // output-es/Data.Eq/index.js
  var eqUnit = { eq: (v) => (v1) => true };
  var eqString = { eq: eqStringImpl };
  var eqNumber = { eq: eqNumberImpl };
  var eqInt = { eq: eqIntImpl };
  var eqChar = { eq: eqCharImpl };

  // output-es/Data.Ord/foreign.js
  var unsafeCompareImpl = function(lt) {
    return function(eq2) {
      return function(gt) {
        return function(x2) {
          return function(y2) {
            return x2 < y2 ? lt : x2 === y2 ? eq2 : gt;
          };
        };
      };
    };
  };
  var ordIntImpl = unsafeCompareImpl;
  var ordNumberImpl = unsafeCompareImpl;
  var ordStringImpl = unsafeCompareImpl;

  // output-es/Data.Ord/index.js
  var ordString = { compare: /* @__PURE__ */ ordStringImpl(LT)(EQ)(GT), Eq0: () => eqString };
  var ordNumber = { compare: /* @__PURE__ */ ordNumberImpl(LT)(EQ)(GT), Eq0: () => eqNumber };
  var ordInt = { compare: /* @__PURE__ */ ordIntImpl(LT)(EQ)(GT), Eq0: () => eqInt };

  // output-es/Unsafe.Coerce/foreign.js
  var unsafeCoerce = function(x2) {
    return x2;
  };

  // output-es/Data.Traversable/foreign.js
  var traverseArrayImpl = function() {
    function array1(a) {
      return [a];
    }
    function array2(a) {
      return function(b) {
        return [a, b];
      };
    }
    function array3(a) {
      return function(b) {
        return function(c) {
          return [a, b, c];
        };
      };
    }
    function concat2(xs) {
      return function(ys) {
        return xs.concat(ys);
      };
    }
    return function(apply4) {
      return function(map3) {
        return function(pure3) {
          return function(f) {
            return function(array4) {
              function go(bot, top3) {
                switch (top3 - bot) {
                  case 0:
                    return pure3([]);
                  case 1:
                    return map3(array1)(f(array4[bot]));
                  case 2:
                    return apply4(map3(array2)(f(array4[bot])))(f(array4[bot + 1]));
                  case 3:
                    return apply4(apply4(map3(array3)(f(array4[bot])))(f(array4[bot + 1])))(f(array4[bot + 2]));
                  default:
                    var pivot = bot + Math.floor((top3 - bot) / 4) * 2;
                    return apply4(map3(concat2)(go(bot, pivot)))(go(pivot, top3));
                }
              }
              return go(0, array4.length);
            };
          };
        };
      };
    };
  }();

  // output-es/Data.Traversable/index.js
  var identity7 = (x2) => x2;
  var traversableTuple = {
    traverse: (dictApplicative) => (f) => (v) => dictApplicative.Apply0().Functor0().map(Tuple(v._1))(f(v._2)),
    sequence: (dictApplicative) => (v) => dictApplicative.Apply0().Functor0().map(Tuple(v._1))(v._2),
    Functor0: () => functorTuple,
    Foldable1: () => foldableTuple
  };
  var traversableArray = {
    traverse: (dictApplicative) => {
      const Apply0 = dictApplicative.Apply0();
      return traverseArrayImpl(Apply0.apply)(Apply0.Functor0().map)(dictApplicative.pure);
    },
    sequence: (dictApplicative) => traversableArray.traverse(dictApplicative)(identity7),
    Functor0: () => functorArray,
    Foldable1: () => foldableArray
  };

  // output-es/Data.Array/foreign.js
  var rangeImpl = function(start2, end) {
    var step = start2 > end ? -1 : 1;
    var result = new Array(step * (end - start2) + 1);
    var i = start2, n = 0;
    while (i !== end) {
      result[n++] = i;
      i += step;
    }
    result[n] = i;
    return result;
  };
  var replicateFill = function(count, value) {
    if (count < 1) {
      return [];
    }
    var result = new Array(count);
    return result.fill(value);
  };
  var replicatePolyfill = function(count, value) {
    var result = [];
    var n = 0;
    for (var i = 0; i < count; i++) {
      result[n++] = value;
    }
    return result;
  };
  var replicateImpl = typeof Array.prototype.fill === "function" ? replicateFill : replicatePolyfill;
  var fromFoldableImpl = function() {
    function Cons2(head, tail3) {
      this.head = head;
      this.tail = tail3;
    }
    var emptyList = {};
    function curryCons(head) {
      return function(tail3) {
        return new Cons2(head, tail3);
      };
    }
    function listToArray(list) {
      var result = [];
      var count = 0;
      var xs = list;
      while (xs !== emptyList) {
        result[count++] = xs.head;
        xs = xs.tail;
      }
      return result;
    }
    return function(foldr2, xs) {
      return listToArray(foldr2(curryCons)(emptyList)(xs));
    };
  }();
  var unconsImpl = function(empty4, next, xs) {
    return xs.length === 0 ? empty4({}) : next(xs[0])(xs.slice(1));
  };
  var findIndexImpl = function(just, nothing, f, xs) {
    for (var i = 0, l = xs.length; i < l; i++) {
      if (f(xs[i]))
        return just(i);
    }
    return nothing;
  };
  var _updateAt = function(just, nothing, i, a, l) {
    if (i < 0 || i >= l.length)
      return nothing;
    var l1 = l.slice();
    l1[i] = a;
    return just(l1);
  };
  var concat = function(xss) {
    if (xss.length <= 1e4) {
      return Array.prototype.concat.apply([], xss);
    }
    var result = [];
    for (var i = 0, l = xss.length; i < l; i++) {
      var xs = xss[i];
      for (var j = 0, m = xs.length; j < m; j++) {
        result.push(xs[j]);
      }
    }
    return result;
  };
  var filterImpl = function(f, xs) {
    return xs.filter(f);
  };
  var partitionImpl = function(f, xs) {
    var yes = [];
    var no = [];
    for (var i = 0; i < xs.length; i++) {
      var x2 = xs[i];
      if (f(x2))
        yes.push(x2);
      else
        no.push(x2);
    }
    return { yes, no };
  };
  var sortByImpl2 = function() {
    function mergeFromTo(compare2, fromOrdering, xs1, xs2, from, to) {
      var mid;
      var i;
      var j;
      var k;
      var x2;
      var y2;
      var c;
      mid = from + (to - from >> 1);
      if (mid - from > 1)
        mergeFromTo(compare2, fromOrdering, xs2, xs1, from, mid);
      if (to - mid > 1)
        mergeFromTo(compare2, fromOrdering, xs2, xs1, mid, to);
      i = from;
      j = mid;
      k = from;
      while (i < mid && j < to) {
        x2 = xs2[i];
        y2 = xs2[j];
        c = fromOrdering(compare2(x2)(y2));
        if (c > 0) {
          xs1[k++] = y2;
          ++j;
        } else {
          xs1[k++] = x2;
          ++i;
        }
      }
      while (i < mid) {
        xs1[k++] = xs2[i++];
      }
      while (j < to) {
        xs1[k++] = xs2[j++];
      }
    }
    return function(compare2, fromOrdering, xs) {
      var out;
      if (xs.length < 2)
        return xs;
      out = xs.slice(0);
      mergeFromTo(compare2, fromOrdering, out, xs.slice(0), 0, xs.length);
      return out;
    };
  }();
  var sliceImpl = function(s, e, l) {
    return l.slice(s, e);
  };
  var zipWithImpl = function(f, xs, ys) {
    var l = xs.length < ys.length ? xs.length : ys.length;
    var result = new Array(l);
    for (var i = 0; i < l; i++) {
      result[i] = f(xs[i])(ys[i]);
    }
    return result;
  };

  // output-es/Data.Array/index.js
  var zipWith = ($0) => ($1) => ($2) => zipWithImpl($0, $1, $2);
  var toUnfoldable = (dictUnfoldable) => (xs) => {
    const len = xs.length;
    return dictUnfoldable.unfoldr((i) => {
      if (i < len) {
        return $Maybe("Just", $Tuple(xs[i], i + 1 | 0));
      }
      return Nothing;
    })(0);
  };
  var sortBy = (comp) => ($0) => sortByImpl2(
    comp,
    (v) => {
      if (v === "GT") {
        return 1;
      }
      if (v === "EQ") {
        return 0;
      }
      if (v === "LT") {
        return -1;
      }
      fail();
    },
    $0
  );
  var sortWith = (dictOrd) => (f) => sortBy((x2) => (y2) => dictOrd.compare(f(x2))(f(y2)));
  var snoc = (xs) => (x2) => (() => {
    const $0 = push(x2);
    return () => {
      const result = [...xs];
      $0(result)();
      return result;
    };
  })()();
  var last = (xs) => {
    const $0 = xs.length - 1 | 0;
    if ($0 >= 0 && $0 < xs.length) {
      return $Maybe("Just", xs[$0]);
    }
    return Nothing;
  };
  var nubBy = (comp) => (xs) => {
    const indexedAndSorted = sortBy((x2) => (y2) => comp(x2._2)(y2._2))(mapWithIndexArray(Tuple)(xs));
    if (0 < indexedAndSorted.length) {
      return arrayMap(snd)(sortWith(ordInt)(fst)((() => {
        const result = [indexedAndSorted[0]];
        for (const v1 of indexedAndSorted) {
          const $0 = comp((() => {
            const $02 = last(result);
            if ($02.tag === "Just") {
              return $02._1._2;
            }
            fail();
          })())(v1._2);
          if ($0 === "LT" || $0 === "GT" || $0 !== "EQ") {
            result.push(v1);
          }
        }
        return result;
      })()));
    }
    return [];
  };
  var notElem = (dictEq) => (a) => (arr) => {
    const $0 = findIndexImpl(Just, Nothing, (v) => dictEq.eq(v)(a), arr);
    if ($0.tag === "Nothing") {
      return true;
    }
    if ($0.tag === "Just") {
      return false;
    }
    fail();
  };
  var elem = (dictEq) => (a) => (arr) => {
    const $0 = findIndexImpl(Just, Nothing, (v) => dictEq.eq(v)(a), arr);
    if ($0.tag === "Nothing") {
      return false;
    }
    if ($0.tag === "Just") {
      return true;
    }
    fail();
  };
  var cons = (x2) => (xs) => [x2, ...xs];
  var some = (dictAlternative) => (dictLazy) => (v) => dictAlternative.Applicative0().Apply0().apply(dictAlternative.Plus1().Alt0().Functor0().map(cons)(v))(dictLazy.defer((v1) => many(dictAlternative)(dictLazy)(v)));
  var many = (dictAlternative) => (dictLazy) => (v) => dictAlternative.Plus1().Alt0().alt(some(dictAlternative)(dictLazy)(v))(dictAlternative.Applicative0().pure([]));

  // output-es/Data.Number/foreign.js
  var isFiniteImpl = isFinite;
  var ceil = Math.ceil;
  var floor = Math.floor;
  var log = Math.log;
  var pow = function(n) {
    return function(p) {
      return Math.pow(n, p);
    };
  };

  // output-es/Data.Int/foreign.js
  var fromNumberImpl = function(just) {
    return function(nothing) {
      return function(n) {
        return (n | 0) === n ? just(n) : nothing;
      };
    };
  };
  var toNumber = function(n) {
    return n;
  };
  var fromStringAsImpl = function(just) {
    return function(nothing) {
      return function(radix) {
        var digits;
        if (radix < 11) {
          digits = "[0-" + (radix - 1).toString() + "]";
        } else if (radix === 11) {
          digits = "[0-9a]";
        } else {
          digits = "[0-9a-" + String.fromCharCode(86 + radix) + "]";
        }
        var pattern3 = new RegExp("^[\\+\\-]?" + digits + "+$", "i");
        return function(s) {
          if (pattern3.test(s)) {
            var i = parseInt(s, radix);
            return (i | 0) === i ? just(i) : nothing;
          } else {
            return nothing;
          }
        };
      };
    };
  };
  var toStringAs = function(radix) {
    return function(i) {
      return i.toString(radix);
    };
  };
  var quot = function(x2) {
    return function(y2) {
      return x2 / y2 | 0;
    };
  };
  var rem = function(x2) {
    return function(y2) {
      return x2 % y2;
    };
  };
  var pow2 = function(x2) {
    return function(y2) {
      return Math.pow(x2, y2) | 0;
    };
  };

  // output-es/Data.Int/index.js
  var fromStringAs = /* @__PURE__ */ fromStringAsImpl(Just)(Nothing);
  var fromNumber = /* @__PURE__ */ fromNumberImpl(Just)(Nothing);
  var unsafeClamp = (x2) => {
    if (!isFiniteImpl(x2)) {
      return 0;
    }
    if (x2 >= toNumber(2147483647)) {
      return 2147483647;
    }
    if (x2 <= toNumber(-2147483648)) {
      return -2147483648;
    }
    const $0 = fromNumber(x2);
    if ($0.tag === "Nothing") {
      return 0;
    }
    if ($0.tag === "Just") {
      return $0._1;
    }
    fail();
  };
  var floor2 = (x2) => unsafeClamp(floor(x2));
  var ceil2 = (x2) => unsafeClamp(ceil(x2));

  // output-es/Data.Nullable/foreign.js
  var nullImpl = null;
  function nullable(a, r, f) {
    return a == null ? r : f(a);
  }
  function notNull(x2) {
    return x2;
  }

  // output-es/Data.Profunctor/index.js
  var profunctorFn = { dimap: (a2b) => (c2d) => (b2c) => (x2) => c2d(b2c(a2b(x2))) };

  // output-es/Data.Profunctor.Strong/index.js
  var identity8 = (x2) => x2;
  var strongFn = /* @__PURE__ */ (() => ({ first: (a2b) => (v) => $Tuple(a2b(v._1), v._2), second: functorTuple.map, Profunctor0: () => profunctorFn }))();
  var fanout = (dictCategory) => {
    const identity1 = dictCategory.identity;
    const $0 = dictCategory.Semigroupoid0();
    const $1 = dictCategory.Semigroupoid0();
    return (dictStrong) => (l) => (r) => $0.compose($1.compose(dictStrong.second(r))(dictStrong.first(l)))(dictStrong.Profunctor0().dimap(identity8)((a) => $Tuple(a, a))(identity1));
  };

  // output-es/Data.Show.Generic/foreign.js
  var intercalate = function(separator) {
    return function(xs) {
      return xs.join(separator);
    };
  };

  // output-es/Data.Show.Generic/index.js
  var genericShowArgsNoArguments = { genericShowArgs: (v) => [] };
  var genericShowArgsProduct = (dictGenericShowArgs) => (dictGenericShowArgs1) => ({ genericShowArgs: (v) => [...dictGenericShowArgs.genericShowArgs(v._1), ...dictGenericShowArgs1.genericShowArgs(v._2)] });
  var genericShowConstructor = (dictGenericShowArgs) => (dictIsSymbol) => ({
    "genericShow'": (v) => {
      const ctor = dictIsSymbol.reflectSymbol($$Proxy);
      const v1 = dictGenericShowArgs.genericShowArgs(v);
      if (v1.length === 0) {
        return ctor;
      }
      return "(" + intercalate(" ")([ctor, ...v1]) + ")";
    }
  });

  // output-es/Data.String.Unsafe/foreign.js
  var charAt = function(i) {
    return function(s) {
      if (i >= 0 && i < s.length)
        return s.charAt(i);
      throw new Error("Data.String.Unsafe.charAt: Invalid index.");
    };
  };

  // output-es/Data.String.CodeUnits/foreign.js
  var fromCharArray = function(a) {
    return a.join("");
  };
  var toCharArray = function(s) {
    return s.split("");
  };
  var singleton = function(c) {
    return c;
  };
  var _charAt = function(just) {
    return function(nothing) {
      return function(i) {
        return function(s) {
          return i >= 0 && i < s.length ? just(s.charAt(i)) : nothing;
        };
      };
    };
  };
  var _toChar = function(just) {
    return function(nothing) {
      return function(s) {
        return s.length === 1 ? just(s) : nothing;
      };
    };
  };
  var length2 = function(s) {
    return s.length;
  };
  var _indexOf = function(just) {
    return function(nothing) {
      return function(x2) {
        return function(s) {
          var i = s.indexOf(x2);
          return i === -1 ? nothing : just(i);
        };
      };
    };
  };
  var take = function(n) {
    return function(s) {
      return s.substr(0, n);
    };
  };
  var drop = function(n) {
    return function(s) {
      return s.substring(n);
    };
  };
  var splitAt = function(i) {
    return function(s) {
      return { before: s.substring(0, i), after: s.substring(i) };
    };
  };

  // output-es/Data.String.CodeUnits/index.js
  var uncons = (v) => {
    if (v === "") {
      return Nothing;
    }
    return $Maybe("Just", { head: charAt(0)(v), tail: drop(1)(v) });
  };
  var toChar = /* @__PURE__ */ _toChar(Just)(Nothing);
  var stripPrefix = (v) => (str) => {
    const v1 = splitAt(length2(v))(str);
    if (v1.before === v) {
      return $Maybe("Just", v1.after);
    }
    return Nothing;
  };
  var indexOf = /* @__PURE__ */ _indexOf(Just)(Nothing);
  var contains2 = (pat) => {
    const $0 = indexOf(pat);
    return (x2) => {
      const $1 = $0(x2);
      if ($1.tag === "Nothing") {
        return false;
      }
      if ($1.tag === "Just") {
        return true;
      }
      fail();
    };
  };
  var charAt2 = /* @__PURE__ */ _charAt(Just)(Nothing);

  // output-es/Data.String.Common/foreign.js
  var replaceAll = function(s1) {
    return function(s2) {
      return function(s3) {
        return s3.replace(new RegExp(s1.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&"), "g"), s2);
      };
    };
  };
  var split = function(sep) {
    return function(s) {
      return s.split(sep);
    };
  };
  var toLower = function(s) {
    return s.toLowerCase();
  };
  var joinWith = function(s) {
    return function(xs) {
      return xs.join(s);
    };
  };

  // output-es/Data.FoldableWithIndex/index.js
  var monoidEndo2 = /* @__PURE__ */ (() => {
    const semigroupEndo1 = { append: (v) => (v1) => (x2) => v(v1(x2)) };
    return { mempty: (x2) => x2, Semigroup0: () => semigroupEndo1 };
  })();
  var traverseWithIndex_ = (dictApplicative) => {
    const $0 = dictApplicative.Apply0();
    return (dictFoldableWithIndex) => (f) => dictFoldableWithIndex.foldrWithIndex((i) => {
      const $1 = f(i);
      return (x2) => {
        const $2 = $1(x2);
        return (b) => $0.apply($0.Functor0().map((v) => identity4)($2))(b);
      };
    })(dictApplicative.pure());
  };
  var forWithIndex_ = (dictApplicative) => {
    const traverseWithIndex_1 = traverseWithIndex_(dictApplicative);
    return (dictFoldableWithIndex) => {
      const $0 = traverseWithIndex_1(dictFoldableWithIndex);
      return (b) => (a) => $0(a)(b);
    };
  };
  var foldableWithIndexArray = {
    foldrWithIndex: (f) => (z) => {
      const $0 = foldrArray((v) => {
        const $02 = v._1;
        const $12 = v._2;
        return (y2) => f($02)($12)(y2);
      })(z);
      const $1 = mapWithIndexArray(Tuple);
      return (x2) => $0($1(x2));
    },
    foldlWithIndex: (f) => (z) => {
      const $0 = foldlArray((y2) => (v) => f(v._1)(y2)(v._2))(z);
      const $1 = mapWithIndexArray(Tuple);
      return (x2) => $0($1(x2));
    },
    foldMapWithIndex: (dictMonoid) => {
      const mempty5 = dictMonoid.mempty;
      return (f) => foldableWithIndexArray.foldrWithIndex((i) => (x2) => (acc) => dictMonoid.Semigroup0().append(f(i)(x2))(acc))(mempty5);
    },
    Foldable0: () => foldableArray
  };
  var foldrWithIndexDefault = (dictFoldableWithIndex) => {
    const foldMapWithIndex1 = dictFoldableWithIndex.foldMapWithIndex(monoidEndo2);
    return (c) => (u) => (xs) => foldMapWithIndex1((i) => c(i))(xs)(u);
  };

  // output-es/Data.Unfoldable1/foreign.js
  var unfoldr1ArrayImpl = function(isNothing2) {
    return function(fromJust3) {
      return function(fst2) {
        return function(snd2) {
          return function(f) {
            return function(b) {
              var result = [];
              var value = b;
              while (true) {
                var tuple = f(value);
                result.push(fst2(tuple));
                var maybe = snd2(tuple);
                if (isNothing2(maybe))
                  return result;
                value = fromJust3(maybe);
              }
            };
          };
        };
      };
    };
  };

  // output-es/Data.Unfoldable1/index.js
  var fromJust = (v) => {
    if (v.tag === "Just") {
      return v._1;
    }
    fail();
  };
  var unfoldable1Array = { unfoldr1: /* @__PURE__ */ unfoldr1ArrayImpl(isNothing)(fromJust)(fst)(snd) };

  // output-es/Data.Unfoldable/foreign.js
  var unfoldrArrayImpl = function(isNothing2) {
    return function(fromJust3) {
      return function(fst2) {
        return function(snd2) {
          return function(f) {
            return function(b) {
              var result = [];
              var value = b;
              while (true) {
                var maybe = f(value);
                if (isNothing2(maybe))
                  return result;
                var tuple = fromJust3(maybe);
                result.push(fst2(tuple));
                value = snd2(tuple);
              }
            };
          };
        };
      };
    };
  };

  // output-es/Data.Unfoldable/index.js
  var fromJust2 = (v) => {
    if (v.tag === "Just") {
      return v._1;
    }
    fail();
  };
  var unfoldableArray = {
    unfoldr: /* @__PURE__ */ unfoldrArrayImpl(isNothing)(fromJust2)(fst)(snd),
    Unfoldable10: () => unfoldable1Array
  };
  var replicate = (dictUnfoldable) => (n) => (v) => dictUnfoldable.unfoldr((i) => {
    if (i <= 0) {
      return Nothing;
    }
    return $Maybe("Just", $Tuple(v, i - 1 | 0));
  })(n);

  // output-es/Foreign.Object/foreign.js
  var empty2 = {};
  function _fmapObject(m0, f) {
    var m = {};
    for (var k in m0) {
      if (hasOwnProperty.call(m0, k)) {
        m[k] = f(m0[k]);
      }
    }
    return m;
  }
  function _mapWithKey(m0, f) {
    var m = {};
    for (var k in m0) {
      if (hasOwnProperty.call(m0, k)) {
        m[k] = f(k)(m0[k]);
      }
    }
    return m;
  }
  function _foldM(bind) {
    return function(f) {
      return function(mz) {
        return function(m) {
          var acc = mz;
          function g(k2) {
            return function(z) {
              return f(z)(k2)(m[k2]);
            };
          }
          for (var k in m) {
            if (hasOwnProperty.call(m, k)) {
              acc = bind(acc)(g(k));
            }
          }
          return acc;
        };
      };
    };
  }
  function all(f) {
    return function(m) {
      for (var k in m) {
        if (hasOwnProperty.call(m, k) && !f(k)(m[k]))
          return false;
      }
      return true;
    };
  }
  function size(m) {
    var s = 0;
    for (var k in m) {
      if (hasOwnProperty.call(m, k)) {
        ++s;
      }
    }
    return s;
  }
  function _lookup(no, yes, k, m) {
    return k in m ? yes(m[k]) : no;
  }
  function toArrayWithKey(f) {
    return function(m) {
      var r = [];
      for (var k in m) {
        if (hasOwnProperty.call(m, k)) {
          r.push(f(k)(m[k]));
        }
      }
      return r;
    };
  }
  var keys = Object.keys || toArrayWithKey(function(k) {
    return function() {
      return k;
    };
  });

  // output-es/Foreign.Object/index.js
  var identity9 = (x2) => x2;
  var values = /* @__PURE__ */ toArrayWithKey((v) => (v1) => v1);
  var toAscUnfoldable = (dictUnfoldable) => {
    const $0 = toArrayWithKey(Tuple);
    return (x2) => toUnfoldable(dictUnfoldable)(sortWith(ordString)(fst)($0(x2)));
  };
  var singleton2 = (k) => (v) => {
    const $0 = {};
    $0[k] = v;
    return $0;
  };
  var mutate = (f) => (m) => {
    const s = { ...m };
    f(s)();
    return s;
  };
  var member = ($0) => ($1) => _lookup(false, (v) => true, $0, $1);
  var mapWithKey = (f) => (m) => _mapWithKey(m, f);
  var lookup = ($0) => ($1) => _lookup(Nothing, Just, $0, $1);
  var isSubmap = (dictEq) => (m1) => (m2) => all((k) => (v) => _lookup(false, dictEq.eq(v), k, m2))(m1);
  var isEmpty = /* @__PURE__ */ all((v) => (v1) => false);
  var insert2 = (k) => (v) => mutate(($0) => () => {
    $0[k] = v;
    return $0;
  });
  var functorObject = { map: (f) => (m) => _fmapObject(m, f) };
  var functorWithIndexObject = { mapWithIndex: mapWithKey, Functor0: () => functorObject };
  var fromFoldable = (dictFoldable) => {
    const $0 = dictFoldable.foldr;
    return (l) => {
      const s = {};
      for (const v of fromFoldableImpl($0, l)) {
        s[v._1] = v._2;
      }
      return s;
    };
  };
  var foldM = (dictMonad) => {
    const bind1 = dictMonad.Bind1().bind;
    return (f) => (z) => _foldM(bind1)(f)(dictMonad.Applicative0().pure(z));
  };
  var foldM1 = /* @__PURE__ */ foldM(monadST);
  var union = (m) => mutate((s) => foldM1((s$p) => (k) => (v) => () => {
    s$p[k] = v;
    return s$p;
  })(s)(m));
  var unionWith = (f) => (m1) => (m2) => mutate((s1) => foldM1((s2) => (k) => (v1) => {
    const $0 = _lookup(v1, (v2) => f(v1)(v2), k, m2);
    return () => {
      s2[k] = $0;
      return s2;
    };
  })(s1)(m1))(m2);
  var fold = /* @__PURE__ */ _foldM(applyFlipped);
  var foldMap = (dictMonoid) => {
    const mempty5 = dictMonoid.mempty;
    return (f) => fold((acc) => (k) => (v) => dictMonoid.Semigroup0().append(acc)(f(k)(v)))(mempty5);
  };
  var foldableObject = {
    foldl: (f) => fold((z) => (v) => f(z)),
    foldr: (f) => (z) => (m) => foldrArray(f)(z)(values(m)),
    foldMap: (dictMonoid) => {
      const foldMap1 = foldMap(dictMonoid);
      return (f) => foldMap1((v) => f);
    }
  };
  var foldableWithIndexObject = {
    foldlWithIndex: (f) => fold((b) => (a) => f(a)(b)),
    foldrWithIndex: (f) => (z) => (m) => foldrArray((v) => f(v._1)(v._2))(z)(toArrayWithKey(Tuple)(m)),
    foldMapWithIndex: (dictMonoid) => foldMap(dictMonoid),
    Foldable0: () => foldableObject
  };
  var traversableWithIndexObject = {
    traverseWithIndex: (dictApplicative) => {
      const Apply0 = dictApplicative.Apply0();
      return (f) => (ms) => fold((acc) => (k) => (v) => Apply0.apply(Apply0.Functor0().map((b) => (a) => mutate(($0) => () => {
        $0[k] = a;
        return $0;
      })(b))(acc))(f(k)(v)))(dictApplicative.pure(empty2))(ms);
    },
    FunctorWithIndex0: () => functorWithIndexObject,
    FoldableWithIndex1: () => foldableWithIndexObject,
    Traversable2: () => traversableObject
  };
  var traversableObject = {
    traverse: (dictApplicative) => {
      const $0 = traversableWithIndexObject.traverseWithIndex(dictApplicative);
      return (x2) => $0((v) => x2);
    },
    sequence: (dictApplicative) => traversableObject.traverse(dictApplicative)(identity9),
    Functor0: () => functorObject,
    Foldable1: () => foldableObject
  };
  var filterWithKey = (predicate) => (m) => {
    const m$p = {};
    return foldM1((acc) => (k) => (v) => {
      if (predicate(k)(v)) {
        return () => {
          acc[k] = v;
          return acc;
        };
      }
      return () => acc;
    })(m$p)(m)();
  };
  var filterKeys = (predicate) => filterWithKey((x2) => {
    const $0 = predicate(x2);
    return (v) => $0;
  });
  var eqObject = (dictEq) => ({ eq: (m1) => (m2) => isSubmap(dictEq)(m1)(m2) && isSubmap(dictEq)(m2)(m1) });
  var $$delete = (k) => mutate(($0) => () => {
    delete $0[k];
    return $0;
  });

  // output-es/Data.NonEmpty/index.js
  var $NonEmpty = (_1, _2) => ({ tag: "NonEmpty", _1, _2 });
  var NonEmpty = (value0) => (value1) => $NonEmpty(value0, value1);
  var traversableNonEmpty = (dictTraversable) => {
    const $0 = dictTraversable.Functor0();
    const functorNonEmpty1 = { map: (f) => (m) => $NonEmpty(f(m._1), $0.map(f)(m._2)) };
    const $1 = dictTraversable.Foldable1();
    const foldableNonEmpty1 = {
      foldMap: (dictMonoid) => {
        const foldMap1 = $1.foldMap(dictMonoid);
        return (f) => (v) => dictMonoid.Semigroup0().append(f(v._1))(foldMap1(f)(v._2));
      },
      foldl: (f) => (b) => (v) => $1.foldl(f)(f(b)(v._1))(v._2),
      foldr: (f) => (b) => (v) => f(v._1)($1.foldr(f)(b)(v._2))
    };
    return {
      sequence: (dictApplicative) => {
        const Apply0 = dictApplicative.Apply0();
        const sequence1 = dictTraversable.sequence(dictApplicative);
        return (v) => Apply0.apply(Apply0.Functor0().map(NonEmpty)(v._1))(sequence1(v._2));
      },
      traverse: (dictApplicative) => {
        const Apply0 = dictApplicative.Apply0();
        const traverse1 = dictTraversable.traverse(dictApplicative);
        return (f) => (v) => Apply0.apply(Apply0.Functor0().map(NonEmpty)(f(v._1)))(traverse1(f)(v._2));
      },
      Functor0: () => functorNonEmpty1,
      Foldable1: () => foldableNonEmpty1
    };
  };
  var foldable1NonEmpty = (dictFoldable) => {
    const foldableNonEmpty1 = {
      foldMap: (dictMonoid) => {
        const foldMap1 = dictFoldable.foldMap(dictMonoid);
        return (f) => (v) => dictMonoid.Semigroup0().append(f(v._1))(foldMap1(f)(v._2));
      },
      foldl: (f) => (b) => (v) => dictFoldable.foldl(f)(f(b)(v._1))(v._2),
      foldr: (f) => (b) => (v) => f(v._1)(dictFoldable.foldr(f)(b)(v._2))
    };
    return {
      foldMap1: (dictSemigroup) => (f) => (v) => dictFoldable.foldl((s) => (a1) => dictSemigroup.append(s)(f(a1)))(f(v._1))(v._2),
      foldr1: (f) => (v) => {
        const $0 = f(v._1);
        const $1 = dictFoldable.foldr((a1) => {
          const $12 = f(a1);
          return (x2) => $Maybe(
            "Just",
            (() => {
              if (x2.tag === "Nothing") {
                return a1;
              }
              if (x2.tag === "Just") {
                return $12(x2._1);
              }
              fail();
            })()
          );
        })(Nothing)(v._2);
        if ($1.tag === "Nothing") {
          return v._1;
        }
        if ($1.tag === "Just") {
          return $0($1._1);
        }
        fail();
      },
      foldl1: (f) => (v) => dictFoldable.foldl(f)(v._1)(v._2),
      Foldable0: () => foldableNonEmpty1
    };
  };

  // output-es/Data.List.Types/index.js
  var $List = (tag, _1, _2) => ({ tag, _1, _2 });
  var identity10 = (x2) => x2;
  var Nil = /* @__PURE__ */ $List("Nil");
  var Cons = (value0) => (value1) => $List("Cons", value0, value1);
  var listMap = (f) => {
    const chunkedRevMap = (chunkedRevMap$a0$copy) => (chunkedRevMap$a1$copy) => {
      let chunkedRevMap$a0 = chunkedRevMap$a0$copy, chunkedRevMap$a1 = chunkedRevMap$a1$copy, chunkedRevMap$c = true, chunkedRevMap$r;
      while (chunkedRevMap$c) {
        const v = chunkedRevMap$a0, v1 = chunkedRevMap$a1;
        if (v1.tag === "Cons" && v1._2.tag === "Cons" && v1._2._2.tag === "Cons") {
          chunkedRevMap$a0 = $List("Cons", v1, v);
          chunkedRevMap$a1 = v1._2._2._2;
          continue;
        }
        const reverseUnrolledMap = (reverseUnrolledMap$a0$copy) => (reverseUnrolledMap$a1$copy) => {
          let reverseUnrolledMap$a0 = reverseUnrolledMap$a0$copy, reverseUnrolledMap$a1 = reverseUnrolledMap$a1$copy, reverseUnrolledMap$c = true, reverseUnrolledMap$r;
          while (reverseUnrolledMap$c) {
            const v2 = reverseUnrolledMap$a0, v3 = reverseUnrolledMap$a1;
            if (v2.tag === "Cons" && v2._1.tag === "Cons" && v2._1._2.tag === "Cons" && v2._1._2._2.tag === "Cons") {
              reverseUnrolledMap$a0 = v2._2;
              reverseUnrolledMap$a1 = $List("Cons", f(v2._1._1), $List("Cons", f(v2._1._2._1), $List("Cons", f(v2._1._2._2._1), v3)));
              continue;
            }
            reverseUnrolledMap$c = false;
            reverseUnrolledMap$r = v3;
          }
          return reverseUnrolledMap$r;
        };
        chunkedRevMap$c = false;
        chunkedRevMap$r = reverseUnrolledMap(v)((() => {
          if (v1.tag === "Cons") {
            if (v1._2.tag === "Cons") {
              if (v1._2._2.tag === "Nil") {
                return $List("Cons", f(v1._1), $List("Cons", f(v1._2._1), Nil));
              }
              return Nil;
            }
            if (v1._2.tag === "Nil") {
              return $List("Cons", f(v1._1), Nil);
            }
          }
          return Nil;
        })());
      }
      return chunkedRevMap$r;
    };
    return chunkedRevMap(Nil);
  };
  var functorList = { map: listMap };
  var functorNonEmptyList = { map: (f) => (m) => $NonEmpty(f(m._1), listMap(f)(m._2)) };
  var foldableList = {
    foldr: (f) => (b) => {
      const $0 = foldableList.foldl((b$1) => (a) => f(a)(b$1))(b);
      const go = (go$a0$copy) => (go$a1$copy) => {
        let go$a0 = go$a0$copy, go$a1 = go$a1$copy, go$c = true, go$r;
        while (go$c) {
          const v = go$a0, v1 = go$a1;
          if (v1.tag === "Nil") {
            go$c = false;
            go$r = v;
            continue;
          }
          if (v1.tag === "Cons") {
            go$a0 = $List("Cons", v1._1, v);
            go$a1 = v1._2;
            continue;
          }
          fail();
        }
        return go$r;
      };
      const $1 = go(Nil);
      return (x2) => $0($1(x2));
    },
    foldl: (f) => {
      const go = (go$a0$copy) => (go$a1$copy) => {
        let go$a0 = go$a0$copy, go$a1 = go$a1$copy, go$c = true, go$r;
        while (go$c) {
          const b = go$a0, v = go$a1;
          if (v.tag === "Nil") {
            go$c = false;
            go$r = b;
            continue;
          }
          if (v.tag === "Cons") {
            go$a0 = f(b)(v._1);
            go$a1 = v._2;
            continue;
          }
          fail();
        }
        return go$r;
      };
      return go;
    },
    foldMap: (dictMonoid) => {
      const mempty5 = dictMonoid.mempty;
      return (f) => foldableList.foldl((acc) => {
        const $0 = dictMonoid.Semigroup0().append(acc);
        return (x2) => $0(f(x2));
      })(mempty5);
    }
  };
  var foldableNonEmptyList = {
    foldMap: (dictMonoid) => {
      const foldMap1 = foldableList.foldMap(dictMonoid);
      return (f) => (v) => dictMonoid.Semigroup0().append(f(v._1))(foldMap1(f)(v._2));
    },
    foldl: (f) => (b) => (v) => {
      const go = (go$a0$copy) => (go$a1$copy) => {
        let go$a0 = go$a0$copy, go$a1 = go$a1$copy, go$c = true, go$r;
        while (go$c) {
          const b$1 = go$a0, v$1 = go$a1;
          if (v$1.tag === "Nil") {
            go$c = false;
            go$r = b$1;
            continue;
          }
          if (v$1.tag === "Cons") {
            go$a0 = f(b$1)(v$1._1);
            go$a1 = v$1._2;
            continue;
          }
          fail();
        }
        return go$r;
      };
      return go(f(b)(v._1))(v._2);
    },
    foldr: (f) => (b) => (v) => f(v._1)(foldableList.foldr(f)(b)(v._2))
  };
  var semigroupNonEmptyList = { append: (v) => (as$p) => $NonEmpty(v._1, foldableList.foldr(Cons)($List("Cons", as$p._1, as$p._2))(v._2)) };
  var showList = (dictShow) => {
    const show4 = dictShow.show;
    return {
      show: (v) => {
        if (v.tag === "Nil") {
          return "Nil";
        }
        const go = (go$a0$copy) => (go$a1$copy) => {
          let go$a0 = go$a0$copy, go$a1 = go$a1$copy, go$c = true, go$r;
          while (go$c) {
            const b = go$a0, v$1 = go$a1;
            if (v$1.tag === "Nil") {
              go$c = false;
              go$r = b;
              continue;
            }
            if (v$1.tag === "Cons") {
              go$a0 = b.init ? { init: false, acc: v$1._1 } : { init: false, acc: b.acc + " : " + v$1._1 };
              go$a1 = v$1._2;
              continue;
            }
            fail();
          }
          return go$r;
        };
        return "(" + go({ init: true, acc: "" })(listMap(show4)(v)).acc + " : Nil)";
      }
    };
  };
  var traversableList = {
    traverse: (dictApplicative) => {
      const Apply0 = dictApplicative.Apply0();
      return (f) => {
        const $0 = Apply0.Functor0().map((() => {
          const go2 = (go$a0$copy) => (go$a1$copy) => {
            let go$a0 = go$a0$copy, go$a1 = go$a1$copy, go$c = true, go$r;
            while (go$c) {
              const b = go$a0, v = go$a1;
              if (v.tag === "Nil") {
                go$c = false;
                go$r = b;
                continue;
              }
              if (v.tag === "Cons") {
                go$a0 = $List("Cons", v._1, b);
                go$a1 = v._2;
                continue;
              }
              fail();
            }
            return go$r;
          };
          return go2(Nil);
        })());
        const go = (go$a0$copy) => (go$a1$copy) => {
          let go$a0 = go$a0$copy, go$a1 = go$a1$copy, go$c = true, go$r;
          while (go$c) {
            const b = go$a0, v = go$a1;
            if (v.tag === "Nil") {
              go$c = false;
              go$r = b;
              continue;
            }
            if (v.tag === "Cons") {
              go$a0 = Apply0.apply(Apply0.Functor0().map((b$1) => (a) => $List("Cons", a, b$1))(b))(f(v._1));
              go$a1 = v._2;
              continue;
            }
            fail();
          }
          return go$r;
        };
        const $1 = go(dictApplicative.pure(Nil));
        return (x2) => $0($1(x2));
      };
    },
    sequence: (dictApplicative) => traversableList.traverse(dictApplicative)(identity10),
    Functor0: () => functorList,
    Foldable1: () => foldableList
  };
  var traversableNonEmptyList = /* @__PURE__ */ traversableNonEmpty(traversableList);
  var unfoldable1List = {
    unfoldr1: (f) => (b) => {
      const go = (go$a0$copy) => (go$a1$copy) => {
        let go$a0 = go$a0$copy, go$a1 = go$a1$copy, go$c = true, go$r;
        while (go$c) {
          const source2 = go$a0, memo = go$a1;
          const v = f(source2);
          if (v._2.tag === "Just") {
            go$a0 = v._2._1;
            go$a1 = $List("Cons", v._1, memo);
            continue;
          }
          if (v._2.tag === "Nothing") {
            const go$1 = (go$1$a0$copy) => (go$1$a1$copy) => {
              let go$1$a0 = go$1$a0$copy, go$1$a1 = go$1$a1$copy, go$1$c = true, go$1$r;
              while (go$1$c) {
                const b$1 = go$1$a0, v$1 = go$1$a1;
                if (v$1.tag === "Nil") {
                  go$1$c = false;
                  go$1$r = b$1;
                  continue;
                }
                if (v$1.tag === "Cons") {
                  go$1$a0 = $List("Cons", v$1._1, b$1);
                  go$1$a1 = v$1._2;
                  continue;
                }
                fail();
              }
              return go$1$r;
            };
            go$c = false;
            go$r = go$1(Nil)($List("Cons", v._1, memo));
            continue;
          }
          fail();
        }
        return go$r;
      };
      return go(b)(Nil);
    }
  };
  var unfoldableList = {
    unfoldr: (f) => (b) => {
      const go = (go$a0$copy) => (go$a1$copy) => {
        let go$a0 = go$a0$copy, go$a1 = go$a1$copy, go$c = true, go$r;
        while (go$c) {
          const source2 = go$a0, memo = go$a1;
          const v = f(source2);
          if (v.tag === "Nothing") {
            const go$1 = (go$1$a0$copy) => (go$1$a1$copy) => {
              let go$1$a0 = go$1$a0$copy, go$1$a1 = go$1$a1$copy, go$1$c = true, go$1$r;
              while (go$1$c) {
                const b$1 = go$1$a0, v$1 = go$1$a1;
                if (v$1.tag === "Nil") {
                  go$1$c = false;
                  go$1$r = b$1;
                  continue;
                }
                if (v$1.tag === "Cons") {
                  go$1$a0 = $List("Cons", v$1._1, b$1);
                  go$1$a1 = v$1._2;
                  continue;
                }
                fail();
              }
              return go$1$r;
            };
            go$c = false;
            go$r = go$1(Nil)(memo);
            continue;
          }
          if (v.tag === "Just") {
            go$a0 = v._1._2;
            go$a1 = $List("Cons", v._1._1, memo);
            continue;
          }
          fail();
        }
        return go$r;
      };
      return go(b)(Nil);
    },
    Unfoldable10: () => unfoldable1List
  };
  var applyList = {
    apply: (v) => (v1) => {
      if (v.tag === "Nil") {
        return Nil;
      }
      if (v.tag === "Cons") {
        return foldableList.foldr(Cons)(applyList.apply(v._2)(v1))(listMap(v._1)(v1));
      }
      fail();
    },
    Functor0: () => functorList
  };
  var applyNonEmptyList = {
    apply: (v) => (v1) => $NonEmpty(
      v._1(v1._1),
      foldableList.foldr(Cons)(applyList.apply($List("Cons", v._1, v._2))(v1._2))(applyList.apply(v._2)($List("Cons", v1._1, Nil)))
    ),
    Functor0: () => functorNonEmptyList
  };
  var bindList = {
    bind: (v) => (v1) => {
      if (v.tag === "Nil") {
        return Nil;
      }
      if (v.tag === "Cons") {
        return foldableList.foldr(Cons)(bindList.bind(v._2)(v1))(v1(v._1));
      }
      fail();
    },
    Apply0: () => applyList
  };
  var bindNonEmptyList = {
    bind: (v) => (f) => {
      const v1 = f(v._1);
      return $NonEmpty(
        v1._1,
        foldableList.foldr(Cons)(bindList.bind(v._2)((x2) => {
          const $0 = f(x2);
          return $List("Cons", $0._1, $0._2);
        }))(v1._2)
      );
    },
    Apply0: () => applyNonEmptyList
  };
  var applicativeList = { pure: (a) => $List("Cons", a, Nil), Apply0: () => applyList };

  // output-es/Data.Map.Internal/index.js
  var $$$Map = (tag, _1, _2, _3, _4, _5, _6) => ({ tag, _1, _2, _3, _4, _5, _6 });
  var $MapIter = (tag, _1, _2, _3) => ({ tag, _1, _2, _3 });
  var $MapIterStep = (tag, _1, _2, _3) => ({ tag, _1, _2, _3 });
  var $Split = (_1, _2, _3) => ({ tag: "Split", _1, _2, _3 });
  var $SplitLast = (_1, _2, _3) => ({ tag: "SplitLast", _1, _2, _3 });
  var Leaf = /* @__PURE__ */ $$$Map("Leaf");
  var IterLeaf = /* @__PURE__ */ $MapIter("IterLeaf");
  var IterDone = /* @__PURE__ */ $MapIterStep("IterDone");
  var unsafeNode = (k, v, l, r) => {
    if (l.tag === "Leaf") {
      if (r.tag === "Leaf") {
        return $$$Map("Node", 1, 1, k, v, l, r);
      }
      if (r.tag === "Node") {
        return $$$Map("Node", 1 + r._1 | 0, 1 + r._2 | 0, k, v, l, r);
      }
      fail();
    }
    if (l.tag === "Node") {
      if (r.tag === "Leaf") {
        return $$$Map("Node", 1 + l._1 | 0, 1 + l._2 | 0, k, v, l, r);
      }
      if (r.tag === "Node") {
        return $$$Map("Node", l._1 > r._1 ? 1 + l._1 | 0 : 1 + r._1 | 0, (1 + l._2 | 0) + r._2 | 0, k, v, l, r);
      }
    }
    fail();
  };
  var size2 = (v) => {
    if (v.tag === "Leaf") {
      return 0;
    }
    if (v.tag === "Node") {
      return v._2;
    }
    fail();
  };
  var unsafeBalancedNode = (k, v, l, r) => {
    if (l.tag === "Leaf") {
      if (r.tag === "Leaf") {
        return $$$Map("Node", 1, 1, k, v, Leaf, Leaf);
      }
      if (r.tag === "Node" && r._1 > 1) {
        if (r._5.tag === "Node" && (() => {
          if (r._6.tag === "Leaf") {
            return r._5._1 > 0;
          }
          if (r._6.tag === "Node") {
            return r._5._1 > r._6._1;
          }
          fail();
        })()) {
          return unsafeNode(r._5._3, r._5._4, unsafeNode(k, v, l, r._5._5), unsafeNode(r._3, r._4, r._5._6, r._6));
        }
        return unsafeNode(r._3, r._4, unsafeNode(k, v, l, r._5), r._6);
      }
      return unsafeNode(k, v, l, r);
    }
    if (l.tag === "Node") {
      if (r.tag === "Node") {
        if (r._1 > (l._1 + 1 | 0)) {
          if (r._5.tag === "Node" && (() => {
            if (r._6.tag === "Leaf") {
              return r._5._1 > 0;
            }
            if (r._6.tag === "Node") {
              return r._5._1 > r._6._1;
            }
            fail();
          })()) {
            return unsafeNode(r._5._3, r._5._4, unsafeNode(k, v, l, r._5._5), unsafeNode(r._3, r._4, r._5._6, r._6));
          }
          return unsafeNode(r._3, r._4, unsafeNode(k, v, l, r._5), r._6);
        }
        if (l._1 > (r._1 + 1 | 0)) {
          if (l._6.tag === "Node" && (() => {
            if (l._5.tag === "Leaf") {
              return 0 <= l._6._1;
            }
            if (l._5.tag === "Node") {
              return l._5._1 <= l._6._1;
            }
            fail();
          })()) {
            return unsafeNode(l._6._3, l._6._4, unsafeNode(l._3, l._4, l._5, l._6._5), unsafeNode(k, v, l._6._6, r));
          }
          return unsafeNode(l._3, l._4, l._5, unsafeNode(k, v, l._6, r));
        }
        return unsafeNode(k, v, l, r);
      }
      if (r.tag === "Leaf" && l._1 > 1) {
        if (l._6.tag === "Node" && (() => {
          if (l._5.tag === "Leaf") {
            return 0 <= l._6._1;
          }
          if (l._5.tag === "Node") {
            return l._5._1 <= l._6._1;
          }
          fail();
        })()) {
          return unsafeNode(l._6._3, l._6._4, unsafeNode(l._3, l._4, l._5, l._6._5), unsafeNode(k, v, l._6._6, r));
        }
        return unsafeNode(l._3, l._4, l._5, unsafeNode(k, v, l._6, r));
      }
      return unsafeNode(k, v, l, r);
    }
    fail();
  };
  var unsafeSplit = (comp, k, m) => {
    if (m.tag === "Leaf") {
      return $Split(Nothing, Leaf, Leaf);
    }
    if (m.tag === "Node") {
      const v = comp(k)(m._3);
      if (v === "LT") {
        const v1 = unsafeSplit(comp, k, m._5);
        return $Split(v1._1, v1._2, unsafeBalancedNode(m._3, m._4, v1._3, m._6));
      }
      if (v === "GT") {
        const v1 = unsafeSplit(comp, k, m._6);
        return $Split(v1._1, unsafeBalancedNode(m._3, m._4, m._5, v1._2), v1._3);
      }
      if (v === "EQ") {
        return $Split($Maybe("Just", m._4), m._5, m._6);
      }
    }
    fail();
  };
  var unsafeSplitLast = (k, v, l, r) => {
    if (r.tag === "Leaf") {
      return $SplitLast(k, v, l);
    }
    if (r.tag === "Node") {
      const v1 = unsafeSplitLast(r._3, r._4, r._5, r._6);
      return $SplitLast(v1._1, v1._2, unsafeBalancedNode(k, v, l, v1._3));
    }
    fail();
  };
  var unsafeJoinNodes = (v, v1) => {
    if (v.tag === "Leaf") {
      return v1;
    }
    if (v.tag === "Node") {
      const v2 = unsafeSplitLast(v._3, v._4, v._5, v._6);
      return unsafeBalancedNode(v2._1, v2._2, v2._3, v1);
    }
    fail();
  };
  var unsafeDifference = (comp, l, r) => {
    if (l.tag === "Leaf") {
      return Leaf;
    }
    if (r.tag === "Leaf") {
      return l;
    }
    if (r.tag === "Node") {
      const v = unsafeSplit(comp, r._3, l);
      return unsafeJoinNodes(unsafeDifference(comp, v._2, r._5), unsafeDifference(comp, v._3, r._6));
    }
    fail();
  };
  var unsafeIntersectionWith = (comp, app, l, r) => {
    if (l.tag === "Leaf") {
      return Leaf;
    }
    if (r.tag === "Leaf") {
      return Leaf;
    }
    if (r.tag === "Node") {
      const v = unsafeSplit(comp, r._3, l);
      const l$p = unsafeIntersectionWith(comp, app, v._2, r._5);
      const r$p = unsafeIntersectionWith(comp, app, v._3, r._6);
      if (v._1.tag === "Just") {
        return unsafeBalancedNode(r._3, app(v._1._1)(r._4), l$p, r$p);
      }
      if (v._1.tag === "Nothing") {
        return unsafeJoinNodes(l$p, r$p);
      }
    }
    fail();
  };
  var unsafeUnionWith = (comp, app, l, r) => {
    if (l.tag === "Leaf") {
      return r;
    }
    if (r.tag === "Leaf") {
      return l;
    }
    if (r.tag === "Node") {
      const v = unsafeSplit(comp, r._3, l);
      const l$p = unsafeUnionWith(comp, app, v._2, r._5);
      const r$p = unsafeUnionWith(comp, app, v._3, r._6);
      if (v._1.tag === "Just") {
        return unsafeBalancedNode(r._3, app(v._1._1)(r._4), l$p, r$p);
      }
      if (v._1.tag === "Nothing") {
        return unsafeBalancedNode(r._3, r._4, l$p, r$p);
      }
    }
    fail();
  };
  var lookup2 = (dictOrd) => (k) => {
    const go = (go$a0$copy) => {
      let go$a0 = go$a0$copy, go$c = true, go$r;
      while (go$c) {
        const v = go$a0;
        if (v.tag === "Leaf") {
          go$c = false;
          go$r = Nothing;
          continue;
        }
        if (v.tag === "Node") {
          const v1 = dictOrd.compare(k)(v._3);
          if (v1 === "LT") {
            go$a0 = v._5;
            continue;
          }
          if (v1 === "GT") {
            go$a0 = v._6;
            continue;
          }
          if (v1 === "EQ") {
            go$c = false;
            go$r = $Maybe("Just", v._4);
            continue;
          }
        }
        fail();
      }
      return go$r;
    };
    return go;
  };
  var stepAscCps = (next) => (done) => {
    const go = (go$a0$copy) => {
      let go$a0 = go$a0$copy, go$c = true, go$r;
      while (go$c) {
        const v = go$a0;
        if (v.tag === "IterLeaf") {
          go$c = false;
          go$r = done();
          continue;
        }
        if (v.tag === "IterEmit") {
          go$c = false;
          go$r = next(v._1, v._2, v._3);
          continue;
        }
        if (v.tag === "IterNode") {
          go$a0 = (() => {
            const go$1 = (go$1$a0$copy) => (go$1$a1$copy) => {
              let go$1$a0 = go$1$a0$copy, go$1$a1 = go$1$a1$copy, go$1$c = true, go$1$r;
              while (go$1$c) {
                const iter = go$1$a0, v$1 = go$1$a1;
                if (v$1.tag === "Leaf") {
                  go$1$c = false;
                  go$1$r = iter;
                  continue;
                }
                if (v$1.tag === "Node") {
                  if (v$1._6.tag === "Leaf") {
                    go$1$a0 = $MapIter("IterEmit", v$1._3, v$1._4, iter);
                    go$1$a1 = v$1._5;
                    continue;
                  }
                  go$1$a0 = $MapIter("IterEmit", v$1._3, v$1._4, $MapIter("IterNode", v$1._6, iter));
                  go$1$a1 = v$1._5;
                  continue;
                }
                fail();
              }
              return go$1$r;
            };
            return go$1(v._2)(v._1);
          })();
          continue;
        }
        fail();
      }
      return go$r;
    };
    return go;
  };
  var stepAsc = /* @__PURE__ */ stepAscCps((k, v, next) => $MapIterStep("IterNext", k, v, next))((v) => IterDone);
  var eqMapIter = (dictEq) => (dictEq1) => ({
    eq: (() => {
      const go = (a) => (b) => {
        const v = stepAsc(a);
        if (v.tag === "IterNext") {
          const v2 = stepAsc(b);
          return v2.tag === "IterNext" && dictEq.eq(v._1)(v2._1) && dictEq1.eq(v._2)(v2._2) && go(v._3)(v2._3);
        }
        if (v.tag === "IterDone") {
          return true;
        }
        fail();
      };
      return go;
    })()
  });
  var isEmpty2 = (v) => v.tag === "Leaf";
  var insert3 = (dictOrd) => (k) => (v) => {
    const go = (v1) => {
      if (v1.tag === "Leaf") {
        return $$$Map("Node", 1, 1, k, v, Leaf, Leaf);
      }
      if (v1.tag === "Node") {
        const v2 = dictOrd.compare(k)(v1._3);
        if (v2 === "LT") {
          return unsafeBalancedNode(v1._3, v1._4, go(v1._5), v1._6);
        }
        if (v2 === "GT") {
          return unsafeBalancedNode(v1._3, v1._4, v1._5, go(v1._6));
        }
        if (v2 === "EQ") {
          return $$$Map("Node", v1._1, v1._2, k, v, v1._5, v1._6);
        }
      }
      fail();
    };
    return go;
  };
  var keys2 = /* @__PURE__ */ (() => {
    const go = (m$p, z$p) => {
      if (m$p.tag === "Leaf") {
        return z$p;
      }
      if (m$p.tag === "Node") {
        return go(m$p._5, $List("Cons", m$p._3, go(m$p._6, z$p)));
      }
      fail();
    };
    return (m) => go(m, Nil);
  })();
  var values2 = /* @__PURE__ */ (() => {
    const go = (m$p, z$p) => {
      if (m$p.tag === "Leaf") {
        return z$p;
      }
      if (m$p.tag === "Node") {
        return go(m$p._5, $List("Cons", m$p._4, go(m$p._6, z$p)));
      }
      fail();
    };
    return (m) => go(m, Nil);
  })();
  var findMin = (findMin$a0$copy) => {
    let findMin$a0 = findMin$a0$copy, findMin$c = true, findMin$r;
    while (findMin$c) {
      const v = findMin$a0;
      if (v.tag === "Leaf") {
        findMin$c = false;
        findMin$r = Nothing;
        continue;
      }
      if (v.tag === "Node") {
        if (v._5.tag === "Leaf") {
          findMin$c = false;
          findMin$r = $Maybe("Just", { key: v._3, value: v._4 });
          continue;
        }
        findMin$a0 = v._5;
        continue;
      }
      fail();
    }
    return findMin$r;
  };
  var filterKeys2 = (dictOrd) => (f) => {
    const go = (v) => {
      if (v.tag === "Leaf") {
        return Leaf;
      }
      if (v.tag === "Node") {
        if (f(v._3)) {
          return unsafeBalancedNode(v._3, v._4, go(v._5), go(v._6));
        }
        return unsafeJoinNodes(go(v._5), go(v._6));
      }
      fail();
    };
    return go;
  };
  var eqMap = (dictEq) => (dictEq1) => ({
    eq: (xs) => (ys) => {
      if (xs.tag === "Leaf") {
        return ys.tag === "Leaf";
      }
      if (xs.tag === "Node") {
        return ys.tag === "Node" && xs._2 === ys._2 && eqMapIter(dictEq)(dictEq1).eq($MapIter("IterNode", xs, IterLeaf))($MapIter("IterNode", ys, IterLeaf));
      }
      fail();
    }
  });
  var fromFoldable2 = (dictOrd) => (dictFoldable) => dictFoldable.foldl((m) => (v) => insert3(dictOrd)(v._1)(v._2)(m))(Leaf);
  var $$delete2 = (dictOrd) => (k) => {
    const go = (v) => {
      if (v.tag === "Leaf") {
        return Leaf;
      }
      if (v.tag === "Node") {
        const v1 = dictOrd.compare(k)(v._3);
        if (v1 === "LT") {
          return unsafeBalancedNode(v._3, v._4, go(v._5), v._6);
        }
        if (v1 === "GT") {
          return unsafeBalancedNode(v._3, v._4, v._5, go(v._6));
        }
        if (v1 === "EQ") {
          return unsafeJoinNodes(v._5, v._6);
        }
      }
      fail();
    };
    return go;
  };

  // output-es/Effect.Exception/foreign.js
  function showErrorImpl(err) {
    return err.stack || err.toString();
  }
  function error(msg) {
    return new Error(msg);
  }
  function message(e) {
    return e.message;
  }
  function throwException(e) {
    return function() {
      throw e;
    };
  }

  // output-es/Control.Monad.Except.Trans/index.js
  var bindExceptT = (dictMonad) => ({
    bind: (v) => (k) => dictMonad.Bind1().bind(v)((v2) => {
      if (v2.tag === "Left") {
        return dictMonad.Applicative0().pure($Either("Left", v2._1));
      }
      if (v2.tag === "Right") {
        return k(v2._1);
      }
      fail();
    }),
    Apply0: () => applyExceptT(dictMonad)
  });
  var applyExceptT = (dictMonad) => {
    const $0 = dictMonad.Bind1().Apply0().Functor0();
    const functorExceptT1 = {
      map: (f) => $0.map((m) => {
        if (m.tag === "Left") {
          return $Either("Left", m._1);
        }
        if (m.tag === "Right") {
          return $Either("Right", f(m._1));
        }
        fail();
      })
    };
    return {
      apply: (() => {
        const $1 = bindExceptT(dictMonad);
        return (f) => (a) => $1.bind(f)((f$p) => $1.bind(a)((a$p) => applicativeExceptT(dictMonad).pure(f$p(a$p))));
      })(),
      Functor0: () => functorExceptT1
    };
  };
  var applicativeExceptT = (dictMonad) => ({ pure: (x2) => dictMonad.Applicative0().pure($Either("Right", x2)), Apply0: () => applyExceptT(dictMonad) });
  var monadThrowExceptT = (dictMonad) => {
    const monadExceptT1 = { Applicative0: () => applicativeExceptT(dictMonad), Bind1: () => bindExceptT(dictMonad) };
    return { throwError: (x2) => dictMonad.Applicative0().pure($Either("Left", x2)), Monad0: () => monadExceptT1 };
  };
  var monadErrorExceptT = (dictMonad) => {
    const monadThrowExceptT1 = monadThrowExceptT(dictMonad);
    return {
      catchError: (v) => (k) => dictMonad.Bind1().bind(v)((v2) => {
        if (v2.tag === "Left") {
          return k(v2._1);
        }
        if (v2.tag === "Right") {
          return dictMonad.Applicative0().pure($Either("Right", v2._1));
        }
        fail();
      }),
      MonadThrow0: () => monadThrowExceptT1
    };
  };
  var altExceptT = (dictSemigroup) => (dictMonad) => {
    const Bind1 = dictMonad.Bind1();
    const $0 = dictMonad.Applicative0();
    const $1 = Bind1.Apply0().Functor0();
    const functorExceptT1 = {
      map: (f) => $1.map((m) => {
        if (m.tag === "Left") {
          return $Either("Left", m._1);
        }
        if (m.tag === "Right") {
          return $Either("Right", f(m._1));
        }
        fail();
      })
    };
    return {
      alt: (v) => (v1) => Bind1.bind(v)((rm) => {
        if (rm.tag === "Right") {
          return $0.pure($Either("Right", rm._1));
        }
        if (rm.tag === "Left") {
          const $2 = rm._1;
          return Bind1.bind(v1)((rn) => {
            if (rn.tag === "Right") {
              return $0.pure($Either("Right", rn._1));
            }
            if (rn.tag === "Left") {
              return $0.pure($Either("Left", dictSemigroup.append($2)(rn._1)));
            }
            fail();
          });
        }
        fail();
      }),
      Functor0: () => functorExceptT1
    };
  };

  // output-es/Data.Semigroup/foreign.js
  var concatString = function(s1) {
    return function(s2) {
      return s1 + s2;
    };
  };

  // output-es/Data.Semigroup.Foldable/index.js
  var maximum = (dictOrd) => {
    const semigroupMax = {
      append: (v) => (v1) => {
        const v$1 = dictOrd.compare(v)(v1);
        if (v$1 === "LT") {
          return v1;
        }
        if (v$1 === "EQ") {
          return v;
        }
        if (v$1 === "GT") {
          return v;
        }
        fail();
      }
    };
    return (dictFoldable1) => dictFoldable1.foldMap1(semigroupMax)(unsafeCoerce);
  };
  var minimum = (dictOrd) => {
    const semigroupMin = {
      append: (v) => (v1) => {
        const v$1 = dictOrd.compare(v)(v1);
        if (v$1 === "LT") {
          return v;
        }
        if (v$1 === "EQ") {
          return v;
        }
        if (v$1 === "GT") {
          return v1;
        }
        fail();
      }
    };
    return (dictFoldable1) => dictFoldable1.foldMap1(semigroupMin)(unsafeCoerce);
  };

  // output-es/Data.Array.NonEmpty.Internal/foreign.js
  var foldr1Impl = function(f, xs) {
    var acc = xs[xs.length - 1];
    for (var i = xs.length - 2; i >= 0; i--) {
      acc = f(xs[i])(acc);
    }
    return acc;
  };
  var foldl1Impl = function(f, xs) {
    var acc = xs[0];
    var len = xs.length;
    for (var i = 1; i < len; i++) {
      acc = f(acc)(xs[i]);
    }
    return acc;
  };
  var traverse1Impl = function() {
    function Cont(fn) {
      this.fn = fn;
    }
    var emptyList = {};
    var ConsCell = function(head, tail3) {
      this.head = head;
      this.tail = tail3;
    };
    function finalCell(head) {
      return new ConsCell(head, emptyList);
    }
    function consList(x2) {
      return function(xs) {
        return new ConsCell(x2, xs);
      };
    }
    function listToArray(list) {
      var arr = [];
      var xs = list;
      while (xs !== emptyList) {
        arr.push(xs.head);
        xs = xs.tail;
      }
      return arr;
    }
    return function(apply4, map3, f) {
      var buildFrom = function(x2, ys) {
        return apply4(map3(consList)(f(x2)))(ys);
      };
      var go = function(acc, currentLen, xs) {
        if (currentLen === 0) {
          return acc;
        } else {
          var last3 = xs[currentLen - 1];
          return new Cont(function() {
            var built = go(buildFrom(last3, acc), currentLen - 1, xs);
            return built;
          });
        }
      };
      return function(array2) {
        var acc = map3(finalCell)(f(array2[array2.length - 1]));
        var result = go(acc, array2.length - 1, array2);
        while (result instanceof Cont) {
          result = result.fn();
        }
        return map3(listToArray)(result);
      };
    };
  }();

  // output-es/Data.Array.NonEmpty.Internal/index.js
  var foldable1NonEmptyArray = {
    foldMap1: (dictSemigroup) => {
      const append2 = dictSemigroup.append;
      return (f) => {
        const $0 = arrayMap(f);
        const $1 = foldable1NonEmptyArray.foldl1(append2);
        return (x2) => $1($0(x2));
      };
    },
    foldr1: ($0) => ($1) => foldr1Impl($0, $1),
    foldl1: ($0) => ($1) => foldl1Impl($0, $1),
    Foldable0: () => foldableArray
  };

  // output-es/Data.List/index.js
  var identity13 = (x2) => x2;
  var updateAt = (v) => (v1) => (v2) => {
    if (v2.tag === "Cons") {
      if (v === 0) {
        return $Maybe("Just", $List("Cons", v1, v2._2));
      }
      const $0 = updateAt(v - 1 | 0)(v1)(v2._2);
      if ($0.tag === "Just") {
        return $Maybe("Just", $List("Cons", v2._1, $0._1));
      }
    }
    return Nothing;
  };
  var unzip2 = /* @__PURE__ */ (() => foldableList.foldr((v) => {
    const $0 = v._1;
    const $1 = v._2;
    return (v1) => $Tuple($List("Cons", $0, v1._1), $List("Cons", $1, v1._2));
  })($Tuple(Nil, Nil)))();
  var toUnfoldable2 = (dictUnfoldable) => dictUnfoldable.unfoldr((xs) => {
    if (xs.tag === "Nil") {
      return Nothing;
    }
    if (xs.tag === "Cons") {
      return $Maybe("Just", $Tuple(xs._1, xs._2));
    }
    fail();
  });
  var span2 = (v) => (v1) => {
    if (v1.tag === "Cons" && v(v1._1)) {
      const v2 = span2(v)(v1._2);
      return { init: $List("Cons", v1._1, v2.init), rest: v2.rest };
    }
    return { init: Nil, rest: v1 };
  };
  var sortBy2 = (cmp) => {
    const merge = (v) => (v1) => {
      if (v.tag === "Cons") {
        if (v1.tag === "Cons") {
          if (cmp(v._1)(v1._1) === "GT") {
            return $List("Cons", v1._1, merge(v)(v1._2));
          }
          return $List("Cons", v._1, merge(v._2)(v1));
        }
        if (v1.tag === "Nil") {
          return v;
        }
        fail();
      }
      if (v.tag === "Nil") {
        return v1;
      }
      if (v1.tag === "Nil") {
        return v;
      }
      fail();
    };
    const mergePairs = (v) => {
      if (v.tag === "Cons" && v._2.tag === "Cons") {
        return $List("Cons", merge(v._1)(v._2._1), mergePairs(v._2._2));
      }
      return v;
    };
    const mergeAll = (mergeAll$a0$copy) => {
      let mergeAll$a0 = mergeAll$a0$copy, mergeAll$c = true, mergeAll$r;
      while (mergeAll$c) {
        const v = mergeAll$a0;
        if (v.tag === "Cons" && v._2.tag === "Nil") {
          mergeAll$c = false;
          mergeAll$r = v._1;
          continue;
        }
        mergeAll$a0 = mergePairs(v);
      }
      return mergeAll$r;
    };
    const $sequedesceascen = ($sequedesceascen$b$copy, $sequedesceascen$a0$copy, $sequedesceascen$a1$copy, $sequedesceascen$a2$copy) => {
      let $sequedesceascen$b = $sequedesceascen$b$copy;
      let $sequedesceascen$a0 = $sequedesceascen$a0$copy;
      let $sequedesceascen$a1 = $sequedesceascen$a1$copy;
      let $sequedesceascen$a2 = $sequedesceascen$a2$copy;
      let $sequedesceascen$c = true;
      let $sequedesceascen$r;
      while ($sequedesceascen$c) {
        if ($sequedesceascen$b === 0) {
          const v = $sequedesceascen$a0;
          if (v.tag === "Cons" && v._2.tag === "Cons") {
            if (cmp(v._1)(v._2._1) === "GT") {
              $sequedesceascen$b = 1;
              $sequedesceascen$a0 = v._2._1;
              $sequedesceascen$a1 = $List("Cons", v._1, Nil);
              $sequedesceascen$a2 = v._2._2;
              continue;
            }
            const $0 = v._1;
            $sequedesceascen$b = 2;
            $sequedesceascen$a0 = v._2._1;
            $sequedesceascen$a1 = (v1) => $List("Cons", $0, v1);
            $sequedesceascen$a2 = v._2._2;
            continue;
          }
          $sequedesceascen$c = false;
          $sequedesceascen$r = $List("Cons", v, Nil);
          continue;
        }
        if ($sequedesceascen$b === 1) {
          const v = $sequedesceascen$a0, v1 = $sequedesceascen$a1, v2 = $sequedesceascen$a2;
          if (v2.tag === "Cons" && cmp(v)(v2._1) === "GT") {
            $sequedesceascen$b = 1;
            $sequedesceascen$a0 = v2._1;
            $sequedesceascen$a1 = $List("Cons", v, v1);
            $sequedesceascen$a2 = v2._2;
            continue;
          }
          $sequedesceascen$c = false;
          $sequedesceascen$r = $List("Cons", $List("Cons", v, v1), sequences(v2));
          continue;
        }
        if ($sequedesceascen$b === 2) {
          const v = $sequedesceascen$a0, v1 = $sequedesceascen$a1, v2 = $sequedesceascen$a2;
          if (v2.tag === "Cons" && (() => {
            const $0 = cmp(v)(v2._1);
            return $0 === "LT" || $0 !== "GT";
          })()) {
            $sequedesceascen$b = 2;
            $sequedesceascen$a0 = v2._1;
            $sequedesceascen$a1 = (ys) => v1($List("Cons", v, ys));
            $sequedesceascen$a2 = v2._2;
            continue;
          }
          $sequedesceascen$c = false;
          $sequedesceascen$r = $List("Cons", v1($List("Cons", v, Nil)), sequences(v2));
        }
      }
      return $sequedesceascen$r;
    };
    const sequences = (v) => $sequedesceascen(0, v);
    const descending2 = (v) => (v1) => (v2) => $sequedesceascen(1, v, v1, v2);
    const ascending3 = (v) => (v1) => (v2) => $sequedesceascen(2, v, v1, v2);
    return (x2) => mergeAll(sequences(x2));
  };
  var reverse2 = /* @__PURE__ */ (() => {
    const go = (go$a0$copy) => (go$a1$copy) => {
      let go$a0 = go$a0$copy, go$a1 = go$a1$copy, go$c = true, go$r;
      while (go$c) {
        const v = go$a0, v1 = go$a1;
        if (v1.tag === "Nil") {
          go$c = false;
          go$r = v;
          continue;
        }
        if (v1.tag === "Cons") {
          go$a0 = $List("Cons", v1._1, v);
          go$a1 = v1._2;
          continue;
        }
        fail();
      }
      return go$r;
    };
    return go(Nil);
  })();
  var take2 = /* @__PURE__ */ (() => {
    const go = (go$a0$copy) => (go$a1$copy) => (go$a2$copy) => {
      let go$a0 = go$a0$copy, go$a1 = go$a1$copy, go$a2 = go$a2$copy, go$c = true, go$r;
      while (go$c) {
        const v = go$a0, v1 = go$a1, v2 = go$a2;
        if (v1 < 1) {
          go$c = false;
          go$r = reverse2(v);
          continue;
        }
        if (v2.tag === "Nil") {
          go$c = false;
          go$r = reverse2(v);
          continue;
        }
        if (v2.tag === "Cons") {
          go$a0 = $List("Cons", v2._1, v);
          go$a1 = v1 - 1 | 0;
          go$a2 = v2._2;
          continue;
        }
        fail();
      }
      return go$r;
    };
    return go(Nil);
  })();
  var unsnoc2 = (lst) => {
    const go = (go$a0$copy) => (go$a1$copy) => {
      let go$a0 = go$a0$copy, go$a1 = go$a1$copy, go$c = true, go$r;
      while (go$c) {
        const v = go$a0, v1 = go$a1;
        if (v.tag === "Nil") {
          go$c = false;
          go$r = Nothing;
          continue;
        }
        if (v.tag === "Cons") {
          if (v._2.tag === "Nil") {
            go$c = false;
            go$r = $Maybe("Just", { revInit: v1, last: v._1 });
            continue;
          }
          go$a0 = v._2;
          go$a1 = $List("Cons", v._1, v1);
          continue;
        }
        fail();
      }
      return go$r;
    };
    const $0 = go(lst)(Nil);
    if ($0.tag === "Just") {
      return $Maybe("Just", { init: reverse2($0._1.revInit), last: $0._1.last });
    }
    return Nothing;
  };
  var zipWith2 = (f) => (xs) => (ys) => {
    const go = (go$a0$copy) => (go$a1$copy) => (go$a2$copy) => {
      let go$a0 = go$a0$copy, go$a1 = go$a1$copy, go$a2 = go$a2$copy, go$c = true, go$r;
      while (go$c) {
        const v = go$a0, v1 = go$a1, v2 = go$a2;
        if (v.tag === "Nil") {
          go$c = false;
          go$r = v2;
          continue;
        }
        if (v1.tag === "Nil") {
          go$c = false;
          go$r = v2;
          continue;
        }
        if (v.tag === "Cons" && v1.tag === "Cons") {
          go$a0 = v._2;
          go$a1 = v1._2;
          go$a2 = $List("Cons", f(v._1)(v1._1), v2);
          continue;
        }
        fail();
      }
      return go$r;
    };
    return reverse2(go(xs)(ys)(Nil));
  };
  var range3 = (start2) => (end) => {
    if (start2 === end) {
      return $List("Cons", start2, Nil);
    }
    const go = (go$a0$copy) => (go$a1$copy) => (go$a2$copy) => (go$a3$copy) => {
      let go$a0 = go$a0$copy, go$a1 = go$a1$copy, go$a2 = go$a2$copy, go$a3 = go$a3$copy, go$c = true, go$r;
      while (go$c) {
        const s = go$a0, e = go$a1, step = go$a2, rest = go$a3;
        if (s === e) {
          go$c = false;
          go$r = $List("Cons", s, rest);
          continue;
        }
        go$a0 = s + step | 0;
        go$a1 = e;
        go$a2 = step;
        go$a3 = $List("Cons", s, rest);
      }
      return go$r;
    };
    return go(end)(start2)(start2 > end ? 1 : -1)(Nil);
  };
  var mapMaybe2 = (f) => {
    const go = (go$a0$copy) => (go$a1$copy) => {
      let go$a0 = go$a0$copy, go$a1 = go$a1$copy, go$c = true, go$r;
      while (go$c) {
        const v = go$a0, v1 = go$a1;
        if (v1.tag === "Nil") {
          go$c = false;
          go$r = reverse2(v);
          continue;
        }
        if (v1.tag === "Cons") {
          const v2 = f(v1._1);
          if (v2.tag === "Nothing") {
            go$a0 = v;
            go$a1 = v1._2;
            continue;
          }
          if (v2.tag === "Just") {
            go$a0 = $List("Cons", v2._1, v);
            go$a1 = v1._2;
            continue;
          }
        }
        fail();
      }
      return go$r;
    };
    return go(Nil);
  };
  var manyRec = (dictMonadRec) => (dictAlternative) => {
    const Alt0 = dictAlternative.Plus1().Alt0();
    const $0 = dictAlternative.Applicative0();
    return (p) => dictMonadRec.tailRecM((acc) => dictMonadRec.Monad0().Bind1().bind(Alt0.alt(Alt0.Functor0().map(Loop)(p))($0.pure($Step(
      "Done",
      void 0
    ))))((aa) => $0.pure((() => {
      if (aa.tag === "Loop") {
        return $Step("Loop", $List("Cons", aa._1, acc));
      }
      if (aa.tag === "Done") {
        return $Step("Done", reverse2(acc));
      }
      fail();
    })())))(Nil);
  };
  var some2 = (dictAlternative) => (dictLazy) => (v) => dictAlternative.Applicative0().Apply0().apply(dictAlternative.Plus1().Alt0().Functor0().map(Cons)(v))(dictLazy.defer((v1) => many2(dictAlternative)(dictLazy)(v)));
  var many2 = (dictAlternative) => (dictLazy) => (v) => dictAlternative.Plus1().Alt0().alt(some2(dictAlternative)(dictLazy)(v))(dictAlternative.Applicative0().pure(Nil));
  var index2 = (index$a0$copy) => (index$a1$copy) => {
    let index$a0 = index$a0$copy, index$a1 = index$a1$copy, index$c = true, index$r;
    while (index$c) {
      const v = index$a0, v1 = index$a1;
      if (v.tag === "Nil") {
        index$c = false;
        index$r = Nothing;
        continue;
      }
      if (v.tag === "Cons") {
        if (v1 === 0) {
          index$c = false;
          index$r = $Maybe("Just", v._1);
          continue;
        }
        index$a0 = v._2;
        index$a1 = v1 - 1 | 0;
        continue;
      }
      fail();
    }
    return index$r;
  };
  var groupBy2 = (v) => (v1) => {
    if (v1.tag === "Nil") {
      return Nil;
    }
    if (v1.tag === "Cons") {
      const v2 = span2(v(v1._1))(v1._2);
      return $List("Cons", $NonEmpty(v1._1, v2.init), groupBy2(v)(v2.rest));
    }
    fail();
  };
  var drop2 = (drop$a0$copy) => (drop$a1$copy) => {
    let drop$a0 = drop$a0$copy, drop$a1 = drop$a1$copy, drop$c = true, drop$r;
    while (drop$c) {
      const v = drop$a0, v1 = drop$a1;
      if (v < 1) {
        drop$c = false;
        drop$r = v1;
        continue;
      }
      if (v1.tag === "Nil") {
        drop$c = false;
        drop$r = Nil;
        continue;
      }
      if (v1.tag === "Cons") {
        drop$a0 = v - 1 | 0;
        drop$a1 = v1._2;
        continue;
      }
      fail();
    }
    return drop$r;
  };
  var deleteBy3 = (v) => (v1) => (v2) => {
    if (v2.tag === "Nil") {
      return Nil;
    }
    if (v2.tag === "Cons") {
      if (v(v1)(v2._1)) {
        return v2._2;
      }
      return $List("Cons", v2._1, deleteBy3(v)(v1)(v2._2));
    }
    fail();
  };
  var difference = (dictEq) => {
    const go = (go$a0$copy) => (go$a1$copy) => {
      let go$a0 = go$a0$copy, go$a1 = go$a1$copy, go$c = true, go$r;
      while (go$c) {
        const b = go$a0, v = go$a1;
        if (v.tag === "Nil") {
          go$c = false;
          go$r = b;
          continue;
        }
        if (v.tag === "Cons") {
          go$a0 = deleteBy3(dictEq.eq)(v._1)(b);
          go$a1 = v._2;
          continue;
        }
        fail();
      }
      return go$r;
    };
    return go;
  };

  // output-es/Partial/foreign.js
  var _crashWith = function(msg) {
    throw new Error(msg);
  };

  // output-es/Data.List.NonEmpty/index.js
  var wrappedOperation = (name3) => (f) => (v) => {
    const v1 = f($List("Cons", v._1, v._2));
    if (v1.tag === "Cons") {
      return $NonEmpty(v1._1, v1._2);
    }
    if (v1.tag === "Nil") {
      return _crashWith("Impossible: empty list in NonEmptyList " + name3);
    }
    fail();
  };
  var unsnoc3 = (v) => {
    const v1 = unsnoc2(v._2);
    if (v1.tag === "Nothing") {
      return { init: Nil, last: v._1 };
    }
    if (v1.tag === "Just") {
      return { init: $List("Cons", v._1, v1._1.init), last: v1._1.last };
    }
    fail();
  };
  var tail = (v) => v._2;
  var init2 = (v) => {
    const $0 = unsnoc2(v._2);
    if ($0.tag === "Just") {
      return $List("Cons", v._1, $0._1.init);
    }
    return Nil;
  };

  // output-es/Data.Set/index.js
  var toUnfoldable1 = /* @__PURE__ */ (() => {
    const $0 = toUnfoldable2(unfoldableArray);
    return (x2) => $0(keys2(x2));
  })();
  var singleton3 = (a) => $$$Map("Node", 1, 1, a, void 0, Leaf, Leaf);
  var showSet = (dictShow) => ({ show: (s) => "(fromFoldable " + showArrayImpl(dictShow.show)(toUnfoldable1(s)) + ")" });
  var foldableSet = {
    foldMap: (dictMonoid) => {
      const foldMap1 = foldableList.foldMap(dictMonoid);
      return (f) => {
        const $0 = foldMap1(f);
        return (x2) => $0(keys2(x2));
      };
    },
    foldl: (f) => (x2) => {
      const go = (go$a0$copy) => (go$a1$copy) => {
        let go$a0 = go$a0$copy, go$a1 = go$a1$copy, go$c = true, go$r;
        while (go$c) {
          const b = go$a0, v = go$a1;
          if (v.tag === "Nil") {
            go$c = false;
            go$r = b;
            continue;
          }
          if (v.tag === "Cons") {
            go$a0 = f(b)(v._1);
            go$a1 = v._2;
            continue;
          }
          fail();
        }
        return go$r;
      };
      const $0 = go(x2);
      return (x$1) => $0(keys2(x$1));
    },
    foldr: (f) => (x2) => {
      const $0 = foldableList.foldr(f)(x2);
      return (x$1) => $0(keys2(x$1));
    }
  };
  var filter3 = (dictOrd) => filterKeys2(dictOrd);
  var map2 = (dictOrd) => (f) => foldableSet.foldl((m) => (a) => insert3(dictOrd)(f(a))()(m))(Leaf);
  var monoidSet = (dictOrd) => {
    const semigroupSet1 = {
      append: (() => {
        const compare2 = dictOrd.compare;
        return (m1) => (m2) => unsafeUnionWith(compare2, $$const, m1, m2);
      })()
    };
    return { mempty: Leaf, Semigroup0: () => semigroupSet1 };
  };
  var unions = (dictFoldable) => (dictOrd) => dictFoldable.foldl((() => {
    const compare2 = dictOrd.compare;
    return (m1) => (m2) => unsafeUnionWith(compare2, $$const, m1, m2);
  })())(Leaf);

  // output-es/Debug/foreign.js
  var req = typeof module === "undefined" ? void 0 : module.require;
  var util = function() {
    try {
      return req === void 0 ? void 0 : req("util");
    } catch (e) {
      return void 0;
    }
  }();
  function _trace(x2, k) {
    if (util !== void 0) {
      console.log(util.inspect(x2, { depth: null, colors: true }));
    } else {
      console.log(x2);
    }
    return k({});
  }
  var now2 = function() {
    var perf;
    if (typeof performance !== "undefined") {
      perf = performance;
    } else if (req) {
      try {
        perf = req("perf_hooks").performance;
      } catch (e) {
      }
    }
    return function() {
      return (perf || Date).now();
    };
  }();

  // output-es/Util/index.js
  var fanout2 = /* @__PURE__ */ fanout(categoryFn)(strongFn);
  var intercalate2 = (sep) => (xs) => {
    const go = (go$a0$copy) => (go$a1$copy) => {
      let go$a0 = go$a0$copy, go$a1 = go$a1$copy, go$c = true, go$r;
      while (go$c) {
        const b = go$a0, v = go$a1;
        if (v.tag === "Nil") {
          go$c = false;
          go$r = b;
          continue;
        }
        if (v.tag === "Cons") {
          go$a0 = b.init ? { init: false, acc: v._1 } : { init: false, acc: foldableList.foldr(Cons)(foldableList.foldr(Cons)(v._1)(sep))(b.acc) };
          go$a1 = v._2;
          continue;
        }
        fail();
      }
      return go$r;
    };
    return go({ init: true, acc: Nil })(xs).acc;
  };
  var identity14 = (x2) => x2;
  var isEmptySet = { isEmpty: isEmpty2 };
  var isEmptyObject = { isEmpty };
  var unzip3 = (dictFunctor) => fanout2((v) => dictFunctor.map(fst)(v))((v) => dictFunctor.map(snd)(v));
  var $$throw = (dictMonadThrow) => (x2) => dictMonadThrow.throwError(error(x2));
  var withMsg = (dictMonadError) => {
    const throw2 = $$throw(dictMonadError.MonadThrow0());
    return (msg) => (m) => dictMonadError.catchError(m)((e) => throw2(message(e) + (msg === "" ? "" : "\n" + msg)));
  };
  var orElse = (dictMonadThrow) => (v) => (v1) => {
    if (v1.tag === "Nothing") {
      return dictMonadThrow.throwError(error(v));
    }
    if (v1.tag === "Just") {
      return dictMonadThrow.Monad0().Applicative0().pure(v1._1);
    }
    fail();
  };
  var mayFailEq = (dictMonadThrow) => (dictShow) => (dictEq) => (x2) => (x$p) => orElse(dictMonadThrow)(dictShow.show(x2) + " \u2260 " + dictShow.show(x$p))((() => {
    const $0 = dictEq.eq(x2)(x$p);
    if (!$0) {
      return Nothing;
    }
    if ($0) {
      return $Maybe("Just", x2);
    }
    fail();
  })());
  var definitely = (v) => (v1) => {
    if (v1.tag === "Just") {
      return v1._1;
    }
    if (v1.tag === "Nothing") {
      return throwException(error("definitely " + v))();
    }
    fail();
  };
  var mustEq = (dictEq) => (dictShow) => (x2) => (x$p) => definitely(dictShow.show(x2) + " equal to " + dictShow.show(x$p))((() => {
    const $0 = dictEq.eq(x2)(x$p);
    if (!$0) {
      return Nothing;
    }
    if ($0) {
      return $Maybe("Just", x2);
    }
    fail();
  })());
  var unsafeIndex = (xs) => (i) => definitely("index within bounds")(i >= 0 && i < xs.length ? $Maybe("Just", xs[i]) : Nothing);
  var nonEmptyListNonEmptyList = {
    nonEmpty: (x2) => definitely("non-empty")((() => {
      if (x2.tag === "Nil") {
        return Nothing;
      }
      if (x2.tag === "Cons") {
        return $Maybe("Just", $NonEmpty(x2._1, x2._2));
      }
      fail();
    })()),
    init: init2,
    tail
  };
  var defined = (x2) => {
    if (x2.tag === "Right") {
      return x2._1;
    }
    if (x2.tag === "Left") {
      return throwException(error(showErrorImpl(x2._1)))();
    }
    fail();
  };
  var spyWhen = (v) => (v1) => (v2) => (v3) => {
    if (v) {
      return _trace(v1 + ":", (v4) => _trace(v2(v3), (v$1) => v3));
    }
    return v3;
  };
  var spyFunWhenM = (dictFunctor) => (b) => (s) => (showIn) => (showOut) => (f) => (x2) => dictFunctor.map(spyWhen(b)(s + " output")(showOut))(f(spyWhen(b)(s + " input")(showIn)(x2)));
  var spyFunWhen = (b) => (s) => (showIn) => (showOut) => (f) => spyFunWhenM(functorIdentity)(b)(s)(showIn)(showOut)((x2) => f(x2));
  var check = (dictMonadThrow) => (v) => {
    if (!v) {
      return $$throw(dictMonadThrow);
    }
    if (v) {
      const $0 = dictMonadThrow.Monad0().Applicative0().pure();
      return (v$1) => $0;
    }
    fail();
  };
  var bind2Flipped = (dictMonad) => {
    const Bind1 = dictMonad.Bind1();
    const $0 = Bind1.Apply0();
    return (f) => (x2) => (y2) => Bind1.bind($0.apply($0.Functor0().map(f)(x2))(y2))(identity5);
  };
  var assertWith = (v) => (v1) => {
    if (v1) {
      return identity14;
    }
    return (v2) => throwException(error("Assertion failure: " + v))();
  };
  var assertWhen = (v) => (v1) => {
    if (!v) {
      return (v$1) => identity14;
    }
    if (v) {
      return (x2) => assertWith(v1)(x2());
    }
    fail();
  };

  // output-es/Util.Set/index.js
  var setSet = (dictOrd) => ({
    empty: Leaf,
    filter: filter3(dictOrd),
    size: size2,
    difference: (() => {
      const compare2 = dictOrd.compare;
      return (m1) => (m2) => unsafeDifference(compare2, m1, m2);
    })(),
    member: (k) => {
      const go = (go$a0$copy) => {
        let go$a0 = go$a0$copy, go$c = true, go$r;
        while (go$c) {
          const v = go$a0;
          if (v.tag === "Leaf") {
            go$c = false;
            go$r = false;
            continue;
          }
          if (v.tag === "Node") {
            const v1 = dictOrd.compare(k)(v._3);
            if (v1 === "LT") {
              go$a0 = v._5;
              continue;
            }
            if (v1 === "GT") {
              go$a0 = v._6;
              continue;
            }
            if (v1 === "EQ") {
              go$c = false;
              go$r = true;
              continue;
            }
          }
          fail();
        }
        return go$r;
      };
      return go;
    },
    union: (() => {
      const compare2 = dictOrd.compare;
      return (m1) => (m2) => unsafeUnionWith(compare2, $$const, m1, m2);
    })(),
    IsEmpty0: () => isEmptySet
  });
  var setObjectString = {
    empty: empty2,
    filter: filterKeys,
    size,
    difference: (x2) => (y2) => foldlArray((b) => (a) => mutate(($0) => () => {
      delete $0[a];
      return $0;
    })(b))(x2)(Object.keys(y2)),
    member,
    union,
    IsEmpty0: () => isEmptyObject
  };

  // output-es/Util.Map/foreign.js
  function intersectionWith_Object(f) {
    return function(m1) {
      return function(m2) {
        var m = {};
        for (var k in m1) {
          if (hasOwnProperty.call(m1, k) && hasOwnProperty.call(m2, k)) {
            m[k] = f(m1[k])(m2[k]);
          }
        }
        return m;
      };
    };
  }

  // output-es/Util.Map/index.js
  var identity15 = (x2) => x2;
  var mapObjectString = {
    maplet: singleton2,
    keys: /* @__PURE__ */ (() => {
      const $0 = foldlArray((m) => (a) => insert3(ordString)(a)()(m))(Leaf);
      return (x2) => $0(Object.keys(x2));
    })(),
    values: /* @__PURE__ */ (() => {
      const $0 = foldrArray(Cons)(Nil);
      return (x2) => $0(values(x2));
    })(),
    filterKeys,
    unionWith,
    lookup,
    delete: $$delete,
    insert: insert2,
    toUnfoldable: (dictUnfoldable) => toAscUnfoldable(dictUnfoldable),
    Set0: () => setObjectString
  };
  var lookup$p = (dictMonadThrow) => (dictShow) => (dictMap) => (k) => (\u03B3) => orElse(dictMonadThrow)("Key " + dictShow.show(k) + " exists in map")(dictMap.lookup(k)(\u03B3));
  var $$get = (dictShow) => (dictMap) => (k) => {
    const $0 = dictMap.lookup(k);
    const $1 = definitely("Key " + dictShow.show(k) + " exists in map");
    return (x2) => $1($0(x2));
  };
  var disjointUnion_inv = (dictOrd) => {
    const $0 = setSet(dictOrd);
    return (dictMap) => (ks) => (m) => $Tuple(dictMap.filterKeys((v) => $0.member(v)(ks))(m), dictMap.filterKeys((v) => !$0.member(v)(ks))(m));
  };
  var disjointUnion = (dictMap) => dictMap.unionWith((v) => (v1) => throwException(error("not disjoint"))());
  var mapFObjectString = {
    intersectionWith: intersectionWith_Object,
    difference: (m1) => (m2) => foldlArray((b) => (a) => mutate(($0) => () => {
      delete $0[a];
      return $0;
    })(b))(m1)(Object.keys(m2)),
    mapWithKey
  };
  var asMaplet = (dictMap) => {
    const toUnfoldable15 = dictMap.toUnfoldable(unfoldableList);
    return (m) => assertWith("")(dictMap.Set0().size(m) === 1)(definitely("singleton map")((() => {
      const $0 = toUnfoldable15(m);
      if ($0.tag === "Nil") {
        return Nothing;
      }
      if ($0.tag === "Cons") {
        return $Maybe("Just", $0._1);
      }
      fail();
    })()));
  };
  var append_inv = (dictOrd) => (dictMap) => (xs) => (\u03B3) => $Tuple(
    dictMap.filterKeys((v) => !setSet(dictOrd).member(v)(xs))(\u03B3),
    dictMap.filterKeys((v) => setSet(dictOrd).member(v)(xs))(\u03B3)
  );
  var update2 = (dictShow) => (dictMap) => (f) => (k) => {
    const $0 = definitely("Key " + dictShow.show(k) + " exists in map");
    return (m) => dictMap.insert(k)(f($0(dictMap.lookup(k)(m))))(m);
  };

  // output-es/Dict/index.js
  var identity16 = (x2) => x2;
  var isEmptyDict = { isEmpty: (v) => isEmpty(v) };
  var setDictString = {
    empty: empty2,
    filter: (p) => (v) => filterWithKey((x2) => {
      const $0 = p(x2);
      return (v$1) => $0;
    })(v),
    size: (v) => size(v),
    member: (x2) => (v) => Object.hasOwn(v, x2),
    difference: (v) => (v1) => setObjectString.difference(v)(v1),
    union: (v) => (v1) => union(v)(v1),
    IsEmpty0: () => isEmptyDict
  };
  var mapDictString = {
    maplet: (k) => (v) => {
      const $0 = {};
      $0[k] = v;
      return $0;
    },
    keys: (v) => mapObjectString.keys(v),
    values: (v) => mapObjectString.values(v),
    filterKeys: (p) => (v) => filterWithKey((x2) => {
      const $0 = p(x2);
      return (v$1) => $0;
    })(v),
    unionWith: (f) => (v) => (v1) => unionWith(f)(v)(v1),
    lookup: (k) => (v) => _lookup(Nothing, Just, k, v),
    delete: (k) => (v) => mutate(($0) => () => {
      delete $0[k];
      return $0;
    })(v),
    insert: (k) => (v) => (v1) => mutate(($0) => () => {
      $0[k] = v;
      return $0;
    })(v1),
    toUnfoldable: (dictUnfoldable) => toAscUnfoldable(dictUnfoldable),
    Set0: () => setDictString
  };
  var functorDict = { map: (f) => (m) => _fmapObject(m, f) };
  var foldableDict = {
    foldl: (f) => (z) => (m) => fold((z$1) => (v) => f(z$1))(z)(m),
    foldr: (f) => (z) => (m) => foldrArray(f)(z)(values(m)),
    foldMap: (dictMonoid) => {
      const foldMap1 = foldMap(dictMonoid);
      return (f) => foldMap1((v) => f);
    }
  };
  var foldableWithIndexStringDi = {
    foldlWithIndex: (f) => (z) => (v) => fold((b) => (a) => f(a)(b))(z)(v),
    foldrWithIndex: (f) => foldrWithIndexDefault(foldableWithIndexStringDi)(f),
    foldMapWithIndex: (dictMonoid) => (f) => foldableWithIndexStringDi.foldlWithIndex((i) => (acc) => (x2) => dictMonoid.Semigroup0().append(acc)(f(i)(x2)))(dictMonoid.mempty),
    Foldable0: () => foldableDict
  };
  var traversableDict = {
    traverse: (dictApplicative) => {
      const $0 = traversableWithIndexObject.traverseWithIndex(dictApplicative);
      return (f) => (m) => dictApplicative.Apply0().Functor0().map((v1) => v1)($0((v) => f)(m));
    },
    sequence: (dictApplicative) => (v) => traversableDict.traverse(dictApplicative)(identity16)(v),
    Functor0: () => functorDict,
    Foldable1: () => foldableDict
  };

  // output-es/Control.Monad.Error.Class/index.js
  var monadThrowEffect = { throwError: throwException, Monad0: () => monadEffect };
  var $$try = (dictMonadError) => {
    const Monad0 = dictMonadError.MonadThrow0().Monad0();
    return (a) => dictMonadError.catchError(Monad0.Bind1().Apply0().Functor0().map(Right)(a))((x2) => Monad0.Applicative0().pure($Either("Left", x2)));
  };

  // output-es/Effect.Aff/foreign.js
  var Aff = function() {
    var EMPTY = {};
    var PURE = "Pure";
    var THROW = "Throw";
    var CATCH = "Catch";
    var SYNC = "Sync";
    var ASYNC = "Async";
    var BIND = "Bind";
    var BRACKET = "Bracket";
    var FORK = "Fork";
    var SEQ = "Sequential";
    var MAP = "Map";
    var APPLY = "Apply";
    var ALT = "Alt";
    var CONS = "Cons";
    var RESUME = "Resume";
    var RELEASE = "Release";
    var FINALIZER = "Finalizer";
    var FINALIZED = "Finalized";
    var FORKED = "Forked";
    var FIBER = "Fiber";
    var THUNK = "Thunk";
    function Aff2(tag, _1, _2, _3) {
      this.tag = tag;
      this._1 = _1;
      this._2 = _2;
      this._3 = _3;
    }
    function AffCtr(tag) {
      var fn = function(_1, _2, _3) {
        return new Aff2(tag, _1, _2, _3);
      };
      fn.tag = tag;
      return fn;
    }
    function nonCanceler2(error3) {
      return new Aff2(PURE, void 0);
    }
    function runEff(eff) {
      try {
        eff();
      } catch (error3) {
        setTimeout(function() {
          throw error3;
        }, 0);
      }
    }
    function runSync(left2, right2, eff) {
      try {
        return right2(eff());
      } catch (error3) {
        return left2(error3);
      }
    }
    function runAsync(left2, eff, k) {
      try {
        return eff(k)();
      } catch (error3) {
        k(left2(error3))();
        return nonCanceler2;
      }
    }
    var Scheduler = function() {
      var limit = 1024;
      var size3 = 0;
      var ix = 0;
      var queue = new Array(limit);
      var draining = false;
      function drain() {
        var thunk;
        draining = true;
        while (size3 !== 0) {
          size3--;
          thunk = queue[ix];
          queue[ix] = void 0;
          ix = (ix + 1) % limit;
          thunk();
        }
        draining = false;
      }
      return {
        isDraining: function() {
          return draining;
        },
        enqueue: function(cb) {
          var i, tmp;
          if (size3 === limit) {
            tmp = draining;
            drain();
            draining = tmp;
          }
          queue[(ix + size3) % limit] = cb;
          size3++;
          if (!draining) {
            drain();
          }
        }
      };
    }();
    function Supervisor(util2) {
      var fibers = {};
      var fiberId = 0;
      var count = 0;
      return {
        register: function(fiber) {
          var fid = fiberId++;
          fiber.onComplete({
            rethrow: true,
            handler: function(result) {
              return function() {
                count--;
                delete fibers[fid];
              };
            }
          })();
          fibers[fid] = fiber;
          count++;
        },
        isEmpty: function() {
          return count === 0;
        },
        killAll: function(killError, cb) {
          return function() {
            if (count === 0) {
              return cb();
            }
            var killCount = 0;
            var kills = {};
            function kill(fid) {
              kills[fid] = fibers[fid].kill(killError, function(result) {
                return function() {
                  delete kills[fid];
                  killCount--;
                  if (util2.isLeft(result) && util2.fromLeft(result)) {
                    setTimeout(function() {
                      throw util2.fromLeft(result);
                    }, 0);
                  }
                  if (killCount === 0) {
                    cb();
                  }
                };
              })();
            }
            for (var k in fibers) {
              if (fibers.hasOwnProperty(k)) {
                killCount++;
                kill(k);
              }
            }
            fibers = {};
            fiberId = 0;
            count = 0;
            return function(error3) {
              return new Aff2(SYNC, function() {
                for (var k2 in kills) {
                  if (kills.hasOwnProperty(k2)) {
                    kills[k2]();
                  }
                }
              });
            };
          };
        }
      };
    }
    var SUSPENDED = 0;
    var CONTINUE = 1;
    var STEP_BIND = 2;
    var STEP_RESULT = 3;
    var PENDING = 4;
    var RETURN = 5;
    var COMPLETED = 6;
    function Fiber(util2, supervisor, aff) {
      var runTick = 0;
      var status = SUSPENDED;
      var step = aff;
      var fail3 = null;
      var interrupt = null;
      var bhead = null;
      var btail = null;
      var attempts = null;
      var bracketCount = 0;
      var joinId = 0;
      var joins = null;
      var rethrow = true;
      function run2(localRunTick) {
        var tmp, result, attempt;
        while (true) {
          tmp = null;
          result = null;
          attempt = null;
          switch (status) {
            case STEP_BIND:
              status = CONTINUE;
              try {
                step = bhead(step);
                if (btail === null) {
                  bhead = null;
                } else {
                  bhead = btail._1;
                  btail = btail._2;
                }
              } catch (e) {
                status = RETURN;
                fail3 = util2.left(e);
                step = null;
              }
              break;
            case STEP_RESULT:
              if (util2.isLeft(step)) {
                status = RETURN;
                fail3 = step;
                step = null;
              } else if (bhead === null) {
                status = RETURN;
              } else {
                status = STEP_BIND;
                step = util2.fromRight(step);
              }
              break;
            case CONTINUE:
              switch (step.tag) {
                case BIND:
                  if (bhead) {
                    btail = new Aff2(CONS, bhead, btail);
                  }
                  bhead = step._2;
                  status = CONTINUE;
                  step = step._1;
                  break;
                case PURE:
                  if (bhead === null) {
                    status = RETURN;
                    step = util2.right(step._1);
                  } else {
                    status = STEP_BIND;
                    step = step._1;
                  }
                  break;
                case SYNC:
                  status = STEP_RESULT;
                  step = runSync(util2.left, util2.right, step._1);
                  break;
                case ASYNC:
                  status = PENDING;
                  step = runAsync(util2.left, step._1, function(result2) {
                    return function() {
                      if (runTick !== localRunTick) {
                        return;
                      }
                      runTick++;
                      Scheduler.enqueue(function() {
                        if (runTick !== localRunTick + 1) {
                          return;
                        }
                        status = STEP_RESULT;
                        step = result2;
                        run2(runTick);
                      });
                    };
                  });
                  return;
                case THROW:
                  status = RETURN;
                  fail3 = util2.left(step._1);
                  step = null;
                  break;
                case CATCH:
                  if (bhead === null) {
                    attempts = new Aff2(CONS, step, attempts, interrupt);
                  } else {
                    attempts = new Aff2(CONS, step, new Aff2(CONS, new Aff2(RESUME, bhead, btail), attempts, interrupt), interrupt);
                  }
                  bhead = null;
                  btail = null;
                  status = CONTINUE;
                  step = step._1;
                  break;
                case BRACKET:
                  bracketCount++;
                  if (bhead === null) {
                    attempts = new Aff2(CONS, step, attempts, interrupt);
                  } else {
                    attempts = new Aff2(CONS, step, new Aff2(CONS, new Aff2(RESUME, bhead, btail), attempts, interrupt), interrupt);
                  }
                  bhead = null;
                  btail = null;
                  status = CONTINUE;
                  step = step._1;
                  break;
                case FORK:
                  status = STEP_RESULT;
                  tmp = Fiber(util2, supervisor, step._2);
                  if (supervisor) {
                    supervisor.register(tmp);
                  }
                  if (step._1) {
                    tmp.run();
                  }
                  step = util2.right(tmp);
                  break;
                case SEQ:
                  status = CONTINUE;
                  step = sequential(util2, supervisor, step._1);
                  break;
              }
              break;
            case RETURN:
              bhead = null;
              btail = null;
              if (attempts === null) {
                status = COMPLETED;
                step = interrupt || fail3 || step;
              } else {
                tmp = attempts._3;
                attempt = attempts._1;
                attempts = attempts._2;
                switch (attempt.tag) {
                  case CATCH:
                    if (interrupt && interrupt !== tmp && bracketCount === 0) {
                      status = RETURN;
                    } else if (fail3) {
                      status = CONTINUE;
                      step = attempt._2(util2.fromLeft(fail3));
                      fail3 = null;
                    }
                    break;
                  case RESUME:
                    if (interrupt && interrupt !== tmp && bracketCount === 0 || fail3) {
                      status = RETURN;
                    } else {
                      bhead = attempt._1;
                      btail = attempt._2;
                      status = STEP_BIND;
                      step = util2.fromRight(step);
                    }
                    break;
                  case BRACKET:
                    bracketCount--;
                    if (fail3 === null) {
                      result = util2.fromRight(step);
                      attempts = new Aff2(CONS, new Aff2(RELEASE, attempt._2, result), attempts, tmp);
                      if (interrupt === tmp || bracketCount > 0) {
                        status = CONTINUE;
                        step = attempt._3(result);
                      }
                    }
                    break;
                  case RELEASE:
                    attempts = new Aff2(CONS, new Aff2(FINALIZED, step, fail3), attempts, interrupt);
                    status = CONTINUE;
                    if (interrupt && interrupt !== tmp && bracketCount === 0) {
                      step = attempt._1.killed(util2.fromLeft(interrupt))(attempt._2);
                    } else if (fail3) {
                      step = attempt._1.failed(util2.fromLeft(fail3))(attempt._2);
                    } else {
                      step = attempt._1.completed(util2.fromRight(step))(attempt._2);
                    }
                    fail3 = null;
                    bracketCount++;
                    break;
                  case FINALIZER:
                    bracketCount++;
                    attempts = new Aff2(CONS, new Aff2(FINALIZED, step, fail3), attempts, interrupt);
                    status = CONTINUE;
                    step = attempt._1;
                    break;
                  case FINALIZED:
                    bracketCount--;
                    status = RETURN;
                    step = attempt._1;
                    fail3 = attempt._2;
                    break;
                }
              }
              break;
            case COMPLETED:
              for (var k in joins) {
                if (joins.hasOwnProperty(k)) {
                  rethrow = rethrow && joins[k].rethrow;
                  runEff(joins[k].handler(step));
                }
              }
              joins = null;
              if (interrupt && fail3) {
                setTimeout(function() {
                  throw util2.fromLeft(fail3);
                }, 0);
              } else if (util2.isLeft(step) && rethrow) {
                setTimeout(function() {
                  if (rethrow) {
                    throw util2.fromLeft(step);
                  }
                }, 0);
              }
              return;
            case SUSPENDED:
              status = CONTINUE;
              break;
            case PENDING:
              return;
          }
        }
      }
      function onComplete(join4) {
        return function() {
          if (status === COMPLETED) {
            rethrow = rethrow && join4.rethrow;
            join4.handler(step)();
            return function() {
            };
          }
          var jid = joinId++;
          joins = joins || {};
          joins[jid] = join4;
          return function() {
            if (joins !== null) {
              delete joins[jid];
            }
          };
        };
      }
      function kill(error3, cb) {
        return function() {
          if (status === COMPLETED) {
            cb(util2.right(void 0))();
            return function() {
            };
          }
          var canceler = onComplete({
            rethrow: false,
            handler: function() {
              return cb(util2.right(void 0));
            }
          })();
          switch (status) {
            case SUSPENDED:
              interrupt = util2.left(error3);
              status = COMPLETED;
              step = interrupt;
              run2(runTick);
              break;
            case PENDING:
              if (interrupt === null) {
                interrupt = util2.left(error3);
              }
              if (bracketCount === 0) {
                if (status === PENDING) {
                  attempts = new Aff2(CONS, new Aff2(FINALIZER, step(error3)), attempts, interrupt);
                }
                status = RETURN;
                step = null;
                fail3 = null;
                run2(++runTick);
              }
              break;
            default:
              if (interrupt === null) {
                interrupt = util2.left(error3);
              }
              if (bracketCount === 0) {
                status = RETURN;
                step = null;
                fail3 = null;
              }
          }
          return canceler;
        };
      }
      function join3(cb) {
        return function() {
          var canceler = onComplete({
            rethrow: false,
            handler: cb
          })();
          if (status === SUSPENDED) {
            run2(runTick);
          }
          return canceler;
        };
      }
      return {
        kill,
        join: join3,
        onComplete,
        isSuspended: function() {
          return status === SUSPENDED;
        },
        run: function() {
          if (status === SUSPENDED) {
            if (!Scheduler.isDraining()) {
              Scheduler.enqueue(function() {
                run2(runTick);
              });
            } else {
              run2(runTick);
            }
          }
        }
      };
    }
    function runPar(util2, supervisor, par, cb) {
      var fiberId = 0;
      var fibers = {};
      var killId = 0;
      var kills = {};
      var early = new Error("[ParAff] Early exit");
      var interrupt = null;
      var root2 = EMPTY;
      function kill(error3, par2, cb2) {
        var step = par2;
        var head = null;
        var tail3 = null;
        var count = 0;
        var kills2 = {};
        var tmp, kid;
        loop:
          while (true) {
            tmp = null;
            switch (step.tag) {
              case FORKED:
                if (step._3 === EMPTY) {
                  tmp = fibers[step._1];
                  kills2[count++] = tmp.kill(error3, function(result) {
                    return function() {
                      count--;
                      if (count === 0) {
                        cb2(result)();
                      }
                    };
                  });
                }
                if (head === null) {
                  break loop;
                }
                step = head._2;
                if (tail3 === null) {
                  head = null;
                } else {
                  head = tail3._1;
                  tail3 = tail3._2;
                }
                break;
              case MAP:
                step = step._2;
                break;
              case APPLY:
              case ALT:
                if (head) {
                  tail3 = new Aff2(CONS, head, tail3);
                }
                head = step;
                step = step._1;
                break;
            }
          }
        if (count === 0) {
          cb2(util2.right(void 0))();
        } else {
          kid = 0;
          tmp = count;
          for (; kid < tmp; kid++) {
            kills2[kid] = kills2[kid]();
          }
        }
        return kills2;
      }
      function join3(result, head, tail3) {
        var fail3, step, lhs, rhs, tmp, kid;
        if (util2.isLeft(result)) {
          fail3 = result;
          step = null;
        } else {
          step = result;
          fail3 = null;
        }
        loop:
          while (true) {
            lhs = null;
            rhs = null;
            tmp = null;
            kid = null;
            if (interrupt !== null) {
              return;
            }
            if (head === null) {
              cb(fail3 || step)();
              return;
            }
            if (head._3 !== EMPTY) {
              return;
            }
            switch (head.tag) {
              case MAP:
                if (fail3 === null) {
                  head._3 = util2.right(head._1(util2.fromRight(step)));
                  step = head._3;
                } else {
                  head._3 = fail3;
                }
                break;
              case APPLY:
                lhs = head._1._3;
                rhs = head._2._3;
                if (fail3) {
                  head._3 = fail3;
                  tmp = true;
                  kid = killId++;
                  kills[kid] = kill(early, fail3 === lhs ? head._2 : head._1, function() {
                    return function() {
                      delete kills[kid];
                      if (tmp) {
                        tmp = false;
                      } else if (tail3 === null) {
                        join3(fail3, null, null);
                      } else {
                        join3(fail3, tail3._1, tail3._2);
                      }
                    };
                  });
                  if (tmp) {
                    tmp = false;
                    return;
                  }
                } else if (lhs === EMPTY || rhs === EMPTY) {
                  return;
                } else {
                  step = util2.right(util2.fromRight(lhs)(util2.fromRight(rhs)));
                  head._3 = step;
                }
                break;
              case ALT:
                lhs = head._1._3;
                rhs = head._2._3;
                if (lhs === EMPTY && util2.isLeft(rhs) || rhs === EMPTY && util2.isLeft(lhs)) {
                  return;
                }
                if (lhs !== EMPTY && util2.isLeft(lhs) && rhs !== EMPTY && util2.isLeft(rhs)) {
                  fail3 = step === lhs ? rhs : lhs;
                  step = null;
                  head._3 = fail3;
                } else {
                  head._3 = step;
                  tmp = true;
                  kid = killId++;
                  kills[kid] = kill(early, step === lhs ? head._2 : head._1, function() {
                    return function() {
                      delete kills[kid];
                      if (tmp) {
                        tmp = false;
                      } else if (tail3 === null) {
                        join3(step, null, null);
                      } else {
                        join3(step, tail3._1, tail3._2);
                      }
                    };
                  });
                  if (tmp) {
                    tmp = false;
                    return;
                  }
                }
                break;
            }
            if (tail3 === null) {
              head = null;
            } else {
              head = tail3._1;
              tail3 = tail3._2;
            }
          }
      }
      function resolve(fiber) {
        return function(result) {
          return function() {
            delete fibers[fiber._1];
            fiber._3 = result;
            join3(result, fiber._2._1, fiber._2._2);
          };
        };
      }
      function run2() {
        var status = CONTINUE;
        var step = par;
        var head = null;
        var tail3 = null;
        var tmp, fid;
        loop:
          while (true) {
            tmp = null;
            fid = null;
            switch (status) {
              case CONTINUE:
                switch (step.tag) {
                  case MAP:
                    if (head) {
                      tail3 = new Aff2(CONS, head, tail3);
                    }
                    head = new Aff2(MAP, step._1, EMPTY, EMPTY);
                    step = step._2;
                    break;
                  case APPLY:
                    if (head) {
                      tail3 = new Aff2(CONS, head, tail3);
                    }
                    head = new Aff2(APPLY, EMPTY, step._2, EMPTY);
                    step = step._1;
                    break;
                  case ALT:
                    if (head) {
                      tail3 = new Aff2(CONS, head, tail3);
                    }
                    head = new Aff2(ALT, EMPTY, step._2, EMPTY);
                    step = step._1;
                    break;
                  default:
                    fid = fiberId++;
                    status = RETURN;
                    tmp = step;
                    step = new Aff2(FORKED, fid, new Aff2(CONS, head, tail3), EMPTY);
                    tmp = Fiber(util2, supervisor, tmp);
                    tmp.onComplete({
                      rethrow: false,
                      handler: resolve(step)
                    })();
                    fibers[fid] = tmp;
                    if (supervisor) {
                      supervisor.register(tmp);
                    }
                }
                break;
              case RETURN:
                if (head === null) {
                  break loop;
                }
                if (head._1 === EMPTY) {
                  head._1 = step;
                  status = CONTINUE;
                  step = head._2;
                  head._2 = EMPTY;
                } else {
                  head._2 = step;
                  step = head;
                  if (tail3 === null) {
                    head = null;
                  } else {
                    head = tail3._1;
                    tail3 = tail3._2;
                  }
                }
            }
          }
        root2 = step;
        for (fid = 0; fid < fiberId; fid++) {
          fibers[fid].run();
        }
      }
      function cancel(error3, cb2) {
        interrupt = util2.left(error3);
        var innerKills;
        for (var kid in kills) {
          if (kills.hasOwnProperty(kid)) {
            innerKills = kills[kid];
            for (kid in innerKills) {
              if (innerKills.hasOwnProperty(kid)) {
                innerKills[kid]();
              }
            }
          }
        }
        kills = null;
        var newKills = kill(error3, root2, cb2);
        return function(killError) {
          return new Aff2(ASYNC, function(killCb) {
            return function() {
              for (var kid2 in newKills) {
                if (newKills.hasOwnProperty(kid2)) {
                  newKills[kid2]();
                }
              }
              return nonCanceler2;
            };
          });
        };
      }
      run2();
      return function(killError) {
        return new Aff2(ASYNC, function(killCb) {
          return function() {
            return cancel(killError, killCb);
          };
        });
      };
    }
    function sequential(util2, supervisor, par) {
      return new Aff2(ASYNC, function(cb) {
        return function() {
          return runPar(util2, supervisor, par, cb);
        };
      });
    }
    Aff2.EMPTY = EMPTY;
    Aff2.Pure = AffCtr(PURE);
    Aff2.Throw = AffCtr(THROW);
    Aff2.Catch = AffCtr(CATCH);
    Aff2.Sync = AffCtr(SYNC);
    Aff2.Async = AffCtr(ASYNC);
    Aff2.Bind = AffCtr(BIND);
    Aff2.Bracket = AffCtr(BRACKET);
    Aff2.Fork = AffCtr(FORK);
    Aff2.Seq = AffCtr(SEQ);
    Aff2.ParMap = AffCtr(MAP);
    Aff2.ParApply = AffCtr(APPLY);
    Aff2.ParAlt = AffCtr(ALT);
    Aff2.Fiber = Fiber;
    Aff2.Supervisor = Supervisor;
    Aff2.Scheduler = Scheduler;
    Aff2.nonCanceler = nonCanceler2;
    return Aff2;
  }();
  var _pure = Aff.Pure;
  var _throwError = Aff.Throw;
  function _catchError(aff) {
    return function(k) {
      return Aff.Catch(aff, k);
    };
  }
  function _map(f) {
    return function(aff) {
      if (aff.tag === Aff.Pure.tag) {
        return Aff.Pure(f(aff._1));
      } else {
        return Aff.Bind(aff, function(value) {
          return Aff.Pure(f(value));
        });
      }
    };
  }
  function _bind(aff) {
    return function(k) {
      return Aff.Bind(aff, k);
    };
  }
  var _liftEffect = Aff.Sync;
  var makeAff = Aff.Async;
  function _makeFiber(util2, aff) {
    return function() {
      return Aff.Fiber(util2, null, aff);
    };
  }
  var _delay = function() {
    function setDelay(n, k) {
      if (n === 0 && typeof setImmediate !== "undefined") {
        return setImmediate(k);
      } else {
        return setTimeout(k, n);
      }
    }
    function clearDelay(n, t2) {
      if (n === 0 && typeof clearImmediate !== "undefined") {
        return clearImmediate(t2);
      } else {
        return clearTimeout(t2);
      }
    }
    return function(right2, ms) {
      return Aff.Async(function(cb) {
        return function() {
          var timer2 = setDelay(ms, cb(right2()));
          return function() {
            return Aff.Sync(function() {
              return right2(clearDelay(ms, timer2));
            });
          };
        };
      });
    };
  }();
  var _sequential = Aff.Seq;

  // output-es/Effect.Aff/index.js
  var functorAff = { map: _map };
  var ffiUtil = {
    isLeft: (v) => {
      if (v.tag === "Left") {
        return true;
      }
      if (v.tag === "Right") {
        return false;
      }
      fail();
    },
    fromLeft: (v) => {
      if (v.tag === "Left") {
        return v._1;
      }
      if (v.tag === "Right") {
        return _crashWith("unsafeFromLeft: Right");
      }
      fail();
    },
    fromRight: (v) => {
      if (v.tag === "Right") {
        return v._1;
      }
      if (v.tag === "Left") {
        return _crashWith("unsafeFromRight: Left");
      }
      fail();
    },
    left: Left,
    right: Right
  };
  var monadAff = { Applicative0: () => applicativeAff, Bind1: () => bindAff };
  var bindAff = { bind: _bind, Apply0: () => applyAff };
  var applyAff = { apply: (f) => (a) => _bind(f)((f$p) => _bind(a)((a$p) => applicativeAff.pure(f$p(a$p)))), Functor0: () => functorAff };
  var applicativeAff = { pure: _pure, Apply0: () => applyAff };
  var monadEffectAff = { liftEffect: _liftEffect, Monad0: () => monadAff };
  var monadThrowAff = { throwError: _throwError, Monad0: () => monadAff };
  var monadErrorAff = { catchError: _catchError, MonadThrow0: () => monadThrowAff };
  var $$try2 = /* @__PURE__ */ $$try(monadErrorAff);
  var runAff = (k) => (aff) => {
    const $0 = _makeFiber(ffiUtil, _bind($$try2(aff))((x2) => _liftEffect(k(x2))));
    return () => {
      const fiber = $0();
      fiber.run();
      return fiber;
    };
  };
  var nonCanceler = /* @__PURE__ */ (() => {
    const $0 = _pure();
    return (v) => $0;
  })();

  // output-es/Effect.Console/foreign.js
  var log2 = function(s) {
    return function() {
      console.log(s);
    };
  };

  // output-es/Data.HeytingAlgebra/foreign.js
  var boolConj = function(b1) {
    return function(b2) {
      return b1 && b2;
    };
  };
  var boolDisj = function(b1) {
    return function(b2) {
      return b1 || b2;
    };
  };
  var boolNot = function(b) {
    return !b;
  };

  // output-es/Util.Pair/index.js
  var $Pair = (_1, _2) => ({ tag: "Pair", _1, _2 });
  var Pair = (value0) => (value1) => $Pair(value0, value1);
  var functorPair = { map: (f) => (v) => $Pair(f(v._1), f(v._2)) };
  var foldablePair = {
    foldl: (f) => (z) => (v) => f(f(z)(v._1))(v._2),
    foldr: (f) => foldrDefault(foldablePair)(f),
    foldMap: (dictMonoid) => (f) => foldablePair.foldl((acc) => (x2) => dictMonoid.Semigroup0().append(acc)(f(x2)))(dictMonoid.mempty)
  };
  var traversablePair = {
    traverse: (dictApplicative) => {
      const Apply0 = dictApplicative.Apply0();
      return (f) => (v) => Apply0.apply(Apply0.Functor0().map(Pair)(f(v._1)))(f(v._2));
    },
    sequence: (dictApplicative) => traversablePair.traverse(dictApplicative)(identity7),
    Functor0: () => functorPair,
    Foldable1: () => foldablePair
  };
  var toTuple = (v) => $Tuple(v._1, v._2);
  var unzip4 = (xys) => unzip2(listMap(toTuple)(xys));
  var fromTuple = (v) => $Pair(v._1, v._2);

  // output-es/Lattice/index.js
  var identity18 = (x2) => x2;
  var length4 = /* @__PURE__ */ foldlArray((c) => (v) => 1 + c | 0)(0);
  var meetSemilatticeUnit = { meet: (v) => identity18 };
  var meetSemilatticeBoolean = { meet: boolConj };
  var joinSemilatticeUnit = { join: (v) => identity18 };
  var joinSemilatticeBoolean = { join: boolDisj };
  var boundedMeetSemilatticeUni = { top: void 0, MeetSemilattice0: () => meetSemilatticeUnit };
  var boundedMeetSemilatticeBoo = { top: true, MeetSemilattice0: () => meetSemilatticeBoolean };
  var boundedJoinSemilatticeUni = { bot: void 0, JoinSemilattice0: () => joinSemilatticeUnit };
  var joinSemilatticeArray = (dictJoinSemilattice) => {
    const join1 = dictJoinSemilattice.join;
    return {
      join: (xs) => (ys) => {
        if (length4(xs) === length4(ys)) {
          return zipWithImpl(join1, xs, ys);
        }
        return throwException(error("Shape mismatch"))();
      }
    };
  };
  var joinSemilatticeList = (dictJoinSemilattice) => {
    const join1 = dictJoinSemilattice.join;
    return {
      join: (xs) => (ys) => {
        if ((() => {
          const go = (go$a0$copy) => (go$a1$copy) => {
            let go$a0 = go$a0$copy, go$a1 = go$a1$copy, go$c = true, go$r;
            while (go$c) {
              const b = go$a0, v = go$a1;
              if (v.tag === "Nil") {
                go$c = false;
                go$r = b;
                continue;
              }
              if (v.tag === "Cons") {
                go$a0 = 1 + b | 0;
                go$a1 = v._2;
                continue;
              }
              fail();
            }
            return go$r;
          };
          const go$1 = (go$1$a0$copy) => (go$1$a1$copy) => {
            let go$1$a0 = go$1$a0$copy, go$1$a1 = go$1$a1$copy, go$1$c = true, go$1$r;
            while (go$1$c) {
              const b = go$1$a0, v = go$1$a1;
              if (v.tag === "Nil") {
                go$1$c = false;
                go$1$r = b;
                continue;
              }
              if (v.tag === "Cons") {
                go$1$a0 = 1 + b | 0;
                go$1$a1 = v._2;
                continue;
              }
              fail();
            }
            return go$1$r;
          };
          return go(0)(xs) === go$1(0)(ys);
        })()) {
          return zipWith2(join1)(xs)(ys);
        }
        return throwException(error("Shape mismatch"))();
      }
    };
  };
  var expandableDictDict = (dictBotOf) => {
    const botOf3 = dictBotOf.botOf;
    return (dictExpandable) => {
      const expand1 = dictExpandable.expand;
      return {
        expand: (kvs) => (kvs$p) => assertWith("")(unsafeDifference(
          ordString.compare,
          mapObjectString.keys(kvs),
          mapObjectString.keys(kvs$p)
        ).tag === "Leaf")(union(intersectionWith_Object(expand1)(kvs)(kvs$p))(_fmapObject(
          mapFObjectString.difference(kvs$p)(kvs),
          botOf3
        )))
      };
    };
  };

  // output-es/Data.Profunctor.Choice/index.js
  var identity19 = (x2) => x2;
  var fanin = (dictCategory) => {
    const identity1 = dictCategory.identity;
    const $0 = dictCategory.Semigroupoid0();
    const $1 = dictCategory.Semigroupoid0();
    return (dictChoice) => (l) => (r) => $0.compose(dictChoice.Profunctor0().dimap((v2) => {
      if (v2.tag === "Left") {
        return v2._1;
      }
      if (v2.tag === "Right") {
        return v2._1;
      }
      fail();
    })(identity19)(identity1))($1.compose(dictChoice.right(r))(dictChoice.left(l)));
  };
  var choiceFn = /* @__PURE__ */ (() => ({
    left: (v) => (v1) => {
      if (v1.tag === "Left") {
        return $Either("Left", v(v1._1));
      }
      if (v1.tag === "Right") {
        return $Either("Right", v1._1);
      }
      fail();
    },
    right: functorEither.map,
    Profunctor0: () => profunctorFn
  }))();

  // output-es/Data.Bounded/foreign.js
  var topChar = String.fromCharCode(65535);
  var bottomChar = String.fromCharCode(0);
  var topNumber = Number.POSITIVE_INFINITY;
  var bottomNumber = Number.NEGATIVE_INFINITY;

  // output-es/Data.Enum/foreign.js
  function toCharCode(c) {
    return c.charCodeAt(0);
  }
  function fromCharCode(c) {
    return String.fromCharCode(c);
  }

  // output-es/Data.Semiring/foreign.js
  var intAdd = function(x2) {
    return function(y2) {
      return x2 + y2 | 0;
    };
  };
  var intMul = function(x2) {
    return function(y2) {
      return x2 * y2 | 0;
    };
  };
  var numAdd = function(n1) {
    return function(n2) {
      return n1 + n2;
    };
  };
  var numMul = function(n1) {
    return function(n2) {
      return n1 * n2;
    };
  };

  // output-es/Data.Ring/foreign.js
  var intSub = function(x2) {
    return function(y2) {
      return x2 - y2 | 0;
    };
  };
  var numSub = function(n1) {
    return function(n2) {
      return n1 - n2;
    };
  };

  // output-es/Data.EuclideanRing/foreign.js
  var intDiv2 = function(x2) {
    return function(y2) {
      if (y2 === 0)
        return 0;
      return y2 > 0 ? Math.floor(x2 / y2) : -Math.floor(x2 / -y2);
    };
  };
  var intMod = function(x2) {
    return function(y2) {
      if (y2 === 0)
        return 0;
      var yy = Math.abs(y2);
      return (x2 % yy + yy) % yy;
    };
  };
  var numDiv = function(n1) {
    return function(n2) {
      return n1 / n2;
    };
  };

  // output-es/Data.String.CodePoints/foreign.js
  var hasArrayFrom = typeof Array.from === "function";
  var hasStringIterator = typeof Symbol !== "undefined" && Symbol != null && typeof Symbol.iterator !== "undefined" && typeof String.prototype[Symbol.iterator] === "function";
  var hasFromCodePoint = typeof String.prototype.fromCodePoint === "function";
  var hasCodePointAt = typeof String.prototype.codePointAt === "function";
  var _unsafeCodePointAt0 = function(fallback) {
    return hasCodePointAt ? function(str) {
      return str.codePointAt(0);
    } : fallback;
  };
  var _codePointAt = function(fallback) {
    return function(Just2) {
      return function(Nothing2) {
        return function(unsafeCodePointAt02) {
          return function(index3) {
            return function(str) {
              var length6 = str.length;
              if (index3 < 0 || index3 >= length6)
                return Nothing2;
              if (hasStringIterator) {
                var iter = str[Symbol.iterator]();
                for (var i = index3; ; --i) {
                  var o = iter.next();
                  if (o.done)
                    return Nothing2;
                  if (i === 0)
                    return Just2(unsafeCodePointAt02(o.value));
                }
              }
              return fallback(index3)(str);
            };
          };
        };
      };
    };
  };
  var _fromCodePointArray = function(singleton6) {
    return hasFromCodePoint ? function(cps) {
      if (cps.length < 1e4) {
        return String.fromCodePoint.apply(String, cps);
      }
      return cps.map(singleton6).join("");
    } : function(cps) {
      return cps.map(singleton6).join("");
    };
  };
  var _singleton = function(fallback) {
    return hasFromCodePoint ? String.fromCodePoint : fallback;
  };
  var _take = function(fallback) {
    return function(n) {
      if (hasStringIterator) {
        return function(str) {
          var accum = "";
          var iter = str[Symbol.iterator]();
          for (var i = 0; i < n; ++i) {
            var o = iter.next();
            if (o.done)
              return accum;
            accum += o.value;
          }
          return accum;
        };
      }
      return fallback(n);
    };
  };
  var _toCodePointArray = function(fallback) {
    return function(unsafeCodePointAt02) {
      if (hasArrayFrom) {
        return function(str) {
          return Array.from(str, unsafeCodePointAt02);
        };
      }
      return fallback;
    };
  };

  // output-es/Data.String.CodePoints/index.js
  var uncons2 = (s) => {
    const v = length2(s);
    if (v === 0) {
      return Nothing;
    }
    if (v === 1) {
      return $Maybe("Just", { head: toCharCode(charAt(0)(s)), tail: "" });
    }
    const cu1 = toCharCode(charAt(1)(s));
    const cu0 = toCharCode(charAt(0)(s));
    if (55296 <= cu0 && cu0 <= 56319 && 56320 <= cu1 && cu1 <= 57343) {
      return $Maybe("Just", { head: (((cu0 - 55296 | 0) * 1024 | 0) + (cu1 - 56320 | 0) | 0) + 65536 | 0, tail: drop(2)(s) });
    }
    return $Maybe("Just", { head: cu0, tail: drop(1)(s) });
  };
  var unconsButWithTuple = (s) => {
    const $0 = uncons2(s);
    if ($0.tag === "Just") {
      return $Maybe("Just", $Tuple($0._1.head, $0._1.tail));
    }
    return Nothing;
  };
  var toCodePointArrayFallback = (s) => unfoldableArray.unfoldr(unconsButWithTuple)(s);
  var unsafeCodePointAt0Fallback = (s) => {
    const cu0 = toCharCode(charAt(0)(s));
    if (55296 <= cu0 && cu0 <= 56319 && length2(s) > 1) {
      const cu1 = toCharCode(charAt(1)(s));
      if (56320 <= cu1 && cu1 <= 57343) {
        return (((cu0 - 55296 | 0) * 1024 | 0) + (cu1 - 56320 | 0) | 0) + 65536 | 0;
      }
    }
    return cu0;
  };
  var unsafeCodePointAt0 = /* @__PURE__ */ _unsafeCodePointAt0(unsafeCodePointAt0Fallback);
  var toCodePointArray = /* @__PURE__ */ _toCodePointArray(toCodePointArrayFallback)(unsafeCodePointAt0);
  var fromCharCode2 = (x2) => singleton((() => {
    if (x2 >= 0 && x2 <= 65535) {
      return fromCharCode(x2);
    }
    if (x2 < 0) {
      return "\0";
    }
    return "\uFFFF";
  })());
  var singletonFallback = (v) => {
    if (v <= 65535) {
      return fromCharCode2(v);
    }
    return fromCharCode2(intDiv(v - 65536 | 0, 1024) + 55296 | 0) + fromCharCode2(intMod(v - 65536 | 0)(1024) + 56320 | 0);
  };
  var fromCodePointArray = /* @__PURE__ */ _fromCodePointArray(singletonFallback);
  var singleton4 = /* @__PURE__ */ _singleton(singletonFallback);
  var takeFallback = (v) => (v1) => {
    if (v < 1) {
      return "";
    }
    const v2 = uncons2(v1);
    if (v2.tag === "Just") {
      return singleton4(v2._1.head) + takeFallback(v - 1 | 0)(v2._1.tail);
    }
    return v1;
  };
  var take3 = /* @__PURE__ */ _take(takeFallback);
  var codePointAtFallback = (codePointAtFallback$a0$copy) => (codePointAtFallback$a1$copy) => {
    let codePointAtFallback$a0 = codePointAtFallback$a0$copy, codePointAtFallback$a1 = codePointAtFallback$a1$copy, codePointAtFallback$c = true, codePointAtFallback$r;
    while (codePointAtFallback$c) {
      const n = codePointAtFallback$a0, s = codePointAtFallback$a1;
      const v = uncons2(s);
      if (v.tag === "Just") {
        if (n === 0) {
          codePointAtFallback$c = false;
          codePointAtFallback$r = $Maybe("Just", v._1.head);
          continue;
        }
        codePointAtFallback$a0 = n - 1 | 0;
        codePointAtFallback$a1 = v._1.tail;
        continue;
      }
      codePointAtFallback$c = false;
      codePointAtFallback$r = Nothing;
    }
    return codePointAtFallback$r;
  };
  var codePointAt2 = (v) => (v1) => {
    if (v < 0) {
      return Nothing;
    }
    if (v === 0) {
      if (v1 === "") {
        return Nothing;
      }
      return $Maybe("Just", unsafeCodePointAt0(v1));
    }
    return _codePointAt(codePointAtFallback)(Just)(Nothing)(unsafeCodePointAt0)(v)(v1);
  };

  // output-es/Data.CodePoint.Unicode.Internal/index.js
  var $UnicodeCategory = (tag) => tag;
  var NUMCAT_LU = /* @__PURE__ */ $UnicodeCategory("NUMCAT_LU");
  var NUMCAT_LL = /* @__PURE__ */ $UnicodeCategory("NUMCAT_LL");
  var NUMCAT_LT = /* @__PURE__ */ $UnicodeCategory("NUMCAT_LT");
  var NUMCAT_LM = /* @__PURE__ */ $UnicodeCategory("NUMCAT_LM");
  var NUMCAT_LO = /* @__PURE__ */ $UnicodeCategory("NUMCAT_LO");
  var NUMCAT_MN = /* @__PURE__ */ $UnicodeCategory("NUMCAT_MN");
  var NUMCAT_MC = /* @__PURE__ */ $UnicodeCategory("NUMCAT_MC");
  var NUMCAT_ME = /* @__PURE__ */ $UnicodeCategory("NUMCAT_ME");
  var NUMCAT_ND = /* @__PURE__ */ $UnicodeCategory("NUMCAT_ND");
  var NUMCAT_NL = /* @__PURE__ */ $UnicodeCategory("NUMCAT_NL");
  var NUMCAT_NO = /* @__PURE__ */ $UnicodeCategory("NUMCAT_NO");
  var NUMCAT_PC = /* @__PURE__ */ $UnicodeCategory("NUMCAT_PC");
  var NUMCAT_PD = /* @__PURE__ */ $UnicodeCategory("NUMCAT_PD");
  var NUMCAT_PS = /* @__PURE__ */ $UnicodeCategory("NUMCAT_PS");
  var NUMCAT_PE = /* @__PURE__ */ $UnicodeCategory("NUMCAT_PE");
  var NUMCAT_PI = /* @__PURE__ */ $UnicodeCategory("NUMCAT_PI");
  var NUMCAT_PF = /* @__PURE__ */ $UnicodeCategory("NUMCAT_PF");
  var NUMCAT_PO = /* @__PURE__ */ $UnicodeCategory("NUMCAT_PO");
  var NUMCAT_SM = /* @__PURE__ */ $UnicodeCategory("NUMCAT_SM");
  var NUMCAT_SC = /* @__PURE__ */ $UnicodeCategory("NUMCAT_SC");
  var NUMCAT_SK = /* @__PURE__ */ $UnicodeCategory("NUMCAT_SK");
  var NUMCAT_SO = /* @__PURE__ */ $UnicodeCategory("NUMCAT_SO");
  var NUMCAT_ZS = /* @__PURE__ */ $UnicodeCategory("NUMCAT_ZS");
  var NUMCAT_ZL = /* @__PURE__ */ $UnicodeCategory("NUMCAT_ZL");
  var NUMCAT_ZP = /* @__PURE__ */ $UnicodeCategory("NUMCAT_ZP");
  var NUMCAT_CC = /* @__PURE__ */ $UnicodeCategory("NUMCAT_CC");
  var NUMCAT_CF = /* @__PURE__ */ $UnicodeCategory("NUMCAT_CF");
  var NUMCAT_CS = /* @__PURE__ */ $UnicodeCategory("NUMCAT_CS");
  var NUMCAT_CO = /* @__PURE__ */ $UnicodeCategory("NUMCAT_CO");
  var NUMCAT_CN = /* @__PURE__ */ $UnicodeCategory("NUMCAT_CN");
  var rule1 = { category: 2, unicodeCat: NUMCAT_ZS, possible: 0, updist: 0, lowdist: 0, titledist: 0 };
  var spacechars = [
    { start: 32, length: 1, convRule: rule1 },
    { start: 160, length: 1, convRule: rule1 },
    { start: 5760, length: 1, convRule: rule1 },
    { start: 8192, length: 11, convRule: rule1 },
    { start: 8239, length: 1, convRule: rule1 },
    { start: 8287, length: 1, convRule: rule1 },
    { start: 12288, length: 1, convRule: rule1 }
  ];
  var rule162 = { category: 67108864, unicodeCat: NUMCAT_ZP, possible: 0, updist: 0, lowdist: 0, titledist: 0 };
  var rule161 = { category: 33554432, unicodeCat: NUMCAT_ZL, possible: 0, updist: 0, lowdist: 0, titledist: 0 };
  var rule13 = { category: 8192, unicodeCat: NUMCAT_SO, possible: 0, updist: 0, lowdist: 0, titledist: 0 };
  var rule170 = { category: 8192, unicodeCat: NUMCAT_SO, possible: 1, updist: 0, lowdist: 26, titledist: 0 };
  var rule171 = { category: 8192, unicodeCat: NUMCAT_SO, possible: 1, updist: -26, lowdist: 0, titledist: -26 };
  var rule6 = { category: 64, unicodeCat: NUMCAT_SM, possible: 0, updist: 0, lowdist: 0, titledist: 0 };
  var rule10 = { category: 1024, unicodeCat: NUMCAT_SK, possible: 0, updist: 0, lowdist: 0, titledist: 0 };
  var rule3 = { category: 8, unicodeCat: NUMCAT_SC, possible: 0, updist: 0, lowdist: 0, titledist: 0 };
  var rule4 = { category: 16, unicodeCat: NUMCAT_PS, possible: 0, updist: 0, lowdist: 0, titledist: 0 };
  var rule2 = { category: 4, unicodeCat: NUMCAT_PO, possible: 0, updist: 0, lowdist: 0, titledist: 0 };
  var rule15 = { category: 32768, unicodeCat: NUMCAT_PI, possible: 0, updist: 0, lowdist: 0, titledist: 0 };
  var rule19 = { category: 262144, unicodeCat: NUMCAT_PF, possible: 0, updist: 0, lowdist: 0, titledist: 0 };
  var rule5 = { category: 32, unicodeCat: NUMCAT_PE, possible: 0, updist: 0, lowdist: 0, titledist: 0 };
  var rule7 = { category: 128, unicodeCat: NUMCAT_PD, possible: 0, updist: 0, lowdist: 0, titledist: 0 };
  var rule11 = { category: 2048, unicodeCat: NUMCAT_PC, possible: 0, updist: 0, lowdist: 0, titledist: 0 };
  var rule17 = { category: 131072, unicodeCat: NUMCAT_NO, possible: 0, updist: 0, lowdist: 0, titledist: 0 };
  var rule128 = { category: 16777216, unicodeCat: NUMCAT_NL, possible: 0, updist: 0, lowdist: 0, titledist: 0 };
  var rule168 = { category: 16777216, unicodeCat: NUMCAT_NL, possible: 1, updist: 0, lowdist: 16, titledist: 0 };
  var rule169 = { category: 16777216, unicodeCat: NUMCAT_NL, possible: 1, updist: -16, lowdist: 0, titledist: -16 };
  var rule8 = { category: 256, unicodeCat: NUMCAT_ND, possible: 0, updist: 0, lowdist: 0, titledist: 0 };
  var rule92 = { category: 2097152, unicodeCat: NUMCAT_MN, possible: 0, updist: 0, lowdist: 0, titledist: 0 };
  var rule93 = { category: 2097152, unicodeCat: NUMCAT_MN, possible: 1, updist: 84, lowdist: 0, titledist: 84 };
  var rule119 = { category: 4194304, unicodeCat: NUMCAT_ME, possible: 0, updist: 0, lowdist: 0, titledist: 0 };
  var rule124 = { category: 8388608, unicodeCat: NUMCAT_MC, possible: 0, updist: 0, lowdist: 0, titledist: 0 };
  var nullrule = { category: 512, unicodeCat: NUMCAT_CN, possible: 0, updist: 0, lowdist: 0, titledist: 0 };
  var rule104 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: 8, titledist: 0 };
  var rule107 = { category: 512, unicodeCat: NUMCAT_LU, possible: 0, updist: 0, lowdist: 0, titledist: 0 };
  var rule115 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: -60, titledist: 0 };
  var rule117 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: -7, titledist: 0 };
  var rule118 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: 80, titledist: 0 };
  var rule120 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: 15, titledist: 0 };
  var rule122 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: 48, titledist: 0 };
  var rule125 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: 7264, titledist: 0 };
  var rule127 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: 38864, titledist: 0 };
  var rule137 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: -3008, titledist: 0 };
  var rule142 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: -7615, titledist: 0 };
  var rule144 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: -8, titledist: 0 };
  var rule153 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: -74, titledist: 0 };
  var rule156 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: -86, titledist: 0 };
  var rule157 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: -100, titledist: 0 };
  var rule158 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: -112, titledist: 0 };
  var rule159 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: -128, titledist: 0 };
  var rule160 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: -126, titledist: 0 };
  var rule163 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: -7517, titledist: 0 };
  var rule164 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: -8383, titledist: 0 };
  var rule165 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: -8262, titledist: 0 };
  var rule166 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: 28, titledist: 0 };
  var rule172 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: -10743, titledist: 0 };
  var rule173 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: -3814, titledist: 0 };
  var rule174 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: -10727, titledist: 0 };
  var rule177 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: -10780, titledist: 0 };
  var rule178 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: -10749, titledist: 0 };
  var rule179 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: -10783, titledist: 0 };
  var rule180 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: -10782, titledist: 0 };
  var rule181 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: -10815, titledist: 0 };
  var rule183 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: -35332, titledist: 0 };
  var rule184 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: -42280, titledist: 0 };
  var rule186 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: -42308, titledist: 0 };
  var rule187 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: -42319, titledist: 0 };
  var rule188 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: -42315, titledist: 0 };
  var rule189 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: -42305, titledist: 0 };
  var rule190 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: -42258, titledist: 0 };
  var rule191 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: -42282, titledist: 0 };
  var rule192 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: -42261, titledist: 0 };
  var rule193 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: 928, titledist: 0 };
  var rule194 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: -48, titledist: 0 };
  var rule195 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: -42307, titledist: 0 };
  var rule196 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: -35384, titledist: 0 };
  var rule201 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: 40, titledist: 0 };
  var rule203 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: 34, titledist: 0 };
  var rule22 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: 1, titledist: 0 };
  var rule24 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: -199, titledist: 0 };
  var rule26 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: -121, titledist: 0 };
  var rule29 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: 210, titledist: 0 };
  var rule30 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: 206, titledist: 0 };
  var rule31 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: 205, titledist: 0 };
  var rule32 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: 79, titledist: 0 };
  var rule33 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: 202, titledist: 0 };
  var rule34 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: 203, titledist: 0 };
  var rule35 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: 207, titledist: 0 };
  var rule37 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: 211, titledist: 0 };
  var rule38 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: 209, titledist: 0 };
  var rule40 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: 213, titledist: 0 };
  var rule42 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: 214, titledist: 0 };
  var rule43 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: 218, titledist: 0 };
  var rule44 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: 217, titledist: 0 };
  var rule45 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: 219, titledist: 0 };
  var rule47 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: 2, titledist: 1 };
  var rule51 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: -97, titledist: 0 };
  var rule52 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: -56, titledist: 0 };
  var rule53 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: -130, titledist: 0 };
  var rule54 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: 10795, titledist: 0 };
  var rule55 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: -163, titledist: 0 };
  var rule56 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: 10792, titledist: 0 };
  var rule58 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: -195, titledist: 0 };
  var rule59 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: 69, titledist: 0 };
  var rule60 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: 71, titledist: 0 };
  var rule9 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: 32, titledist: 0 };
  var rule94 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: 116, titledist: 0 };
  var rule95 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: 38, titledist: 0 };
  var rule96 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: 37, titledist: 0 };
  var rule97 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: 64, titledist: 0 };
  var rule98 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: 63, titledist: 0 };
  var rule151 = { category: 524288, unicodeCat: NUMCAT_LT, possible: 1, updist: 0, lowdist: -8, titledist: 0 };
  var rule154 = { category: 524288, unicodeCat: NUMCAT_LT, possible: 1, updist: 0, lowdist: -9, titledist: 0 };
  var rule48 = { category: 524288, unicodeCat: NUMCAT_LT, possible: 1, updist: -1, lowdist: 1, titledist: 0 };
  var rule14 = { category: 16384, unicodeCat: NUMCAT_LO, possible: 0, updist: 0, lowdist: 0, titledist: 0 };
  var rule91 = { category: 1048576, unicodeCat: NUMCAT_LM, possible: 0, updist: 0, lowdist: 0, titledist: 0 };
  var rule100 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: -37, lowdist: 0, titledist: -37 };
  var rule101 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: -31, lowdist: 0, titledist: -31 };
  var rule102 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: -64, lowdist: 0, titledist: -64 };
  var rule103 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: -63, lowdist: 0, titledist: -63 };
  var rule105 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: -62, lowdist: 0, titledist: -62 };
  var rule106 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: -57, lowdist: 0, titledist: -57 };
  var rule108 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: -47, lowdist: 0, titledist: -47 };
  var rule109 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: -54, lowdist: 0, titledist: -54 };
  var rule110 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: -8, lowdist: 0, titledist: -8 };
  var rule111 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: -86, lowdist: 0, titledist: -86 };
  var rule112 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: -80, lowdist: 0, titledist: -80 };
  var rule113 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: 7, lowdist: 0, titledist: 7 };
  var rule114 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: -116, lowdist: 0, titledist: -116 };
  var rule116 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: -96, lowdist: 0, titledist: -96 };
  var rule12 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: -32, lowdist: 0, titledist: -32 };
  var rule121 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: -15, lowdist: 0, titledist: -15 };
  var rule123 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: -48, lowdist: 0, titledist: -48 };
  var rule126 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: 3008, lowdist: 0, titledist: 0 };
  var rule129 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: -6254, lowdist: 0, titledist: -6254 };
  var rule130 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: -6253, lowdist: 0, titledist: -6253 };
  var rule131 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: -6244, lowdist: 0, titledist: -6244 };
  var rule132 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: -6242, lowdist: 0, titledist: -6242 };
  var rule133 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: -6243, lowdist: 0, titledist: -6243 };
  var rule134 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: -6236, lowdist: 0, titledist: -6236 };
  var rule135 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: -6181, lowdist: 0, titledist: -6181 };
  var rule136 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: 35266, lowdist: 0, titledist: 35266 };
  var rule138 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: 35332, lowdist: 0, titledist: 35332 };
  var rule139 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: 3814, lowdist: 0, titledist: 3814 };
  var rule140 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: 35384, lowdist: 0, titledist: 35384 };
  var rule141 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: -59, lowdist: 0, titledist: -59 };
  var rule143 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: 8, lowdist: 0, titledist: 8 };
  var rule145 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: 74, lowdist: 0, titledist: 74 };
  var rule146 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: 86, lowdist: 0, titledist: 86 };
  var rule147 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: 100, lowdist: 0, titledist: 100 };
  var rule148 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: 128, lowdist: 0, titledist: 128 };
  var rule149 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: 112, lowdist: 0, titledist: 112 };
  var rule150 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: 126, lowdist: 0, titledist: 126 };
  var rule152 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: 9, lowdist: 0, titledist: 9 };
  var rule155 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: -7205, lowdist: 0, titledist: -7205 };
  var rule167 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: -28, lowdist: 0, titledist: -28 };
  var rule175 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: -10795, lowdist: 0, titledist: -10795 };
  var rule176 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: -10792, lowdist: 0, titledist: -10792 };
  var rule18 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: 743, lowdist: 0, titledist: 743 };
  var rule182 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: -7264, lowdist: 0, titledist: -7264 };
  var rule185 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: 48, lowdist: 0, titledist: 48 };
  var rule197 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: -928, lowdist: 0, titledist: -928 };
  var rule198 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: -38864, lowdist: 0, titledist: -38864 };
  var rule20 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 0, updist: 0, lowdist: 0, titledist: 0 };
  var rule202 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: -40, lowdist: 0, titledist: -40 };
  var rule204 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: -34, lowdist: 0, titledist: -34 };
  var rule21 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: 121, lowdist: 0, titledist: 121 };
  var rule23 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: -1, lowdist: 0, titledist: -1 };
  var rule25 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: -232, lowdist: 0, titledist: -232 };
  var rule27 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: -300, lowdist: 0, titledist: -300 };
  var rule28 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: 195, lowdist: 0, titledist: 195 };
  var rule36 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: 97, lowdist: 0, titledist: 97 };
  var rule39 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: 163, lowdist: 0, titledist: 163 };
  var rule41 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: 130, lowdist: 0, titledist: 130 };
  var rule46 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: 56, lowdist: 0, titledist: 56 };
  var rule49 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: -2, lowdist: 0, titledist: -1 };
  var rule50 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: -79, lowdist: 0, titledist: -79 };
  var rule57 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: 10815, lowdist: 0, titledist: 10815 };
  var rule61 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: 10783, lowdist: 0, titledist: 10783 };
  var rule62 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: 10780, lowdist: 0, titledist: 10780 };
  var rule63 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: 10782, lowdist: 0, titledist: 10782 };
  var rule64 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: -210, lowdist: 0, titledist: -210 };
  var rule65 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: -206, lowdist: 0, titledist: -206 };
  var rule66 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: -205, lowdist: 0, titledist: -205 };
  var rule67 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: -202, lowdist: 0, titledist: -202 };
  var rule68 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: -203, lowdist: 0, titledist: -203 };
  var rule69 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: 42319, lowdist: 0, titledist: 42319 };
  var rule70 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: 42315, lowdist: 0, titledist: 42315 };
  var rule71 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: -207, lowdist: 0, titledist: -207 };
  var rule72 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: 42280, lowdist: 0, titledist: 42280 };
  var rule73 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: 42308, lowdist: 0, titledist: 42308 };
  var rule74 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: -209, lowdist: 0, titledist: -209 };
  var rule75 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: -211, lowdist: 0, titledist: -211 };
  var rule76 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: 10743, lowdist: 0, titledist: 10743 };
  var rule77 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: 42305, lowdist: 0, titledist: 42305 };
  var rule78 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: 10749, lowdist: 0, titledist: 10749 };
  var rule79 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: -213, lowdist: 0, titledist: -213 };
  var rule80 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: -214, lowdist: 0, titledist: -214 };
  var rule81 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: 10727, lowdist: 0, titledist: 10727 };
  var rule82 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: -218, lowdist: 0, titledist: -218 };
  var rule83 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: 42307, lowdist: 0, titledist: 42307 };
  var rule84 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: 42282, lowdist: 0, titledist: 42282 };
  var rule85 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: -69, lowdist: 0, titledist: -69 };
  var rule86 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: -217, lowdist: 0, titledist: -217 };
  var rule87 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: -71, lowdist: 0, titledist: -71 };
  var rule88 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: -219, lowdist: 0, titledist: -219 };
  var rule89 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: 42261, lowdist: 0, titledist: 42261 };
  var rule90 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: 42258, lowdist: 0, titledist: 42258 };
  var rule99 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: -38, lowdist: 0, titledist: -38 };
  var rule199 = { category: 134217728, unicodeCat: NUMCAT_CS, possible: 0, updist: 0, lowdist: 0, titledist: 0 };
  var rule200 = { category: 268435456, unicodeCat: NUMCAT_CO, possible: 0, updist: 0, lowdist: 0, titledist: 0 };
  var rule16 = { category: 65536, unicodeCat: NUMCAT_CF, possible: 0, updist: 0, lowdist: 0, titledist: 0 };
  var rule0 = { category: 1, unicodeCat: NUMCAT_CC, possible: 0, updist: 0, lowdist: 0, titledist: 0 };
  var convchars = [
    { start: 65, length: 26, convRule: rule9 },
    { start: 97, length: 26, convRule: rule12 },
    { start: 181, length: 1, convRule: rule18 },
    { start: 192, length: 23, convRule: rule9 },
    { start: 216, length: 7, convRule: rule9 },
    { start: 224, length: 23, convRule: rule12 },
    { start: 248, length: 7, convRule: rule12 },
    { start: 255, length: 1, convRule: rule21 },
    { start: 256, length: 1, convRule: rule22 },
    { start: 257, length: 1, convRule: rule23 },
    { start: 258, length: 1, convRule: rule22 },
    { start: 259, length: 1, convRule: rule23 },
    { start: 260, length: 1, convRule: rule22 },
    { start: 261, length: 1, convRule: rule23 },
    { start: 262, length: 1, convRule: rule22 },
    { start: 263, length: 1, convRule: rule23 },
    { start: 264, length: 1, convRule: rule22 },
    { start: 265, length: 1, convRule: rule23 },
    { start: 266, length: 1, convRule: rule22 },
    { start: 267, length: 1, convRule: rule23 },
    { start: 268, length: 1, convRule: rule22 },
    { start: 269, length: 1, convRule: rule23 },
    { start: 270, length: 1, convRule: rule22 },
    { start: 271, length: 1, convRule: rule23 },
    { start: 272, length: 1, convRule: rule22 },
    { start: 273, length: 1, convRule: rule23 },
    { start: 274, length: 1, convRule: rule22 },
    { start: 275, length: 1, convRule: rule23 },
    { start: 276, length: 1, convRule: rule22 },
    { start: 277, length: 1, convRule: rule23 },
    { start: 278, length: 1, convRule: rule22 },
    { start: 279, length: 1, convRule: rule23 },
    { start: 280, length: 1, convRule: rule22 },
    { start: 281, length: 1, convRule: rule23 },
    { start: 282, length: 1, convRule: rule22 },
    { start: 283, length: 1, convRule: rule23 },
    { start: 284, length: 1, convRule: rule22 },
    { start: 285, length: 1, convRule: rule23 },
    { start: 286, length: 1, convRule: rule22 },
    { start: 287, length: 1, convRule: rule23 },
    { start: 288, length: 1, convRule: rule22 },
    { start: 289, length: 1, convRule: rule23 },
    { start: 290, length: 1, convRule: rule22 },
    { start: 291, length: 1, convRule: rule23 },
    { start: 292, length: 1, convRule: rule22 },
    { start: 293, length: 1, convRule: rule23 },
    { start: 294, length: 1, convRule: rule22 },
    { start: 295, length: 1, convRule: rule23 },
    { start: 296, length: 1, convRule: rule22 },
    { start: 297, length: 1, convRule: rule23 },
    { start: 298, length: 1, convRule: rule22 },
    { start: 299, length: 1, convRule: rule23 },
    { start: 300, length: 1, convRule: rule22 },
    { start: 301, length: 1, convRule: rule23 },
    { start: 302, length: 1, convRule: rule22 },
    { start: 303, length: 1, convRule: rule23 },
    { start: 304, length: 1, convRule: rule24 },
    { start: 305, length: 1, convRule: rule25 },
    { start: 306, length: 1, convRule: rule22 },
    { start: 307, length: 1, convRule: rule23 },
    { start: 308, length: 1, convRule: rule22 },
    { start: 309, length: 1, convRule: rule23 },
    { start: 310, length: 1, convRule: rule22 },
    { start: 311, length: 1, convRule: rule23 },
    { start: 313, length: 1, convRule: rule22 },
    { start: 314, length: 1, convRule: rule23 },
    { start: 315, length: 1, convRule: rule22 },
    { start: 316, length: 1, convRule: rule23 },
    { start: 317, length: 1, convRule: rule22 },
    { start: 318, length: 1, convRule: rule23 },
    { start: 319, length: 1, convRule: rule22 },
    { start: 320, length: 1, convRule: rule23 },
    { start: 321, length: 1, convRule: rule22 },
    { start: 322, length: 1, convRule: rule23 },
    { start: 323, length: 1, convRule: rule22 },
    { start: 324, length: 1, convRule: rule23 },
    { start: 325, length: 1, convRule: rule22 },
    { start: 326, length: 1, convRule: rule23 },
    { start: 327, length: 1, convRule: rule22 },
    { start: 328, length: 1, convRule: rule23 },
    { start: 330, length: 1, convRule: rule22 },
    { start: 331, length: 1, convRule: rule23 },
    { start: 332, length: 1, convRule: rule22 },
    { start: 333, length: 1, convRule: rule23 },
    { start: 334, length: 1, convRule: rule22 },
    { start: 335, length: 1, convRule: rule23 },
    { start: 336, length: 1, convRule: rule22 },
    { start: 337, length: 1, convRule: rule23 },
    { start: 338, length: 1, convRule: rule22 },
    { start: 339, length: 1, convRule: rule23 },
    { start: 340, length: 1, convRule: rule22 },
    { start: 341, length: 1, convRule: rule23 },
    { start: 342, length: 1, convRule: rule22 },
    { start: 343, length: 1, convRule: rule23 },
    { start: 344, length: 1, convRule: rule22 },
    { start: 345, length: 1, convRule: rule23 },
    { start: 346, length: 1, convRule: rule22 },
    { start: 347, length: 1, convRule: rule23 },
    { start: 348, length: 1, convRule: rule22 },
    { start: 349, length: 1, convRule: rule23 },
    { start: 350, length: 1, convRule: rule22 },
    { start: 351, length: 1, convRule: rule23 },
    { start: 352, length: 1, convRule: rule22 },
    { start: 353, length: 1, convRule: rule23 },
    { start: 354, length: 1, convRule: rule22 },
    { start: 355, length: 1, convRule: rule23 },
    { start: 356, length: 1, convRule: rule22 },
    { start: 357, length: 1, convRule: rule23 },
    { start: 358, length: 1, convRule: rule22 },
    { start: 359, length: 1, convRule: rule23 },
    { start: 360, length: 1, convRule: rule22 },
    { start: 361, length: 1, convRule: rule23 },
    { start: 362, length: 1, convRule: rule22 },
    { start: 363, length: 1, convRule: rule23 },
    { start: 364, length: 1, convRule: rule22 },
    { start: 365, length: 1, convRule: rule23 },
    { start: 366, length: 1, convRule: rule22 },
    { start: 367, length: 1, convRule: rule23 },
    { start: 368, length: 1, convRule: rule22 },
    { start: 369, length: 1, convRule: rule23 },
    { start: 370, length: 1, convRule: rule22 },
    { start: 371, length: 1, convRule: rule23 },
    { start: 372, length: 1, convRule: rule22 },
    { start: 373, length: 1, convRule: rule23 },
    { start: 374, length: 1, convRule: rule22 },
    { start: 375, length: 1, convRule: rule23 },
    { start: 376, length: 1, convRule: rule26 },
    { start: 377, length: 1, convRule: rule22 },
    { start: 378, length: 1, convRule: rule23 },
    { start: 379, length: 1, convRule: rule22 },
    { start: 380, length: 1, convRule: rule23 },
    { start: 381, length: 1, convRule: rule22 },
    { start: 382, length: 1, convRule: rule23 },
    { start: 383, length: 1, convRule: rule27 },
    { start: 384, length: 1, convRule: rule28 },
    { start: 385, length: 1, convRule: rule29 },
    { start: 386, length: 1, convRule: rule22 },
    { start: 387, length: 1, convRule: rule23 },
    { start: 388, length: 1, convRule: rule22 },
    { start: 389, length: 1, convRule: rule23 },
    { start: 390, length: 1, convRule: rule30 },
    { start: 391, length: 1, convRule: rule22 },
    { start: 392, length: 1, convRule: rule23 },
    { start: 393, length: 2, convRule: rule31 },
    { start: 395, length: 1, convRule: rule22 },
    { start: 396, length: 1, convRule: rule23 },
    { start: 398, length: 1, convRule: rule32 },
    { start: 399, length: 1, convRule: rule33 },
    { start: 400, length: 1, convRule: rule34 },
    { start: 401, length: 1, convRule: rule22 },
    { start: 402, length: 1, convRule: rule23 },
    { start: 403, length: 1, convRule: rule31 },
    { start: 404, length: 1, convRule: rule35 },
    { start: 405, length: 1, convRule: rule36 },
    { start: 406, length: 1, convRule: rule37 },
    { start: 407, length: 1, convRule: rule38 },
    { start: 408, length: 1, convRule: rule22 },
    { start: 409, length: 1, convRule: rule23 },
    { start: 410, length: 1, convRule: rule39 },
    { start: 412, length: 1, convRule: rule37 },
    { start: 413, length: 1, convRule: rule40 },
    { start: 414, length: 1, convRule: rule41 },
    { start: 415, length: 1, convRule: rule42 },
    { start: 416, length: 1, convRule: rule22 },
    { start: 417, length: 1, convRule: rule23 },
    { start: 418, length: 1, convRule: rule22 },
    { start: 419, length: 1, convRule: rule23 },
    { start: 420, length: 1, convRule: rule22 },
    { start: 421, length: 1, convRule: rule23 },
    { start: 422, length: 1, convRule: rule43 },
    { start: 423, length: 1, convRule: rule22 },
    { start: 424, length: 1, convRule: rule23 },
    { start: 425, length: 1, convRule: rule43 },
    { start: 428, length: 1, convRule: rule22 },
    { start: 429, length: 1, convRule: rule23 },
    { start: 430, length: 1, convRule: rule43 },
    { start: 431, length: 1, convRule: rule22 },
    { start: 432, length: 1, convRule: rule23 },
    { start: 433, length: 2, convRule: rule44 },
    { start: 435, length: 1, convRule: rule22 },
    { start: 436, length: 1, convRule: rule23 },
    { start: 437, length: 1, convRule: rule22 },
    { start: 438, length: 1, convRule: rule23 },
    { start: 439, length: 1, convRule: rule45 },
    { start: 440, length: 1, convRule: rule22 },
    { start: 441, length: 1, convRule: rule23 },
    { start: 444, length: 1, convRule: rule22 },
    { start: 445, length: 1, convRule: rule23 },
    { start: 447, length: 1, convRule: rule46 },
    { start: 452, length: 1, convRule: rule47 },
    { start: 453, length: 1, convRule: rule48 },
    { start: 454, length: 1, convRule: rule49 },
    { start: 455, length: 1, convRule: rule47 },
    { start: 456, length: 1, convRule: rule48 },
    { start: 457, length: 1, convRule: rule49 },
    { start: 458, length: 1, convRule: rule47 },
    { start: 459, length: 1, convRule: rule48 },
    { start: 460, length: 1, convRule: rule49 },
    { start: 461, length: 1, convRule: rule22 },
    { start: 462, length: 1, convRule: rule23 },
    { start: 463, length: 1, convRule: rule22 },
    { start: 464, length: 1, convRule: rule23 },
    { start: 465, length: 1, convRule: rule22 },
    { start: 466, length: 1, convRule: rule23 },
    { start: 467, length: 1, convRule: rule22 },
    { start: 468, length: 1, convRule: rule23 },
    { start: 469, length: 1, convRule: rule22 },
    { start: 470, length: 1, convRule: rule23 },
    { start: 471, length: 1, convRule: rule22 },
    { start: 472, length: 1, convRule: rule23 },
    { start: 473, length: 1, convRule: rule22 },
    { start: 474, length: 1, convRule: rule23 },
    { start: 475, length: 1, convRule: rule22 },
    { start: 476, length: 1, convRule: rule23 },
    { start: 477, length: 1, convRule: rule50 },
    { start: 478, length: 1, convRule: rule22 },
    { start: 479, length: 1, convRule: rule23 },
    { start: 480, length: 1, convRule: rule22 },
    { start: 481, length: 1, convRule: rule23 },
    { start: 482, length: 1, convRule: rule22 },
    { start: 483, length: 1, convRule: rule23 },
    { start: 484, length: 1, convRule: rule22 },
    { start: 485, length: 1, convRule: rule23 },
    { start: 486, length: 1, convRule: rule22 },
    { start: 487, length: 1, convRule: rule23 },
    { start: 488, length: 1, convRule: rule22 },
    { start: 489, length: 1, convRule: rule23 },
    { start: 490, length: 1, convRule: rule22 },
    { start: 491, length: 1, convRule: rule23 },
    { start: 492, length: 1, convRule: rule22 },
    { start: 493, length: 1, convRule: rule23 },
    { start: 494, length: 1, convRule: rule22 },
    { start: 495, length: 1, convRule: rule23 },
    { start: 497, length: 1, convRule: rule47 },
    { start: 498, length: 1, convRule: rule48 },
    { start: 499, length: 1, convRule: rule49 },
    { start: 500, length: 1, convRule: rule22 },
    { start: 501, length: 1, convRule: rule23 },
    { start: 502, length: 1, convRule: rule51 },
    { start: 503, length: 1, convRule: rule52 },
    { start: 504, length: 1, convRule: rule22 },
    { start: 505, length: 1, convRule: rule23 },
    { start: 506, length: 1, convRule: rule22 },
    { start: 507, length: 1, convRule: rule23 },
    { start: 508, length: 1, convRule: rule22 },
    { start: 509, length: 1, convRule: rule23 },
    { start: 510, length: 1, convRule: rule22 },
    { start: 511, length: 1, convRule: rule23 },
    { start: 512, length: 1, convRule: rule22 },
    { start: 513, length: 1, convRule: rule23 },
    { start: 514, length: 1, convRule: rule22 },
    { start: 515, length: 1, convRule: rule23 },
    { start: 516, length: 1, convRule: rule22 },
    { start: 517, length: 1, convRule: rule23 },
    { start: 518, length: 1, convRule: rule22 },
    { start: 519, length: 1, convRule: rule23 },
    { start: 520, length: 1, convRule: rule22 },
    { start: 521, length: 1, convRule: rule23 },
    { start: 522, length: 1, convRule: rule22 },
    { start: 523, length: 1, convRule: rule23 },
    { start: 524, length: 1, convRule: rule22 },
    { start: 525, length: 1, convRule: rule23 },
    { start: 526, length: 1, convRule: rule22 },
    { start: 527, length: 1, convRule: rule23 },
    { start: 528, length: 1, convRule: rule22 },
    { start: 529, length: 1, convRule: rule23 },
    { start: 530, length: 1, convRule: rule22 },
    { start: 531, length: 1, convRule: rule23 },
    { start: 532, length: 1, convRule: rule22 },
    { start: 533, length: 1, convRule: rule23 },
    { start: 534, length: 1, convRule: rule22 },
    { start: 535, length: 1, convRule: rule23 },
    { start: 536, length: 1, convRule: rule22 },
    { start: 537, length: 1, convRule: rule23 },
    { start: 538, length: 1, convRule: rule22 },
    { start: 539, length: 1, convRule: rule23 },
    { start: 540, length: 1, convRule: rule22 },
    { start: 541, length: 1, convRule: rule23 },
    { start: 542, length: 1, convRule: rule22 },
    { start: 543, length: 1, convRule: rule23 },
    { start: 544, length: 1, convRule: rule53 },
    { start: 546, length: 1, convRule: rule22 },
    { start: 547, length: 1, convRule: rule23 },
    { start: 548, length: 1, convRule: rule22 },
    { start: 549, length: 1, convRule: rule23 },
    { start: 550, length: 1, convRule: rule22 },
    { start: 551, length: 1, convRule: rule23 },
    { start: 552, length: 1, convRule: rule22 },
    { start: 553, length: 1, convRule: rule23 },
    { start: 554, length: 1, convRule: rule22 },
    { start: 555, length: 1, convRule: rule23 },
    { start: 556, length: 1, convRule: rule22 },
    { start: 557, length: 1, convRule: rule23 },
    { start: 558, length: 1, convRule: rule22 },
    { start: 559, length: 1, convRule: rule23 },
    { start: 560, length: 1, convRule: rule22 },
    { start: 561, length: 1, convRule: rule23 },
    { start: 562, length: 1, convRule: rule22 },
    { start: 563, length: 1, convRule: rule23 },
    { start: 570, length: 1, convRule: rule54 },
    { start: 571, length: 1, convRule: rule22 },
    { start: 572, length: 1, convRule: rule23 },
    { start: 573, length: 1, convRule: rule55 },
    { start: 574, length: 1, convRule: rule56 },
    { start: 575, length: 2, convRule: rule57 },
    { start: 577, length: 1, convRule: rule22 },
    { start: 578, length: 1, convRule: rule23 },
    { start: 579, length: 1, convRule: rule58 },
    { start: 580, length: 1, convRule: rule59 },
    { start: 581, length: 1, convRule: rule60 },
    { start: 582, length: 1, convRule: rule22 },
    { start: 583, length: 1, convRule: rule23 },
    { start: 584, length: 1, convRule: rule22 },
    { start: 585, length: 1, convRule: rule23 },
    { start: 586, length: 1, convRule: rule22 },
    { start: 587, length: 1, convRule: rule23 },
    { start: 588, length: 1, convRule: rule22 },
    { start: 589, length: 1, convRule: rule23 },
    { start: 590, length: 1, convRule: rule22 },
    { start: 591, length: 1, convRule: rule23 },
    { start: 592, length: 1, convRule: rule61 },
    { start: 593, length: 1, convRule: rule62 },
    { start: 594, length: 1, convRule: rule63 },
    { start: 595, length: 1, convRule: rule64 },
    { start: 596, length: 1, convRule: rule65 },
    { start: 598, length: 2, convRule: rule66 },
    { start: 601, length: 1, convRule: rule67 },
    { start: 603, length: 1, convRule: rule68 },
    { start: 604, length: 1, convRule: rule69 },
    { start: 608, length: 1, convRule: rule66 },
    { start: 609, length: 1, convRule: rule70 },
    { start: 611, length: 1, convRule: rule71 },
    { start: 613, length: 1, convRule: rule72 },
    { start: 614, length: 1, convRule: rule73 },
    { start: 616, length: 1, convRule: rule74 },
    { start: 617, length: 1, convRule: rule75 },
    { start: 618, length: 1, convRule: rule73 },
    { start: 619, length: 1, convRule: rule76 },
    { start: 620, length: 1, convRule: rule77 },
    { start: 623, length: 1, convRule: rule75 },
    { start: 625, length: 1, convRule: rule78 },
    { start: 626, length: 1, convRule: rule79 },
    { start: 629, length: 1, convRule: rule80 },
    { start: 637, length: 1, convRule: rule81 },
    { start: 640, length: 1, convRule: rule82 },
    { start: 642, length: 1, convRule: rule83 },
    { start: 643, length: 1, convRule: rule82 },
    { start: 647, length: 1, convRule: rule84 },
    { start: 648, length: 1, convRule: rule82 },
    { start: 649, length: 1, convRule: rule85 },
    { start: 650, length: 2, convRule: rule86 },
    { start: 652, length: 1, convRule: rule87 },
    { start: 658, length: 1, convRule: rule88 },
    { start: 669, length: 1, convRule: rule89 },
    { start: 670, length: 1, convRule: rule90 },
    { start: 837, length: 1, convRule: rule93 },
    { start: 880, length: 1, convRule: rule22 },
    { start: 881, length: 1, convRule: rule23 },
    { start: 882, length: 1, convRule: rule22 },
    { start: 883, length: 1, convRule: rule23 },
    { start: 886, length: 1, convRule: rule22 },
    { start: 887, length: 1, convRule: rule23 },
    { start: 891, length: 3, convRule: rule41 },
    { start: 895, length: 1, convRule: rule94 },
    { start: 902, length: 1, convRule: rule95 },
    { start: 904, length: 3, convRule: rule96 },
    { start: 908, length: 1, convRule: rule97 },
    { start: 910, length: 2, convRule: rule98 },
    { start: 913, length: 17, convRule: rule9 },
    { start: 931, length: 9, convRule: rule9 },
    { start: 940, length: 1, convRule: rule99 },
    { start: 941, length: 3, convRule: rule100 },
    { start: 945, length: 17, convRule: rule12 },
    { start: 962, length: 1, convRule: rule101 },
    { start: 963, length: 9, convRule: rule12 },
    { start: 972, length: 1, convRule: rule102 },
    { start: 973, length: 2, convRule: rule103 },
    { start: 975, length: 1, convRule: rule104 },
    { start: 976, length: 1, convRule: rule105 },
    { start: 977, length: 1, convRule: rule106 },
    { start: 981, length: 1, convRule: rule108 },
    { start: 982, length: 1, convRule: rule109 },
    { start: 983, length: 1, convRule: rule110 },
    { start: 984, length: 1, convRule: rule22 },
    { start: 985, length: 1, convRule: rule23 },
    { start: 986, length: 1, convRule: rule22 },
    { start: 987, length: 1, convRule: rule23 },
    { start: 988, length: 1, convRule: rule22 },
    { start: 989, length: 1, convRule: rule23 },
    { start: 990, length: 1, convRule: rule22 },
    { start: 991, length: 1, convRule: rule23 },
    { start: 992, length: 1, convRule: rule22 },
    { start: 993, length: 1, convRule: rule23 },
    { start: 994, length: 1, convRule: rule22 },
    { start: 995, length: 1, convRule: rule23 },
    { start: 996, length: 1, convRule: rule22 },
    { start: 997, length: 1, convRule: rule23 },
    { start: 998, length: 1, convRule: rule22 },
    { start: 999, length: 1, convRule: rule23 },
    { start: 1e3, length: 1, convRule: rule22 },
    { start: 1001, length: 1, convRule: rule23 },
    { start: 1002, length: 1, convRule: rule22 },
    { start: 1003, length: 1, convRule: rule23 },
    { start: 1004, length: 1, convRule: rule22 },
    { start: 1005, length: 1, convRule: rule23 },
    { start: 1006, length: 1, convRule: rule22 },
    { start: 1007, length: 1, convRule: rule23 },
    { start: 1008, length: 1, convRule: rule111 },
    { start: 1009, length: 1, convRule: rule112 },
    { start: 1010, length: 1, convRule: rule113 },
    { start: 1011, length: 1, convRule: rule114 },
    { start: 1012, length: 1, convRule: rule115 },
    { start: 1013, length: 1, convRule: rule116 },
    { start: 1015, length: 1, convRule: rule22 },
    { start: 1016, length: 1, convRule: rule23 },
    { start: 1017, length: 1, convRule: rule117 },
    { start: 1018, length: 1, convRule: rule22 },
    { start: 1019, length: 1, convRule: rule23 },
    { start: 1021, length: 3, convRule: rule53 },
    { start: 1024, length: 16, convRule: rule118 },
    { start: 1040, length: 32, convRule: rule9 },
    { start: 1072, length: 32, convRule: rule12 },
    { start: 1104, length: 16, convRule: rule112 },
    { start: 1120, length: 1, convRule: rule22 },
    { start: 1121, length: 1, convRule: rule23 },
    { start: 1122, length: 1, convRule: rule22 },
    { start: 1123, length: 1, convRule: rule23 },
    { start: 1124, length: 1, convRule: rule22 },
    { start: 1125, length: 1, convRule: rule23 },
    { start: 1126, length: 1, convRule: rule22 },
    { start: 1127, length: 1, convRule: rule23 },
    { start: 1128, length: 1, convRule: rule22 },
    { start: 1129, length: 1, convRule: rule23 },
    { start: 1130, length: 1, convRule: rule22 },
    { start: 1131, length: 1, convRule: rule23 },
    { start: 1132, length: 1, convRule: rule22 },
    { start: 1133, length: 1, convRule: rule23 },
    { start: 1134, length: 1, convRule: rule22 },
    { start: 1135, length: 1, convRule: rule23 },
    { start: 1136, length: 1, convRule: rule22 },
    { start: 1137, length: 1, convRule: rule23 },
    { start: 1138, length: 1, convRule: rule22 },
    { start: 1139, length: 1, convRule: rule23 },
    { start: 1140, length: 1, convRule: rule22 },
    { start: 1141, length: 1, convRule: rule23 },
    { start: 1142, length: 1, convRule: rule22 },
    { start: 1143, length: 1, convRule: rule23 },
    { start: 1144, length: 1, convRule: rule22 },
    { start: 1145, length: 1, convRule: rule23 },
    { start: 1146, length: 1, convRule: rule22 },
    { start: 1147, length: 1, convRule: rule23 },
    { start: 1148, length: 1, convRule: rule22 },
    { start: 1149, length: 1, convRule: rule23 },
    { start: 1150, length: 1, convRule: rule22 },
    { start: 1151, length: 1, convRule: rule23 },
    { start: 1152, length: 1, convRule: rule22 },
    { start: 1153, length: 1, convRule: rule23 },
    { start: 1162, length: 1, convRule: rule22 },
    { start: 1163, length: 1, convRule: rule23 },
    { start: 1164, length: 1, convRule: rule22 },
    { start: 1165, length: 1, convRule: rule23 },
    { start: 1166, length: 1, convRule: rule22 },
    { start: 1167, length: 1, convRule: rule23 },
    { start: 1168, length: 1, convRule: rule22 },
    { start: 1169, length: 1, convRule: rule23 },
    { start: 1170, length: 1, convRule: rule22 },
    { start: 1171, length: 1, convRule: rule23 },
    { start: 1172, length: 1, convRule: rule22 },
    { start: 1173, length: 1, convRule: rule23 },
    { start: 1174, length: 1, convRule: rule22 },
    { start: 1175, length: 1, convRule: rule23 },
    { start: 1176, length: 1, convRule: rule22 },
    { start: 1177, length: 1, convRule: rule23 },
    { start: 1178, length: 1, convRule: rule22 },
    { start: 1179, length: 1, convRule: rule23 },
    { start: 1180, length: 1, convRule: rule22 },
    { start: 1181, length: 1, convRule: rule23 },
    { start: 1182, length: 1, convRule: rule22 },
    { start: 1183, length: 1, convRule: rule23 },
    { start: 1184, length: 1, convRule: rule22 },
    { start: 1185, length: 1, convRule: rule23 },
    { start: 1186, length: 1, convRule: rule22 },
    { start: 1187, length: 1, convRule: rule23 },
    { start: 1188, length: 1, convRule: rule22 },
    { start: 1189, length: 1, convRule: rule23 },
    { start: 1190, length: 1, convRule: rule22 },
    { start: 1191, length: 1, convRule: rule23 },
    { start: 1192, length: 1, convRule: rule22 },
    { start: 1193, length: 1, convRule: rule23 },
    { start: 1194, length: 1, convRule: rule22 },
    { start: 1195, length: 1, convRule: rule23 },
    { start: 1196, length: 1, convRule: rule22 },
    { start: 1197, length: 1, convRule: rule23 },
    { start: 1198, length: 1, convRule: rule22 },
    { start: 1199, length: 1, convRule: rule23 },
    { start: 1200, length: 1, convRule: rule22 },
    { start: 1201, length: 1, convRule: rule23 },
    { start: 1202, length: 1, convRule: rule22 },
    { start: 1203, length: 1, convRule: rule23 },
    { start: 1204, length: 1, convRule: rule22 },
    { start: 1205, length: 1, convRule: rule23 },
    { start: 1206, length: 1, convRule: rule22 },
    { start: 1207, length: 1, convRule: rule23 },
    { start: 1208, length: 1, convRule: rule22 },
    { start: 1209, length: 1, convRule: rule23 },
    { start: 1210, length: 1, convRule: rule22 },
    { start: 1211, length: 1, convRule: rule23 },
    { start: 1212, length: 1, convRule: rule22 },
    { start: 1213, length: 1, convRule: rule23 },
    { start: 1214, length: 1, convRule: rule22 },
    { start: 1215, length: 1, convRule: rule23 },
    { start: 1216, length: 1, convRule: rule120 },
    { start: 1217, length: 1, convRule: rule22 },
    { start: 1218, length: 1, convRule: rule23 },
    { start: 1219, length: 1, convRule: rule22 },
    { start: 1220, length: 1, convRule: rule23 },
    { start: 1221, length: 1, convRule: rule22 },
    { start: 1222, length: 1, convRule: rule23 },
    { start: 1223, length: 1, convRule: rule22 },
    { start: 1224, length: 1, convRule: rule23 },
    { start: 1225, length: 1, convRule: rule22 },
    { start: 1226, length: 1, convRule: rule23 },
    { start: 1227, length: 1, convRule: rule22 },
    { start: 1228, length: 1, convRule: rule23 },
    { start: 1229, length: 1, convRule: rule22 },
    { start: 1230, length: 1, convRule: rule23 },
    { start: 1231, length: 1, convRule: rule121 },
    { start: 1232, length: 1, convRule: rule22 },
    { start: 1233, length: 1, convRule: rule23 },
    { start: 1234, length: 1, convRule: rule22 },
    { start: 1235, length: 1, convRule: rule23 },
    { start: 1236, length: 1, convRule: rule22 },
    { start: 1237, length: 1, convRule: rule23 },
    { start: 1238, length: 1, convRule: rule22 },
    { start: 1239, length: 1, convRule: rule23 },
    { start: 1240, length: 1, convRule: rule22 },
    { start: 1241, length: 1, convRule: rule23 },
    { start: 1242, length: 1, convRule: rule22 },
    { start: 1243, length: 1, convRule: rule23 },
    { start: 1244, length: 1, convRule: rule22 },
    { start: 1245, length: 1, convRule: rule23 },
    { start: 1246, length: 1, convRule: rule22 },
    { start: 1247, length: 1, convRule: rule23 },
    { start: 1248, length: 1, convRule: rule22 },
    { start: 1249, length: 1, convRule: rule23 },
    { start: 1250, length: 1, convRule: rule22 },
    { start: 1251, length: 1, convRule: rule23 },
    { start: 1252, length: 1, convRule: rule22 },
    { start: 1253, length: 1, convRule: rule23 },
    { start: 1254, length: 1, convRule: rule22 },
    { start: 1255, length: 1, convRule: rule23 },
    { start: 1256, length: 1, convRule: rule22 },
    { start: 1257, length: 1, convRule: rule23 },
    { start: 1258, length: 1, convRule: rule22 },
    { start: 1259, length: 1, convRule: rule23 },
    { start: 1260, length: 1, convRule: rule22 },
    { start: 1261, length: 1, convRule: rule23 },
    { start: 1262, length: 1, convRule: rule22 },
    { start: 1263, length: 1, convRule: rule23 },
    { start: 1264, length: 1, convRule: rule22 },
    { start: 1265, length: 1, convRule: rule23 },
    { start: 1266, length: 1, convRule: rule22 },
    { start: 1267, length: 1, convRule: rule23 },
    { start: 1268, length: 1, convRule: rule22 },
    { start: 1269, length: 1, convRule: rule23 },
    { start: 1270, length: 1, convRule: rule22 },
    { start: 1271, length: 1, convRule: rule23 },
    { start: 1272, length: 1, convRule: rule22 },
    { start: 1273, length: 1, convRule: rule23 },
    { start: 1274, length: 1, convRule: rule22 },
    { start: 1275, length: 1, convRule: rule23 },
    { start: 1276, length: 1, convRule: rule22 },
    { start: 1277, length: 1, convRule: rule23 },
    { start: 1278, length: 1, convRule: rule22 },
    { start: 1279, length: 1, convRule: rule23 },
    { start: 1280, length: 1, convRule: rule22 },
    { start: 1281, length: 1, convRule: rule23 },
    { start: 1282, length: 1, convRule: rule22 },
    { start: 1283, length: 1, convRule: rule23 },
    { start: 1284, length: 1, convRule: rule22 },
    { start: 1285, length: 1, convRule: rule23 },
    { start: 1286, length: 1, convRule: rule22 },
    { start: 1287, length: 1, convRule: rule23 },
    { start: 1288, length: 1, convRule: rule22 },
    { start: 1289, length: 1, convRule: rule23 },
    { start: 1290, length: 1, convRule: rule22 },
    { start: 1291, length: 1, convRule: rule23 },
    { start: 1292, length: 1, convRule: rule22 },
    { start: 1293, length: 1, convRule: rule23 },
    { start: 1294, length: 1, convRule: rule22 },
    { start: 1295, length: 1, convRule: rule23 },
    { start: 1296, length: 1, convRule: rule22 },
    { start: 1297, length: 1, convRule: rule23 },
    { start: 1298, length: 1, convRule: rule22 },
    { start: 1299, length: 1, convRule: rule23 },
    { start: 1300, length: 1, convRule: rule22 },
    { start: 1301, length: 1, convRule: rule23 },
    { start: 1302, length: 1, convRule: rule22 },
    { start: 1303, length: 1, convRule: rule23 },
    { start: 1304, length: 1, convRule: rule22 },
    { start: 1305, length: 1, convRule: rule23 },
    { start: 1306, length: 1, convRule: rule22 },
    { start: 1307, length: 1, convRule: rule23 },
    { start: 1308, length: 1, convRule: rule22 },
    { start: 1309, length: 1, convRule: rule23 },
    { start: 1310, length: 1, convRule: rule22 },
    { start: 1311, length: 1, convRule: rule23 },
    { start: 1312, length: 1, convRule: rule22 },
    { start: 1313, length: 1, convRule: rule23 },
    { start: 1314, length: 1, convRule: rule22 },
    { start: 1315, length: 1, convRule: rule23 },
    { start: 1316, length: 1, convRule: rule22 },
    { start: 1317, length: 1, convRule: rule23 },
    { start: 1318, length: 1, convRule: rule22 },
    { start: 1319, length: 1, convRule: rule23 },
    { start: 1320, length: 1, convRule: rule22 },
    { start: 1321, length: 1, convRule: rule23 },
    { start: 1322, length: 1, convRule: rule22 },
    { start: 1323, length: 1, convRule: rule23 },
    { start: 1324, length: 1, convRule: rule22 },
    { start: 1325, length: 1, convRule: rule23 },
    { start: 1326, length: 1, convRule: rule22 },
    { start: 1327, length: 1, convRule: rule23 },
    { start: 1329, length: 38, convRule: rule122 },
    { start: 1377, length: 38, convRule: rule123 },
    { start: 4256, length: 38, convRule: rule125 },
    { start: 4295, length: 1, convRule: rule125 },
    { start: 4301, length: 1, convRule: rule125 },
    { start: 4304, length: 43, convRule: rule126 },
    { start: 4349, length: 3, convRule: rule126 },
    { start: 5024, length: 80, convRule: rule127 },
    { start: 5104, length: 6, convRule: rule104 },
    { start: 5112, length: 6, convRule: rule110 },
    { start: 7296, length: 1, convRule: rule129 },
    { start: 7297, length: 1, convRule: rule130 },
    { start: 7298, length: 1, convRule: rule131 },
    { start: 7299, length: 2, convRule: rule132 },
    { start: 7301, length: 1, convRule: rule133 },
    { start: 7302, length: 1, convRule: rule134 },
    { start: 7303, length: 1, convRule: rule135 },
    { start: 7304, length: 1, convRule: rule136 },
    { start: 7312, length: 43, convRule: rule137 },
    { start: 7357, length: 3, convRule: rule137 },
    { start: 7545, length: 1, convRule: rule138 },
    { start: 7549, length: 1, convRule: rule139 },
    { start: 7566, length: 1, convRule: rule140 },
    { start: 7680, length: 1, convRule: rule22 },
    { start: 7681, length: 1, convRule: rule23 },
    { start: 7682, length: 1, convRule: rule22 },
    { start: 7683, length: 1, convRule: rule23 },
    { start: 7684, length: 1, convRule: rule22 },
    { start: 7685, length: 1, convRule: rule23 },
    { start: 7686, length: 1, convRule: rule22 },
    { start: 7687, length: 1, convRule: rule23 },
    { start: 7688, length: 1, convRule: rule22 },
    { start: 7689, length: 1, convRule: rule23 },
    { start: 7690, length: 1, convRule: rule22 },
    { start: 7691, length: 1, convRule: rule23 },
    { start: 7692, length: 1, convRule: rule22 },
    { start: 7693, length: 1, convRule: rule23 },
    { start: 7694, length: 1, convRule: rule22 },
    { start: 7695, length: 1, convRule: rule23 },
    { start: 7696, length: 1, convRule: rule22 },
    { start: 7697, length: 1, convRule: rule23 },
    { start: 7698, length: 1, convRule: rule22 },
    { start: 7699, length: 1, convRule: rule23 },
    { start: 7700, length: 1, convRule: rule22 },
    { start: 7701, length: 1, convRule: rule23 },
    { start: 7702, length: 1, convRule: rule22 },
    { start: 7703, length: 1, convRule: rule23 },
    { start: 7704, length: 1, convRule: rule22 },
    { start: 7705, length: 1, convRule: rule23 },
    { start: 7706, length: 1, convRule: rule22 },
    { start: 7707, length: 1, convRule: rule23 },
    { start: 7708, length: 1, convRule: rule22 },
    { start: 7709, length: 1, convRule: rule23 },
    { start: 7710, length: 1, convRule: rule22 },
    { start: 7711, length: 1, convRule: rule23 },
    { start: 7712, length: 1, convRule: rule22 },
    { start: 7713, length: 1, convRule: rule23 },
    { start: 7714, length: 1, convRule: rule22 },
    { start: 7715, length: 1, convRule: rule23 },
    { start: 7716, length: 1, convRule: rule22 },
    { start: 7717, length: 1, convRule: rule23 },
    { start: 7718, length: 1, convRule: rule22 },
    { start: 7719, length: 1, convRule: rule23 },
    { start: 7720, length: 1, convRule: rule22 },
    { start: 7721, length: 1, convRule: rule23 },
    { start: 7722, length: 1, convRule: rule22 },
    { start: 7723, length: 1, convRule: rule23 },
    { start: 7724, length: 1, convRule: rule22 },
    { start: 7725, length: 1, convRule: rule23 },
    { start: 7726, length: 1, convRule: rule22 },
    { start: 7727, length: 1, convRule: rule23 },
    { start: 7728, length: 1, convRule: rule22 },
    { start: 7729, length: 1, convRule: rule23 },
    { start: 7730, length: 1, convRule: rule22 },
    { start: 7731, length: 1, convRule: rule23 },
    { start: 7732, length: 1, convRule: rule22 },
    { start: 7733, length: 1, convRule: rule23 },
    { start: 7734, length: 1, convRule: rule22 },
    { start: 7735, length: 1, convRule: rule23 },
    { start: 7736, length: 1, convRule: rule22 },
    { start: 7737, length: 1, convRule: rule23 },
    { start: 7738, length: 1, convRule: rule22 },
    { start: 7739, length: 1, convRule: rule23 },
    { start: 7740, length: 1, convRule: rule22 },
    { start: 7741, length: 1, convRule: rule23 },
    { start: 7742, length: 1, convRule: rule22 },
    { start: 7743, length: 1, convRule: rule23 },
    { start: 7744, length: 1, convRule: rule22 },
    { start: 7745, length: 1, convRule: rule23 },
    { start: 7746, length: 1, convRule: rule22 },
    { start: 7747, length: 1, convRule: rule23 },
    { start: 7748, length: 1, convRule: rule22 },
    { start: 7749, length: 1, convRule: rule23 },
    { start: 7750, length: 1, convRule: rule22 },
    { start: 7751, length: 1, convRule: rule23 },
    { start: 7752, length: 1, convRule: rule22 },
    { start: 7753, length: 1, convRule: rule23 },
    { start: 7754, length: 1, convRule: rule22 },
    { start: 7755, length: 1, convRule: rule23 },
    { start: 7756, length: 1, convRule: rule22 },
    { start: 7757, length: 1, convRule: rule23 },
    { start: 7758, length: 1, convRule: rule22 },
    { start: 7759, length: 1, convRule: rule23 },
    { start: 7760, length: 1, convRule: rule22 },
    { start: 7761, length: 1, convRule: rule23 },
    { start: 7762, length: 1, convRule: rule22 },
    { start: 7763, length: 1, convRule: rule23 },
    { start: 7764, length: 1, convRule: rule22 },
    { start: 7765, length: 1, convRule: rule23 },
    { start: 7766, length: 1, convRule: rule22 },
    { start: 7767, length: 1, convRule: rule23 },
    { start: 7768, length: 1, convRule: rule22 },
    { start: 7769, length: 1, convRule: rule23 },
    { start: 7770, length: 1, convRule: rule22 },
    { start: 7771, length: 1, convRule: rule23 },
    { start: 7772, length: 1, convRule: rule22 },
    { start: 7773, length: 1, convRule: rule23 },
    { start: 7774, length: 1, convRule: rule22 },
    { start: 7775, length: 1, convRule: rule23 },
    { start: 7776, length: 1, convRule: rule22 },
    { start: 7777, length: 1, convRule: rule23 },
    { start: 7778, length: 1, convRule: rule22 },
    { start: 7779, length: 1, convRule: rule23 },
    { start: 7780, length: 1, convRule: rule22 },
    { start: 7781, length: 1, convRule: rule23 },
    { start: 7782, length: 1, convRule: rule22 },
    { start: 7783, length: 1, convRule: rule23 },
    { start: 7784, length: 1, convRule: rule22 },
    { start: 7785, length: 1, convRule: rule23 },
    { start: 7786, length: 1, convRule: rule22 },
    { start: 7787, length: 1, convRule: rule23 },
    { start: 7788, length: 1, convRule: rule22 },
    { start: 7789, length: 1, convRule: rule23 },
    { start: 7790, length: 1, convRule: rule22 },
    { start: 7791, length: 1, convRule: rule23 },
    { start: 7792, length: 1, convRule: rule22 },
    { start: 7793, length: 1, convRule: rule23 },
    { start: 7794, length: 1, convRule: rule22 },
    { start: 7795, length: 1, convRule: rule23 },
    { start: 7796, length: 1, convRule: rule22 },
    { start: 7797, length: 1, convRule: rule23 },
    { start: 7798, length: 1, convRule: rule22 },
    { start: 7799, length: 1, convRule: rule23 },
    { start: 7800, length: 1, convRule: rule22 },
    { start: 7801, length: 1, convRule: rule23 },
    { start: 7802, length: 1, convRule: rule22 },
    { start: 7803, length: 1, convRule: rule23 },
    { start: 7804, length: 1, convRule: rule22 },
    { start: 7805, length: 1, convRule: rule23 },
    { start: 7806, length: 1, convRule: rule22 },
    { start: 7807, length: 1, convRule: rule23 },
    { start: 7808, length: 1, convRule: rule22 },
    { start: 7809, length: 1, convRule: rule23 },
    { start: 7810, length: 1, convRule: rule22 },
    { start: 7811, length: 1, convRule: rule23 },
    { start: 7812, length: 1, convRule: rule22 },
    { start: 7813, length: 1, convRule: rule23 },
    { start: 7814, length: 1, convRule: rule22 },
    { start: 7815, length: 1, convRule: rule23 },
    { start: 7816, length: 1, convRule: rule22 },
    { start: 7817, length: 1, convRule: rule23 },
    { start: 7818, length: 1, convRule: rule22 },
    { start: 7819, length: 1, convRule: rule23 },
    { start: 7820, length: 1, convRule: rule22 },
    { start: 7821, length: 1, convRule: rule23 },
    { start: 7822, length: 1, convRule: rule22 },
    { start: 7823, length: 1, convRule: rule23 },
    { start: 7824, length: 1, convRule: rule22 },
    { start: 7825, length: 1, convRule: rule23 },
    { start: 7826, length: 1, convRule: rule22 },
    { start: 7827, length: 1, convRule: rule23 },
    { start: 7828, length: 1, convRule: rule22 },
    { start: 7829, length: 1, convRule: rule23 },
    { start: 7835, length: 1, convRule: rule141 },
    { start: 7838, length: 1, convRule: rule142 },
    { start: 7840, length: 1, convRule: rule22 },
    { start: 7841, length: 1, convRule: rule23 },
    { start: 7842, length: 1, convRule: rule22 },
    { start: 7843, length: 1, convRule: rule23 },
    { start: 7844, length: 1, convRule: rule22 },
    { start: 7845, length: 1, convRule: rule23 },
    { start: 7846, length: 1, convRule: rule22 },
    { start: 7847, length: 1, convRule: rule23 },
    { start: 7848, length: 1, convRule: rule22 },
    { start: 7849, length: 1, convRule: rule23 },
    { start: 7850, length: 1, convRule: rule22 },
    { start: 7851, length: 1, convRule: rule23 },
    { start: 7852, length: 1, convRule: rule22 },
    { start: 7853, length: 1, convRule: rule23 },
    { start: 7854, length: 1, convRule: rule22 },
    { start: 7855, length: 1, convRule: rule23 },
    { start: 7856, length: 1, convRule: rule22 },
    { start: 7857, length: 1, convRule: rule23 },
    { start: 7858, length: 1, convRule: rule22 },
    { start: 7859, length: 1, convRule: rule23 },
    { start: 7860, length: 1, convRule: rule22 },
    { start: 7861, length: 1, convRule: rule23 },
    { start: 7862, length: 1, convRule: rule22 },
    { start: 7863, length: 1, convRule: rule23 },
    { start: 7864, length: 1, convRule: rule22 },
    { start: 7865, length: 1, convRule: rule23 },
    { start: 7866, length: 1, convRule: rule22 },
    { start: 7867, length: 1, convRule: rule23 },
    { start: 7868, length: 1, convRule: rule22 },
    { start: 7869, length: 1, convRule: rule23 },
    { start: 7870, length: 1, convRule: rule22 },
    { start: 7871, length: 1, convRule: rule23 },
    { start: 7872, length: 1, convRule: rule22 },
    { start: 7873, length: 1, convRule: rule23 },
    { start: 7874, length: 1, convRule: rule22 },
    { start: 7875, length: 1, convRule: rule23 },
    { start: 7876, length: 1, convRule: rule22 },
    { start: 7877, length: 1, convRule: rule23 },
    { start: 7878, length: 1, convRule: rule22 },
    { start: 7879, length: 1, convRule: rule23 },
    { start: 7880, length: 1, convRule: rule22 },
    { start: 7881, length: 1, convRule: rule23 },
    { start: 7882, length: 1, convRule: rule22 },
    { start: 7883, length: 1, convRule: rule23 },
    { start: 7884, length: 1, convRule: rule22 },
    { start: 7885, length: 1, convRule: rule23 },
    { start: 7886, length: 1, convRule: rule22 },
    { start: 7887, length: 1, convRule: rule23 },
    { start: 7888, length: 1, convRule: rule22 },
    { start: 7889, length: 1, convRule: rule23 },
    { start: 7890, length: 1, convRule: rule22 },
    { start: 7891, length: 1, convRule: rule23 },
    { start: 7892, length: 1, convRule: rule22 },
    { start: 7893, length: 1, convRule: rule23 },
    { start: 7894, length: 1, convRule: rule22 },
    { start: 7895, length: 1, convRule: rule23 },
    { start: 7896, length: 1, convRule: rule22 },
    { start: 7897, length: 1, convRule: rule23 },
    { start: 7898, length: 1, convRule: rule22 },
    { start: 7899, length: 1, convRule: rule23 },
    { start: 7900, length: 1, convRule: rule22 },
    { start: 7901, length: 1, convRule: rule23 },
    { start: 7902, length: 1, convRule: rule22 },
    { start: 7903, length: 1, convRule: rule23 },
    { start: 7904, length: 1, convRule: rule22 },
    { start: 7905, length: 1, convRule: rule23 },
    { start: 7906, length: 1, convRule: rule22 },
    { start: 7907, length: 1, convRule: rule23 },
    { start: 7908, length: 1, convRule: rule22 },
    { start: 7909, length: 1, convRule: rule23 },
    { start: 7910, length: 1, convRule: rule22 },
    { start: 7911, length: 1, convRule: rule23 },
    { start: 7912, length: 1, convRule: rule22 },
    { start: 7913, length: 1, convRule: rule23 },
    { start: 7914, length: 1, convRule: rule22 },
    { start: 7915, length: 1, convRule: rule23 },
    { start: 7916, length: 1, convRule: rule22 },
    { start: 7917, length: 1, convRule: rule23 },
    { start: 7918, length: 1, convRule: rule22 },
    { start: 7919, length: 1, convRule: rule23 },
    { start: 7920, length: 1, convRule: rule22 },
    { start: 7921, length: 1, convRule: rule23 },
    { start: 7922, length: 1, convRule: rule22 },
    { start: 7923, length: 1, convRule: rule23 },
    { start: 7924, length: 1, convRule: rule22 },
    { start: 7925, length: 1, convRule: rule23 },
    { start: 7926, length: 1, convRule: rule22 },
    { start: 7927, length: 1, convRule: rule23 },
    { start: 7928, length: 1, convRule: rule22 },
    { start: 7929, length: 1, convRule: rule23 },
    { start: 7930, length: 1, convRule: rule22 },
    { start: 7931, length: 1, convRule: rule23 },
    { start: 7932, length: 1, convRule: rule22 },
    { start: 7933, length: 1, convRule: rule23 },
    { start: 7934, length: 1, convRule: rule22 },
    { start: 7935, length: 1, convRule: rule23 },
    { start: 7936, length: 8, convRule: rule143 },
    { start: 7944, length: 8, convRule: rule144 },
    { start: 7952, length: 6, convRule: rule143 },
    { start: 7960, length: 6, convRule: rule144 },
    { start: 7968, length: 8, convRule: rule143 },
    { start: 7976, length: 8, convRule: rule144 },
    { start: 7984, length: 8, convRule: rule143 },
    { start: 7992, length: 8, convRule: rule144 },
    { start: 8e3, length: 6, convRule: rule143 },
    { start: 8008, length: 6, convRule: rule144 },
    { start: 8017, length: 1, convRule: rule143 },
    { start: 8019, length: 1, convRule: rule143 },
    { start: 8021, length: 1, convRule: rule143 },
    { start: 8023, length: 1, convRule: rule143 },
    { start: 8025, length: 1, convRule: rule144 },
    { start: 8027, length: 1, convRule: rule144 },
    { start: 8029, length: 1, convRule: rule144 },
    { start: 8031, length: 1, convRule: rule144 },
    { start: 8032, length: 8, convRule: rule143 },
    { start: 8040, length: 8, convRule: rule144 },
    { start: 8048, length: 2, convRule: rule145 },
    { start: 8050, length: 4, convRule: rule146 },
    { start: 8054, length: 2, convRule: rule147 },
    { start: 8056, length: 2, convRule: rule148 },
    { start: 8058, length: 2, convRule: rule149 },
    { start: 8060, length: 2, convRule: rule150 },
    { start: 8064, length: 8, convRule: rule143 },
    { start: 8072, length: 8, convRule: rule151 },
    { start: 8080, length: 8, convRule: rule143 },
    { start: 8088, length: 8, convRule: rule151 },
    { start: 8096, length: 8, convRule: rule143 },
    { start: 8104, length: 8, convRule: rule151 },
    { start: 8112, length: 2, convRule: rule143 },
    { start: 8115, length: 1, convRule: rule152 },
    { start: 8120, length: 2, convRule: rule144 },
    { start: 8122, length: 2, convRule: rule153 },
    { start: 8124, length: 1, convRule: rule154 },
    { start: 8126, length: 1, convRule: rule155 },
    { start: 8131, length: 1, convRule: rule152 },
    { start: 8136, length: 4, convRule: rule156 },
    { start: 8140, length: 1, convRule: rule154 },
    { start: 8144, length: 2, convRule: rule143 },
    { start: 8152, length: 2, convRule: rule144 },
    { start: 8154, length: 2, convRule: rule157 },
    { start: 8160, length: 2, convRule: rule143 },
    { start: 8165, length: 1, convRule: rule113 },
    { start: 8168, length: 2, convRule: rule144 },
    { start: 8170, length: 2, convRule: rule158 },
    { start: 8172, length: 1, convRule: rule117 },
    { start: 8179, length: 1, convRule: rule152 },
    { start: 8184, length: 2, convRule: rule159 },
    { start: 8186, length: 2, convRule: rule160 },
    { start: 8188, length: 1, convRule: rule154 },
    { start: 8486, length: 1, convRule: rule163 },
    { start: 8490, length: 1, convRule: rule164 },
    { start: 8491, length: 1, convRule: rule165 },
    { start: 8498, length: 1, convRule: rule166 },
    { start: 8526, length: 1, convRule: rule167 },
    { start: 8544, length: 16, convRule: rule168 },
    { start: 8560, length: 16, convRule: rule169 },
    { start: 8579, length: 1, convRule: rule22 },
    { start: 8580, length: 1, convRule: rule23 },
    { start: 9398, length: 26, convRule: rule170 },
    { start: 9424, length: 26, convRule: rule171 },
    { start: 11264, length: 47, convRule: rule122 },
    { start: 11312, length: 47, convRule: rule123 },
    { start: 11360, length: 1, convRule: rule22 },
    { start: 11361, length: 1, convRule: rule23 },
    { start: 11362, length: 1, convRule: rule172 },
    { start: 11363, length: 1, convRule: rule173 },
    { start: 11364, length: 1, convRule: rule174 },
    { start: 11365, length: 1, convRule: rule175 },
    { start: 11366, length: 1, convRule: rule176 },
    { start: 11367, length: 1, convRule: rule22 },
    { start: 11368, length: 1, convRule: rule23 },
    { start: 11369, length: 1, convRule: rule22 },
    { start: 11370, length: 1, convRule: rule23 },
    { start: 11371, length: 1, convRule: rule22 },
    { start: 11372, length: 1, convRule: rule23 },
    { start: 11373, length: 1, convRule: rule177 },
    { start: 11374, length: 1, convRule: rule178 },
    { start: 11375, length: 1, convRule: rule179 },
    { start: 11376, length: 1, convRule: rule180 },
    { start: 11378, length: 1, convRule: rule22 },
    { start: 11379, length: 1, convRule: rule23 },
    { start: 11381, length: 1, convRule: rule22 },
    { start: 11382, length: 1, convRule: rule23 },
    { start: 11390, length: 2, convRule: rule181 },
    { start: 11392, length: 1, convRule: rule22 },
    { start: 11393, length: 1, convRule: rule23 },
    { start: 11394, length: 1, convRule: rule22 },
    { start: 11395, length: 1, convRule: rule23 },
    { start: 11396, length: 1, convRule: rule22 },
    { start: 11397, length: 1, convRule: rule23 },
    { start: 11398, length: 1, convRule: rule22 },
    { start: 11399, length: 1, convRule: rule23 },
    { start: 11400, length: 1, convRule: rule22 },
    { start: 11401, length: 1, convRule: rule23 },
    { start: 11402, length: 1, convRule: rule22 },
    { start: 11403, length: 1, convRule: rule23 },
    { start: 11404, length: 1, convRule: rule22 },
    { start: 11405, length: 1, convRule: rule23 },
    { start: 11406, length: 1, convRule: rule22 },
    { start: 11407, length: 1, convRule: rule23 },
    { start: 11408, length: 1, convRule: rule22 },
    { start: 11409, length: 1, convRule: rule23 },
    { start: 11410, length: 1, convRule: rule22 },
    { start: 11411, length: 1, convRule: rule23 },
    { start: 11412, length: 1, convRule: rule22 },
    { start: 11413, length: 1, convRule: rule23 },
    { start: 11414, length: 1, convRule: rule22 },
    { start: 11415, length: 1, convRule: rule23 },
    { start: 11416, length: 1, convRule: rule22 },
    { start: 11417, length: 1, convRule: rule23 },
    { start: 11418, length: 1, convRule: rule22 },
    { start: 11419, length: 1, convRule: rule23 },
    { start: 11420, length: 1, convRule: rule22 },
    { start: 11421, length: 1, convRule: rule23 },
    { start: 11422, length: 1, convRule: rule22 },
    { start: 11423, length: 1, convRule: rule23 },
    { start: 11424, length: 1, convRule: rule22 },
    { start: 11425, length: 1, convRule: rule23 },
    { start: 11426, length: 1, convRule: rule22 },
    { start: 11427, length: 1, convRule: rule23 },
    { start: 11428, length: 1, convRule: rule22 },
    { start: 11429, length: 1, convRule: rule23 },
    { start: 11430, length: 1, convRule: rule22 },
    { start: 11431, length: 1, convRule: rule23 },
    { start: 11432, length: 1, convRule: rule22 },
    { start: 11433, length: 1, convRule: rule23 },
    { start: 11434, length: 1, convRule: rule22 },
    { start: 11435, length: 1, convRule: rule23 },
    { start: 11436, length: 1, convRule: rule22 },
    { start: 11437, length: 1, convRule: rule23 },
    { start: 11438, length: 1, convRule: rule22 },
    { start: 11439, length: 1, convRule: rule23 },
    { start: 11440, length: 1, convRule: rule22 },
    { start: 11441, length: 1, convRule: rule23 },
    { start: 11442, length: 1, convRule: rule22 },
    { start: 11443, length: 1, convRule: rule23 },
    { start: 11444, length: 1, convRule: rule22 },
    { start: 11445, length: 1, convRule: rule23 },
    { start: 11446, length: 1, convRule: rule22 },
    { start: 11447, length: 1, convRule: rule23 },
    { start: 11448, length: 1, convRule: rule22 },
    { start: 11449, length: 1, convRule: rule23 },
    { start: 11450, length: 1, convRule: rule22 },
    { start: 11451, length: 1, convRule: rule23 },
    { start: 11452, length: 1, convRule: rule22 },
    { start: 11453, length: 1, convRule: rule23 },
    { start: 11454, length: 1, convRule: rule22 },
    { start: 11455, length: 1, convRule: rule23 },
    { start: 11456, length: 1, convRule: rule22 },
    { start: 11457, length: 1, convRule: rule23 },
    { start: 11458, length: 1, convRule: rule22 },
    { start: 11459, length: 1, convRule: rule23 },
    { start: 11460, length: 1, convRule: rule22 },
    { start: 11461, length: 1, convRule: rule23 },
    { start: 11462, length: 1, convRule: rule22 },
    { start: 11463, length: 1, convRule: rule23 },
    { start: 11464, length: 1, convRule: rule22 },
    { start: 11465, length: 1, convRule: rule23 },
    { start: 11466, length: 1, convRule: rule22 },
    { start: 11467, length: 1, convRule: rule23 },
    { start: 11468, length: 1, convRule: rule22 },
    { start: 11469, length: 1, convRule: rule23 },
    { start: 11470, length: 1, convRule: rule22 },
    { start: 11471, length: 1, convRule: rule23 },
    { start: 11472, length: 1, convRule: rule22 },
    { start: 11473, length: 1, convRule: rule23 },
    { start: 11474, length: 1, convRule: rule22 },
    { start: 11475, length: 1, convRule: rule23 },
    { start: 11476, length: 1, convRule: rule22 },
    { start: 11477, length: 1, convRule: rule23 },
    { start: 11478, length: 1, convRule: rule22 },
    { start: 11479, length: 1, convRule: rule23 },
    { start: 11480, length: 1, convRule: rule22 },
    { start: 11481, length: 1, convRule: rule23 },
    { start: 11482, length: 1, convRule: rule22 },
    { start: 11483, length: 1, convRule: rule23 },
    { start: 11484, length: 1, convRule: rule22 },
    { start: 11485, length: 1, convRule: rule23 },
    { start: 11486, length: 1, convRule: rule22 },
    { start: 11487, length: 1, convRule: rule23 },
    { start: 11488, length: 1, convRule: rule22 },
    { start: 11489, length: 1, convRule: rule23 },
    { start: 11490, length: 1, convRule: rule22 },
    { start: 11491, length: 1, convRule: rule23 },
    { start: 11499, length: 1, convRule: rule22 },
    { start: 11500, length: 1, convRule: rule23 },
    { start: 11501, length: 1, convRule: rule22 },
    { start: 11502, length: 1, convRule: rule23 },
    { start: 11506, length: 1, convRule: rule22 },
    { start: 11507, length: 1, convRule: rule23 },
    { start: 11520, length: 38, convRule: rule182 },
    { start: 11559, length: 1, convRule: rule182 },
    { start: 11565, length: 1, convRule: rule182 },
    { start: 42560, length: 1, convRule: rule22 },
    { start: 42561, length: 1, convRule: rule23 },
    { start: 42562, length: 1, convRule: rule22 },
    { start: 42563, length: 1, convRule: rule23 },
    { start: 42564, length: 1, convRule: rule22 },
    { start: 42565, length: 1, convRule: rule23 },
    { start: 42566, length: 1, convRule: rule22 },
    { start: 42567, length: 1, convRule: rule23 },
    { start: 42568, length: 1, convRule: rule22 },
    { start: 42569, length: 1, convRule: rule23 },
    { start: 42570, length: 1, convRule: rule22 },
    { start: 42571, length: 1, convRule: rule23 },
    { start: 42572, length: 1, convRule: rule22 },
    { start: 42573, length: 1, convRule: rule23 },
    { start: 42574, length: 1, convRule: rule22 },
    { start: 42575, length: 1, convRule: rule23 },
    { start: 42576, length: 1, convRule: rule22 },
    { start: 42577, length: 1, convRule: rule23 },
    { start: 42578, length: 1, convRule: rule22 },
    { start: 42579, length: 1, convRule: rule23 },
    { start: 42580, length: 1, convRule: rule22 },
    { start: 42581, length: 1, convRule: rule23 },
    { start: 42582, length: 1, convRule: rule22 },
    { start: 42583, length: 1, convRule: rule23 },
    { start: 42584, length: 1, convRule: rule22 },
    { start: 42585, length: 1, convRule: rule23 },
    { start: 42586, length: 1, convRule: rule22 },
    { start: 42587, length: 1, convRule: rule23 },
    { start: 42588, length: 1, convRule: rule22 },
    { start: 42589, length: 1, convRule: rule23 },
    { start: 42590, length: 1, convRule: rule22 },
    { start: 42591, length: 1, convRule: rule23 },
    { start: 42592, length: 1, convRule: rule22 },
    { start: 42593, length: 1, convRule: rule23 },
    { start: 42594, length: 1, convRule: rule22 },
    { start: 42595, length: 1, convRule: rule23 },
    { start: 42596, length: 1, convRule: rule22 },
    { start: 42597, length: 1, convRule: rule23 },
    { start: 42598, length: 1, convRule: rule22 },
    { start: 42599, length: 1, convRule: rule23 },
    { start: 42600, length: 1, convRule: rule22 },
    { start: 42601, length: 1, convRule: rule23 },
    { start: 42602, length: 1, convRule: rule22 },
    { start: 42603, length: 1, convRule: rule23 },
    { start: 42604, length: 1, convRule: rule22 },
    { start: 42605, length: 1, convRule: rule23 },
    { start: 42624, length: 1, convRule: rule22 },
    { start: 42625, length: 1, convRule: rule23 },
    { start: 42626, length: 1, convRule: rule22 },
    { start: 42627, length: 1, convRule: rule23 },
    { start: 42628, length: 1, convRule: rule22 },
    { start: 42629, length: 1, convRule: rule23 },
    { start: 42630, length: 1, convRule: rule22 },
    { start: 42631, length: 1, convRule: rule23 },
    { start: 42632, length: 1, convRule: rule22 },
    { start: 42633, length: 1, convRule: rule23 },
    { start: 42634, length: 1, convRule: rule22 },
    { start: 42635, length: 1, convRule: rule23 },
    { start: 42636, length: 1, convRule: rule22 },
    { start: 42637, length: 1, convRule: rule23 },
    { start: 42638, length: 1, convRule: rule22 },
    { start: 42639, length: 1, convRule: rule23 },
    { start: 42640, length: 1, convRule: rule22 },
    { start: 42641, length: 1, convRule: rule23 },
    { start: 42642, length: 1, convRule: rule22 },
    { start: 42643, length: 1, convRule: rule23 },
    { start: 42644, length: 1, convRule: rule22 },
    { start: 42645, length: 1, convRule: rule23 },
    { start: 42646, length: 1, convRule: rule22 },
    { start: 42647, length: 1, convRule: rule23 },
    { start: 42648, length: 1, convRule: rule22 },
    { start: 42649, length: 1, convRule: rule23 },
    { start: 42650, length: 1, convRule: rule22 },
    { start: 42651, length: 1, convRule: rule23 },
    { start: 42786, length: 1, convRule: rule22 },
    { start: 42787, length: 1, convRule: rule23 },
    { start: 42788, length: 1, convRule: rule22 },
    { start: 42789, length: 1, convRule: rule23 },
    { start: 42790, length: 1, convRule: rule22 },
    { start: 42791, length: 1, convRule: rule23 },
    { start: 42792, length: 1, convRule: rule22 },
    { start: 42793, length: 1, convRule: rule23 },
    { start: 42794, length: 1, convRule: rule22 },
    { start: 42795, length: 1, convRule: rule23 },
    { start: 42796, length: 1, convRule: rule22 },
    { start: 42797, length: 1, convRule: rule23 },
    { start: 42798, length: 1, convRule: rule22 },
    { start: 42799, length: 1, convRule: rule23 },
    { start: 42802, length: 1, convRule: rule22 },
    { start: 42803, length: 1, convRule: rule23 },
    { start: 42804, length: 1, convRule: rule22 },
    { start: 42805, length: 1, convRule: rule23 },
    { start: 42806, length: 1, convRule: rule22 },
    { start: 42807, length: 1, convRule: rule23 },
    { start: 42808, length: 1, convRule: rule22 },
    { start: 42809, length: 1, convRule: rule23 },
    { start: 42810, length: 1, convRule: rule22 },
    { start: 42811, length: 1, convRule: rule23 },
    { start: 42812, length: 1, convRule: rule22 },
    { start: 42813, length: 1, convRule: rule23 },
    { start: 42814, length: 1, convRule: rule22 },
    { start: 42815, length: 1, convRule: rule23 },
    { start: 42816, length: 1, convRule: rule22 },
    { start: 42817, length: 1, convRule: rule23 },
    { start: 42818, length: 1, convRule: rule22 },
    { start: 42819, length: 1, convRule: rule23 },
    { start: 42820, length: 1, convRule: rule22 },
    { start: 42821, length: 1, convRule: rule23 },
    { start: 42822, length: 1, convRule: rule22 },
    { start: 42823, length: 1, convRule: rule23 },
    { start: 42824, length: 1, convRule: rule22 },
    { start: 42825, length: 1, convRule: rule23 },
    { start: 42826, length: 1, convRule: rule22 },
    { start: 42827, length: 1, convRule: rule23 },
    { start: 42828, length: 1, convRule: rule22 },
    { start: 42829, length: 1, convRule: rule23 },
    { start: 42830, length: 1, convRule: rule22 },
    { start: 42831, length: 1, convRule: rule23 },
    { start: 42832, length: 1, convRule: rule22 },
    { start: 42833, length: 1, convRule: rule23 },
    { start: 42834, length: 1, convRule: rule22 },
    { start: 42835, length: 1, convRule: rule23 },
    { start: 42836, length: 1, convRule: rule22 },
    { start: 42837, length: 1, convRule: rule23 },
    { start: 42838, length: 1, convRule: rule22 },
    { start: 42839, length: 1, convRule: rule23 },
    { start: 42840, length: 1, convRule: rule22 },
    { start: 42841, length: 1, convRule: rule23 },
    { start: 42842, length: 1, convRule: rule22 },
    { start: 42843, length: 1, convRule: rule23 },
    { start: 42844, length: 1, convRule: rule22 },
    { start: 42845, length: 1, convRule: rule23 },
    { start: 42846, length: 1, convRule: rule22 },
    { start: 42847, length: 1, convRule: rule23 },
    { start: 42848, length: 1, convRule: rule22 },
    { start: 42849, length: 1, convRule: rule23 },
    { start: 42850, length: 1, convRule: rule22 },
    { start: 42851, length: 1, convRule: rule23 },
    { start: 42852, length: 1, convRule: rule22 },
    { start: 42853, length: 1, convRule: rule23 },
    { start: 42854, length: 1, convRule: rule22 },
    { start: 42855, length: 1, convRule: rule23 },
    { start: 42856, length: 1, convRule: rule22 },
    { start: 42857, length: 1, convRule: rule23 },
    { start: 42858, length: 1, convRule: rule22 },
    { start: 42859, length: 1, convRule: rule23 },
    { start: 42860, length: 1, convRule: rule22 },
    { start: 42861, length: 1, convRule: rule23 },
    { start: 42862, length: 1, convRule: rule22 },
    { start: 42863, length: 1, convRule: rule23 },
    { start: 42873, length: 1, convRule: rule22 },
    { start: 42874, length: 1, convRule: rule23 },
    { start: 42875, length: 1, convRule: rule22 },
    { start: 42876, length: 1, convRule: rule23 },
    { start: 42877, length: 1, convRule: rule183 },
    { start: 42878, length: 1, convRule: rule22 },
    { start: 42879, length: 1, convRule: rule23 },
    { start: 42880, length: 1, convRule: rule22 },
    { start: 42881, length: 1, convRule: rule23 },
    { start: 42882, length: 1, convRule: rule22 },
    { start: 42883, length: 1, convRule: rule23 },
    { start: 42884, length: 1, convRule: rule22 },
    { start: 42885, length: 1, convRule: rule23 },
    { start: 42886, length: 1, convRule: rule22 },
    { start: 42887, length: 1, convRule: rule23 },
    { start: 42891, length: 1, convRule: rule22 },
    { start: 42892, length: 1, convRule: rule23 },
    { start: 42893, length: 1, convRule: rule184 },
    { start: 42896, length: 1, convRule: rule22 },
    { start: 42897, length: 1, convRule: rule23 },
    { start: 42898, length: 1, convRule: rule22 },
    { start: 42899, length: 1, convRule: rule23 },
    { start: 42900, length: 1, convRule: rule185 },
    { start: 42902, length: 1, convRule: rule22 },
    { start: 42903, length: 1, convRule: rule23 },
    { start: 42904, length: 1, convRule: rule22 },
    { start: 42905, length: 1, convRule: rule23 },
    { start: 42906, length: 1, convRule: rule22 },
    { start: 42907, length: 1, convRule: rule23 },
    { start: 42908, length: 1, convRule: rule22 },
    { start: 42909, length: 1, convRule: rule23 },
    { start: 42910, length: 1, convRule: rule22 },
    { start: 42911, length: 1, convRule: rule23 },
    { start: 42912, length: 1, convRule: rule22 },
    { start: 42913, length: 1, convRule: rule23 },
    { start: 42914, length: 1, convRule: rule22 },
    { start: 42915, length: 1, convRule: rule23 },
    { start: 42916, length: 1, convRule: rule22 },
    { start: 42917, length: 1, convRule: rule23 },
    { start: 42918, length: 1, convRule: rule22 },
    { start: 42919, length: 1, convRule: rule23 },
    { start: 42920, length: 1, convRule: rule22 },
    { start: 42921, length: 1, convRule: rule23 },
    { start: 42922, length: 1, convRule: rule186 },
    { start: 42923, length: 1, convRule: rule187 },
    { start: 42924, length: 1, convRule: rule188 },
    { start: 42925, length: 1, convRule: rule189 },
    { start: 42926, length: 1, convRule: rule186 },
    { start: 42928, length: 1, convRule: rule190 },
    { start: 42929, length: 1, convRule: rule191 },
    { start: 42930, length: 1, convRule: rule192 },
    { start: 42931, length: 1, convRule: rule193 },
    { start: 42932, length: 1, convRule: rule22 },
    { start: 42933, length: 1, convRule: rule23 },
    { start: 42934, length: 1, convRule: rule22 },
    { start: 42935, length: 1, convRule: rule23 },
    { start: 42936, length: 1, convRule: rule22 },
    { start: 42937, length: 1, convRule: rule23 },
    { start: 42938, length: 1, convRule: rule22 },
    { start: 42939, length: 1, convRule: rule23 },
    { start: 42940, length: 1, convRule: rule22 },
    { start: 42941, length: 1, convRule: rule23 },
    { start: 42942, length: 1, convRule: rule22 },
    { start: 42943, length: 1, convRule: rule23 },
    { start: 42946, length: 1, convRule: rule22 },
    { start: 42947, length: 1, convRule: rule23 },
    { start: 42948, length: 1, convRule: rule194 },
    { start: 42949, length: 1, convRule: rule195 },
    { start: 42950, length: 1, convRule: rule196 },
    { start: 42951, length: 1, convRule: rule22 },
    { start: 42952, length: 1, convRule: rule23 },
    { start: 42953, length: 1, convRule: rule22 },
    { start: 42954, length: 1, convRule: rule23 },
    { start: 42997, length: 1, convRule: rule22 },
    { start: 42998, length: 1, convRule: rule23 },
    { start: 43859, length: 1, convRule: rule197 },
    { start: 43888, length: 80, convRule: rule198 },
    { start: 65313, length: 26, convRule: rule9 },
    { start: 65345, length: 26, convRule: rule12 },
    { start: 66560, length: 40, convRule: rule201 },
    { start: 66600, length: 40, convRule: rule202 },
    { start: 66736, length: 36, convRule: rule201 },
    { start: 66776, length: 36, convRule: rule202 },
    { start: 68736, length: 51, convRule: rule97 },
    { start: 68800, length: 51, convRule: rule102 },
    { start: 71840, length: 32, convRule: rule9 },
    { start: 71872, length: 32, convRule: rule12 },
    { start: 93760, length: 32, convRule: rule9 },
    { start: 93792, length: 32, convRule: rule12 },
    { start: 125184, length: 34, convRule: rule203 },
    { start: 125218, length: 34, convRule: rule204 }
  ];
  var bsearch = (a) => (array2) => (size3) => (compare2) => {
    const go = (go$a0$copy) => (go$a1$copy) => {
      let go$a0 = go$a0$copy, go$a1 = go$a1$copy, go$c = true, go$r;
      while (go$c) {
        const i = go$a0, k = go$a1;
        if (i > k || i >= array2.length) {
          go$c = false;
          go$r = Nothing;
          continue;
        }
        const j = unsafeClamp(floor(toNumber(i + k | 0) / 2));
        const b = array2[j];
        const v = compare2(a)(b);
        if (v === "EQ") {
          go$c = false;
          go$r = $Maybe("Just", b);
          continue;
        }
        if (v === "GT") {
          go$a0 = j + 1 | 0;
          go$a1 = k;
          continue;
        }
        go$a0 = i;
        go$a1 = j - 1 | 0;
      }
      return go$r;
    };
    return go(0)(size3);
  };
  var blkCmp = (v) => (v1) => {
    if (v.start >= v1.start && v.start < (v1.start + v1.length | 0)) {
      return EQ;
    }
    if (v.start > v1.start) {
      return GT;
    }
    return LT;
  };
  var getRule = (blocks) => (unichar) => (size3) => {
    const maybeCharBlock = bsearch({ start: unichar, length: 1, convRule: nullrule })(blocks)(size3)(blkCmp);
    if (maybeCharBlock.tag === "Nothing") {
      return Nothing;
    }
    if (maybeCharBlock.tag === "Just") {
      return $Maybe("Just", maybeCharBlock._1.convRule);
    }
    fail();
  };
  var caseConv = (f) => ($$char) => {
    const maybeConversionRule = getRule(convchars)($$char)(1332);
    if (maybeConversionRule.tag === "Nothing") {
      return $$char;
    }
    if (maybeConversionRule.tag === "Just") {
      return $$char + f(maybeConversionRule._1) | 0;
    }
    fail();
  };
  var uTowlower = /* @__PURE__ */ caseConv((v) => v.lowdist);
  var uTowupper = /* @__PURE__ */ caseConv((v) => v.updist);
  var checkAttrS = (categories) => ($$char) => {
    const maybeConversionRule = getRule(spacechars)($$char)(7);
    if (maybeConversionRule.tag === "Nothing") {
      return false;
    }
    if (maybeConversionRule.tag === "Just") {
      const $0 = maybeConversionRule._1.category;
      const $1 = findIndexImpl(Just, Nothing, (v) => v === $0, categories);
      if ($1.tag === "Nothing") {
        return false;
      }
      if ($1.tag === "Just") {
        return true;
      }
    }
    fail();
  };
  var allchars = [
    { start: 0, length: 32, convRule: rule0 },
    { start: 32, length: 1, convRule: rule1 },
    { start: 33, length: 3, convRule: rule2 },
    { start: 36, length: 1, convRule: rule3 },
    { start: 37, length: 3, convRule: rule2 },
    { start: 40, length: 1, convRule: rule4 },
    { start: 41, length: 1, convRule: rule5 },
    { start: 42, length: 1, convRule: rule2 },
    { start: 43, length: 1, convRule: rule6 },
    { start: 44, length: 1, convRule: rule2 },
    { start: 45, length: 1, convRule: rule7 },
    { start: 46, length: 2, convRule: rule2 },
    { start: 48, length: 10, convRule: rule8 },
    { start: 58, length: 2, convRule: rule2 },
    { start: 60, length: 3, convRule: rule6 },
    { start: 63, length: 2, convRule: rule2 },
    { start: 65, length: 26, convRule: rule9 },
    { start: 91, length: 1, convRule: rule4 },
    { start: 92, length: 1, convRule: rule2 },
    { start: 93, length: 1, convRule: rule5 },
    { start: 94, length: 1, convRule: rule10 },
    { start: 95, length: 1, convRule: rule11 },
    { start: 96, length: 1, convRule: rule10 },
    { start: 97, length: 26, convRule: rule12 },
    { start: 123, length: 1, convRule: rule4 },
    { start: 124, length: 1, convRule: rule6 },
    { start: 125, length: 1, convRule: rule5 },
    { start: 126, length: 1, convRule: rule6 },
    { start: 127, length: 33, convRule: rule0 },
    { start: 160, length: 1, convRule: rule1 },
    { start: 161, length: 1, convRule: rule2 },
    { start: 162, length: 4, convRule: rule3 },
    { start: 166, length: 1, convRule: rule13 },
    { start: 167, length: 1, convRule: rule2 },
    { start: 168, length: 1, convRule: rule10 },
    { start: 169, length: 1, convRule: rule13 },
    { start: 170, length: 1, convRule: rule14 },
    { start: 171, length: 1, convRule: rule15 },
    { start: 172, length: 1, convRule: rule6 },
    { start: 173, length: 1, convRule: rule16 },
    { start: 174, length: 1, convRule: rule13 },
    { start: 175, length: 1, convRule: rule10 },
    { start: 176, length: 1, convRule: rule13 },
    { start: 177, length: 1, convRule: rule6 },
    { start: 178, length: 2, convRule: rule17 },
    { start: 180, length: 1, convRule: rule10 },
    { start: 181, length: 1, convRule: rule18 },
    { start: 182, length: 2, convRule: rule2 },
    { start: 184, length: 1, convRule: rule10 },
    { start: 185, length: 1, convRule: rule17 },
    { start: 186, length: 1, convRule: rule14 },
    { start: 187, length: 1, convRule: rule19 },
    { start: 188, length: 3, convRule: rule17 },
    { start: 191, length: 1, convRule: rule2 },
    { start: 192, length: 23, convRule: rule9 },
    { start: 215, length: 1, convRule: rule6 },
    { start: 216, length: 7, convRule: rule9 },
    { start: 223, length: 1, convRule: rule20 },
    { start: 224, length: 23, convRule: rule12 },
    { start: 247, length: 1, convRule: rule6 },
    { start: 248, length: 7, convRule: rule12 },
    { start: 255, length: 1, convRule: rule21 },
    { start: 256, length: 1, convRule: rule22 },
    { start: 257, length: 1, convRule: rule23 },
    { start: 258, length: 1, convRule: rule22 },
    { start: 259, length: 1, convRule: rule23 },
    { start: 260, length: 1, convRule: rule22 },
    { start: 261, length: 1, convRule: rule23 },
    { start: 262, length: 1, convRule: rule22 },
    { start: 263, length: 1, convRule: rule23 },
    { start: 264, length: 1, convRule: rule22 },
    { start: 265, length: 1, convRule: rule23 },
    { start: 266, length: 1, convRule: rule22 },
    { start: 267, length: 1, convRule: rule23 },
    { start: 268, length: 1, convRule: rule22 },
    { start: 269, length: 1, convRule: rule23 },
    { start: 270, length: 1, convRule: rule22 },
    { start: 271, length: 1, convRule: rule23 },
    { start: 272, length: 1, convRule: rule22 },
    { start: 273, length: 1, convRule: rule23 },
    { start: 274, length: 1, convRule: rule22 },
    { start: 275, length: 1, convRule: rule23 },
    { start: 276, length: 1, convRule: rule22 },
    { start: 277, length: 1, convRule: rule23 },
    { start: 278, length: 1, convRule: rule22 },
    { start: 279, length: 1, convRule: rule23 },
    { start: 280, length: 1, convRule: rule22 },
    { start: 281, length: 1, convRule: rule23 },
    { start: 282, length: 1, convRule: rule22 },
    { start: 283, length: 1, convRule: rule23 },
    { start: 284, length: 1, convRule: rule22 },
    { start: 285, length: 1, convRule: rule23 },
    { start: 286, length: 1, convRule: rule22 },
    { start: 287, length: 1, convRule: rule23 },
    { start: 288, length: 1, convRule: rule22 },
    { start: 289, length: 1, convRule: rule23 },
    { start: 290, length: 1, convRule: rule22 },
    { start: 291, length: 1, convRule: rule23 },
    { start: 292, length: 1, convRule: rule22 },
    { start: 293, length: 1, convRule: rule23 },
    { start: 294, length: 1, convRule: rule22 },
    { start: 295, length: 1, convRule: rule23 },
    { start: 296, length: 1, convRule: rule22 },
    { start: 297, length: 1, convRule: rule23 },
    { start: 298, length: 1, convRule: rule22 },
    { start: 299, length: 1, convRule: rule23 },
    { start: 300, length: 1, convRule: rule22 },
    { start: 301, length: 1, convRule: rule23 },
    { start: 302, length: 1, convRule: rule22 },
    { start: 303, length: 1, convRule: rule23 },
    { start: 304, length: 1, convRule: rule24 },
    { start: 305, length: 1, convRule: rule25 },
    { start: 306, length: 1, convRule: rule22 },
    { start: 307, length: 1, convRule: rule23 },
    { start: 308, length: 1, convRule: rule22 },
    { start: 309, length: 1, convRule: rule23 },
    { start: 310, length: 1, convRule: rule22 },
    { start: 311, length: 1, convRule: rule23 },
    { start: 312, length: 1, convRule: rule20 },
    { start: 313, length: 1, convRule: rule22 },
    { start: 314, length: 1, convRule: rule23 },
    { start: 315, length: 1, convRule: rule22 },
    { start: 316, length: 1, convRule: rule23 },
    { start: 317, length: 1, convRule: rule22 },
    { start: 318, length: 1, convRule: rule23 },
    { start: 319, length: 1, convRule: rule22 },
    { start: 320, length: 1, convRule: rule23 },
    { start: 321, length: 1, convRule: rule22 },
    { start: 322, length: 1, convRule: rule23 },
    { start: 323, length: 1, convRule: rule22 },
    { start: 324, length: 1, convRule: rule23 },
    { start: 325, length: 1, convRule: rule22 },
    { start: 326, length: 1, convRule: rule23 },
    { start: 327, length: 1, convRule: rule22 },
    { start: 328, length: 1, convRule: rule23 },
    { start: 329, length: 1, convRule: rule20 },
    { start: 330, length: 1, convRule: rule22 },
    { start: 331, length: 1, convRule: rule23 },
    { start: 332, length: 1, convRule: rule22 },
    { start: 333, length: 1, convRule: rule23 },
    { start: 334, length: 1, convRule: rule22 },
    { start: 335, length: 1, convRule: rule23 },
    { start: 336, length: 1, convRule: rule22 },
    { start: 337, length: 1, convRule: rule23 },
    { start: 338, length: 1, convRule: rule22 },
    { start: 339, length: 1, convRule: rule23 },
    { start: 340, length: 1, convRule: rule22 },
    { start: 341, length: 1, convRule: rule23 },
    { start: 342, length: 1, convRule: rule22 },
    { start: 343, length: 1, convRule: rule23 },
    { start: 344, length: 1, convRule: rule22 },
    { start: 345, length: 1, convRule: rule23 },
    { start: 346, length: 1, convRule: rule22 },
    { start: 347, length: 1, convRule: rule23 },
    { start: 348, length: 1, convRule: rule22 },
    { start: 349, length: 1, convRule: rule23 },
    { start: 350, length: 1, convRule: rule22 },
    { start: 351, length: 1, convRule: rule23 },
    { start: 352, length: 1, convRule: rule22 },
    { start: 353, length: 1, convRule: rule23 },
    { start: 354, length: 1, convRule: rule22 },
    { start: 355, length: 1, convRule: rule23 },
    { start: 356, length: 1, convRule: rule22 },
    { start: 357, length: 1, convRule: rule23 },
    { start: 358, length: 1, convRule: rule22 },
    { start: 359, length: 1, convRule: rule23 },
    { start: 360, length: 1, convRule: rule22 },
    { start: 361, length: 1, convRule: rule23 },
    { start: 362, length: 1, convRule: rule22 },
    { start: 363, length: 1, convRule: rule23 },
    { start: 364, length: 1, convRule: rule22 },
    { start: 365, length: 1, convRule: rule23 },
    { start: 366, length: 1, convRule: rule22 },
    { start: 367, length: 1, convRule: rule23 },
    { start: 368, length: 1, convRule: rule22 },
    { start: 369, length: 1, convRule: rule23 },
    { start: 370, length: 1, convRule: rule22 },
    { start: 371, length: 1, convRule: rule23 },
    { start: 372, length: 1, convRule: rule22 },
    { start: 373, length: 1, convRule: rule23 },
    { start: 374, length: 1, convRule: rule22 },
    { start: 375, length: 1, convRule: rule23 },
    { start: 376, length: 1, convRule: rule26 },
    { start: 377, length: 1, convRule: rule22 },
    { start: 378, length: 1, convRule: rule23 },
    { start: 379, length: 1, convRule: rule22 },
    { start: 380, length: 1, convRule: rule23 },
    { start: 381, length: 1, convRule: rule22 },
    { start: 382, length: 1, convRule: rule23 },
    { start: 383, length: 1, convRule: rule27 },
    { start: 384, length: 1, convRule: rule28 },
    { start: 385, length: 1, convRule: rule29 },
    { start: 386, length: 1, convRule: rule22 },
    { start: 387, length: 1, convRule: rule23 },
    { start: 388, length: 1, convRule: rule22 },
    { start: 389, length: 1, convRule: rule23 },
    { start: 390, length: 1, convRule: rule30 },
    { start: 391, length: 1, convRule: rule22 },
    { start: 392, length: 1, convRule: rule23 },
    { start: 393, length: 2, convRule: rule31 },
    { start: 395, length: 1, convRule: rule22 },
    { start: 396, length: 1, convRule: rule23 },
    { start: 397, length: 1, convRule: rule20 },
    { start: 398, length: 1, convRule: rule32 },
    { start: 399, length: 1, convRule: rule33 },
    { start: 400, length: 1, convRule: rule34 },
    { start: 401, length: 1, convRule: rule22 },
    { start: 402, length: 1, convRule: rule23 },
    { start: 403, length: 1, convRule: rule31 },
    { start: 404, length: 1, convRule: rule35 },
    { start: 405, length: 1, convRule: rule36 },
    { start: 406, length: 1, convRule: rule37 },
    { start: 407, length: 1, convRule: rule38 },
    { start: 408, length: 1, convRule: rule22 },
    { start: 409, length: 1, convRule: rule23 },
    { start: 410, length: 1, convRule: rule39 },
    { start: 411, length: 1, convRule: rule20 },
    { start: 412, length: 1, convRule: rule37 },
    { start: 413, length: 1, convRule: rule40 },
    { start: 414, length: 1, convRule: rule41 },
    { start: 415, length: 1, convRule: rule42 },
    { start: 416, length: 1, convRule: rule22 },
    { start: 417, length: 1, convRule: rule23 },
    { start: 418, length: 1, convRule: rule22 },
    { start: 419, length: 1, convRule: rule23 },
    { start: 420, length: 1, convRule: rule22 },
    { start: 421, length: 1, convRule: rule23 },
    { start: 422, length: 1, convRule: rule43 },
    { start: 423, length: 1, convRule: rule22 },
    { start: 424, length: 1, convRule: rule23 },
    { start: 425, length: 1, convRule: rule43 },
    { start: 426, length: 2, convRule: rule20 },
    { start: 428, length: 1, convRule: rule22 },
    { start: 429, length: 1, convRule: rule23 },
    { start: 430, length: 1, convRule: rule43 },
    { start: 431, length: 1, convRule: rule22 },
    { start: 432, length: 1, convRule: rule23 },
    { start: 433, length: 2, convRule: rule44 },
    { start: 435, length: 1, convRule: rule22 },
    { start: 436, length: 1, convRule: rule23 },
    { start: 437, length: 1, convRule: rule22 },
    { start: 438, length: 1, convRule: rule23 },
    { start: 439, length: 1, convRule: rule45 },
    { start: 440, length: 1, convRule: rule22 },
    { start: 441, length: 1, convRule: rule23 },
    { start: 442, length: 1, convRule: rule20 },
    { start: 443, length: 1, convRule: rule14 },
    { start: 444, length: 1, convRule: rule22 },
    { start: 445, length: 1, convRule: rule23 },
    { start: 446, length: 1, convRule: rule20 },
    { start: 447, length: 1, convRule: rule46 },
    { start: 448, length: 4, convRule: rule14 },
    { start: 452, length: 1, convRule: rule47 },
    { start: 453, length: 1, convRule: rule48 },
    { start: 454, length: 1, convRule: rule49 },
    { start: 455, length: 1, convRule: rule47 },
    { start: 456, length: 1, convRule: rule48 },
    { start: 457, length: 1, convRule: rule49 },
    { start: 458, length: 1, convRule: rule47 },
    { start: 459, length: 1, convRule: rule48 },
    { start: 460, length: 1, convRule: rule49 },
    { start: 461, length: 1, convRule: rule22 },
    { start: 462, length: 1, convRule: rule23 },
    { start: 463, length: 1, convRule: rule22 },
    { start: 464, length: 1, convRule: rule23 },
    { start: 465, length: 1, convRule: rule22 },
    { start: 466, length: 1, convRule: rule23 },
    { start: 467, length: 1, convRule: rule22 },
    { start: 468, length: 1, convRule: rule23 },
    { start: 469, length: 1, convRule: rule22 },
    { start: 470, length: 1, convRule: rule23 },
    { start: 471, length: 1, convRule: rule22 },
    { start: 472, length: 1, convRule: rule23 },
    { start: 473, length: 1, convRule: rule22 },
    { start: 474, length: 1, convRule: rule23 },
    { start: 475, length: 1, convRule: rule22 },
    { start: 476, length: 1, convRule: rule23 },
    { start: 477, length: 1, convRule: rule50 },
    { start: 478, length: 1, convRule: rule22 },
    { start: 479, length: 1, convRule: rule23 },
    { start: 480, length: 1, convRule: rule22 },
    { start: 481, length: 1, convRule: rule23 },
    { start: 482, length: 1, convRule: rule22 },
    { start: 483, length: 1, convRule: rule23 },
    { start: 484, length: 1, convRule: rule22 },
    { start: 485, length: 1, convRule: rule23 },
    { start: 486, length: 1, convRule: rule22 },
    { start: 487, length: 1, convRule: rule23 },
    { start: 488, length: 1, convRule: rule22 },
    { start: 489, length: 1, convRule: rule23 },
    { start: 490, length: 1, convRule: rule22 },
    { start: 491, length: 1, convRule: rule23 },
    { start: 492, length: 1, convRule: rule22 },
    { start: 493, length: 1, convRule: rule23 },
    { start: 494, length: 1, convRule: rule22 },
    { start: 495, length: 1, convRule: rule23 },
    { start: 496, length: 1, convRule: rule20 },
    { start: 497, length: 1, convRule: rule47 },
    { start: 498, length: 1, convRule: rule48 },
    { start: 499, length: 1, convRule: rule49 },
    { start: 500, length: 1, convRule: rule22 },
    { start: 501, length: 1, convRule: rule23 },
    { start: 502, length: 1, convRule: rule51 },
    { start: 503, length: 1, convRule: rule52 },
    { start: 504, length: 1, convRule: rule22 },
    { start: 505, length: 1, convRule: rule23 },
    { start: 506, length: 1, convRule: rule22 },
    { start: 507, length: 1, convRule: rule23 },
    { start: 508, length: 1, convRule: rule22 },
    { start: 509, length: 1, convRule: rule23 },
    { start: 510, length: 1, convRule: rule22 },
    { start: 511, length: 1, convRule: rule23 },
    { start: 512, length: 1, convRule: rule22 },
    { start: 513, length: 1, convRule: rule23 },
    { start: 514, length: 1, convRule: rule22 },
    { start: 515, length: 1, convRule: rule23 },
    { start: 516, length: 1, convRule: rule22 },
    { start: 517, length: 1, convRule: rule23 },
    { start: 518, length: 1, convRule: rule22 },
    { start: 519, length: 1, convRule: rule23 },
    { start: 520, length: 1, convRule: rule22 },
    { start: 521, length: 1, convRule: rule23 },
    { start: 522, length: 1, convRule: rule22 },
    { start: 523, length: 1, convRule: rule23 },
    { start: 524, length: 1, convRule: rule22 },
    { start: 525, length: 1, convRule: rule23 },
    { start: 526, length: 1, convRule: rule22 },
    { start: 527, length: 1, convRule: rule23 },
    { start: 528, length: 1, convRule: rule22 },
    { start: 529, length: 1, convRule: rule23 },
    { start: 530, length: 1, convRule: rule22 },
    { start: 531, length: 1, convRule: rule23 },
    { start: 532, length: 1, convRule: rule22 },
    { start: 533, length: 1, convRule: rule23 },
    { start: 534, length: 1, convRule: rule22 },
    { start: 535, length: 1, convRule: rule23 },
    { start: 536, length: 1, convRule: rule22 },
    { start: 537, length: 1, convRule: rule23 },
    { start: 538, length: 1, convRule: rule22 },
    { start: 539, length: 1, convRule: rule23 },
    { start: 540, length: 1, convRule: rule22 },
    { start: 541, length: 1, convRule: rule23 },
    { start: 542, length: 1, convRule: rule22 },
    { start: 543, length: 1, convRule: rule23 },
    { start: 544, length: 1, convRule: rule53 },
    { start: 545, length: 1, convRule: rule20 },
    { start: 546, length: 1, convRule: rule22 },
    { start: 547, length: 1, convRule: rule23 },
    { start: 548, length: 1, convRule: rule22 },
    { start: 549, length: 1, convRule: rule23 },
    { start: 550, length: 1, convRule: rule22 },
    { start: 551, length: 1, convRule: rule23 },
    { start: 552, length: 1, convRule: rule22 },
    { start: 553, length: 1, convRule: rule23 },
    { start: 554, length: 1, convRule: rule22 },
    { start: 555, length: 1, convRule: rule23 },
    { start: 556, length: 1, convRule: rule22 },
    { start: 557, length: 1, convRule: rule23 },
    { start: 558, length: 1, convRule: rule22 },
    { start: 559, length: 1, convRule: rule23 },
    { start: 560, length: 1, convRule: rule22 },
    { start: 561, length: 1, convRule: rule23 },
    { start: 562, length: 1, convRule: rule22 },
    { start: 563, length: 1, convRule: rule23 },
    { start: 564, length: 6, convRule: rule20 },
    { start: 570, length: 1, convRule: rule54 },
    { start: 571, length: 1, convRule: rule22 },
    { start: 572, length: 1, convRule: rule23 },
    { start: 573, length: 1, convRule: rule55 },
    { start: 574, length: 1, convRule: rule56 },
    { start: 575, length: 2, convRule: rule57 },
    { start: 577, length: 1, convRule: rule22 },
    { start: 578, length: 1, convRule: rule23 },
    { start: 579, length: 1, convRule: rule58 },
    { start: 580, length: 1, convRule: rule59 },
    { start: 581, length: 1, convRule: rule60 },
    { start: 582, length: 1, convRule: rule22 },
    { start: 583, length: 1, convRule: rule23 },
    { start: 584, length: 1, convRule: rule22 },
    { start: 585, length: 1, convRule: rule23 },
    { start: 586, length: 1, convRule: rule22 },
    { start: 587, length: 1, convRule: rule23 },
    { start: 588, length: 1, convRule: rule22 },
    { start: 589, length: 1, convRule: rule23 },
    { start: 590, length: 1, convRule: rule22 },
    { start: 591, length: 1, convRule: rule23 },
    { start: 592, length: 1, convRule: rule61 },
    { start: 593, length: 1, convRule: rule62 },
    { start: 594, length: 1, convRule: rule63 },
    { start: 595, length: 1, convRule: rule64 },
    { start: 596, length: 1, convRule: rule65 },
    { start: 597, length: 1, convRule: rule20 },
    { start: 598, length: 2, convRule: rule66 },
    { start: 600, length: 1, convRule: rule20 },
    { start: 601, length: 1, convRule: rule67 },
    { start: 602, length: 1, convRule: rule20 },
    { start: 603, length: 1, convRule: rule68 },
    { start: 604, length: 1, convRule: rule69 },
    { start: 605, length: 3, convRule: rule20 },
    { start: 608, length: 1, convRule: rule66 },
    { start: 609, length: 1, convRule: rule70 },
    { start: 610, length: 1, convRule: rule20 },
    { start: 611, length: 1, convRule: rule71 },
    { start: 612, length: 1, convRule: rule20 },
    { start: 613, length: 1, convRule: rule72 },
    { start: 614, length: 1, convRule: rule73 },
    { start: 615, length: 1, convRule: rule20 },
    { start: 616, length: 1, convRule: rule74 },
    { start: 617, length: 1, convRule: rule75 },
    { start: 618, length: 1, convRule: rule73 },
    { start: 619, length: 1, convRule: rule76 },
    { start: 620, length: 1, convRule: rule77 },
    { start: 621, length: 2, convRule: rule20 },
    { start: 623, length: 1, convRule: rule75 },
    { start: 624, length: 1, convRule: rule20 },
    { start: 625, length: 1, convRule: rule78 },
    { start: 626, length: 1, convRule: rule79 },
    { start: 627, length: 2, convRule: rule20 },
    { start: 629, length: 1, convRule: rule80 },
    { start: 630, length: 7, convRule: rule20 },
    { start: 637, length: 1, convRule: rule81 },
    { start: 638, length: 2, convRule: rule20 },
    { start: 640, length: 1, convRule: rule82 },
    { start: 641, length: 1, convRule: rule20 },
    { start: 642, length: 1, convRule: rule83 },
    { start: 643, length: 1, convRule: rule82 },
    { start: 644, length: 3, convRule: rule20 },
    { start: 647, length: 1, convRule: rule84 },
    { start: 648, length: 1, convRule: rule82 },
    { start: 649, length: 1, convRule: rule85 },
    { start: 650, length: 2, convRule: rule86 },
    { start: 652, length: 1, convRule: rule87 },
    { start: 653, length: 5, convRule: rule20 },
    { start: 658, length: 1, convRule: rule88 },
    { start: 659, length: 1, convRule: rule20 },
    { start: 660, length: 1, convRule: rule14 },
    { start: 661, length: 8, convRule: rule20 },
    { start: 669, length: 1, convRule: rule89 },
    { start: 670, length: 1, convRule: rule90 },
    { start: 671, length: 17, convRule: rule20 },
    { start: 688, length: 18, convRule: rule91 },
    { start: 706, length: 4, convRule: rule10 },
    { start: 710, length: 12, convRule: rule91 },
    { start: 722, length: 14, convRule: rule10 },
    { start: 736, length: 5, convRule: rule91 },
    { start: 741, length: 7, convRule: rule10 },
    { start: 748, length: 1, convRule: rule91 },
    { start: 749, length: 1, convRule: rule10 },
    { start: 750, length: 1, convRule: rule91 },
    { start: 751, length: 17, convRule: rule10 },
    { start: 768, length: 69, convRule: rule92 },
    { start: 837, length: 1, convRule: rule93 },
    { start: 838, length: 42, convRule: rule92 },
    { start: 880, length: 1, convRule: rule22 },
    { start: 881, length: 1, convRule: rule23 },
    { start: 882, length: 1, convRule: rule22 },
    { start: 883, length: 1, convRule: rule23 },
    { start: 884, length: 1, convRule: rule91 },
    { start: 885, length: 1, convRule: rule10 },
    { start: 886, length: 1, convRule: rule22 },
    { start: 887, length: 1, convRule: rule23 },
    { start: 890, length: 1, convRule: rule91 },
    { start: 891, length: 3, convRule: rule41 },
    { start: 894, length: 1, convRule: rule2 },
    { start: 895, length: 1, convRule: rule94 },
    { start: 900, length: 2, convRule: rule10 },
    { start: 902, length: 1, convRule: rule95 },
    { start: 903, length: 1, convRule: rule2 },
    { start: 904, length: 3, convRule: rule96 },
    { start: 908, length: 1, convRule: rule97 },
    { start: 910, length: 2, convRule: rule98 },
    { start: 912, length: 1, convRule: rule20 },
    { start: 913, length: 17, convRule: rule9 },
    { start: 931, length: 9, convRule: rule9 },
    { start: 940, length: 1, convRule: rule99 },
    { start: 941, length: 3, convRule: rule100 },
    { start: 944, length: 1, convRule: rule20 },
    { start: 945, length: 17, convRule: rule12 },
    { start: 962, length: 1, convRule: rule101 },
    { start: 963, length: 9, convRule: rule12 },
    { start: 972, length: 1, convRule: rule102 },
    { start: 973, length: 2, convRule: rule103 },
    { start: 975, length: 1, convRule: rule104 },
    { start: 976, length: 1, convRule: rule105 },
    { start: 977, length: 1, convRule: rule106 },
    { start: 978, length: 3, convRule: rule107 },
    { start: 981, length: 1, convRule: rule108 },
    { start: 982, length: 1, convRule: rule109 },
    { start: 983, length: 1, convRule: rule110 },
    { start: 984, length: 1, convRule: rule22 },
    { start: 985, length: 1, convRule: rule23 },
    { start: 986, length: 1, convRule: rule22 },
    { start: 987, length: 1, convRule: rule23 },
    { start: 988, length: 1, convRule: rule22 },
    { start: 989, length: 1, convRule: rule23 },
    { start: 990, length: 1, convRule: rule22 },
    { start: 991, length: 1, convRule: rule23 },
    { start: 992, length: 1, convRule: rule22 },
    { start: 993, length: 1, convRule: rule23 },
    { start: 994, length: 1, convRule: rule22 },
    { start: 995, length: 1, convRule: rule23 },
    { start: 996, length: 1, convRule: rule22 },
    { start: 997, length: 1, convRule: rule23 },
    { start: 998, length: 1, convRule: rule22 },
    { start: 999, length: 1, convRule: rule23 },
    { start: 1e3, length: 1, convRule: rule22 },
    { start: 1001, length: 1, convRule: rule23 },
    { start: 1002, length: 1, convRule: rule22 },
    { start: 1003, length: 1, convRule: rule23 },
    { start: 1004, length: 1, convRule: rule22 },
    { start: 1005, length: 1, convRule: rule23 },
    { start: 1006, length: 1, convRule: rule22 },
    { start: 1007, length: 1, convRule: rule23 },
    { start: 1008, length: 1, convRule: rule111 },
    { start: 1009, length: 1, convRule: rule112 },
    { start: 1010, length: 1, convRule: rule113 },
    { start: 1011, length: 1, convRule: rule114 },
    { start: 1012, length: 1, convRule: rule115 },
    { start: 1013, length: 1, convRule: rule116 },
    { start: 1014, length: 1, convRule: rule6 },
    { start: 1015, length: 1, convRule: rule22 },
    { start: 1016, length: 1, convRule: rule23 },
    { start: 1017, length: 1, convRule: rule117 },
    { start: 1018, length: 1, convRule: rule22 },
    { start: 1019, length: 1, convRule: rule23 },
    { start: 1020, length: 1, convRule: rule20 },
    { start: 1021, length: 3, convRule: rule53 },
    { start: 1024, length: 16, convRule: rule118 },
    { start: 1040, length: 32, convRule: rule9 },
    { start: 1072, length: 32, convRule: rule12 },
    { start: 1104, length: 16, convRule: rule112 },
    { start: 1120, length: 1, convRule: rule22 },
    { start: 1121, length: 1, convRule: rule23 },
    { start: 1122, length: 1, convRule: rule22 },
    { start: 1123, length: 1, convRule: rule23 },
    { start: 1124, length: 1, convRule: rule22 },
    { start: 1125, length: 1, convRule: rule23 },
    { start: 1126, length: 1, convRule: rule22 },
    { start: 1127, length: 1, convRule: rule23 },
    { start: 1128, length: 1, convRule: rule22 },
    { start: 1129, length: 1, convRule: rule23 },
    { start: 1130, length: 1, convRule: rule22 },
    { start: 1131, length: 1, convRule: rule23 },
    { start: 1132, length: 1, convRule: rule22 },
    { start: 1133, length: 1, convRule: rule23 },
    { start: 1134, length: 1, convRule: rule22 },
    { start: 1135, length: 1, convRule: rule23 },
    { start: 1136, length: 1, convRule: rule22 },
    { start: 1137, length: 1, convRule: rule23 },
    { start: 1138, length: 1, convRule: rule22 },
    { start: 1139, length: 1, convRule: rule23 },
    { start: 1140, length: 1, convRule: rule22 },
    { start: 1141, length: 1, convRule: rule23 },
    { start: 1142, length: 1, convRule: rule22 },
    { start: 1143, length: 1, convRule: rule23 },
    { start: 1144, length: 1, convRule: rule22 },
    { start: 1145, length: 1, convRule: rule23 },
    { start: 1146, length: 1, convRule: rule22 },
    { start: 1147, length: 1, convRule: rule23 },
    { start: 1148, length: 1, convRule: rule22 },
    { start: 1149, length: 1, convRule: rule23 },
    { start: 1150, length: 1, convRule: rule22 },
    { start: 1151, length: 1, convRule: rule23 },
    { start: 1152, length: 1, convRule: rule22 },
    { start: 1153, length: 1, convRule: rule23 },
    { start: 1154, length: 1, convRule: rule13 },
    { start: 1155, length: 5, convRule: rule92 },
    { start: 1160, length: 2, convRule: rule119 },
    { start: 1162, length: 1, convRule: rule22 },
    { start: 1163, length: 1, convRule: rule23 },
    { start: 1164, length: 1, convRule: rule22 },
    { start: 1165, length: 1, convRule: rule23 },
    { start: 1166, length: 1, convRule: rule22 },
    { start: 1167, length: 1, convRule: rule23 },
    { start: 1168, length: 1, convRule: rule22 },
    { start: 1169, length: 1, convRule: rule23 },
    { start: 1170, length: 1, convRule: rule22 },
    { start: 1171, length: 1, convRule: rule23 },
    { start: 1172, length: 1, convRule: rule22 },
    { start: 1173, length: 1, convRule: rule23 },
    { start: 1174, length: 1, convRule: rule22 },
    { start: 1175, length: 1, convRule: rule23 },
    { start: 1176, length: 1, convRule: rule22 },
    { start: 1177, length: 1, convRule: rule23 },
    { start: 1178, length: 1, convRule: rule22 },
    { start: 1179, length: 1, convRule: rule23 },
    { start: 1180, length: 1, convRule: rule22 },
    { start: 1181, length: 1, convRule: rule23 },
    { start: 1182, length: 1, convRule: rule22 },
    { start: 1183, length: 1, convRule: rule23 },
    { start: 1184, length: 1, convRule: rule22 },
    { start: 1185, length: 1, convRule: rule23 },
    { start: 1186, length: 1, convRule: rule22 },
    { start: 1187, length: 1, convRule: rule23 },
    { start: 1188, length: 1, convRule: rule22 },
    { start: 1189, length: 1, convRule: rule23 },
    { start: 1190, length: 1, convRule: rule22 },
    { start: 1191, length: 1, convRule: rule23 },
    { start: 1192, length: 1, convRule: rule22 },
    { start: 1193, length: 1, convRule: rule23 },
    { start: 1194, length: 1, convRule: rule22 },
    { start: 1195, length: 1, convRule: rule23 },
    { start: 1196, length: 1, convRule: rule22 },
    { start: 1197, length: 1, convRule: rule23 },
    { start: 1198, length: 1, convRule: rule22 },
    { start: 1199, length: 1, convRule: rule23 },
    { start: 1200, length: 1, convRule: rule22 },
    { start: 1201, length: 1, convRule: rule23 },
    { start: 1202, length: 1, convRule: rule22 },
    { start: 1203, length: 1, convRule: rule23 },
    { start: 1204, length: 1, convRule: rule22 },
    { start: 1205, length: 1, convRule: rule23 },
    { start: 1206, length: 1, convRule: rule22 },
    { start: 1207, length: 1, convRule: rule23 },
    { start: 1208, length: 1, convRule: rule22 },
    { start: 1209, length: 1, convRule: rule23 },
    { start: 1210, length: 1, convRule: rule22 },
    { start: 1211, length: 1, convRule: rule23 },
    { start: 1212, length: 1, convRule: rule22 },
    { start: 1213, length: 1, convRule: rule23 },
    { start: 1214, length: 1, convRule: rule22 },
    { start: 1215, length: 1, convRule: rule23 },
    { start: 1216, length: 1, convRule: rule120 },
    { start: 1217, length: 1, convRule: rule22 },
    { start: 1218, length: 1, convRule: rule23 },
    { start: 1219, length: 1, convRule: rule22 },
    { start: 1220, length: 1, convRule: rule23 },
    { start: 1221, length: 1, convRule: rule22 },
    { start: 1222, length: 1, convRule: rule23 },
    { start: 1223, length: 1, convRule: rule22 },
    { start: 1224, length: 1, convRule: rule23 },
    { start: 1225, length: 1, convRule: rule22 },
    { start: 1226, length: 1, convRule: rule23 },
    { start: 1227, length: 1, convRule: rule22 },
    { start: 1228, length: 1, convRule: rule23 },
    { start: 1229, length: 1, convRule: rule22 },
    { start: 1230, length: 1, convRule: rule23 },
    { start: 1231, length: 1, convRule: rule121 },
    { start: 1232, length: 1, convRule: rule22 },
    { start: 1233, length: 1, convRule: rule23 },
    { start: 1234, length: 1, convRule: rule22 },
    { start: 1235, length: 1, convRule: rule23 },
    { start: 1236, length: 1, convRule: rule22 },
    { start: 1237, length: 1, convRule: rule23 },
    { start: 1238, length: 1, convRule: rule22 },
    { start: 1239, length: 1, convRule: rule23 },
    { start: 1240, length: 1, convRule: rule22 },
    { start: 1241, length: 1, convRule: rule23 },
    { start: 1242, length: 1, convRule: rule22 },
    { start: 1243, length: 1, convRule: rule23 },
    { start: 1244, length: 1, convRule: rule22 },
    { start: 1245, length: 1, convRule: rule23 },
    { start: 1246, length: 1, convRule: rule22 },
    { start: 1247, length: 1, convRule: rule23 },
    { start: 1248, length: 1, convRule: rule22 },
    { start: 1249, length: 1, convRule: rule23 },
    { start: 1250, length: 1, convRule: rule22 },
    { start: 1251, length: 1, convRule: rule23 },
    { start: 1252, length: 1, convRule: rule22 },
    { start: 1253, length: 1, convRule: rule23 },
    { start: 1254, length: 1, convRule: rule22 },
    { start: 1255, length: 1, convRule: rule23 },
    { start: 1256, length: 1, convRule: rule22 },
    { start: 1257, length: 1, convRule: rule23 },
    { start: 1258, length: 1, convRule: rule22 },
    { start: 1259, length: 1, convRule: rule23 },
    { start: 1260, length: 1, convRule: rule22 },
    { start: 1261, length: 1, convRule: rule23 },
    { start: 1262, length: 1, convRule: rule22 },
    { start: 1263, length: 1, convRule: rule23 },
    { start: 1264, length: 1, convRule: rule22 },
    { start: 1265, length: 1, convRule: rule23 },
    { start: 1266, length: 1, convRule: rule22 },
    { start: 1267, length: 1, convRule: rule23 },
    { start: 1268, length: 1, convRule: rule22 },
    { start: 1269, length: 1, convRule: rule23 },
    { start: 1270, length: 1, convRule: rule22 },
    { start: 1271, length: 1, convRule: rule23 },
    { start: 1272, length: 1, convRule: rule22 },
    { start: 1273, length: 1, convRule: rule23 },
    { start: 1274, length: 1, convRule: rule22 },
    { start: 1275, length: 1, convRule: rule23 },
    { start: 1276, length: 1, convRule: rule22 },
    { start: 1277, length: 1, convRule: rule23 },
    { start: 1278, length: 1, convRule: rule22 },
    { start: 1279, length: 1, convRule: rule23 },
    { start: 1280, length: 1, convRule: rule22 },
    { start: 1281, length: 1, convRule: rule23 },
    { start: 1282, length: 1, convRule: rule22 },
    { start: 1283, length: 1, convRule: rule23 },
    { start: 1284, length: 1, convRule: rule22 },
    { start: 1285, length: 1, convRule: rule23 },
    { start: 1286, length: 1, convRule: rule22 },
    { start: 1287, length: 1, convRule: rule23 },
    { start: 1288, length: 1, convRule: rule22 },
    { start: 1289, length: 1, convRule: rule23 },
    { start: 1290, length: 1, convRule: rule22 },
    { start: 1291, length: 1, convRule: rule23 },
    { start: 1292, length: 1, convRule: rule22 },
    { start: 1293, length: 1, convRule: rule23 },
    { start: 1294, length: 1, convRule: rule22 },
    { start: 1295, length: 1, convRule: rule23 },
    { start: 1296, length: 1, convRule: rule22 },
    { start: 1297, length: 1, convRule: rule23 },
    { start: 1298, length: 1, convRule: rule22 },
    { start: 1299, length: 1, convRule: rule23 },
    { start: 1300, length: 1, convRule: rule22 },
    { start: 1301, length: 1, convRule: rule23 },
    { start: 1302, length: 1, convRule: rule22 },
    { start: 1303, length: 1, convRule: rule23 },
    { start: 1304, length: 1, convRule: rule22 },
    { start: 1305, length: 1, convRule: rule23 },
    { start: 1306, length: 1, convRule: rule22 },
    { start: 1307, length: 1, convRule: rule23 },
    { start: 1308, length: 1, convRule: rule22 },
    { start: 1309, length: 1, convRule: rule23 },
    { start: 1310, length: 1, convRule: rule22 },
    { start: 1311, length: 1, convRule: rule23 },
    { start: 1312, length: 1, convRule: rule22 },
    { start: 1313, length: 1, convRule: rule23 },
    { start: 1314, length: 1, convRule: rule22 },
    { start: 1315, length: 1, convRule: rule23 },
    { start: 1316, length: 1, convRule: rule22 },
    { start: 1317, length: 1, convRule: rule23 },
    { start: 1318, length: 1, convRule: rule22 },
    { start: 1319, length: 1, convRule: rule23 },
    { start: 1320, length: 1, convRule: rule22 },
    { start: 1321, length: 1, convRule: rule23 },
    { start: 1322, length: 1, convRule: rule22 },
    { start: 1323, length: 1, convRule: rule23 },
    { start: 1324, length: 1, convRule: rule22 },
    { start: 1325, length: 1, convRule: rule23 },
    { start: 1326, length: 1, convRule: rule22 },
    { start: 1327, length: 1, convRule: rule23 },
    { start: 1329, length: 38, convRule: rule122 },
    { start: 1369, length: 1, convRule: rule91 },
    { start: 1370, length: 6, convRule: rule2 },
    { start: 1376, length: 1, convRule: rule20 },
    { start: 1377, length: 38, convRule: rule123 },
    { start: 1415, length: 2, convRule: rule20 },
    { start: 1417, length: 1, convRule: rule2 },
    { start: 1418, length: 1, convRule: rule7 },
    { start: 1421, length: 2, convRule: rule13 },
    { start: 1423, length: 1, convRule: rule3 },
    { start: 1425, length: 45, convRule: rule92 },
    { start: 1470, length: 1, convRule: rule7 },
    { start: 1471, length: 1, convRule: rule92 },
    { start: 1472, length: 1, convRule: rule2 },
    { start: 1473, length: 2, convRule: rule92 },
    { start: 1475, length: 1, convRule: rule2 },
    { start: 1476, length: 2, convRule: rule92 },
    { start: 1478, length: 1, convRule: rule2 },
    { start: 1479, length: 1, convRule: rule92 },
    { start: 1488, length: 27, convRule: rule14 },
    { start: 1519, length: 4, convRule: rule14 },
    { start: 1523, length: 2, convRule: rule2 },
    { start: 1536, length: 6, convRule: rule16 },
    { start: 1542, length: 3, convRule: rule6 },
    { start: 1545, length: 2, convRule: rule2 },
    { start: 1547, length: 1, convRule: rule3 },
    { start: 1548, length: 2, convRule: rule2 },
    { start: 1550, length: 2, convRule: rule13 },
    { start: 1552, length: 11, convRule: rule92 },
    { start: 1563, length: 1, convRule: rule2 },
    { start: 1564, length: 1, convRule: rule16 },
    { start: 1566, length: 2, convRule: rule2 },
    { start: 1568, length: 32, convRule: rule14 },
    { start: 1600, length: 1, convRule: rule91 },
    { start: 1601, length: 10, convRule: rule14 },
    { start: 1611, length: 21, convRule: rule92 },
    { start: 1632, length: 10, convRule: rule8 },
    { start: 1642, length: 4, convRule: rule2 },
    { start: 1646, length: 2, convRule: rule14 },
    { start: 1648, length: 1, convRule: rule92 },
    { start: 1649, length: 99, convRule: rule14 },
    { start: 1748, length: 1, convRule: rule2 },
    { start: 1749, length: 1, convRule: rule14 },
    { start: 1750, length: 7, convRule: rule92 },
    { start: 1757, length: 1, convRule: rule16 },
    { start: 1758, length: 1, convRule: rule13 },
    { start: 1759, length: 6, convRule: rule92 },
    { start: 1765, length: 2, convRule: rule91 },
    { start: 1767, length: 2, convRule: rule92 },
    { start: 1769, length: 1, convRule: rule13 },
    { start: 1770, length: 4, convRule: rule92 },
    { start: 1774, length: 2, convRule: rule14 },
    { start: 1776, length: 10, convRule: rule8 },
    { start: 1786, length: 3, convRule: rule14 },
    { start: 1789, length: 2, convRule: rule13 },
    { start: 1791, length: 1, convRule: rule14 },
    { start: 1792, length: 14, convRule: rule2 },
    { start: 1807, length: 1, convRule: rule16 },
    { start: 1808, length: 1, convRule: rule14 },
    { start: 1809, length: 1, convRule: rule92 },
    { start: 1810, length: 30, convRule: rule14 },
    { start: 1840, length: 27, convRule: rule92 },
    { start: 1869, length: 89, convRule: rule14 },
    { start: 1958, length: 11, convRule: rule92 },
    { start: 1969, length: 1, convRule: rule14 },
    { start: 1984, length: 10, convRule: rule8 },
    { start: 1994, length: 33, convRule: rule14 },
    { start: 2027, length: 9, convRule: rule92 },
    { start: 2036, length: 2, convRule: rule91 },
    { start: 2038, length: 1, convRule: rule13 },
    { start: 2039, length: 3, convRule: rule2 },
    { start: 2042, length: 1, convRule: rule91 },
    { start: 2045, length: 1, convRule: rule92 },
    { start: 2046, length: 2, convRule: rule3 },
    { start: 2048, length: 22, convRule: rule14 },
    { start: 2070, length: 4, convRule: rule92 },
    { start: 2074, length: 1, convRule: rule91 },
    { start: 2075, length: 9, convRule: rule92 },
    { start: 2084, length: 1, convRule: rule91 },
    { start: 2085, length: 3, convRule: rule92 },
    { start: 2088, length: 1, convRule: rule91 },
    { start: 2089, length: 5, convRule: rule92 },
    { start: 2096, length: 15, convRule: rule2 },
    { start: 2112, length: 25, convRule: rule14 },
    { start: 2137, length: 3, convRule: rule92 },
    { start: 2142, length: 1, convRule: rule2 },
    { start: 2144, length: 11, convRule: rule14 },
    { start: 2208, length: 21, convRule: rule14 },
    { start: 2230, length: 18, convRule: rule14 },
    { start: 2259, length: 15, convRule: rule92 },
    { start: 2274, length: 1, convRule: rule16 },
    { start: 2275, length: 32, convRule: rule92 },
    { start: 2307, length: 1, convRule: rule124 },
    { start: 2308, length: 54, convRule: rule14 },
    { start: 2362, length: 1, convRule: rule92 },
    { start: 2363, length: 1, convRule: rule124 },
    { start: 2364, length: 1, convRule: rule92 },
    { start: 2365, length: 1, convRule: rule14 },
    { start: 2366, length: 3, convRule: rule124 },
    { start: 2369, length: 8, convRule: rule92 },
    { start: 2377, length: 4, convRule: rule124 },
    { start: 2381, length: 1, convRule: rule92 },
    { start: 2382, length: 2, convRule: rule124 },
    { start: 2384, length: 1, convRule: rule14 },
    { start: 2385, length: 7, convRule: rule92 },
    { start: 2392, length: 10, convRule: rule14 },
    { start: 2402, length: 2, convRule: rule92 },
    { start: 2404, length: 2, convRule: rule2 },
    { start: 2406, length: 10, convRule: rule8 },
    { start: 2416, length: 1, convRule: rule2 },
    { start: 2417, length: 1, convRule: rule91 },
    { start: 2418, length: 15, convRule: rule14 },
    { start: 2433, length: 1, convRule: rule92 },
    { start: 2434, length: 2, convRule: rule124 },
    { start: 2437, length: 8, convRule: rule14 },
    { start: 2447, length: 2, convRule: rule14 },
    { start: 2451, length: 22, convRule: rule14 },
    { start: 2474, length: 7, convRule: rule14 },
    { start: 2482, length: 1, convRule: rule14 },
    { start: 2486, length: 4, convRule: rule14 },
    { start: 2492, length: 1, convRule: rule92 },
    { start: 2493, length: 1, convRule: rule14 },
    { start: 2494, length: 3, convRule: rule124 },
    { start: 2497, length: 4, convRule: rule92 },
    { start: 2503, length: 2, convRule: rule124 },
    { start: 2507, length: 2, convRule: rule124 },
    { start: 2509, length: 1, convRule: rule92 },
    { start: 2510, length: 1, convRule: rule14 },
    { start: 2519, length: 1, convRule: rule124 },
    { start: 2524, length: 2, convRule: rule14 },
    { start: 2527, length: 3, convRule: rule14 },
    { start: 2530, length: 2, convRule: rule92 },
    { start: 2534, length: 10, convRule: rule8 },
    { start: 2544, length: 2, convRule: rule14 },
    { start: 2546, length: 2, convRule: rule3 },
    { start: 2548, length: 6, convRule: rule17 },
    { start: 2554, length: 1, convRule: rule13 },
    { start: 2555, length: 1, convRule: rule3 },
    { start: 2556, length: 1, convRule: rule14 },
    { start: 2557, length: 1, convRule: rule2 },
    { start: 2558, length: 1, convRule: rule92 },
    { start: 2561, length: 2, convRule: rule92 },
    { start: 2563, length: 1, convRule: rule124 },
    { start: 2565, length: 6, convRule: rule14 },
    { start: 2575, length: 2, convRule: rule14 },
    { start: 2579, length: 22, convRule: rule14 },
    { start: 2602, length: 7, convRule: rule14 },
    { start: 2610, length: 2, convRule: rule14 },
    { start: 2613, length: 2, convRule: rule14 },
    { start: 2616, length: 2, convRule: rule14 },
    { start: 2620, length: 1, convRule: rule92 },
    { start: 2622, length: 3, convRule: rule124 },
    { start: 2625, length: 2, convRule: rule92 },
    { start: 2631, length: 2, convRule: rule92 },
    { start: 2635, length: 3, convRule: rule92 },
    { start: 2641, length: 1, convRule: rule92 },
    { start: 2649, length: 4, convRule: rule14 },
    { start: 2654, length: 1, convRule: rule14 },
    { start: 2662, length: 10, convRule: rule8 },
    { start: 2672, length: 2, convRule: rule92 },
    { start: 2674, length: 3, convRule: rule14 },
    { start: 2677, length: 1, convRule: rule92 },
    { start: 2678, length: 1, convRule: rule2 },
    { start: 2689, length: 2, convRule: rule92 },
    { start: 2691, length: 1, convRule: rule124 },
    { start: 2693, length: 9, convRule: rule14 },
    { start: 2703, length: 3, convRule: rule14 },
    { start: 2707, length: 22, convRule: rule14 },
    { start: 2730, length: 7, convRule: rule14 },
    { start: 2738, length: 2, convRule: rule14 },
    { start: 2741, length: 5, convRule: rule14 },
    { start: 2748, length: 1, convRule: rule92 },
    { start: 2749, length: 1, convRule: rule14 },
    { start: 2750, length: 3, convRule: rule124 },
    { start: 2753, length: 5, convRule: rule92 },
    { start: 2759, length: 2, convRule: rule92 },
    { start: 2761, length: 1, convRule: rule124 },
    { start: 2763, length: 2, convRule: rule124 },
    { start: 2765, length: 1, convRule: rule92 },
    { start: 2768, length: 1, convRule: rule14 },
    { start: 2784, length: 2, convRule: rule14 },
    { start: 2786, length: 2, convRule: rule92 },
    { start: 2790, length: 10, convRule: rule8 },
    { start: 2800, length: 1, convRule: rule2 },
    { start: 2801, length: 1, convRule: rule3 },
    { start: 2809, length: 1, convRule: rule14 },
    { start: 2810, length: 6, convRule: rule92 },
    { start: 2817, length: 1, convRule: rule92 },
    { start: 2818, length: 2, convRule: rule124 },
    { start: 2821, length: 8, convRule: rule14 },
    { start: 2831, length: 2, convRule: rule14 },
    { start: 2835, length: 22, convRule: rule14 },
    { start: 2858, length: 7, convRule: rule14 },
    { start: 2866, length: 2, convRule: rule14 },
    { start: 2869, length: 5, convRule: rule14 },
    { start: 2876, length: 1, convRule: rule92 },
    { start: 2877, length: 1, convRule: rule14 },
    { start: 2878, length: 1, convRule: rule124 },
    { start: 2879, length: 1, convRule: rule92 },
    { start: 2880, length: 1, convRule: rule124 },
    { start: 2881, length: 4, convRule: rule92 },
    { start: 2887, length: 2, convRule: rule124 },
    { start: 2891, length: 2, convRule: rule124 },
    { start: 2893, length: 1, convRule: rule92 },
    { start: 2901, length: 2, convRule: rule92 },
    { start: 2903, length: 1, convRule: rule124 },
    { start: 2908, length: 2, convRule: rule14 },
    { start: 2911, length: 3, convRule: rule14 },
    { start: 2914, length: 2, convRule: rule92 },
    { start: 2918, length: 10, convRule: rule8 },
    { start: 2928, length: 1, convRule: rule13 },
    { start: 2929, length: 1, convRule: rule14 },
    { start: 2930, length: 6, convRule: rule17 },
    { start: 2946, length: 1, convRule: rule92 },
    { start: 2947, length: 1, convRule: rule14 },
    { start: 2949, length: 6, convRule: rule14 },
    { start: 2958, length: 3, convRule: rule14 },
    { start: 2962, length: 4, convRule: rule14 },
    { start: 2969, length: 2, convRule: rule14 },
    { start: 2972, length: 1, convRule: rule14 },
    { start: 2974, length: 2, convRule: rule14 },
    { start: 2979, length: 2, convRule: rule14 },
    { start: 2984, length: 3, convRule: rule14 },
    { start: 2990, length: 12, convRule: rule14 },
    { start: 3006, length: 2, convRule: rule124 },
    { start: 3008, length: 1, convRule: rule92 },
    { start: 3009, length: 2, convRule: rule124 },
    { start: 3014, length: 3, convRule: rule124 },
    { start: 3018, length: 3, convRule: rule124 },
    { start: 3021, length: 1, convRule: rule92 },
    { start: 3024, length: 1, convRule: rule14 },
    { start: 3031, length: 1, convRule: rule124 },
    { start: 3046, length: 10, convRule: rule8 },
    { start: 3056, length: 3, convRule: rule17 },
    { start: 3059, length: 6, convRule: rule13 },
    { start: 3065, length: 1, convRule: rule3 },
    { start: 3066, length: 1, convRule: rule13 },
    { start: 3072, length: 1, convRule: rule92 },
    { start: 3073, length: 3, convRule: rule124 },
    { start: 3076, length: 1, convRule: rule92 },
    { start: 3077, length: 8, convRule: rule14 },
    { start: 3086, length: 3, convRule: rule14 },
    { start: 3090, length: 23, convRule: rule14 },
    { start: 3114, length: 16, convRule: rule14 },
    { start: 3133, length: 1, convRule: rule14 },
    { start: 3134, length: 3, convRule: rule92 },
    { start: 3137, length: 4, convRule: rule124 },
    { start: 3142, length: 3, convRule: rule92 },
    { start: 3146, length: 4, convRule: rule92 },
    { start: 3157, length: 2, convRule: rule92 },
    { start: 3160, length: 3, convRule: rule14 },
    { start: 3168, length: 2, convRule: rule14 },
    { start: 3170, length: 2, convRule: rule92 },
    { start: 3174, length: 10, convRule: rule8 },
    { start: 3191, length: 1, convRule: rule2 },
    { start: 3192, length: 7, convRule: rule17 },
    { start: 3199, length: 1, convRule: rule13 },
    { start: 3200, length: 1, convRule: rule14 },
    { start: 3201, length: 1, convRule: rule92 },
    { start: 3202, length: 2, convRule: rule124 },
    { start: 3204, length: 1, convRule: rule2 },
    { start: 3205, length: 8, convRule: rule14 },
    { start: 3214, length: 3, convRule: rule14 },
    { start: 3218, length: 23, convRule: rule14 },
    { start: 3242, length: 10, convRule: rule14 },
    { start: 3253, length: 5, convRule: rule14 },
    { start: 3260, length: 1, convRule: rule92 },
    { start: 3261, length: 1, convRule: rule14 },
    { start: 3262, length: 1, convRule: rule124 },
    { start: 3263, length: 1, convRule: rule92 },
    { start: 3264, length: 5, convRule: rule124 },
    { start: 3270, length: 1, convRule: rule92 },
    { start: 3271, length: 2, convRule: rule124 },
    { start: 3274, length: 2, convRule: rule124 },
    { start: 3276, length: 2, convRule: rule92 },
    { start: 3285, length: 2, convRule: rule124 },
    { start: 3294, length: 1, convRule: rule14 },
    { start: 3296, length: 2, convRule: rule14 },
    { start: 3298, length: 2, convRule: rule92 },
    { start: 3302, length: 10, convRule: rule8 },
    { start: 3313, length: 2, convRule: rule14 },
    { start: 3328, length: 2, convRule: rule92 },
    { start: 3330, length: 2, convRule: rule124 },
    { start: 3332, length: 9, convRule: rule14 },
    { start: 3342, length: 3, convRule: rule14 },
    { start: 3346, length: 41, convRule: rule14 },
    { start: 3387, length: 2, convRule: rule92 },
    { start: 3389, length: 1, convRule: rule14 },
    { start: 3390, length: 3, convRule: rule124 },
    { start: 3393, length: 4, convRule: rule92 },
    { start: 3398, length: 3, convRule: rule124 },
    { start: 3402, length: 3, convRule: rule124 },
    { start: 3405, length: 1, convRule: rule92 },
    { start: 3406, length: 1, convRule: rule14 },
    { start: 3407, length: 1, convRule: rule13 },
    { start: 3412, length: 3, convRule: rule14 },
    { start: 3415, length: 1, convRule: rule124 },
    { start: 3416, length: 7, convRule: rule17 },
    { start: 3423, length: 3, convRule: rule14 },
    { start: 3426, length: 2, convRule: rule92 },
    { start: 3430, length: 10, convRule: rule8 },
    { start: 3440, length: 9, convRule: rule17 },
    { start: 3449, length: 1, convRule: rule13 },
    { start: 3450, length: 6, convRule: rule14 },
    { start: 3457, length: 1, convRule: rule92 },
    { start: 3458, length: 2, convRule: rule124 },
    { start: 3461, length: 18, convRule: rule14 },
    { start: 3482, length: 24, convRule: rule14 },
    { start: 3507, length: 9, convRule: rule14 },
    { start: 3517, length: 1, convRule: rule14 },
    { start: 3520, length: 7, convRule: rule14 },
    { start: 3530, length: 1, convRule: rule92 },
    { start: 3535, length: 3, convRule: rule124 },
    { start: 3538, length: 3, convRule: rule92 },
    { start: 3542, length: 1, convRule: rule92 },
    { start: 3544, length: 8, convRule: rule124 },
    { start: 3558, length: 10, convRule: rule8 },
    { start: 3570, length: 2, convRule: rule124 },
    { start: 3572, length: 1, convRule: rule2 },
    { start: 3585, length: 48, convRule: rule14 },
    { start: 3633, length: 1, convRule: rule92 },
    { start: 3634, length: 2, convRule: rule14 },
    { start: 3636, length: 7, convRule: rule92 },
    { start: 3647, length: 1, convRule: rule3 },
    { start: 3648, length: 6, convRule: rule14 },
    { start: 3654, length: 1, convRule: rule91 },
    { start: 3655, length: 8, convRule: rule92 },
    { start: 3663, length: 1, convRule: rule2 },
    { start: 3664, length: 10, convRule: rule8 },
    { start: 3674, length: 2, convRule: rule2 },
    { start: 3713, length: 2, convRule: rule14 },
    { start: 3716, length: 1, convRule: rule14 },
    { start: 3718, length: 5, convRule: rule14 },
    { start: 3724, length: 24, convRule: rule14 },
    { start: 3749, length: 1, convRule: rule14 },
    { start: 3751, length: 10, convRule: rule14 },
    { start: 3761, length: 1, convRule: rule92 },
    { start: 3762, length: 2, convRule: rule14 },
    { start: 3764, length: 9, convRule: rule92 },
    { start: 3773, length: 1, convRule: rule14 },
    { start: 3776, length: 5, convRule: rule14 },
    { start: 3782, length: 1, convRule: rule91 },
    { start: 3784, length: 6, convRule: rule92 },
    { start: 3792, length: 10, convRule: rule8 },
    { start: 3804, length: 4, convRule: rule14 },
    { start: 3840, length: 1, convRule: rule14 },
    { start: 3841, length: 3, convRule: rule13 },
    { start: 3844, length: 15, convRule: rule2 },
    { start: 3859, length: 1, convRule: rule13 },
    { start: 3860, length: 1, convRule: rule2 },
    { start: 3861, length: 3, convRule: rule13 },
    { start: 3864, length: 2, convRule: rule92 },
    { start: 3866, length: 6, convRule: rule13 },
    { start: 3872, length: 10, convRule: rule8 },
    { start: 3882, length: 10, convRule: rule17 },
    { start: 3892, length: 1, convRule: rule13 },
    { start: 3893, length: 1, convRule: rule92 },
    { start: 3894, length: 1, convRule: rule13 },
    { start: 3895, length: 1, convRule: rule92 },
    { start: 3896, length: 1, convRule: rule13 },
    { start: 3897, length: 1, convRule: rule92 },
    { start: 3898, length: 1, convRule: rule4 },
    { start: 3899, length: 1, convRule: rule5 },
    { start: 3900, length: 1, convRule: rule4 },
    { start: 3901, length: 1, convRule: rule5 },
    { start: 3902, length: 2, convRule: rule124 },
    { start: 3904, length: 8, convRule: rule14 },
    { start: 3913, length: 36, convRule: rule14 },
    { start: 3953, length: 14, convRule: rule92 },
    { start: 3967, length: 1, convRule: rule124 },
    { start: 3968, length: 5, convRule: rule92 },
    { start: 3973, length: 1, convRule: rule2 },
    { start: 3974, length: 2, convRule: rule92 },
    { start: 3976, length: 5, convRule: rule14 },
    { start: 3981, length: 11, convRule: rule92 },
    { start: 3993, length: 36, convRule: rule92 },
    { start: 4030, length: 8, convRule: rule13 },
    { start: 4038, length: 1, convRule: rule92 },
    { start: 4039, length: 6, convRule: rule13 },
    { start: 4046, length: 2, convRule: rule13 },
    { start: 4048, length: 5, convRule: rule2 },
    { start: 4053, length: 4, convRule: rule13 },
    { start: 4057, length: 2, convRule: rule2 },
    { start: 4096, length: 43, convRule: rule14 },
    { start: 4139, length: 2, convRule: rule124 },
    { start: 4141, length: 4, convRule: rule92 },
    { start: 4145, length: 1, convRule: rule124 },
    { start: 4146, length: 6, convRule: rule92 },
    { start: 4152, length: 1, convRule: rule124 },
    { start: 4153, length: 2, convRule: rule92 },
    { start: 4155, length: 2, convRule: rule124 },
    { start: 4157, length: 2, convRule: rule92 },
    { start: 4159, length: 1, convRule: rule14 },
    { start: 4160, length: 10, convRule: rule8 },
    { start: 4170, length: 6, convRule: rule2 },
    { start: 4176, length: 6, convRule: rule14 },
    { start: 4182, length: 2, convRule: rule124 },
    { start: 4184, length: 2, convRule: rule92 },
    { start: 4186, length: 4, convRule: rule14 },
    { start: 4190, length: 3, convRule: rule92 },
    { start: 4193, length: 1, convRule: rule14 },
    { start: 4194, length: 3, convRule: rule124 },
    { start: 4197, length: 2, convRule: rule14 },
    { start: 4199, length: 7, convRule: rule124 },
    { start: 4206, length: 3, convRule: rule14 },
    { start: 4209, length: 4, convRule: rule92 },
    { start: 4213, length: 13, convRule: rule14 },
    { start: 4226, length: 1, convRule: rule92 },
    { start: 4227, length: 2, convRule: rule124 },
    { start: 4229, length: 2, convRule: rule92 },
    { start: 4231, length: 6, convRule: rule124 },
    { start: 4237, length: 1, convRule: rule92 },
    { start: 4238, length: 1, convRule: rule14 },
    { start: 4239, length: 1, convRule: rule124 },
    { start: 4240, length: 10, convRule: rule8 },
    { start: 4250, length: 3, convRule: rule124 },
    { start: 4253, length: 1, convRule: rule92 },
    { start: 4254, length: 2, convRule: rule13 },
    { start: 4256, length: 38, convRule: rule125 },
    { start: 4295, length: 1, convRule: rule125 },
    { start: 4301, length: 1, convRule: rule125 },
    { start: 4304, length: 43, convRule: rule126 },
    { start: 4347, length: 1, convRule: rule2 },
    { start: 4348, length: 1, convRule: rule91 },
    { start: 4349, length: 3, convRule: rule126 },
    { start: 4352, length: 329, convRule: rule14 },
    { start: 4682, length: 4, convRule: rule14 },
    { start: 4688, length: 7, convRule: rule14 },
    { start: 4696, length: 1, convRule: rule14 },
    { start: 4698, length: 4, convRule: rule14 },
    { start: 4704, length: 41, convRule: rule14 },
    { start: 4746, length: 4, convRule: rule14 },
    { start: 4752, length: 33, convRule: rule14 },
    { start: 4786, length: 4, convRule: rule14 },
    { start: 4792, length: 7, convRule: rule14 },
    { start: 4800, length: 1, convRule: rule14 },
    { start: 4802, length: 4, convRule: rule14 },
    { start: 4808, length: 15, convRule: rule14 },
    { start: 4824, length: 57, convRule: rule14 },
    { start: 4882, length: 4, convRule: rule14 },
    { start: 4888, length: 67, convRule: rule14 },
    { start: 4957, length: 3, convRule: rule92 },
    { start: 4960, length: 9, convRule: rule2 },
    { start: 4969, length: 20, convRule: rule17 },
    { start: 4992, length: 16, convRule: rule14 },
    { start: 5008, length: 10, convRule: rule13 },
    { start: 5024, length: 80, convRule: rule127 },
    { start: 5104, length: 6, convRule: rule104 },
    { start: 5112, length: 6, convRule: rule110 },
    { start: 5120, length: 1, convRule: rule7 },
    { start: 5121, length: 620, convRule: rule14 },
    { start: 5741, length: 1, convRule: rule13 },
    { start: 5742, length: 1, convRule: rule2 },
    { start: 5743, length: 17, convRule: rule14 },
    { start: 5760, length: 1, convRule: rule1 },
    { start: 5761, length: 26, convRule: rule14 },
    { start: 5787, length: 1, convRule: rule4 },
    { start: 5788, length: 1, convRule: rule5 },
    { start: 5792, length: 75, convRule: rule14 },
    { start: 5867, length: 3, convRule: rule2 },
    { start: 5870, length: 3, convRule: rule128 },
    { start: 5873, length: 8, convRule: rule14 },
    { start: 5888, length: 13, convRule: rule14 },
    { start: 5902, length: 4, convRule: rule14 },
    { start: 5906, length: 3, convRule: rule92 },
    { start: 5920, length: 18, convRule: rule14 },
    { start: 5938, length: 3, convRule: rule92 },
    { start: 5941, length: 2, convRule: rule2 },
    { start: 5952, length: 18, convRule: rule14 },
    { start: 5970, length: 2, convRule: rule92 },
    { start: 5984, length: 13, convRule: rule14 },
    { start: 5998, length: 3, convRule: rule14 },
    { start: 6002, length: 2, convRule: rule92 },
    { start: 6016, length: 52, convRule: rule14 },
    { start: 6068, length: 2, convRule: rule92 },
    { start: 6070, length: 1, convRule: rule124 },
    { start: 6071, length: 7, convRule: rule92 },
    { start: 6078, length: 8, convRule: rule124 },
    { start: 6086, length: 1, convRule: rule92 },
    { start: 6087, length: 2, convRule: rule124 },
    { start: 6089, length: 11, convRule: rule92 },
    { start: 6100, length: 3, convRule: rule2 },
    { start: 6103, length: 1, convRule: rule91 },
    { start: 6104, length: 3, convRule: rule2 },
    { start: 6107, length: 1, convRule: rule3 },
    { start: 6108, length: 1, convRule: rule14 },
    { start: 6109, length: 1, convRule: rule92 },
    { start: 6112, length: 10, convRule: rule8 },
    { start: 6128, length: 10, convRule: rule17 },
    { start: 6144, length: 6, convRule: rule2 },
    { start: 6150, length: 1, convRule: rule7 },
    { start: 6151, length: 4, convRule: rule2 },
    { start: 6155, length: 3, convRule: rule92 },
    { start: 6158, length: 1, convRule: rule16 },
    { start: 6160, length: 10, convRule: rule8 },
    { start: 6176, length: 35, convRule: rule14 },
    { start: 6211, length: 1, convRule: rule91 },
    { start: 6212, length: 53, convRule: rule14 },
    { start: 6272, length: 5, convRule: rule14 },
    { start: 6277, length: 2, convRule: rule92 },
    { start: 6279, length: 34, convRule: rule14 },
    { start: 6313, length: 1, convRule: rule92 },
    { start: 6314, length: 1, convRule: rule14 },
    { start: 6320, length: 70, convRule: rule14 },
    { start: 6400, length: 31, convRule: rule14 },
    { start: 6432, length: 3, convRule: rule92 },
    { start: 6435, length: 4, convRule: rule124 },
    { start: 6439, length: 2, convRule: rule92 },
    { start: 6441, length: 3, convRule: rule124 },
    { start: 6448, length: 2, convRule: rule124 },
    { start: 6450, length: 1, convRule: rule92 },
    { start: 6451, length: 6, convRule: rule124 },
    { start: 6457, length: 3, convRule: rule92 },
    { start: 6464, length: 1, convRule: rule13 },
    { start: 6468, length: 2, convRule: rule2 },
    { start: 6470, length: 10, convRule: rule8 },
    { start: 6480, length: 30, convRule: rule14 },
    { start: 6512, length: 5, convRule: rule14 },
    { start: 6528, length: 44, convRule: rule14 },
    { start: 6576, length: 26, convRule: rule14 },
    { start: 6608, length: 10, convRule: rule8 },
    { start: 6618, length: 1, convRule: rule17 },
    { start: 6622, length: 34, convRule: rule13 },
    { start: 6656, length: 23, convRule: rule14 },
    { start: 6679, length: 2, convRule: rule92 },
    { start: 6681, length: 2, convRule: rule124 },
    { start: 6683, length: 1, convRule: rule92 },
    { start: 6686, length: 2, convRule: rule2 },
    { start: 6688, length: 53, convRule: rule14 },
    { start: 6741, length: 1, convRule: rule124 },
    { start: 6742, length: 1, convRule: rule92 },
    { start: 6743, length: 1, convRule: rule124 },
    { start: 6744, length: 7, convRule: rule92 },
    { start: 6752, length: 1, convRule: rule92 },
    { start: 6753, length: 1, convRule: rule124 },
    { start: 6754, length: 1, convRule: rule92 },
    { start: 6755, length: 2, convRule: rule124 },
    { start: 6757, length: 8, convRule: rule92 },
    { start: 6765, length: 6, convRule: rule124 },
    { start: 6771, length: 10, convRule: rule92 },
    { start: 6783, length: 1, convRule: rule92 },
    { start: 6784, length: 10, convRule: rule8 },
    { start: 6800, length: 10, convRule: rule8 },
    { start: 6816, length: 7, convRule: rule2 },
    { start: 6823, length: 1, convRule: rule91 },
    { start: 6824, length: 6, convRule: rule2 },
    { start: 6832, length: 14, convRule: rule92 },
    { start: 6846, length: 1, convRule: rule119 },
    { start: 6847, length: 2, convRule: rule92 },
    { start: 6912, length: 4, convRule: rule92 },
    { start: 6916, length: 1, convRule: rule124 },
    { start: 6917, length: 47, convRule: rule14 },
    { start: 6964, length: 1, convRule: rule92 },
    { start: 6965, length: 1, convRule: rule124 },
    { start: 6966, length: 5, convRule: rule92 },
    { start: 6971, length: 1, convRule: rule124 },
    { start: 6972, length: 1, convRule: rule92 },
    { start: 6973, length: 5, convRule: rule124 },
    { start: 6978, length: 1, convRule: rule92 },
    { start: 6979, length: 2, convRule: rule124 },
    { start: 6981, length: 7, convRule: rule14 },
    { start: 6992, length: 10, convRule: rule8 },
    { start: 7002, length: 7, convRule: rule2 },
    { start: 7009, length: 10, convRule: rule13 },
    { start: 7019, length: 9, convRule: rule92 },
    { start: 7028, length: 9, convRule: rule13 },
    { start: 7040, length: 2, convRule: rule92 },
    { start: 7042, length: 1, convRule: rule124 },
    { start: 7043, length: 30, convRule: rule14 },
    { start: 7073, length: 1, convRule: rule124 },
    { start: 7074, length: 4, convRule: rule92 },
    { start: 7078, length: 2, convRule: rule124 },
    { start: 7080, length: 2, convRule: rule92 },
    { start: 7082, length: 1, convRule: rule124 },
    { start: 7083, length: 3, convRule: rule92 },
    { start: 7086, length: 2, convRule: rule14 },
    { start: 7088, length: 10, convRule: rule8 },
    { start: 7098, length: 44, convRule: rule14 },
    { start: 7142, length: 1, convRule: rule92 },
    { start: 7143, length: 1, convRule: rule124 },
    { start: 7144, length: 2, convRule: rule92 },
    { start: 7146, length: 3, convRule: rule124 },
    { start: 7149, length: 1, convRule: rule92 },
    { start: 7150, length: 1, convRule: rule124 },
    { start: 7151, length: 3, convRule: rule92 },
    { start: 7154, length: 2, convRule: rule124 },
    { start: 7164, length: 4, convRule: rule2 },
    { start: 7168, length: 36, convRule: rule14 },
    { start: 7204, length: 8, convRule: rule124 },
    { start: 7212, length: 8, convRule: rule92 },
    { start: 7220, length: 2, convRule: rule124 },
    { start: 7222, length: 2, convRule: rule92 },
    { start: 7227, length: 5, convRule: rule2 },
    { start: 7232, length: 10, convRule: rule8 },
    { start: 7245, length: 3, convRule: rule14 },
    { start: 7248, length: 10, convRule: rule8 },
    { start: 7258, length: 30, convRule: rule14 },
    { start: 7288, length: 6, convRule: rule91 },
    { start: 7294, length: 2, convRule: rule2 },
    { start: 7296, length: 1, convRule: rule129 },
    { start: 7297, length: 1, convRule: rule130 },
    { start: 7298, length: 1, convRule: rule131 },
    { start: 7299, length: 2, convRule: rule132 },
    { start: 7301, length: 1, convRule: rule133 },
    { start: 7302, length: 1, convRule: rule134 },
    { start: 7303, length: 1, convRule: rule135 },
    { start: 7304, length: 1, convRule: rule136 },
    { start: 7312, length: 43, convRule: rule137 },
    { start: 7357, length: 3, convRule: rule137 },
    { start: 7360, length: 8, convRule: rule2 },
    { start: 7376, length: 3, convRule: rule92 },
    { start: 7379, length: 1, convRule: rule2 },
    { start: 7380, length: 13, convRule: rule92 },
    { start: 7393, length: 1, convRule: rule124 },
    { start: 7394, length: 7, convRule: rule92 },
    { start: 7401, length: 4, convRule: rule14 },
    { start: 7405, length: 1, convRule: rule92 },
    { start: 7406, length: 6, convRule: rule14 },
    { start: 7412, length: 1, convRule: rule92 },
    { start: 7413, length: 2, convRule: rule14 },
    { start: 7415, length: 1, convRule: rule124 },
    { start: 7416, length: 2, convRule: rule92 },
    { start: 7418, length: 1, convRule: rule14 },
    { start: 7424, length: 44, convRule: rule20 },
    { start: 7468, length: 63, convRule: rule91 },
    { start: 7531, length: 13, convRule: rule20 },
    { start: 7544, length: 1, convRule: rule91 },
    { start: 7545, length: 1, convRule: rule138 },
    { start: 7546, length: 3, convRule: rule20 },
    { start: 7549, length: 1, convRule: rule139 },
    { start: 7550, length: 16, convRule: rule20 },
    { start: 7566, length: 1, convRule: rule140 },
    { start: 7567, length: 12, convRule: rule20 },
    { start: 7579, length: 37, convRule: rule91 },
    { start: 7616, length: 58, convRule: rule92 },
    { start: 7675, length: 5, convRule: rule92 },
    { start: 7680, length: 1, convRule: rule22 },
    { start: 7681, length: 1, convRule: rule23 },
    { start: 7682, length: 1, convRule: rule22 },
    { start: 7683, length: 1, convRule: rule23 },
    { start: 7684, length: 1, convRule: rule22 },
    { start: 7685, length: 1, convRule: rule23 },
    { start: 7686, length: 1, convRule: rule22 },
    { start: 7687, length: 1, convRule: rule23 },
    { start: 7688, length: 1, convRule: rule22 },
    { start: 7689, length: 1, convRule: rule23 },
    { start: 7690, length: 1, convRule: rule22 },
    { start: 7691, length: 1, convRule: rule23 },
    { start: 7692, length: 1, convRule: rule22 },
    { start: 7693, length: 1, convRule: rule23 },
    { start: 7694, length: 1, convRule: rule22 },
    { start: 7695, length: 1, convRule: rule23 },
    { start: 7696, length: 1, convRule: rule22 },
    { start: 7697, length: 1, convRule: rule23 },
    { start: 7698, length: 1, convRule: rule22 },
    { start: 7699, length: 1, convRule: rule23 },
    { start: 7700, length: 1, convRule: rule22 },
    { start: 7701, length: 1, convRule: rule23 },
    { start: 7702, length: 1, convRule: rule22 },
    { start: 7703, length: 1, convRule: rule23 },
    { start: 7704, length: 1, convRule: rule22 },
    { start: 7705, length: 1, convRule: rule23 },
    { start: 7706, length: 1, convRule: rule22 },
    { start: 7707, length: 1, convRule: rule23 },
    { start: 7708, length: 1, convRule: rule22 },
    { start: 7709, length: 1, convRule: rule23 },
    { start: 7710, length: 1, convRule: rule22 },
    { start: 7711, length: 1, convRule: rule23 },
    { start: 7712, length: 1, convRule: rule22 },
    { start: 7713, length: 1, convRule: rule23 },
    { start: 7714, length: 1, convRule: rule22 },
    { start: 7715, length: 1, convRule: rule23 },
    { start: 7716, length: 1, convRule: rule22 },
    { start: 7717, length: 1, convRule: rule23 },
    { start: 7718, length: 1, convRule: rule22 },
    { start: 7719, length: 1, convRule: rule23 },
    { start: 7720, length: 1, convRule: rule22 },
    { start: 7721, length: 1, convRule: rule23 },
    { start: 7722, length: 1, convRule: rule22 },
    { start: 7723, length: 1, convRule: rule23 },
    { start: 7724, length: 1, convRule: rule22 },
    { start: 7725, length: 1, convRule: rule23 },
    { start: 7726, length: 1, convRule: rule22 },
    { start: 7727, length: 1, convRule: rule23 },
    { start: 7728, length: 1, convRule: rule22 },
    { start: 7729, length: 1, convRule: rule23 },
    { start: 7730, length: 1, convRule: rule22 },
    { start: 7731, length: 1, convRule: rule23 },
    { start: 7732, length: 1, convRule: rule22 },
    { start: 7733, length: 1, convRule: rule23 },
    { start: 7734, length: 1, convRule: rule22 },
    { start: 7735, length: 1, convRule: rule23 },
    { start: 7736, length: 1, convRule: rule22 },
    { start: 7737, length: 1, convRule: rule23 },
    { start: 7738, length: 1, convRule: rule22 },
    { start: 7739, length: 1, convRule: rule23 },
    { start: 7740, length: 1, convRule: rule22 },
    { start: 7741, length: 1, convRule: rule23 },
    { start: 7742, length: 1, convRule: rule22 },
    { start: 7743, length: 1, convRule: rule23 },
    { start: 7744, length: 1, convRule: rule22 },
    { start: 7745, length: 1, convRule: rule23 },
    { start: 7746, length: 1, convRule: rule22 },
    { start: 7747, length: 1, convRule: rule23 },
    { start: 7748, length: 1, convRule: rule22 },
    { start: 7749, length: 1, convRule: rule23 },
    { start: 7750, length: 1, convRule: rule22 },
    { start: 7751, length: 1, convRule: rule23 },
    { start: 7752, length: 1, convRule: rule22 },
    { start: 7753, length: 1, convRule: rule23 },
    { start: 7754, length: 1, convRule: rule22 },
    { start: 7755, length: 1, convRule: rule23 },
    { start: 7756, length: 1, convRule: rule22 },
    { start: 7757, length: 1, convRule: rule23 },
    { start: 7758, length: 1, convRule: rule22 },
    { start: 7759, length: 1, convRule: rule23 },
    { start: 7760, length: 1, convRule: rule22 },
    { start: 7761, length: 1, convRule: rule23 },
    { start: 7762, length: 1, convRule: rule22 },
    { start: 7763, length: 1, convRule: rule23 },
    { start: 7764, length: 1, convRule: rule22 },
    { start: 7765, length: 1, convRule: rule23 },
    { start: 7766, length: 1, convRule: rule22 },
    { start: 7767, length: 1, convRule: rule23 },
    { start: 7768, length: 1, convRule: rule22 },
    { start: 7769, length: 1, convRule: rule23 },
    { start: 7770, length: 1, convRule: rule22 },
    { start: 7771, length: 1, convRule: rule23 },
    { start: 7772, length: 1, convRule: rule22 },
    { start: 7773, length: 1, convRule: rule23 },
    { start: 7774, length: 1, convRule: rule22 },
    { start: 7775, length: 1, convRule: rule23 },
    { start: 7776, length: 1, convRule: rule22 },
    { start: 7777, length: 1, convRule: rule23 },
    { start: 7778, length: 1, convRule: rule22 },
    { start: 7779, length: 1, convRule: rule23 },
    { start: 7780, length: 1, convRule: rule22 },
    { start: 7781, length: 1, convRule: rule23 },
    { start: 7782, length: 1, convRule: rule22 },
    { start: 7783, length: 1, convRule: rule23 },
    { start: 7784, length: 1, convRule: rule22 },
    { start: 7785, length: 1, convRule: rule23 },
    { start: 7786, length: 1, convRule: rule22 },
    { start: 7787, length: 1, convRule: rule23 },
    { start: 7788, length: 1, convRule: rule22 },
    { start: 7789, length: 1, convRule: rule23 },
    { start: 7790, length: 1, convRule: rule22 },
    { start: 7791, length: 1, convRule: rule23 },
    { start: 7792, length: 1, convRule: rule22 },
    { start: 7793, length: 1, convRule: rule23 },
    { start: 7794, length: 1, convRule: rule22 },
    { start: 7795, length: 1, convRule: rule23 },
    { start: 7796, length: 1, convRule: rule22 },
    { start: 7797, length: 1, convRule: rule23 },
    { start: 7798, length: 1, convRule: rule22 },
    { start: 7799, length: 1, convRule: rule23 },
    { start: 7800, length: 1, convRule: rule22 },
    { start: 7801, length: 1, convRule: rule23 },
    { start: 7802, length: 1, convRule: rule22 },
    { start: 7803, length: 1, convRule: rule23 },
    { start: 7804, length: 1, convRule: rule22 },
    { start: 7805, length: 1, convRule: rule23 },
    { start: 7806, length: 1, convRule: rule22 },
    { start: 7807, length: 1, convRule: rule23 },
    { start: 7808, length: 1, convRule: rule22 },
    { start: 7809, length: 1, convRule: rule23 },
    { start: 7810, length: 1, convRule: rule22 },
    { start: 7811, length: 1, convRule: rule23 },
    { start: 7812, length: 1, convRule: rule22 },
    { start: 7813, length: 1, convRule: rule23 },
    { start: 7814, length: 1, convRule: rule22 },
    { start: 7815, length: 1, convRule: rule23 },
    { start: 7816, length: 1, convRule: rule22 },
    { start: 7817, length: 1, convRule: rule23 },
    { start: 7818, length: 1, convRule: rule22 },
    { start: 7819, length: 1, convRule: rule23 },
    { start: 7820, length: 1, convRule: rule22 },
    { start: 7821, length: 1, convRule: rule23 },
    { start: 7822, length: 1, convRule: rule22 },
    { start: 7823, length: 1, convRule: rule23 },
    { start: 7824, length: 1, convRule: rule22 },
    { start: 7825, length: 1, convRule: rule23 },
    { start: 7826, length: 1, convRule: rule22 },
    { start: 7827, length: 1, convRule: rule23 },
    { start: 7828, length: 1, convRule: rule22 },
    { start: 7829, length: 1, convRule: rule23 },
    { start: 7830, length: 5, convRule: rule20 },
    { start: 7835, length: 1, convRule: rule141 },
    { start: 7836, length: 2, convRule: rule20 },
    { start: 7838, length: 1, convRule: rule142 },
    { start: 7839, length: 1, convRule: rule20 },
    { start: 7840, length: 1, convRule: rule22 },
    { start: 7841, length: 1, convRule: rule23 },
    { start: 7842, length: 1, convRule: rule22 },
    { start: 7843, length: 1, convRule: rule23 },
    { start: 7844, length: 1, convRule: rule22 },
    { start: 7845, length: 1, convRule: rule23 },
    { start: 7846, length: 1, convRule: rule22 },
    { start: 7847, length: 1, convRule: rule23 },
    { start: 7848, length: 1, convRule: rule22 },
    { start: 7849, length: 1, convRule: rule23 },
    { start: 7850, length: 1, convRule: rule22 },
    { start: 7851, length: 1, convRule: rule23 },
    { start: 7852, length: 1, convRule: rule22 },
    { start: 7853, length: 1, convRule: rule23 },
    { start: 7854, length: 1, convRule: rule22 },
    { start: 7855, length: 1, convRule: rule23 },
    { start: 7856, length: 1, convRule: rule22 },
    { start: 7857, length: 1, convRule: rule23 },
    { start: 7858, length: 1, convRule: rule22 },
    { start: 7859, length: 1, convRule: rule23 },
    { start: 7860, length: 1, convRule: rule22 },
    { start: 7861, length: 1, convRule: rule23 },
    { start: 7862, length: 1, convRule: rule22 },
    { start: 7863, length: 1, convRule: rule23 },
    { start: 7864, length: 1, convRule: rule22 },
    { start: 7865, length: 1, convRule: rule23 },
    { start: 7866, length: 1, convRule: rule22 },
    { start: 7867, length: 1, convRule: rule23 },
    { start: 7868, length: 1, convRule: rule22 },
    { start: 7869, length: 1, convRule: rule23 },
    { start: 7870, length: 1, convRule: rule22 },
    { start: 7871, length: 1, convRule: rule23 },
    { start: 7872, length: 1, convRule: rule22 },
    { start: 7873, length: 1, convRule: rule23 },
    { start: 7874, length: 1, convRule: rule22 },
    { start: 7875, length: 1, convRule: rule23 },
    { start: 7876, length: 1, convRule: rule22 },
    { start: 7877, length: 1, convRule: rule23 },
    { start: 7878, length: 1, convRule: rule22 },
    { start: 7879, length: 1, convRule: rule23 },
    { start: 7880, length: 1, convRule: rule22 },
    { start: 7881, length: 1, convRule: rule23 },
    { start: 7882, length: 1, convRule: rule22 },
    { start: 7883, length: 1, convRule: rule23 },
    { start: 7884, length: 1, convRule: rule22 },
    { start: 7885, length: 1, convRule: rule23 },
    { start: 7886, length: 1, convRule: rule22 },
    { start: 7887, length: 1, convRule: rule23 },
    { start: 7888, length: 1, convRule: rule22 },
    { start: 7889, length: 1, convRule: rule23 },
    { start: 7890, length: 1, convRule: rule22 },
    { start: 7891, length: 1, convRule: rule23 },
    { start: 7892, length: 1, convRule: rule22 },
    { start: 7893, length: 1, convRule: rule23 },
    { start: 7894, length: 1, convRule: rule22 },
    { start: 7895, length: 1, convRule: rule23 },
    { start: 7896, length: 1, convRule: rule22 },
    { start: 7897, length: 1, convRule: rule23 },
    { start: 7898, length: 1, convRule: rule22 },
    { start: 7899, length: 1, convRule: rule23 },
    { start: 7900, length: 1, convRule: rule22 },
    { start: 7901, length: 1, convRule: rule23 },
    { start: 7902, length: 1, convRule: rule22 },
    { start: 7903, length: 1, convRule: rule23 },
    { start: 7904, length: 1, convRule: rule22 },
    { start: 7905, length: 1, convRule: rule23 },
    { start: 7906, length: 1, convRule: rule22 },
    { start: 7907, length: 1, convRule: rule23 },
    { start: 7908, length: 1, convRule: rule22 },
    { start: 7909, length: 1, convRule: rule23 },
    { start: 7910, length: 1, convRule: rule22 },
    { start: 7911, length: 1, convRule: rule23 },
    { start: 7912, length: 1, convRule: rule22 },
    { start: 7913, length: 1, convRule: rule23 },
    { start: 7914, length: 1, convRule: rule22 },
    { start: 7915, length: 1, convRule: rule23 },
    { start: 7916, length: 1, convRule: rule22 },
    { start: 7917, length: 1, convRule: rule23 },
    { start: 7918, length: 1, convRule: rule22 },
    { start: 7919, length: 1, convRule: rule23 },
    { start: 7920, length: 1, convRule: rule22 },
    { start: 7921, length: 1, convRule: rule23 },
    { start: 7922, length: 1, convRule: rule22 },
    { start: 7923, length: 1, convRule: rule23 },
    { start: 7924, length: 1, convRule: rule22 },
    { start: 7925, length: 1, convRule: rule23 },
    { start: 7926, length: 1, convRule: rule22 },
    { start: 7927, length: 1, convRule: rule23 },
    { start: 7928, length: 1, convRule: rule22 },
    { start: 7929, length: 1, convRule: rule23 },
    { start: 7930, length: 1, convRule: rule22 },
    { start: 7931, length: 1, convRule: rule23 },
    { start: 7932, length: 1, convRule: rule22 },
    { start: 7933, length: 1, convRule: rule23 },
    { start: 7934, length: 1, convRule: rule22 },
    { start: 7935, length: 1, convRule: rule23 },
    { start: 7936, length: 8, convRule: rule143 },
    { start: 7944, length: 8, convRule: rule144 },
    { start: 7952, length: 6, convRule: rule143 },
    { start: 7960, length: 6, convRule: rule144 },
    { start: 7968, length: 8, convRule: rule143 },
    { start: 7976, length: 8, convRule: rule144 },
    { start: 7984, length: 8, convRule: rule143 },
    { start: 7992, length: 8, convRule: rule144 },
    { start: 8e3, length: 6, convRule: rule143 },
    { start: 8008, length: 6, convRule: rule144 },
    { start: 8016, length: 1, convRule: rule20 },
    { start: 8017, length: 1, convRule: rule143 },
    { start: 8018, length: 1, convRule: rule20 },
    { start: 8019, length: 1, convRule: rule143 },
    { start: 8020, length: 1, convRule: rule20 },
    { start: 8021, length: 1, convRule: rule143 },
    { start: 8022, length: 1, convRule: rule20 },
    { start: 8023, length: 1, convRule: rule143 },
    { start: 8025, length: 1, convRule: rule144 },
    { start: 8027, length: 1, convRule: rule144 },
    { start: 8029, length: 1, convRule: rule144 },
    { start: 8031, length: 1, convRule: rule144 },
    { start: 8032, length: 8, convRule: rule143 },
    { start: 8040, length: 8, convRule: rule144 },
    { start: 8048, length: 2, convRule: rule145 },
    { start: 8050, length: 4, convRule: rule146 },
    { start: 8054, length: 2, convRule: rule147 },
    { start: 8056, length: 2, convRule: rule148 },
    { start: 8058, length: 2, convRule: rule149 },
    { start: 8060, length: 2, convRule: rule150 },
    { start: 8064, length: 8, convRule: rule143 },
    { start: 8072, length: 8, convRule: rule151 },
    { start: 8080, length: 8, convRule: rule143 },
    { start: 8088, length: 8, convRule: rule151 },
    { start: 8096, length: 8, convRule: rule143 },
    { start: 8104, length: 8, convRule: rule151 },
    { start: 8112, length: 2, convRule: rule143 },
    { start: 8114, length: 1, convRule: rule20 },
    { start: 8115, length: 1, convRule: rule152 },
    { start: 8116, length: 1, convRule: rule20 },
    { start: 8118, length: 2, convRule: rule20 },
    { start: 8120, length: 2, convRule: rule144 },
    { start: 8122, length: 2, convRule: rule153 },
    { start: 8124, length: 1, convRule: rule154 },
    { start: 8125, length: 1, convRule: rule10 },
    { start: 8126, length: 1, convRule: rule155 },
    { start: 8127, length: 3, convRule: rule10 },
    { start: 8130, length: 1, convRule: rule20 },
    { start: 8131, length: 1, convRule: rule152 },
    { start: 8132, length: 1, convRule: rule20 },
    { start: 8134, length: 2, convRule: rule20 },
    { start: 8136, length: 4, convRule: rule156 },
    { start: 8140, length: 1, convRule: rule154 },
    { start: 8141, length: 3, convRule: rule10 },
    { start: 8144, length: 2, convRule: rule143 },
    { start: 8146, length: 2, convRule: rule20 },
    { start: 8150, length: 2, convRule: rule20 },
    { start: 8152, length: 2, convRule: rule144 },
    { start: 8154, length: 2, convRule: rule157 },
    { start: 8157, length: 3, convRule: rule10 },
    { start: 8160, length: 2, convRule: rule143 },
    { start: 8162, length: 3, convRule: rule20 },
    { start: 8165, length: 1, convRule: rule113 },
    { start: 8166, length: 2, convRule: rule20 },
    { start: 8168, length: 2, convRule: rule144 },
    { start: 8170, length: 2, convRule: rule158 },
    { start: 8172, length: 1, convRule: rule117 },
    { start: 8173, length: 3, convRule: rule10 },
    { start: 8178, length: 1, convRule: rule20 },
    { start: 8179, length: 1, convRule: rule152 },
    { start: 8180, length: 1, convRule: rule20 },
    { start: 8182, length: 2, convRule: rule20 },
    { start: 8184, length: 2, convRule: rule159 },
    { start: 8186, length: 2, convRule: rule160 },
    { start: 8188, length: 1, convRule: rule154 },
    { start: 8189, length: 2, convRule: rule10 },
    { start: 8192, length: 11, convRule: rule1 },
    { start: 8203, length: 5, convRule: rule16 },
    { start: 8208, length: 6, convRule: rule7 },
    { start: 8214, length: 2, convRule: rule2 },
    { start: 8216, length: 1, convRule: rule15 },
    { start: 8217, length: 1, convRule: rule19 },
    { start: 8218, length: 1, convRule: rule4 },
    { start: 8219, length: 2, convRule: rule15 },
    { start: 8221, length: 1, convRule: rule19 },
    { start: 8222, length: 1, convRule: rule4 },
    { start: 8223, length: 1, convRule: rule15 },
    { start: 8224, length: 8, convRule: rule2 },
    { start: 8232, length: 1, convRule: rule161 },
    { start: 8233, length: 1, convRule: rule162 },
    { start: 8234, length: 5, convRule: rule16 },
    { start: 8239, length: 1, convRule: rule1 },
    { start: 8240, length: 9, convRule: rule2 },
    { start: 8249, length: 1, convRule: rule15 },
    { start: 8250, length: 1, convRule: rule19 },
    { start: 8251, length: 4, convRule: rule2 },
    { start: 8255, length: 2, convRule: rule11 },
    { start: 8257, length: 3, convRule: rule2 },
    { start: 8260, length: 1, convRule: rule6 },
    { start: 8261, length: 1, convRule: rule4 },
    { start: 8262, length: 1, convRule: rule5 },
    { start: 8263, length: 11, convRule: rule2 },
    { start: 8274, length: 1, convRule: rule6 },
    { start: 8275, length: 1, convRule: rule2 },
    { start: 8276, length: 1, convRule: rule11 },
    { start: 8277, length: 10, convRule: rule2 },
    { start: 8287, length: 1, convRule: rule1 },
    { start: 8288, length: 5, convRule: rule16 },
    { start: 8294, length: 10, convRule: rule16 },
    { start: 8304, length: 1, convRule: rule17 },
    { start: 8305, length: 1, convRule: rule91 },
    { start: 8308, length: 6, convRule: rule17 },
    { start: 8314, length: 3, convRule: rule6 },
    { start: 8317, length: 1, convRule: rule4 },
    { start: 8318, length: 1, convRule: rule5 },
    { start: 8319, length: 1, convRule: rule91 },
    { start: 8320, length: 10, convRule: rule17 },
    { start: 8330, length: 3, convRule: rule6 },
    { start: 8333, length: 1, convRule: rule4 },
    { start: 8334, length: 1, convRule: rule5 },
    { start: 8336, length: 13, convRule: rule91 },
    { start: 8352, length: 32, convRule: rule3 },
    { start: 8400, length: 13, convRule: rule92 },
    { start: 8413, length: 4, convRule: rule119 },
    { start: 8417, length: 1, convRule: rule92 },
    { start: 8418, length: 3, convRule: rule119 },
    { start: 8421, length: 12, convRule: rule92 },
    { start: 8448, length: 2, convRule: rule13 },
    { start: 8450, length: 1, convRule: rule107 },
    { start: 8451, length: 4, convRule: rule13 },
    { start: 8455, length: 1, convRule: rule107 },
    { start: 8456, length: 2, convRule: rule13 },
    { start: 8458, length: 1, convRule: rule20 },
    { start: 8459, length: 3, convRule: rule107 },
    { start: 8462, length: 2, convRule: rule20 },
    { start: 8464, length: 3, convRule: rule107 },
    { start: 8467, length: 1, convRule: rule20 },
    { start: 8468, length: 1, convRule: rule13 },
    { start: 8469, length: 1, convRule: rule107 },
    { start: 8470, length: 2, convRule: rule13 },
    { start: 8472, length: 1, convRule: rule6 },
    { start: 8473, length: 5, convRule: rule107 },
    { start: 8478, length: 6, convRule: rule13 },
    { start: 8484, length: 1, convRule: rule107 },
    { start: 8485, length: 1, convRule: rule13 },
    { start: 8486, length: 1, convRule: rule163 },
    { start: 8487, length: 1, convRule: rule13 },
    { start: 8488, length: 1, convRule: rule107 },
    { start: 8489, length: 1, convRule: rule13 },
    { start: 8490, length: 1, convRule: rule164 },
    { start: 8491, length: 1, convRule: rule165 },
    { start: 8492, length: 2, convRule: rule107 },
    { start: 8494, length: 1, convRule: rule13 },
    { start: 8495, length: 1, convRule: rule20 },
    { start: 8496, length: 2, convRule: rule107 },
    { start: 8498, length: 1, convRule: rule166 },
    { start: 8499, length: 1, convRule: rule107 },
    { start: 8500, length: 1, convRule: rule20 },
    { start: 8501, length: 4, convRule: rule14 },
    { start: 8505, length: 1, convRule: rule20 },
    { start: 8506, length: 2, convRule: rule13 },
    { start: 8508, length: 2, convRule: rule20 },
    { start: 8510, length: 2, convRule: rule107 },
    { start: 8512, length: 5, convRule: rule6 },
    { start: 8517, length: 1, convRule: rule107 },
    { start: 8518, length: 4, convRule: rule20 },
    { start: 8522, length: 1, convRule: rule13 },
    { start: 8523, length: 1, convRule: rule6 },
    { start: 8524, length: 2, convRule: rule13 },
    { start: 8526, length: 1, convRule: rule167 },
    { start: 8527, length: 1, convRule: rule13 },
    { start: 8528, length: 16, convRule: rule17 },
    { start: 8544, length: 16, convRule: rule168 },
    { start: 8560, length: 16, convRule: rule169 },
    { start: 8576, length: 3, convRule: rule128 },
    { start: 8579, length: 1, convRule: rule22 },
    { start: 8580, length: 1, convRule: rule23 },
    { start: 8581, length: 4, convRule: rule128 },
    { start: 8585, length: 1, convRule: rule17 },
    { start: 8586, length: 2, convRule: rule13 },
    { start: 8592, length: 5, convRule: rule6 },
    { start: 8597, length: 5, convRule: rule13 },
    { start: 8602, length: 2, convRule: rule6 },
    { start: 8604, length: 4, convRule: rule13 },
    { start: 8608, length: 1, convRule: rule6 },
    { start: 8609, length: 2, convRule: rule13 },
    { start: 8611, length: 1, convRule: rule6 },
    { start: 8612, length: 2, convRule: rule13 },
    { start: 8614, length: 1, convRule: rule6 },
    { start: 8615, length: 7, convRule: rule13 },
    { start: 8622, length: 1, convRule: rule6 },
    { start: 8623, length: 31, convRule: rule13 },
    { start: 8654, length: 2, convRule: rule6 },
    { start: 8656, length: 2, convRule: rule13 },
    { start: 8658, length: 1, convRule: rule6 },
    { start: 8659, length: 1, convRule: rule13 },
    { start: 8660, length: 1, convRule: rule6 },
    { start: 8661, length: 31, convRule: rule13 },
    { start: 8692, length: 268, convRule: rule6 },
    { start: 8960, length: 8, convRule: rule13 },
    { start: 8968, length: 1, convRule: rule4 },
    { start: 8969, length: 1, convRule: rule5 },
    { start: 8970, length: 1, convRule: rule4 },
    { start: 8971, length: 1, convRule: rule5 },
    { start: 8972, length: 20, convRule: rule13 },
    { start: 8992, length: 2, convRule: rule6 },
    { start: 8994, length: 7, convRule: rule13 },
    { start: 9001, length: 1, convRule: rule4 },
    { start: 9002, length: 1, convRule: rule5 },
    { start: 9003, length: 81, convRule: rule13 },
    { start: 9084, length: 1, convRule: rule6 },
    { start: 9085, length: 30, convRule: rule13 },
    { start: 9115, length: 25, convRule: rule6 },
    { start: 9140, length: 40, convRule: rule13 },
    { start: 9180, length: 6, convRule: rule6 },
    { start: 9186, length: 69, convRule: rule13 },
    { start: 9280, length: 11, convRule: rule13 },
    { start: 9312, length: 60, convRule: rule17 },
    { start: 9372, length: 26, convRule: rule13 },
    { start: 9398, length: 26, convRule: rule170 },
    { start: 9424, length: 26, convRule: rule171 },
    { start: 9450, length: 22, convRule: rule17 },
    { start: 9472, length: 183, convRule: rule13 },
    { start: 9655, length: 1, convRule: rule6 },
    { start: 9656, length: 9, convRule: rule13 },
    { start: 9665, length: 1, convRule: rule6 },
    { start: 9666, length: 54, convRule: rule13 },
    { start: 9720, length: 8, convRule: rule6 },
    { start: 9728, length: 111, convRule: rule13 },
    { start: 9839, length: 1, convRule: rule6 },
    { start: 9840, length: 248, convRule: rule13 },
    { start: 10088, length: 1, convRule: rule4 },
    { start: 10089, length: 1, convRule: rule5 },
    { start: 10090, length: 1, convRule: rule4 },
    { start: 10091, length: 1, convRule: rule5 },
    { start: 10092, length: 1, convRule: rule4 },
    { start: 10093, length: 1, convRule: rule5 },
    { start: 10094, length: 1, convRule: rule4 },
    { start: 10095, length: 1, convRule: rule5 },
    { start: 10096, length: 1, convRule: rule4 },
    { start: 10097, length: 1, convRule: rule5 },
    { start: 10098, length: 1, convRule: rule4 },
    { start: 10099, length: 1, convRule: rule5 },
    { start: 10100, length: 1, convRule: rule4 },
    { start: 10101, length: 1, convRule: rule5 },
    { start: 10102, length: 30, convRule: rule17 },
    { start: 10132, length: 44, convRule: rule13 },
    { start: 10176, length: 5, convRule: rule6 },
    { start: 10181, length: 1, convRule: rule4 },
    { start: 10182, length: 1, convRule: rule5 },
    { start: 10183, length: 31, convRule: rule6 },
    { start: 10214, length: 1, convRule: rule4 },
    { start: 10215, length: 1, convRule: rule5 },
    { start: 10216, length: 1, convRule: rule4 },
    { start: 10217, length: 1, convRule: rule5 },
    { start: 10218, length: 1, convRule: rule4 },
    { start: 10219, length: 1, convRule: rule5 },
    { start: 10220, length: 1, convRule: rule4 },
    { start: 10221, length: 1, convRule: rule5 },
    { start: 10222, length: 1, convRule: rule4 },
    { start: 10223, length: 1, convRule: rule5 },
    { start: 10224, length: 16, convRule: rule6 },
    { start: 10240, length: 256, convRule: rule13 },
    { start: 10496, length: 131, convRule: rule6 },
    { start: 10627, length: 1, convRule: rule4 },
    { start: 10628, length: 1, convRule: rule5 },
    { start: 10629, length: 1, convRule: rule4 },
    { start: 10630, length: 1, convRule: rule5 },
    { start: 10631, length: 1, convRule: rule4 },
    { start: 10632, length: 1, convRule: rule5 },
    { start: 10633, length: 1, convRule: rule4 },
    { start: 10634, length: 1, convRule: rule5 },
    { start: 10635, length: 1, convRule: rule4 },
    { start: 10636, length: 1, convRule: rule5 },
    { start: 10637, length: 1, convRule: rule4 },
    { start: 10638, length: 1, convRule: rule5 },
    { start: 10639, length: 1, convRule: rule4 },
    { start: 10640, length: 1, convRule: rule5 },
    { start: 10641, length: 1, convRule: rule4 },
    { start: 10642, length: 1, convRule: rule5 },
    { start: 10643, length: 1, convRule: rule4 },
    { start: 10644, length: 1, convRule: rule5 },
    { start: 10645, length: 1, convRule: rule4 },
    { start: 10646, length: 1, convRule: rule5 },
    { start: 10647, length: 1, convRule: rule4 },
    { start: 10648, length: 1, convRule: rule5 },
    { start: 10649, length: 63, convRule: rule6 },
    { start: 10712, length: 1, convRule: rule4 },
    { start: 10713, length: 1, convRule: rule5 },
    { start: 10714, length: 1, convRule: rule4 },
    { start: 10715, length: 1, convRule: rule5 },
    { start: 10716, length: 32, convRule: rule6 },
    { start: 10748, length: 1, convRule: rule4 },
    { start: 10749, length: 1, convRule: rule5 },
    { start: 10750, length: 258, convRule: rule6 },
    { start: 11008, length: 48, convRule: rule13 },
    { start: 11056, length: 21, convRule: rule6 },
    { start: 11077, length: 2, convRule: rule13 },
    { start: 11079, length: 6, convRule: rule6 },
    { start: 11085, length: 39, convRule: rule13 },
    { start: 11126, length: 32, convRule: rule13 },
    { start: 11159, length: 105, convRule: rule13 },
    { start: 11264, length: 47, convRule: rule122 },
    { start: 11312, length: 47, convRule: rule123 },
    { start: 11360, length: 1, convRule: rule22 },
    { start: 11361, length: 1, convRule: rule23 },
    { start: 11362, length: 1, convRule: rule172 },
    { start: 11363, length: 1, convRule: rule173 },
    { start: 11364, length: 1, convRule: rule174 },
    { start: 11365, length: 1, convRule: rule175 },
    { start: 11366, length: 1, convRule: rule176 },
    { start: 11367, length: 1, convRule: rule22 },
    { start: 11368, length: 1, convRule: rule23 },
    { start: 11369, length: 1, convRule: rule22 },
    { start: 11370, length: 1, convRule: rule23 },
    { start: 11371, length: 1, convRule: rule22 },
    { start: 11372, length: 1, convRule: rule23 },
    { start: 11373, length: 1, convRule: rule177 },
    { start: 11374, length: 1, convRule: rule178 },
    { start: 11375, length: 1, convRule: rule179 },
    { start: 11376, length: 1, convRule: rule180 },
    { start: 11377, length: 1, convRule: rule20 },
    { start: 11378, length: 1, convRule: rule22 },
    { start: 11379, length: 1, convRule: rule23 },
    { start: 11380, length: 1, convRule: rule20 },
    { start: 11381, length: 1, convRule: rule22 },
    { start: 11382, length: 1, convRule: rule23 },
    { start: 11383, length: 5, convRule: rule20 },
    { start: 11388, length: 2, convRule: rule91 },
    { start: 11390, length: 2, convRule: rule181 },
    { start: 11392, length: 1, convRule: rule22 },
    { start: 11393, length: 1, convRule: rule23 },
    { start: 11394, length: 1, convRule: rule22 },
    { start: 11395, length: 1, convRule: rule23 },
    { start: 11396, length: 1, convRule: rule22 },
    { start: 11397, length: 1, convRule: rule23 },
    { start: 11398, length: 1, convRule: rule22 },
    { start: 11399, length: 1, convRule: rule23 },
    { start: 11400, length: 1, convRule: rule22 },
    { start: 11401, length: 1, convRule: rule23 },
    { start: 11402, length: 1, convRule: rule22 },
    { start: 11403, length: 1, convRule: rule23 },
    { start: 11404, length: 1, convRule: rule22 },
    { start: 11405, length: 1, convRule: rule23 },
    { start: 11406, length: 1, convRule: rule22 },
    { start: 11407, length: 1, convRule: rule23 },
    { start: 11408, length: 1, convRule: rule22 },
    { start: 11409, length: 1, convRule: rule23 },
    { start: 11410, length: 1, convRule: rule22 },
    { start: 11411, length: 1, convRule: rule23 },
    { start: 11412, length: 1, convRule: rule22 },
    { start: 11413, length: 1, convRule: rule23 },
    { start: 11414, length: 1, convRule: rule22 },
    { start: 11415, length: 1, convRule: rule23 },
    { start: 11416, length: 1, convRule: rule22 },
    { start: 11417, length: 1, convRule: rule23 },
    { start: 11418, length: 1, convRule: rule22 },
    { start: 11419, length: 1, convRule: rule23 },
    { start: 11420, length: 1, convRule: rule22 },
    { start: 11421, length: 1, convRule: rule23 },
    { start: 11422, length: 1, convRule: rule22 },
    { start: 11423, length: 1, convRule: rule23 },
    { start: 11424, length: 1, convRule: rule22 },
    { start: 11425, length: 1, convRule: rule23 },
    { start: 11426, length: 1, convRule: rule22 },
    { start: 11427, length: 1, convRule: rule23 },
    { start: 11428, length: 1, convRule: rule22 },
    { start: 11429, length: 1, convRule: rule23 },
    { start: 11430, length: 1, convRule: rule22 },
    { start: 11431, length: 1, convRule: rule23 },
    { start: 11432, length: 1, convRule: rule22 },
    { start: 11433, length: 1, convRule: rule23 },
    { start: 11434, length: 1, convRule: rule22 },
    { start: 11435, length: 1, convRule: rule23 },
    { start: 11436, length: 1, convRule: rule22 },
    { start: 11437, length: 1, convRule: rule23 },
    { start: 11438, length: 1, convRule: rule22 },
    { start: 11439, length: 1, convRule: rule23 },
    { start: 11440, length: 1, convRule: rule22 },
    { start: 11441, length: 1, convRule: rule23 },
    { start: 11442, length: 1, convRule: rule22 },
    { start: 11443, length: 1, convRule: rule23 },
    { start: 11444, length: 1, convRule: rule22 },
    { start: 11445, length: 1, convRule: rule23 },
    { start: 11446, length: 1, convRule: rule22 },
    { start: 11447, length: 1, convRule: rule23 },
    { start: 11448, length: 1, convRule: rule22 },
    { start: 11449, length: 1, convRule: rule23 },
    { start: 11450, length: 1, convRule: rule22 },
    { start: 11451, length: 1, convRule: rule23 },
    { start: 11452, length: 1, convRule: rule22 },
    { start: 11453, length: 1, convRule: rule23 },
    { start: 11454, length: 1, convRule: rule22 },
    { start: 11455, length: 1, convRule: rule23 },
    { start: 11456, length: 1, convRule: rule22 },
    { start: 11457, length: 1, convRule: rule23 },
    { start: 11458, length: 1, convRule: rule22 },
    { start: 11459, length: 1, convRule: rule23 },
    { start: 11460, length: 1, convRule: rule22 },
    { start: 11461, length: 1, convRule: rule23 },
    { start: 11462, length: 1, convRule: rule22 },
    { start: 11463, length: 1, convRule: rule23 },
    { start: 11464, length: 1, convRule: rule22 },
    { start: 11465, length: 1, convRule: rule23 },
    { start: 11466, length: 1, convRule: rule22 },
    { start: 11467, length: 1, convRule: rule23 },
    { start: 11468, length: 1, convRule: rule22 },
    { start: 11469, length: 1, convRule: rule23 },
    { start: 11470, length: 1, convRule: rule22 },
    { start: 11471, length: 1, convRule: rule23 },
    { start: 11472, length: 1, convRule: rule22 },
    { start: 11473, length: 1, convRule: rule23 },
    { start: 11474, length: 1, convRule: rule22 },
    { start: 11475, length: 1, convRule: rule23 },
    { start: 11476, length: 1, convRule: rule22 },
    { start: 11477, length: 1, convRule: rule23 },
    { start: 11478, length: 1, convRule: rule22 },
    { start: 11479, length: 1, convRule: rule23 },
    { start: 11480, length: 1, convRule: rule22 },
    { start: 11481, length: 1, convRule: rule23 },
    { start: 11482, length: 1, convRule: rule22 },
    { start: 11483, length: 1, convRule: rule23 },
    { start: 11484, length: 1, convRule: rule22 },
    { start: 11485, length: 1, convRule: rule23 },
    { start: 11486, length: 1, convRule: rule22 },
    { start: 11487, length: 1, convRule: rule23 },
    { start: 11488, length: 1, convRule: rule22 },
    { start: 11489, length: 1, convRule: rule23 },
    { start: 11490, length: 1, convRule: rule22 },
    { start: 11491, length: 1, convRule: rule23 },
    { start: 11492, length: 1, convRule: rule20 },
    { start: 11493, length: 6, convRule: rule13 },
    { start: 11499, length: 1, convRule: rule22 },
    { start: 11500, length: 1, convRule: rule23 },
    { start: 11501, length: 1, convRule: rule22 },
    { start: 11502, length: 1, convRule: rule23 },
    { start: 11503, length: 3, convRule: rule92 },
    { start: 11506, length: 1, convRule: rule22 },
    { start: 11507, length: 1, convRule: rule23 },
    { start: 11513, length: 4, convRule: rule2 },
    { start: 11517, length: 1, convRule: rule17 },
    { start: 11518, length: 2, convRule: rule2 },
    { start: 11520, length: 38, convRule: rule182 },
    { start: 11559, length: 1, convRule: rule182 },
    { start: 11565, length: 1, convRule: rule182 },
    { start: 11568, length: 56, convRule: rule14 },
    { start: 11631, length: 1, convRule: rule91 },
    { start: 11632, length: 1, convRule: rule2 },
    { start: 11647, length: 1, convRule: rule92 },
    { start: 11648, length: 23, convRule: rule14 },
    { start: 11680, length: 7, convRule: rule14 },
    { start: 11688, length: 7, convRule: rule14 },
    { start: 11696, length: 7, convRule: rule14 },
    { start: 11704, length: 7, convRule: rule14 },
    { start: 11712, length: 7, convRule: rule14 },
    { start: 11720, length: 7, convRule: rule14 },
    { start: 11728, length: 7, convRule: rule14 },
    { start: 11736, length: 7, convRule: rule14 },
    { start: 11744, length: 32, convRule: rule92 },
    { start: 11776, length: 2, convRule: rule2 },
    { start: 11778, length: 1, convRule: rule15 },
    { start: 11779, length: 1, convRule: rule19 },
    { start: 11780, length: 1, convRule: rule15 },
    { start: 11781, length: 1, convRule: rule19 },
    { start: 11782, length: 3, convRule: rule2 },
    { start: 11785, length: 1, convRule: rule15 },
    { start: 11786, length: 1, convRule: rule19 },
    { start: 11787, length: 1, convRule: rule2 },
    { start: 11788, length: 1, convRule: rule15 },
    { start: 11789, length: 1, convRule: rule19 },
    { start: 11790, length: 9, convRule: rule2 },
    { start: 11799, length: 1, convRule: rule7 },
    { start: 11800, length: 2, convRule: rule2 },
    { start: 11802, length: 1, convRule: rule7 },
    { start: 11803, length: 1, convRule: rule2 },
    { start: 11804, length: 1, convRule: rule15 },
    { start: 11805, length: 1, convRule: rule19 },
    { start: 11806, length: 2, convRule: rule2 },
    { start: 11808, length: 1, convRule: rule15 },
    { start: 11809, length: 1, convRule: rule19 },
    { start: 11810, length: 1, convRule: rule4 },
    { start: 11811, length: 1, convRule: rule5 },
    { start: 11812, length: 1, convRule: rule4 },
    { start: 11813, length: 1, convRule: rule5 },
    { start: 11814, length: 1, convRule: rule4 },
    { start: 11815, length: 1, convRule: rule5 },
    { start: 11816, length: 1, convRule: rule4 },
    { start: 11817, length: 1, convRule: rule5 },
    { start: 11818, length: 5, convRule: rule2 },
    { start: 11823, length: 1, convRule: rule91 },
    { start: 11824, length: 10, convRule: rule2 },
    { start: 11834, length: 2, convRule: rule7 },
    { start: 11836, length: 4, convRule: rule2 },
    { start: 11840, length: 1, convRule: rule7 },
    { start: 11841, length: 1, convRule: rule2 },
    { start: 11842, length: 1, convRule: rule4 },
    { start: 11843, length: 13, convRule: rule2 },
    { start: 11856, length: 2, convRule: rule13 },
    { start: 11858, length: 1, convRule: rule2 },
    { start: 11904, length: 26, convRule: rule13 },
    { start: 11931, length: 89, convRule: rule13 },
    { start: 12032, length: 214, convRule: rule13 },
    { start: 12272, length: 12, convRule: rule13 },
    { start: 12288, length: 1, convRule: rule1 },
    { start: 12289, length: 3, convRule: rule2 },
    { start: 12292, length: 1, convRule: rule13 },
    { start: 12293, length: 1, convRule: rule91 },
    { start: 12294, length: 1, convRule: rule14 },
    { start: 12295, length: 1, convRule: rule128 },
    { start: 12296, length: 1, convRule: rule4 },
    { start: 12297, length: 1, convRule: rule5 },
    { start: 12298, length: 1, convRule: rule4 },
    { start: 12299, length: 1, convRule: rule5 },
    { start: 12300, length: 1, convRule: rule4 },
    { start: 12301, length: 1, convRule: rule5 },
    { start: 12302, length: 1, convRule: rule4 },
    { start: 12303, length: 1, convRule: rule5 },
    { start: 12304, length: 1, convRule: rule4 },
    { start: 12305, length: 1, convRule: rule5 },
    { start: 12306, length: 2, convRule: rule13 },
    { start: 12308, length: 1, convRule: rule4 },
    { start: 12309, length: 1, convRule: rule5 },
    { start: 12310, length: 1, convRule: rule4 },
    { start: 12311, length: 1, convRule: rule5 },
    { start: 12312, length: 1, convRule: rule4 },
    { start: 12313, length: 1, convRule: rule5 },
    { start: 12314, length: 1, convRule: rule4 },
    { start: 12315, length: 1, convRule: rule5 },
    { start: 12316, length: 1, convRule: rule7 },
    { start: 12317, length: 1, convRule: rule4 },
    { start: 12318, length: 2, convRule: rule5 },
    { start: 12320, length: 1, convRule: rule13 },
    { start: 12321, length: 9, convRule: rule128 },
    { start: 12330, length: 4, convRule: rule92 },
    { start: 12334, length: 2, convRule: rule124 },
    { start: 12336, length: 1, convRule: rule7 },
    { start: 12337, length: 5, convRule: rule91 },
    { start: 12342, length: 2, convRule: rule13 },
    { start: 12344, length: 3, convRule: rule128 },
    { start: 12347, length: 1, convRule: rule91 },
    { start: 12348, length: 1, convRule: rule14 },
    { start: 12349, length: 1, convRule: rule2 },
    { start: 12350, length: 2, convRule: rule13 },
    { start: 12353, length: 86, convRule: rule14 },
    { start: 12441, length: 2, convRule: rule92 },
    { start: 12443, length: 2, convRule: rule10 },
    { start: 12445, length: 2, convRule: rule91 },
    { start: 12447, length: 1, convRule: rule14 },
    { start: 12448, length: 1, convRule: rule7 },
    { start: 12449, length: 90, convRule: rule14 },
    { start: 12539, length: 1, convRule: rule2 },
    { start: 12540, length: 3, convRule: rule91 },
    { start: 12543, length: 1, convRule: rule14 },
    { start: 12549, length: 43, convRule: rule14 },
    { start: 12593, length: 94, convRule: rule14 },
    { start: 12688, length: 2, convRule: rule13 },
    { start: 12690, length: 4, convRule: rule17 },
    { start: 12694, length: 10, convRule: rule13 },
    { start: 12704, length: 32, convRule: rule14 },
    { start: 12736, length: 36, convRule: rule13 },
    { start: 12784, length: 16, convRule: rule14 },
    { start: 12800, length: 31, convRule: rule13 },
    { start: 12832, length: 10, convRule: rule17 },
    { start: 12842, length: 30, convRule: rule13 },
    { start: 12872, length: 8, convRule: rule17 },
    { start: 12880, length: 1, convRule: rule13 },
    { start: 12881, length: 15, convRule: rule17 },
    { start: 12896, length: 32, convRule: rule13 },
    { start: 12928, length: 10, convRule: rule17 },
    { start: 12938, length: 39, convRule: rule13 },
    { start: 12977, length: 15, convRule: rule17 },
    { start: 12992, length: 320, convRule: rule13 },
    { start: 13312, length: 6592, convRule: rule14 },
    { start: 19904, length: 64, convRule: rule13 },
    { start: 19968, length: 20989, convRule: rule14 },
    { start: 40960, length: 21, convRule: rule14 },
    { start: 40981, length: 1, convRule: rule91 },
    { start: 40982, length: 1143, convRule: rule14 },
    { start: 42128, length: 55, convRule: rule13 },
    { start: 42192, length: 40, convRule: rule14 },
    { start: 42232, length: 6, convRule: rule91 },
    { start: 42238, length: 2, convRule: rule2 },
    { start: 42240, length: 268, convRule: rule14 },
    { start: 42508, length: 1, convRule: rule91 },
    { start: 42509, length: 3, convRule: rule2 },
    { start: 42512, length: 16, convRule: rule14 },
    { start: 42528, length: 10, convRule: rule8 },
    { start: 42538, length: 2, convRule: rule14 },
    { start: 42560, length: 1, convRule: rule22 },
    { start: 42561, length: 1, convRule: rule23 },
    { start: 42562, length: 1, convRule: rule22 },
    { start: 42563, length: 1, convRule: rule23 },
    { start: 42564, length: 1, convRule: rule22 },
    { start: 42565, length: 1, convRule: rule23 },
    { start: 42566, length: 1, convRule: rule22 },
    { start: 42567, length: 1, convRule: rule23 },
    { start: 42568, length: 1, convRule: rule22 },
    { start: 42569, length: 1, convRule: rule23 },
    { start: 42570, length: 1, convRule: rule22 },
    { start: 42571, length: 1, convRule: rule23 },
    { start: 42572, length: 1, convRule: rule22 },
    { start: 42573, length: 1, convRule: rule23 },
    { start: 42574, length: 1, convRule: rule22 },
    { start: 42575, length: 1, convRule: rule23 },
    { start: 42576, length: 1, convRule: rule22 },
    { start: 42577, length: 1, convRule: rule23 },
    { start: 42578, length: 1, convRule: rule22 },
    { start: 42579, length: 1, convRule: rule23 },
    { start: 42580, length: 1, convRule: rule22 },
    { start: 42581, length: 1, convRule: rule23 },
    { start: 42582, length: 1, convRule: rule22 },
    { start: 42583, length: 1, convRule: rule23 },
    { start: 42584, length: 1, convRule: rule22 },
    { start: 42585, length: 1, convRule: rule23 },
    { start: 42586, length: 1, convRule: rule22 },
    { start: 42587, length: 1, convRule: rule23 },
    { start: 42588, length: 1, convRule: rule22 },
    { start: 42589, length: 1, convRule: rule23 },
    { start: 42590, length: 1, convRule: rule22 },
    { start: 42591, length: 1, convRule: rule23 },
    { start: 42592, length: 1, convRule: rule22 },
    { start: 42593, length: 1, convRule: rule23 },
    { start: 42594, length: 1, convRule: rule22 },
    { start: 42595, length: 1, convRule: rule23 },
    { start: 42596, length: 1, convRule: rule22 },
    { start: 42597, length: 1, convRule: rule23 },
    { start: 42598, length: 1, convRule: rule22 },
    { start: 42599, length: 1, convRule: rule23 },
    { start: 42600, length: 1, convRule: rule22 },
    { start: 42601, length: 1, convRule: rule23 },
    { start: 42602, length: 1, convRule: rule22 },
    { start: 42603, length: 1, convRule: rule23 },
    { start: 42604, length: 1, convRule: rule22 },
    { start: 42605, length: 1, convRule: rule23 },
    { start: 42606, length: 1, convRule: rule14 },
    { start: 42607, length: 1, convRule: rule92 },
    { start: 42608, length: 3, convRule: rule119 },
    { start: 42611, length: 1, convRule: rule2 },
    { start: 42612, length: 10, convRule: rule92 },
    { start: 42622, length: 1, convRule: rule2 },
    { start: 42623, length: 1, convRule: rule91 },
    { start: 42624, length: 1, convRule: rule22 },
    { start: 42625, length: 1, convRule: rule23 },
    { start: 42626, length: 1, convRule: rule22 },
    { start: 42627, length: 1, convRule: rule23 },
    { start: 42628, length: 1, convRule: rule22 },
    { start: 42629, length: 1, convRule: rule23 },
    { start: 42630, length: 1, convRule: rule22 },
    { start: 42631, length: 1, convRule: rule23 },
    { start: 42632, length: 1, convRule: rule22 },
    { start: 42633, length: 1, convRule: rule23 },
    { start: 42634, length: 1, convRule: rule22 },
    { start: 42635, length: 1, convRule: rule23 },
    { start: 42636, length: 1, convRule: rule22 },
    { start: 42637, length: 1, convRule: rule23 },
    { start: 42638, length: 1, convRule: rule22 },
    { start: 42639, length: 1, convRule: rule23 },
    { start: 42640, length: 1, convRule: rule22 },
    { start: 42641, length: 1, convRule: rule23 },
    { start: 42642, length: 1, convRule: rule22 },
    { start: 42643, length: 1, convRule: rule23 },
    { start: 42644, length: 1, convRule: rule22 },
    { start: 42645, length: 1, convRule: rule23 },
    { start: 42646, length: 1, convRule: rule22 },
    { start: 42647, length: 1, convRule: rule23 },
    { start: 42648, length: 1, convRule: rule22 },
    { start: 42649, length: 1, convRule: rule23 },
    { start: 42650, length: 1, convRule: rule22 },
    { start: 42651, length: 1, convRule: rule23 },
    { start: 42652, length: 2, convRule: rule91 },
    { start: 42654, length: 2, convRule: rule92 },
    { start: 42656, length: 70, convRule: rule14 },
    { start: 42726, length: 10, convRule: rule128 },
    { start: 42736, length: 2, convRule: rule92 },
    { start: 42738, length: 6, convRule: rule2 },
    { start: 42752, length: 23, convRule: rule10 },
    { start: 42775, length: 9, convRule: rule91 },
    { start: 42784, length: 2, convRule: rule10 },
    { start: 42786, length: 1, convRule: rule22 },
    { start: 42787, length: 1, convRule: rule23 },
    { start: 42788, length: 1, convRule: rule22 },
    { start: 42789, length: 1, convRule: rule23 },
    { start: 42790, length: 1, convRule: rule22 },
    { start: 42791, length: 1, convRule: rule23 },
    { start: 42792, length: 1, convRule: rule22 },
    { start: 42793, length: 1, convRule: rule23 },
    { start: 42794, length: 1, convRule: rule22 },
    { start: 42795, length: 1, convRule: rule23 },
    { start: 42796, length: 1, convRule: rule22 },
    { start: 42797, length: 1, convRule: rule23 },
    { start: 42798, length: 1, convRule: rule22 },
    { start: 42799, length: 1, convRule: rule23 },
    { start: 42800, length: 2, convRule: rule20 },
    { start: 42802, length: 1, convRule: rule22 },
    { start: 42803, length: 1, convRule: rule23 },
    { start: 42804, length: 1, convRule: rule22 },
    { start: 42805, length: 1, convRule: rule23 },
    { start: 42806, length: 1, convRule: rule22 },
    { start: 42807, length: 1, convRule: rule23 },
    { start: 42808, length: 1, convRule: rule22 },
    { start: 42809, length: 1, convRule: rule23 },
    { start: 42810, length: 1, convRule: rule22 },
    { start: 42811, length: 1, convRule: rule23 },
    { start: 42812, length: 1, convRule: rule22 },
    { start: 42813, length: 1, convRule: rule23 },
    { start: 42814, length: 1, convRule: rule22 },
    { start: 42815, length: 1, convRule: rule23 },
    { start: 42816, length: 1, convRule: rule22 },
    { start: 42817, length: 1, convRule: rule23 },
    { start: 42818, length: 1, convRule: rule22 },
    { start: 42819, length: 1, convRule: rule23 },
    { start: 42820, length: 1, convRule: rule22 },
    { start: 42821, length: 1, convRule: rule23 },
    { start: 42822, length: 1, convRule: rule22 },
    { start: 42823, length: 1, convRule: rule23 },
    { start: 42824, length: 1, convRule: rule22 },
    { start: 42825, length: 1, convRule: rule23 },
    { start: 42826, length: 1, convRule: rule22 },
    { start: 42827, length: 1, convRule: rule23 },
    { start: 42828, length: 1, convRule: rule22 },
    { start: 42829, length: 1, convRule: rule23 },
    { start: 42830, length: 1, convRule: rule22 },
    { start: 42831, length: 1, convRule: rule23 },
    { start: 42832, length: 1, convRule: rule22 },
    { start: 42833, length: 1, convRule: rule23 },
    { start: 42834, length: 1, convRule: rule22 },
    { start: 42835, length: 1, convRule: rule23 },
    { start: 42836, length: 1, convRule: rule22 },
    { start: 42837, length: 1, convRule: rule23 },
    { start: 42838, length: 1, convRule: rule22 },
    { start: 42839, length: 1, convRule: rule23 },
    { start: 42840, length: 1, convRule: rule22 },
    { start: 42841, length: 1, convRule: rule23 },
    { start: 42842, length: 1, convRule: rule22 },
    { start: 42843, length: 1, convRule: rule23 },
    { start: 42844, length: 1, convRule: rule22 },
    { start: 42845, length: 1, convRule: rule23 },
    { start: 42846, length: 1, convRule: rule22 },
    { start: 42847, length: 1, convRule: rule23 },
    { start: 42848, length: 1, convRule: rule22 },
    { start: 42849, length: 1, convRule: rule23 },
    { start: 42850, length: 1, convRule: rule22 },
    { start: 42851, length: 1, convRule: rule23 },
    { start: 42852, length: 1, convRule: rule22 },
    { start: 42853, length: 1, convRule: rule23 },
    { start: 42854, length: 1, convRule: rule22 },
    { start: 42855, length: 1, convRule: rule23 },
    { start: 42856, length: 1, convRule: rule22 },
    { start: 42857, length: 1, convRule: rule23 },
    { start: 42858, length: 1, convRule: rule22 },
    { start: 42859, length: 1, convRule: rule23 },
    { start: 42860, length: 1, convRule: rule22 },
    { start: 42861, length: 1, convRule: rule23 },
    { start: 42862, length: 1, convRule: rule22 },
    { start: 42863, length: 1, convRule: rule23 },
    { start: 42864, length: 1, convRule: rule91 },
    { start: 42865, length: 8, convRule: rule20 },
    { start: 42873, length: 1, convRule: rule22 },
    { start: 42874, length: 1, convRule: rule23 },
    { start: 42875, length: 1, convRule: rule22 },
    { start: 42876, length: 1, convRule: rule23 },
    { start: 42877, length: 1, convRule: rule183 },
    { start: 42878, length: 1, convRule: rule22 },
    { start: 42879, length: 1, convRule: rule23 },
    { start: 42880, length: 1, convRule: rule22 },
    { start: 42881, length: 1, convRule: rule23 },
    { start: 42882, length: 1, convRule: rule22 },
    { start: 42883, length: 1, convRule: rule23 },
    { start: 42884, length: 1, convRule: rule22 },
    { start: 42885, length: 1, convRule: rule23 },
    { start: 42886, length: 1, convRule: rule22 },
    { start: 42887, length: 1, convRule: rule23 },
    { start: 42888, length: 1, convRule: rule91 },
    { start: 42889, length: 2, convRule: rule10 },
    { start: 42891, length: 1, convRule: rule22 },
    { start: 42892, length: 1, convRule: rule23 },
    { start: 42893, length: 1, convRule: rule184 },
    { start: 42894, length: 1, convRule: rule20 },
    { start: 42895, length: 1, convRule: rule14 },
    { start: 42896, length: 1, convRule: rule22 },
    { start: 42897, length: 1, convRule: rule23 },
    { start: 42898, length: 1, convRule: rule22 },
    { start: 42899, length: 1, convRule: rule23 },
    { start: 42900, length: 1, convRule: rule185 },
    { start: 42901, length: 1, convRule: rule20 },
    { start: 42902, length: 1, convRule: rule22 },
    { start: 42903, length: 1, convRule: rule23 },
    { start: 42904, length: 1, convRule: rule22 },
    { start: 42905, length: 1, convRule: rule23 },
    { start: 42906, length: 1, convRule: rule22 },
    { start: 42907, length: 1, convRule: rule23 },
    { start: 42908, length: 1, convRule: rule22 },
    { start: 42909, length: 1, convRule: rule23 },
    { start: 42910, length: 1, convRule: rule22 },
    { start: 42911, length: 1, convRule: rule23 },
    { start: 42912, length: 1, convRule: rule22 },
    { start: 42913, length: 1, convRule: rule23 },
    { start: 42914, length: 1, convRule: rule22 },
    { start: 42915, length: 1, convRule: rule23 },
    { start: 42916, length: 1, convRule: rule22 },
    { start: 42917, length: 1, convRule: rule23 },
    { start: 42918, length: 1, convRule: rule22 },
    { start: 42919, length: 1, convRule: rule23 },
    { start: 42920, length: 1, convRule: rule22 },
    { start: 42921, length: 1, convRule: rule23 },
    { start: 42922, length: 1, convRule: rule186 },
    { start: 42923, length: 1, convRule: rule187 },
    { start: 42924, length: 1, convRule: rule188 },
    { start: 42925, length: 1, convRule: rule189 },
    { start: 42926, length: 1, convRule: rule186 },
    { start: 42927, length: 1, convRule: rule20 },
    { start: 42928, length: 1, convRule: rule190 },
    { start: 42929, length: 1, convRule: rule191 },
    { start: 42930, length: 1, convRule: rule192 },
    { start: 42931, length: 1, convRule: rule193 },
    { start: 42932, length: 1, convRule: rule22 },
    { start: 42933, length: 1, convRule: rule23 },
    { start: 42934, length: 1, convRule: rule22 },
    { start: 42935, length: 1, convRule: rule23 },
    { start: 42936, length: 1, convRule: rule22 },
    { start: 42937, length: 1, convRule: rule23 },
    { start: 42938, length: 1, convRule: rule22 },
    { start: 42939, length: 1, convRule: rule23 },
    { start: 42940, length: 1, convRule: rule22 },
    { start: 42941, length: 1, convRule: rule23 },
    { start: 42942, length: 1, convRule: rule22 },
    { start: 42943, length: 1, convRule: rule23 },
    { start: 42946, length: 1, convRule: rule22 },
    { start: 42947, length: 1, convRule: rule23 },
    { start: 42948, length: 1, convRule: rule194 },
    { start: 42949, length: 1, convRule: rule195 },
    { start: 42950, length: 1, convRule: rule196 },
    { start: 42951, length: 1, convRule: rule22 },
    { start: 42952, length: 1, convRule: rule23 },
    { start: 42953, length: 1, convRule: rule22 },
    { start: 42954, length: 1, convRule: rule23 },
    { start: 42997, length: 1, convRule: rule22 },
    { start: 42998, length: 1, convRule: rule23 },
    { start: 42999, length: 1, convRule: rule14 },
    { start: 43e3, length: 2, convRule: rule91 },
    { start: 43002, length: 1, convRule: rule20 },
    { start: 43003, length: 7, convRule: rule14 },
    { start: 43010, length: 1, convRule: rule92 },
    { start: 43011, length: 3, convRule: rule14 },
    { start: 43014, length: 1, convRule: rule92 },
    { start: 43015, length: 4, convRule: rule14 },
    { start: 43019, length: 1, convRule: rule92 },
    { start: 43020, length: 23, convRule: rule14 },
    { start: 43043, length: 2, convRule: rule124 },
    { start: 43045, length: 2, convRule: rule92 },
    { start: 43047, length: 1, convRule: rule124 },
    { start: 43048, length: 4, convRule: rule13 },
    { start: 43052, length: 1, convRule: rule92 },
    { start: 43056, length: 6, convRule: rule17 },
    { start: 43062, length: 2, convRule: rule13 },
    { start: 43064, length: 1, convRule: rule3 },
    { start: 43065, length: 1, convRule: rule13 },
    { start: 43072, length: 52, convRule: rule14 },
    { start: 43124, length: 4, convRule: rule2 },
    { start: 43136, length: 2, convRule: rule124 },
    { start: 43138, length: 50, convRule: rule14 },
    { start: 43188, length: 16, convRule: rule124 },
    { start: 43204, length: 2, convRule: rule92 },
    { start: 43214, length: 2, convRule: rule2 },
    { start: 43216, length: 10, convRule: rule8 },
    { start: 43232, length: 18, convRule: rule92 },
    { start: 43250, length: 6, convRule: rule14 },
    { start: 43256, length: 3, convRule: rule2 },
    { start: 43259, length: 1, convRule: rule14 },
    { start: 43260, length: 1, convRule: rule2 },
    { start: 43261, length: 2, convRule: rule14 },
    { start: 43263, length: 1, convRule: rule92 },
    { start: 43264, length: 10, convRule: rule8 },
    { start: 43274, length: 28, convRule: rule14 },
    { start: 43302, length: 8, convRule: rule92 },
    { start: 43310, length: 2, convRule: rule2 },
    { start: 43312, length: 23, convRule: rule14 },
    { start: 43335, length: 11, convRule: rule92 },
    { start: 43346, length: 2, convRule: rule124 },
    { start: 43359, length: 1, convRule: rule2 },
    { start: 43360, length: 29, convRule: rule14 },
    { start: 43392, length: 3, convRule: rule92 },
    { start: 43395, length: 1, convRule: rule124 },
    { start: 43396, length: 47, convRule: rule14 },
    { start: 43443, length: 1, convRule: rule92 },
    { start: 43444, length: 2, convRule: rule124 },
    { start: 43446, length: 4, convRule: rule92 },
    { start: 43450, length: 2, convRule: rule124 },
    { start: 43452, length: 2, convRule: rule92 },
    { start: 43454, length: 3, convRule: rule124 },
    { start: 43457, length: 13, convRule: rule2 },
    { start: 43471, length: 1, convRule: rule91 },
    { start: 43472, length: 10, convRule: rule8 },
    { start: 43486, length: 2, convRule: rule2 },
    { start: 43488, length: 5, convRule: rule14 },
    { start: 43493, length: 1, convRule: rule92 },
    { start: 43494, length: 1, convRule: rule91 },
    { start: 43495, length: 9, convRule: rule14 },
    { start: 43504, length: 10, convRule: rule8 },
    { start: 43514, length: 5, convRule: rule14 },
    { start: 43520, length: 41, convRule: rule14 },
    { start: 43561, length: 6, convRule: rule92 },
    { start: 43567, length: 2, convRule: rule124 },
    { start: 43569, length: 2, convRule: rule92 },
    { start: 43571, length: 2, convRule: rule124 },
    { start: 43573, length: 2, convRule: rule92 },
    { start: 43584, length: 3, convRule: rule14 },
    { start: 43587, length: 1, convRule: rule92 },
    { start: 43588, length: 8, convRule: rule14 },
    { start: 43596, length: 1, convRule: rule92 },
    { start: 43597, length: 1, convRule: rule124 },
    { start: 43600, length: 10, convRule: rule8 },
    { start: 43612, length: 4, convRule: rule2 },
    { start: 43616, length: 16, convRule: rule14 },
    { start: 43632, length: 1, convRule: rule91 },
    { start: 43633, length: 6, convRule: rule14 },
    { start: 43639, length: 3, convRule: rule13 },
    { start: 43642, length: 1, convRule: rule14 },
    { start: 43643, length: 1, convRule: rule124 },
    { start: 43644, length: 1, convRule: rule92 },
    { start: 43645, length: 1, convRule: rule124 },
    { start: 43646, length: 50, convRule: rule14 },
    { start: 43696, length: 1, convRule: rule92 },
    { start: 43697, length: 1, convRule: rule14 },
    { start: 43698, length: 3, convRule: rule92 },
    { start: 43701, length: 2, convRule: rule14 },
    { start: 43703, length: 2, convRule: rule92 },
    { start: 43705, length: 5, convRule: rule14 },
    { start: 43710, length: 2, convRule: rule92 },
    { start: 43712, length: 1, convRule: rule14 },
    { start: 43713, length: 1, convRule: rule92 },
    { start: 43714, length: 1, convRule: rule14 },
    { start: 43739, length: 2, convRule: rule14 },
    { start: 43741, length: 1, convRule: rule91 },
    { start: 43742, length: 2, convRule: rule2 },
    { start: 43744, length: 11, convRule: rule14 },
    { start: 43755, length: 1, convRule: rule124 },
    { start: 43756, length: 2, convRule: rule92 },
    { start: 43758, length: 2, convRule: rule124 },
    { start: 43760, length: 2, convRule: rule2 },
    { start: 43762, length: 1, convRule: rule14 },
    { start: 43763, length: 2, convRule: rule91 },
    { start: 43765, length: 1, convRule: rule124 },
    { start: 43766, length: 1, convRule: rule92 },
    { start: 43777, length: 6, convRule: rule14 },
    { start: 43785, length: 6, convRule: rule14 },
    { start: 43793, length: 6, convRule: rule14 },
    { start: 43808, length: 7, convRule: rule14 },
    { start: 43816, length: 7, convRule: rule14 },
    { start: 43824, length: 35, convRule: rule20 },
    { start: 43859, length: 1, convRule: rule197 },
    { start: 43860, length: 7, convRule: rule20 },
    { start: 43867, length: 1, convRule: rule10 },
    { start: 43868, length: 4, convRule: rule91 },
    { start: 43872, length: 9, convRule: rule20 },
    { start: 43881, length: 1, convRule: rule91 },
    { start: 43882, length: 2, convRule: rule10 },
    { start: 43888, length: 80, convRule: rule198 },
    { start: 43968, length: 35, convRule: rule14 },
    { start: 44003, length: 2, convRule: rule124 },
    { start: 44005, length: 1, convRule: rule92 },
    { start: 44006, length: 2, convRule: rule124 },
    { start: 44008, length: 1, convRule: rule92 },
    { start: 44009, length: 2, convRule: rule124 },
    { start: 44011, length: 1, convRule: rule2 },
    { start: 44012, length: 1, convRule: rule124 },
    { start: 44013, length: 1, convRule: rule92 },
    { start: 44016, length: 10, convRule: rule8 },
    { start: 44032, length: 11172, convRule: rule14 },
    { start: 55216, length: 23, convRule: rule14 },
    { start: 55243, length: 49, convRule: rule14 },
    { start: 55296, length: 896, convRule: rule199 },
    { start: 56192, length: 128, convRule: rule199 },
    { start: 56320, length: 1024, convRule: rule199 },
    { start: 57344, length: 6400, convRule: rule200 },
    { start: 63744, length: 366, convRule: rule14 },
    { start: 64112, length: 106, convRule: rule14 },
    { start: 64256, length: 7, convRule: rule20 },
    { start: 64275, length: 5, convRule: rule20 },
    { start: 64285, length: 1, convRule: rule14 },
    { start: 64286, length: 1, convRule: rule92 },
    { start: 64287, length: 10, convRule: rule14 },
    { start: 64297, length: 1, convRule: rule6 },
    { start: 64298, length: 13, convRule: rule14 },
    { start: 64312, length: 5, convRule: rule14 },
    { start: 64318, length: 1, convRule: rule14 },
    { start: 64320, length: 2, convRule: rule14 },
    { start: 64323, length: 2, convRule: rule14 },
    { start: 64326, length: 108, convRule: rule14 },
    { start: 64434, length: 16, convRule: rule10 },
    { start: 64467, length: 363, convRule: rule14 },
    { start: 64830, length: 1, convRule: rule5 },
    { start: 64831, length: 1, convRule: rule4 },
    { start: 64848, length: 64, convRule: rule14 },
    { start: 64914, length: 54, convRule: rule14 },
    { start: 65008, length: 12, convRule: rule14 },
    { start: 65020, length: 1, convRule: rule3 },
    { start: 65021, length: 1, convRule: rule13 },
    { start: 65024, length: 16, convRule: rule92 },
    { start: 65040, length: 7, convRule: rule2 },
    { start: 65047, length: 1, convRule: rule4 },
    { start: 65048, length: 1, convRule: rule5 },
    { start: 65049, length: 1, convRule: rule2 },
    { start: 65056, length: 16, convRule: rule92 },
    { start: 65072, length: 1, convRule: rule2 },
    { start: 65073, length: 2, convRule: rule7 },
    { start: 65075, length: 2, convRule: rule11 },
    { start: 65077, length: 1, convRule: rule4 },
    { start: 65078, length: 1, convRule: rule5 },
    { start: 65079, length: 1, convRule: rule4 },
    { start: 65080, length: 1, convRule: rule5 },
    { start: 65081, length: 1, convRule: rule4 },
    { start: 65082, length: 1, convRule: rule5 },
    { start: 65083, length: 1, convRule: rule4 },
    { start: 65084, length: 1, convRule: rule5 },
    { start: 65085, length: 1, convRule: rule4 },
    { start: 65086, length: 1, convRule: rule5 },
    { start: 65087, length: 1, convRule: rule4 },
    { start: 65088, length: 1, convRule: rule5 },
    { start: 65089, length: 1, convRule: rule4 },
    { start: 65090, length: 1, convRule: rule5 },
    { start: 65091, length: 1, convRule: rule4 },
    { start: 65092, length: 1, convRule: rule5 },
    { start: 65093, length: 2, convRule: rule2 },
    { start: 65095, length: 1, convRule: rule4 },
    { start: 65096, length: 1, convRule: rule5 },
    { start: 65097, length: 4, convRule: rule2 },
    { start: 65101, length: 3, convRule: rule11 },
    { start: 65104, length: 3, convRule: rule2 },
    { start: 65108, length: 4, convRule: rule2 },
    { start: 65112, length: 1, convRule: rule7 },
    { start: 65113, length: 1, convRule: rule4 },
    { start: 65114, length: 1, convRule: rule5 },
    { start: 65115, length: 1, convRule: rule4 },
    { start: 65116, length: 1, convRule: rule5 },
    { start: 65117, length: 1, convRule: rule4 },
    { start: 65118, length: 1, convRule: rule5 },
    { start: 65119, length: 3, convRule: rule2 },
    { start: 65122, length: 1, convRule: rule6 },
    { start: 65123, length: 1, convRule: rule7 },
    { start: 65124, length: 3, convRule: rule6 },
    { start: 65128, length: 1, convRule: rule2 },
    { start: 65129, length: 1, convRule: rule3 },
    { start: 65130, length: 2, convRule: rule2 },
    { start: 65136, length: 5, convRule: rule14 },
    { start: 65142, length: 135, convRule: rule14 },
    { start: 65279, length: 1, convRule: rule16 },
    { start: 65281, length: 3, convRule: rule2 },
    { start: 65284, length: 1, convRule: rule3 },
    { start: 65285, length: 3, convRule: rule2 },
    { start: 65288, length: 1, convRule: rule4 },
    { start: 65289, length: 1, convRule: rule5 },
    { start: 65290, length: 1, convRule: rule2 },
    { start: 65291, length: 1, convRule: rule6 },
    { start: 65292, length: 1, convRule: rule2 },
    { start: 65293, length: 1, convRule: rule7 },
    { start: 65294, length: 2, convRule: rule2 },
    { start: 65296, length: 10, convRule: rule8 },
    { start: 65306, length: 2, convRule: rule2 },
    { start: 65308, length: 3, convRule: rule6 },
    { start: 65311, length: 2, convRule: rule2 },
    { start: 65313, length: 26, convRule: rule9 },
    { start: 65339, length: 1, convRule: rule4 },
    { start: 65340, length: 1, convRule: rule2 },
    { start: 65341, length: 1, convRule: rule5 },
    { start: 65342, length: 1, convRule: rule10 },
    { start: 65343, length: 1, convRule: rule11 },
    { start: 65344, length: 1, convRule: rule10 },
    { start: 65345, length: 26, convRule: rule12 },
    { start: 65371, length: 1, convRule: rule4 },
    { start: 65372, length: 1, convRule: rule6 },
    { start: 65373, length: 1, convRule: rule5 },
    { start: 65374, length: 1, convRule: rule6 },
    { start: 65375, length: 1, convRule: rule4 },
    { start: 65376, length: 1, convRule: rule5 },
    { start: 65377, length: 1, convRule: rule2 },
    { start: 65378, length: 1, convRule: rule4 },
    { start: 65379, length: 1, convRule: rule5 },
    { start: 65380, length: 2, convRule: rule2 },
    { start: 65382, length: 10, convRule: rule14 },
    { start: 65392, length: 1, convRule: rule91 },
    { start: 65393, length: 45, convRule: rule14 },
    { start: 65438, length: 2, convRule: rule91 },
    { start: 65440, length: 31, convRule: rule14 },
    { start: 65474, length: 6, convRule: rule14 },
    { start: 65482, length: 6, convRule: rule14 },
    { start: 65490, length: 6, convRule: rule14 },
    { start: 65498, length: 3, convRule: rule14 },
    { start: 65504, length: 2, convRule: rule3 },
    { start: 65506, length: 1, convRule: rule6 },
    { start: 65507, length: 1, convRule: rule10 },
    { start: 65508, length: 1, convRule: rule13 },
    { start: 65509, length: 2, convRule: rule3 },
    { start: 65512, length: 1, convRule: rule13 },
    { start: 65513, length: 4, convRule: rule6 },
    { start: 65517, length: 2, convRule: rule13 },
    { start: 65529, length: 3, convRule: rule16 },
    { start: 65532, length: 2, convRule: rule13 },
    { start: 65536, length: 12, convRule: rule14 },
    { start: 65549, length: 26, convRule: rule14 },
    { start: 65576, length: 19, convRule: rule14 },
    { start: 65596, length: 2, convRule: rule14 },
    { start: 65599, length: 15, convRule: rule14 },
    { start: 65616, length: 14, convRule: rule14 },
    { start: 65664, length: 123, convRule: rule14 },
    { start: 65792, length: 3, convRule: rule2 },
    { start: 65799, length: 45, convRule: rule17 },
    { start: 65847, length: 9, convRule: rule13 },
    { start: 65856, length: 53, convRule: rule128 },
    { start: 65909, length: 4, convRule: rule17 },
    { start: 65913, length: 17, convRule: rule13 },
    { start: 65930, length: 2, convRule: rule17 },
    { start: 65932, length: 3, convRule: rule13 },
    { start: 65936, length: 13, convRule: rule13 },
    { start: 65952, length: 1, convRule: rule13 },
    { start: 66e3, length: 45, convRule: rule13 },
    { start: 66045, length: 1, convRule: rule92 },
    { start: 66176, length: 29, convRule: rule14 },
    { start: 66208, length: 49, convRule: rule14 },
    { start: 66272, length: 1, convRule: rule92 },
    { start: 66273, length: 27, convRule: rule17 },
    { start: 66304, length: 32, convRule: rule14 },
    { start: 66336, length: 4, convRule: rule17 },
    { start: 66349, length: 20, convRule: rule14 },
    { start: 66369, length: 1, convRule: rule128 },
    { start: 66370, length: 8, convRule: rule14 },
    { start: 66378, length: 1, convRule: rule128 },
    { start: 66384, length: 38, convRule: rule14 },
    { start: 66422, length: 5, convRule: rule92 },
    { start: 66432, length: 30, convRule: rule14 },
    { start: 66463, length: 1, convRule: rule2 },
    { start: 66464, length: 36, convRule: rule14 },
    { start: 66504, length: 8, convRule: rule14 },
    { start: 66512, length: 1, convRule: rule2 },
    { start: 66513, length: 5, convRule: rule128 },
    { start: 66560, length: 40, convRule: rule201 },
    { start: 66600, length: 40, convRule: rule202 },
    { start: 66640, length: 78, convRule: rule14 },
    { start: 66720, length: 10, convRule: rule8 },
    { start: 66736, length: 36, convRule: rule201 },
    { start: 66776, length: 36, convRule: rule202 },
    { start: 66816, length: 40, convRule: rule14 },
    { start: 66864, length: 52, convRule: rule14 },
    { start: 66927, length: 1, convRule: rule2 },
    { start: 67072, length: 311, convRule: rule14 },
    { start: 67392, length: 22, convRule: rule14 },
    { start: 67424, length: 8, convRule: rule14 },
    { start: 67584, length: 6, convRule: rule14 },
    { start: 67592, length: 1, convRule: rule14 },
    { start: 67594, length: 44, convRule: rule14 },
    { start: 67639, length: 2, convRule: rule14 },
    { start: 67644, length: 1, convRule: rule14 },
    { start: 67647, length: 23, convRule: rule14 },
    { start: 67671, length: 1, convRule: rule2 },
    { start: 67672, length: 8, convRule: rule17 },
    { start: 67680, length: 23, convRule: rule14 },
    { start: 67703, length: 2, convRule: rule13 },
    { start: 67705, length: 7, convRule: rule17 },
    { start: 67712, length: 31, convRule: rule14 },
    { start: 67751, length: 9, convRule: rule17 },
    { start: 67808, length: 19, convRule: rule14 },
    { start: 67828, length: 2, convRule: rule14 },
    { start: 67835, length: 5, convRule: rule17 },
    { start: 67840, length: 22, convRule: rule14 },
    { start: 67862, length: 6, convRule: rule17 },
    { start: 67871, length: 1, convRule: rule2 },
    { start: 67872, length: 26, convRule: rule14 },
    { start: 67903, length: 1, convRule: rule2 },
    { start: 67968, length: 56, convRule: rule14 },
    { start: 68028, length: 2, convRule: rule17 },
    { start: 68030, length: 2, convRule: rule14 },
    { start: 68032, length: 16, convRule: rule17 },
    { start: 68050, length: 46, convRule: rule17 },
    { start: 68096, length: 1, convRule: rule14 },
    { start: 68097, length: 3, convRule: rule92 },
    { start: 68101, length: 2, convRule: rule92 },
    { start: 68108, length: 4, convRule: rule92 },
    { start: 68112, length: 4, convRule: rule14 },
    { start: 68117, length: 3, convRule: rule14 },
    { start: 68121, length: 29, convRule: rule14 },
    { start: 68152, length: 3, convRule: rule92 },
    { start: 68159, length: 1, convRule: rule92 },
    { start: 68160, length: 9, convRule: rule17 },
    { start: 68176, length: 9, convRule: rule2 },
    { start: 68192, length: 29, convRule: rule14 },
    { start: 68221, length: 2, convRule: rule17 },
    { start: 68223, length: 1, convRule: rule2 },
    { start: 68224, length: 29, convRule: rule14 },
    { start: 68253, length: 3, convRule: rule17 },
    { start: 68288, length: 8, convRule: rule14 },
    { start: 68296, length: 1, convRule: rule13 },
    { start: 68297, length: 28, convRule: rule14 },
    { start: 68325, length: 2, convRule: rule92 },
    { start: 68331, length: 5, convRule: rule17 },
    { start: 68336, length: 7, convRule: rule2 },
    { start: 68352, length: 54, convRule: rule14 },
    { start: 68409, length: 7, convRule: rule2 },
    { start: 68416, length: 22, convRule: rule14 },
    { start: 68440, length: 8, convRule: rule17 },
    { start: 68448, length: 19, convRule: rule14 },
    { start: 68472, length: 8, convRule: rule17 },
    { start: 68480, length: 18, convRule: rule14 },
    { start: 68505, length: 4, convRule: rule2 },
    { start: 68521, length: 7, convRule: rule17 },
    { start: 68608, length: 73, convRule: rule14 },
    { start: 68736, length: 51, convRule: rule97 },
    { start: 68800, length: 51, convRule: rule102 },
    { start: 68858, length: 6, convRule: rule17 },
    { start: 68864, length: 36, convRule: rule14 },
    { start: 68900, length: 4, convRule: rule92 },
    { start: 68912, length: 10, convRule: rule8 },
    { start: 69216, length: 31, convRule: rule17 },
    { start: 69248, length: 42, convRule: rule14 },
    { start: 69291, length: 2, convRule: rule92 },
    { start: 69293, length: 1, convRule: rule7 },
    { start: 69296, length: 2, convRule: rule14 },
    { start: 69376, length: 29, convRule: rule14 },
    { start: 69405, length: 10, convRule: rule17 },
    { start: 69415, length: 1, convRule: rule14 },
    { start: 69424, length: 22, convRule: rule14 },
    { start: 69446, length: 11, convRule: rule92 },
    { start: 69457, length: 4, convRule: rule17 },
    { start: 69461, length: 5, convRule: rule2 },
    { start: 69552, length: 21, convRule: rule14 },
    { start: 69573, length: 7, convRule: rule17 },
    { start: 69600, length: 23, convRule: rule14 },
    { start: 69632, length: 1, convRule: rule124 },
    { start: 69633, length: 1, convRule: rule92 },
    { start: 69634, length: 1, convRule: rule124 },
    { start: 69635, length: 53, convRule: rule14 },
    { start: 69688, length: 15, convRule: rule92 },
    { start: 69703, length: 7, convRule: rule2 },
    { start: 69714, length: 20, convRule: rule17 },
    { start: 69734, length: 10, convRule: rule8 },
    { start: 69759, length: 3, convRule: rule92 },
    { start: 69762, length: 1, convRule: rule124 },
    { start: 69763, length: 45, convRule: rule14 },
    { start: 69808, length: 3, convRule: rule124 },
    { start: 69811, length: 4, convRule: rule92 },
    { start: 69815, length: 2, convRule: rule124 },
    { start: 69817, length: 2, convRule: rule92 },
    { start: 69819, length: 2, convRule: rule2 },
    { start: 69821, length: 1, convRule: rule16 },
    { start: 69822, length: 4, convRule: rule2 },
    { start: 69837, length: 1, convRule: rule16 },
    { start: 69840, length: 25, convRule: rule14 },
    { start: 69872, length: 10, convRule: rule8 },
    { start: 69888, length: 3, convRule: rule92 },
    { start: 69891, length: 36, convRule: rule14 },
    { start: 69927, length: 5, convRule: rule92 },
    { start: 69932, length: 1, convRule: rule124 },
    { start: 69933, length: 8, convRule: rule92 },
    { start: 69942, length: 10, convRule: rule8 },
    { start: 69952, length: 4, convRule: rule2 },
    { start: 69956, length: 1, convRule: rule14 },
    { start: 69957, length: 2, convRule: rule124 },
    { start: 69959, length: 1, convRule: rule14 },
    { start: 69968, length: 35, convRule: rule14 },
    { start: 70003, length: 1, convRule: rule92 },
    { start: 70004, length: 2, convRule: rule2 },
    { start: 70006, length: 1, convRule: rule14 },
    { start: 70016, length: 2, convRule: rule92 },
    { start: 70018, length: 1, convRule: rule124 },
    { start: 70019, length: 48, convRule: rule14 },
    { start: 70067, length: 3, convRule: rule124 },
    { start: 70070, length: 9, convRule: rule92 },
    { start: 70079, length: 2, convRule: rule124 },
    { start: 70081, length: 4, convRule: rule14 },
    { start: 70085, length: 4, convRule: rule2 },
    { start: 70089, length: 4, convRule: rule92 },
    { start: 70093, length: 1, convRule: rule2 },
    { start: 70094, length: 1, convRule: rule124 },
    { start: 70095, length: 1, convRule: rule92 },
    { start: 70096, length: 10, convRule: rule8 },
    { start: 70106, length: 1, convRule: rule14 },
    { start: 70107, length: 1, convRule: rule2 },
    { start: 70108, length: 1, convRule: rule14 },
    { start: 70109, length: 3, convRule: rule2 },
    { start: 70113, length: 20, convRule: rule17 },
    { start: 70144, length: 18, convRule: rule14 },
    { start: 70163, length: 25, convRule: rule14 },
    { start: 70188, length: 3, convRule: rule124 },
    { start: 70191, length: 3, convRule: rule92 },
    { start: 70194, length: 2, convRule: rule124 },
    { start: 70196, length: 1, convRule: rule92 },
    { start: 70197, length: 1, convRule: rule124 },
    { start: 70198, length: 2, convRule: rule92 },
    { start: 70200, length: 6, convRule: rule2 },
    { start: 70206, length: 1, convRule: rule92 },
    { start: 70272, length: 7, convRule: rule14 },
    { start: 70280, length: 1, convRule: rule14 },
    { start: 70282, length: 4, convRule: rule14 },
    { start: 70287, length: 15, convRule: rule14 },
    { start: 70303, length: 10, convRule: rule14 },
    { start: 70313, length: 1, convRule: rule2 },
    { start: 70320, length: 47, convRule: rule14 },
    { start: 70367, length: 1, convRule: rule92 },
    { start: 70368, length: 3, convRule: rule124 },
    { start: 70371, length: 8, convRule: rule92 },
    { start: 70384, length: 10, convRule: rule8 },
    { start: 70400, length: 2, convRule: rule92 },
    { start: 70402, length: 2, convRule: rule124 },
    { start: 70405, length: 8, convRule: rule14 },
    { start: 70415, length: 2, convRule: rule14 },
    { start: 70419, length: 22, convRule: rule14 },
    { start: 70442, length: 7, convRule: rule14 },
    { start: 70450, length: 2, convRule: rule14 },
    { start: 70453, length: 5, convRule: rule14 },
    { start: 70459, length: 2, convRule: rule92 },
    { start: 70461, length: 1, convRule: rule14 },
    { start: 70462, length: 2, convRule: rule124 },
    { start: 70464, length: 1, convRule: rule92 },
    { start: 70465, length: 4, convRule: rule124 },
    { start: 70471, length: 2, convRule: rule124 },
    { start: 70475, length: 3, convRule: rule124 },
    { start: 70480, length: 1, convRule: rule14 },
    { start: 70487, length: 1, convRule: rule124 },
    { start: 70493, length: 5, convRule: rule14 },
    { start: 70498, length: 2, convRule: rule124 },
    { start: 70502, length: 7, convRule: rule92 },
    { start: 70512, length: 5, convRule: rule92 },
    { start: 70656, length: 53, convRule: rule14 },
    { start: 70709, length: 3, convRule: rule124 },
    { start: 70712, length: 8, convRule: rule92 },
    { start: 70720, length: 2, convRule: rule124 },
    { start: 70722, length: 3, convRule: rule92 },
    { start: 70725, length: 1, convRule: rule124 },
    { start: 70726, length: 1, convRule: rule92 },
    { start: 70727, length: 4, convRule: rule14 },
    { start: 70731, length: 5, convRule: rule2 },
    { start: 70736, length: 10, convRule: rule8 },
    { start: 70746, length: 2, convRule: rule2 },
    { start: 70749, length: 1, convRule: rule2 },
    { start: 70750, length: 1, convRule: rule92 },
    { start: 70751, length: 3, convRule: rule14 },
    { start: 70784, length: 48, convRule: rule14 },
    { start: 70832, length: 3, convRule: rule124 },
    { start: 70835, length: 6, convRule: rule92 },
    { start: 70841, length: 1, convRule: rule124 },
    { start: 70842, length: 1, convRule: rule92 },
    { start: 70843, length: 4, convRule: rule124 },
    { start: 70847, length: 2, convRule: rule92 },
    { start: 70849, length: 1, convRule: rule124 },
    { start: 70850, length: 2, convRule: rule92 },
    { start: 70852, length: 2, convRule: rule14 },
    { start: 70854, length: 1, convRule: rule2 },
    { start: 70855, length: 1, convRule: rule14 },
    { start: 70864, length: 10, convRule: rule8 },
    { start: 71040, length: 47, convRule: rule14 },
    { start: 71087, length: 3, convRule: rule124 },
    { start: 71090, length: 4, convRule: rule92 },
    { start: 71096, length: 4, convRule: rule124 },
    { start: 71100, length: 2, convRule: rule92 },
    { start: 71102, length: 1, convRule: rule124 },
    { start: 71103, length: 2, convRule: rule92 },
    { start: 71105, length: 23, convRule: rule2 },
    { start: 71128, length: 4, convRule: rule14 },
    { start: 71132, length: 2, convRule: rule92 },
    { start: 71168, length: 48, convRule: rule14 },
    { start: 71216, length: 3, convRule: rule124 },
    { start: 71219, length: 8, convRule: rule92 },
    { start: 71227, length: 2, convRule: rule124 },
    { start: 71229, length: 1, convRule: rule92 },
    { start: 71230, length: 1, convRule: rule124 },
    { start: 71231, length: 2, convRule: rule92 },
    { start: 71233, length: 3, convRule: rule2 },
    { start: 71236, length: 1, convRule: rule14 },
    { start: 71248, length: 10, convRule: rule8 },
    { start: 71264, length: 13, convRule: rule2 },
    { start: 71296, length: 43, convRule: rule14 },
    { start: 71339, length: 1, convRule: rule92 },
    { start: 71340, length: 1, convRule: rule124 },
    { start: 71341, length: 1, convRule: rule92 },
    { start: 71342, length: 2, convRule: rule124 },
    { start: 71344, length: 6, convRule: rule92 },
    { start: 71350, length: 1, convRule: rule124 },
    { start: 71351, length: 1, convRule: rule92 },
    { start: 71352, length: 1, convRule: rule14 },
    { start: 71360, length: 10, convRule: rule8 },
    { start: 71424, length: 27, convRule: rule14 },
    { start: 71453, length: 3, convRule: rule92 },
    { start: 71456, length: 2, convRule: rule124 },
    { start: 71458, length: 4, convRule: rule92 },
    { start: 71462, length: 1, convRule: rule124 },
    { start: 71463, length: 5, convRule: rule92 },
    { start: 71472, length: 10, convRule: rule8 },
    { start: 71482, length: 2, convRule: rule17 },
    { start: 71484, length: 3, convRule: rule2 },
    { start: 71487, length: 1, convRule: rule13 },
    { start: 71680, length: 44, convRule: rule14 },
    { start: 71724, length: 3, convRule: rule124 },
    { start: 71727, length: 9, convRule: rule92 },
    { start: 71736, length: 1, convRule: rule124 },
    { start: 71737, length: 2, convRule: rule92 },
    { start: 71739, length: 1, convRule: rule2 },
    { start: 71840, length: 32, convRule: rule9 },
    { start: 71872, length: 32, convRule: rule12 },
    { start: 71904, length: 10, convRule: rule8 },
    { start: 71914, length: 9, convRule: rule17 },
    { start: 71935, length: 8, convRule: rule14 },
    { start: 71945, length: 1, convRule: rule14 },
    { start: 71948, length: 8, convRule: rule14 },
    { start: 71957, length: 2, convRule: rule14 },
    { start: 71960, length: 24, convRule: rule14 },
    { start: 71984, length: 6, convRule: rule124 },
    { start: 71991, length: 2, convRule: rule124 },
    { start: 71995, length: 2, convRule: rule92 },
    { start: 71997, length: 1, convRule: rule124 },
    { start: 71998, length: 1, convRule: rule92 },
    { start: 71999, length: 1, convRule: rule14 },
    { start: 72e3, length: 1, convRule: rule124 },
    { start: 72001, length: 1, convRule: rule14 },
    { start: 72002, length: 1, convRule: rule124 },
    { start: 72003, length: 1, convRule: rule92 },
    { start: 72004, length: 3, convRule: rule2 },
    { start: 72016, length: 10, convRule: rule8 },
    { start: 72096, length: 8, convRule: rule14 },
    { start: 72106, length: 39, convRule: rule14 },
    { start: 72145, length: 3, convRule: rule124 },
    { start: 72148, length: 4, convRule: rule92 },
    { start: 72154, length: 2, convRule: rule92 },
    { start: 72156, length: 4, convRule: rule124 },
    { start: 72160, length: 1, convRule: rule92 },
    { start: 72161, length: 1, convRule: rule14 },
    { start: 72162, length: 1, convRule: rule2 },
    { start: 72163, length: 1, convRule: rule14 },
    { start: 72164, length: 1, convRule: rule124 },
    { start: 72192, length: 1, convRule: rule14 },
    { start: 72193, length: 10, convRule: rule92 },
    { start: 72203, length: 40, convRule: rule14 },
    { start: 72243, length: 6, convRule: rule92 },
    { start: 72249, length: 1, convRule: rule124 },
    { start: 72250, length: 1, convRule: rule14 },
    { start: 72251, length: 4, convRule: rule92 },
    { start: 72255, length: 8, convRule: rule2 },
    { start: 72263, length: 1, convRule: rule92 },
    { start: 72272, length: 1, convRule: rule14 },
    { start: 72273, length: 6, convRule: rule92 },
    { start: 72279, length: 2, convRule: rule124 },
    { start: 72281, length: 3, convRule: rule92 },
    { start: 72284, length: 46, convRule: rule14 },
    { start: 72330, length: 13, convRule: rule92 },
    { start: 72343, length: 1, convRule: rule124 },
    { start: 72344, length: 2, convRule: rule92 },
    { start: 72346, length: 3, convRule: rule2 },
    { start: 72349, length: 1, convRule: rule14 },
    { start: 72350, length: 5, convRule: rule2 },
    { start: 72384, length: 57, convRule: rule14 },
    { start: 72704, length: 9, convRule: rule14 },
    { start: 72714, length: 37, convRule: rule14 },
    { start: 72751, length: 1, convRule: rule124 },
    { start: 72752, length: 7, convRule: rule92 },
    { start: 72760, length: 6, convRule: rule92 },
    { start: 72766, length: 1, convRule: rule124 },
    { start: 72767, length: 1, convRule: rule92 },
    { start: 72768, length: 1, convRule: rule14 },
    { start: 72769, length: 5, convRule: rule2 },
    { start: 72784, length: 10, convRule: rule8 },
    { start: 72794, length: 19, convRule: rule17 },
    { start: 72816, length: 2, convRule: rule2 },
    { start: 72818, length: 30, convRule: rule14 },
    { start: 72850, length: 22, convRule: rule92 },
    { start: 72873, length: 1, convRule: rule124 },
    { start: 72874, length: 7, convRule: rule92 },
    { start: 72881, length: 1, convRule: rule124 },
    { start: 72882, length: 2, convRule: rule92 },
    { start: 72884, length: 1, convRule: rule124 },
    { start: 72885, length: 2, convRule: rule92 },
    { start: 72960, length: 7, convRule: rule14 },
    { start: 72968, length: 2, convRule: rule14 },
    { start: 72971, length: 38, convRule: rule14 },
    { start: 73009, length: 6, convRule: rule92 },
    { start: 73018, length: 1, convRule: rule92 },
    { start: 73020, length: 2, convRule: rule92 },
    { start: 73023, length: 7, convRule: rule92 },
    { start: 73030, length: 1, convRule: rule14 },
    { start: 73031, length: 1, convRule: rule92 },
    { start: 73040, length: 10, convRule: rule8 },
    { start: 73056, length: 6, convRule: rule14 },
    { start: 73063, length: 2, convRule: rule14 },
    { start: 73066, length: 32, convRule: rule14 },
    { start: 73098, length: 5, convRule: rule124 },
    { start: 73104, length: 2, convRule: rule92 },
    { start: 73107, length: 2, convRule: rule124 },
    { start: 73109, length: 1, convRule: rule92 },
    { start: 73110, length: 1, convRule: rule124 },
    { start: 73111, length: 1, convRule: rule92 },
    { start: 73112, length: 1, convRule: rule14 },
    { start: 73120, length: 10, convRule: rule8 },
    { start: 73440, length: 19, convRule: rule14 },
    { start: 73459, length: 2, convRule: rule92 },
    { start: 73461, length: 2, convRule: rule124 },
    { start: 73463, length: 2, convRule: rule2 },
    { start: 73648, length: 1, convRule: rule14 },
    { start: 73664, length: 21, convRule: rule17 },
    { start: 73685, length: 8, convRule: rule13 },
    { start: 73693, length: 4, convRule: rule3 },
    { start: 73697, length: 17, convRule: rule13 },
    { start: 73727, length: 1, convRule: rule2 },
    { start: 73728, length: 922, convRule: rule14 },
    { start: 74752, length: 111, convRule: rule128 },
    { start: 74864, length: 5, convRule: rule2 },
    { start: 74880, length: 196, convRule: rule14 },
    { start: 77824, length: 1071, convRule: rule14 },
    { start: 78896, length: 9, convRule: rule16 },
    { start: 82944, length: 583, convRule: rule14 },
    { start: 92160, length: 569, convRule: rule14 },
    { start: 92736, length: 31, convRule: rule14 },
    { start: 92768, length: 10, convRule: rule8 },
    { start: 92782, length: 2, convRule: rule2 },
    { start: 92880, length: 30, convRule: rule14 },
    { start: 92912, length: 5, convRule: rule92 },
    { start: 92917, length: 1, convRule: rule2 },
    { start: 92928, length: 48, convRule: rule14 },
    { start: 92976, length: 7, convRule: rule92 },
    { start: 92983, length: 5, convRule: rule2 },
    { start: 92988, length: 4, convRule: rule13 },
    { start: 92992, length: 4, convRule: rule91 },
    { start: 92996, length: 1, convRule: rule2 },
    { start: 92997, length: 1, convRule: rule13 },
    { start: 93008, length: 10, convRule: rule8 },
    { start: 93019, length: 7, convRule: rule17 },
    { start: 93027, length: 21, convRule: rule14 },
    { start: 93053, length: 19, convRule: rule14 },
    { start: 93760, length: 32, convRule: rule9 },
    { start: 93792, length: 32, convRule: rule12 },
    { start: 93824, length: 23, convRule: rule17 },
    { start: 93847, length: 4, convRule: rule2 },
    { start: 93952, length: 75, convRule: rule14 },
    { start: 94031, length: 1, convRule: rule92 },
    { start: 94032, length: 1, convRule: rule14 },
    { start: 94033, length: 55, convRule: rule124 },
    { start: 94095, length: 4, convRule: rule92 },
    { start: 94099, length: 13, convRule: rule91 },
    { start: 94176, length: 2, convRule: rule91 },
    { start: 94178, length: 1, convRule: rule2 },
    { start: 94179, length: 1, convRule: rule91 },
    { start: 94180, length: 1, convRule: rule92 },
    { start: 94192, length: 2, convRule: rule124 },
    { start: 94208, length: 6136, convRule: rule14 },
    { start: 100352, length: 1238, convRule: rule14 },
    { start: 101632, length: 9, convRule: rule14 },
    { start: 110592, length: 287, convRule: rule14 },
    { start: 110928, length: 3, convRule: rule14 },
    { start: 110948, length: 4, convRule: rule14 },
    { start: 110960, length: 396, convRule: rule14 },
    { start: 113664, length: 107, convRule: rule14 },
    { start: 113776, length: 13, convRule: rule14 },
    { start: 113792, length: 9, convRule: rule14 },
    { start: 113808, length: 10, convRule: rule14 },
    { start: 113820, length: 1, convRule: rule13 },
    { start: 113821, length: 2, convRule: rule92 },
    { start: 113823, length: 1, convRule: rule2 },
    { start: 113824, length: 4, convRule: rule16 },
    { start: 118784, length: 246, convRule: rule13 },
    { start: 119040, length: 39, convRule: rule13 },
    { start: 119081, length: 60, convRule: rule13 },
    { start: 119141, length: 2, convRule: rule124 },
    { start: 119143, length: 3, convRule: rule92 },
    { start: 119146, length: 3, convRule: rule13 },
    { start: 119149, length: 6, convRule: rule124 },
    { start: 119155, length: 8, convRule: rule16 },
    { start: 119163, length: 8, convRule: rule92 },
    { start: 119171, length: 2, convRule: rule13 },
    { start: 119173, length: 7, convRule: rule92 },
    { start: 119180, length: 30, convRule: rule13 },
    { start: 119210, length: 4, convRule: rule92 },
    { start: 119214, length: 59, convRule: rule13 },
    { start: 119296, length: 66, convRule: rule13 },
    { start: 119362, length: 3, convRule: rule92 },
    { start: 119365, length: 1, convRule: rule13 },
    { start: 119520, length: 20, convRule: rule17 },
    { start: 119552, length: 87, convRule: rule13 },
    { start: 119648, length: 25, convRule: rule17 },
    { start: 119808, length: 26, convRule: rule107 },
    { start: 119834, length: 26, convRule: rule20 },
    { start: 119860, length: 26, convRule: rule107 },
    { start: 119886, length: 7, convRule: rule20 },
    { start: 119894, length: 18, convRule: rule20 },
    { start: 119912, length: 26, convRule: rule107 },
    { start: 119938, length: 26, convRule: rule20 },
    { start: 119964, length: 1, convRule: rule107 },
    { start: 119966, length: 2, convRule: rule107 },
    { start: 119970, length: 1, convRule: rule107 },
    { start: 119973, length: 2, convRule: rule107 },
    { start: 119977, length: 4, convRule: rule107 },
    { start: 119982, length: 8, convRule: rule107 },
    { start: 119990, length: 4, convRule: rule20 },
    { start: 119995, length: 1, convRule: rule20 },
    { start: 119997, length: 7, convRule: rule20 },
    { start: 120005, length: 11, convRule: rule20 },
    { start: 120016, length: 26, convRule: rule107 },
    { start: 120042, length: 26, convRule: rule20 },
    { start: 120068, length: 2, convRule: rule107 },
    { start: 120071, length: 4, convRule: rule107 },
    { start: 120077, length: 8, convRule: rule107 },
    { start: 120086, length: 7, convRule: rule107 },
    { start: 120094, length: 26, convRule: rule20 },
    { start: 120120, length: 2, convRule: rule107 },
    { start: 120123, length: 4, convRule: rule107 },
    { start: 120128, length: 5, convRule: rule107 },
    { start: 120134, length: 1, convRule: rule107 },
    { start: 120138, length: 7, convRule: rule107 },
    { start: 120146, length: 26, convRule: rule20 },
    { start: 120172, length: 26, convRule: rule107 },
    { start: 120198, length: 26, convRule: rule20 },
    { start: 120224, length: 26, convRule: rule107 },
    { start: 120250, length: 26, convRule: rule20 },
    { start: 120276, length: 26, convRule: rule107 },
    { start: 120302, length: 26, convRule: rule20 },
    { start: 120328, length: 26, convRule: rule107 },
    { start: 120354, length: 26, convRule: rule20 },
    { start: 120380, length: 26, convRule: rule107 },
    { start: 120406, length: 26, convRule: rule20 },
    { start: 120432, length: 26, convRule: rule107 },
    { start: 120458, length: 28, convRule: rule20 },
    { start: 120488, length: 25, convRule: rule107 },
    { start: 120513, length: 1, convRule: rule6 },
    { start: 120514, length: 25, convRule: rule20 },
    { start: 120539, length: 1, convRule: rule6 },
    { start: 120540, length: 6, convRule: rule20 },
    { start: 120546, length: 25, convRule: rule107 },
    { start: 120571, length: 1, convRule: rule6 },
    { start: 120572, length: 25, convRule: rule20 },
    { start: 120597, length: 1, convRule: rule6 },
    { start: 120598, length: 6, convRule: rule20 },
    { start: 120604, length: 25, convRule: rule107 },
    { start: 120629, length: 1, convRule: rule6 },
    { start: 120630, length: 25, convRule: rule20 },
    { start: 120655, length: 1, convRule: rule6 },
    { start: 120656, length: 6, convRule: rule20 },
    { start: 120662, length: 25, convRule: rule107 },
    { start: 120687, length: 1, convRule: rule6 },
    { start: 120688, length: 25, convRule: rule20 },
    { start: 120713, length: 1, convRule: rule6 },
    { start: 120714, length: 6, convRule: rule20 },
    { start: 120720, length: 25, convRule: rule107 },
    { start: 120745, length: 1, convRule: rule6 },
    { start: 120746, length: 25, convRule: rule20 },
    { start: 120771, length: 1, convRule: rule6 },
    { start: 120772, length: 6, convRule: rule20 },
    { start: 120778, length: 1, convRule: rule107 },
    { start: 120779, length: 1, convRule: rule20 },
    { start: 120782, length: 50, convRule: rule8 },
    { start: 120832, length: 512, convRule: rule13 },
    { start: 121344, length: 55, convRule: rule92 },
    { start: 121399, length: 4, convRule: rule13 },
    { start: 121403, length: 50, convRule: rule92 },
    { start: 121453, length: 8, convRule: rule13 },
    { start: 121461, length: 1, convRule: rule92 },
    { start: 121462, length: 14, convRule: rule13 },
    { start: 121476, length: 1, convRule: rule92 },
    { start: 121477, length: 2, convRule: rule13 },
    { start: 121479, length: 5, convRule: rule2 },
    { start: 121499, length: 5, convRule: rule92 },
    { start: 121505, length: 15, convRule: rule92 },
    { start: 122880, length: 7, convRule: rule92 },
    { start: 122888, length: 17, convRule: rule92 },
    { start: 122907, length: 7, convRule: rule92 },
    { start: 122915, length: 2, convRule: rule92 },
    { start: 122918, length: 5, convRule: rule92 },
    { start: 123136, length: 45, convRule: rule14 },
    { start: 123184, length: 7, convRule: rule92 },
    { start: 123191, length: 7, convRule: rule91 },
    { start: 123200, length: 10, convRule: rule8 },
    { start: 123214, length: 1, convRule: rule14 },
    { start: 123215, length: 1, convRule: rule13 },
    { start: 123584, length: 44, convRule: rule14 },
    { start: 123628, length: 4, convRule: rule92 },
    { start: 123632, length: 10, convRule: rule8 },
    { start: 123647, length: 1, convRule: rule3 },
    { start: 124928, length: 197, convRule: rule14 },
    { start: 125127, length: 9, convRule: rule17 },
    { start: 125136, length: 7, convRule: rule92 },
    { start: 125184, length: 34, convRule: rule203 },
    { start: 125218, length: 34, convRule: rule204 },
    { start: 125252, length: 7, convRule: rule92 },
    { start: 125259, length: 1, convRule: rule91 },
    { start: 125264, length: 10, convRule: rule8 },
    { start: 125278, length: 2, convRule: rule2 },
    { start: 126065, length: 59, convRule: rule17 },
    { start: 126124, length: 1, convRule: rule13 },
    { start: 126125, length: 3, convRule: rule17 },
    { start: 126128, length: 1, convRule: rule3 },
    { start: 126129, length: 4, convRule: rule17 },
    { start: 126209, length: 45, convRule: rule17 },
    { start: 126254, length: 1, convRule: rule13 },
    { start: 126255, length: 15, convRule: rule17 },
    { start: 126464, length: 4, convRule: rule14 },
    { start: 126469, length: 27, convRule: rule14 },
    { start: 126497, length: 2, convRule: rule14 },
    { start: 126500, length: 1, convRule: rule14 },
    { start: 126503, length: 1, convRule: rule14 },
    { start: 126505, length: 10, convRule: rule14 },
    { start: 126516, length: 4, convRule: rule14 },
    { start: 126521, length: 1, convRule: rule14 },
    { start: 126523, length: 1, convRule: rule14 },
    { start: 126530, length: 1, convRule: rule14 },
    { start: 126535, length: 1, convRule: rule14 },
    { start: 126537, length: 1, convRule: rule14 },
    { start: 126539, length: 1, convRule: rule14 },
    { start: 126541, length: 3, convRule: rule14 },
    { start: 126545, length: 2, convRule: rule14 },
    { start: 126548, length: 1, convRule: rule14 },
    { start: 126551, length: 1, convRule: rule14 },
    { start: 126553, length: 1, convRule: rule14 },
    { start: 126555, length: 1, convRule: rule14 },
    { start: 126557, length: 1, convRule: rule14 },
    { start: 126559, length: 1, convRule: rule14 },
    { start: 126561, length: 2, convRule: rule14 },
    { start: 126564, length: 1, convRule: rule14 },
    { start: 126567, length: 4, convRule: rule14 },
    { start: 126572, length: 7, convRule: rule14 },
    { start: 126580, length: 4, convRule: rule14 },
    { start: 126585, length: 4, convRule: rule14 },
    { start: 126590, length: 1, convRule: rule14 },
    { start: 126592, length: 10, convRule: rule14 },
    { start: 126603, length: 17, convRule: rule14 },
    { start: 126625, length: 3, convRule: rule14 },
    { start: 126629, length: 5, convRule: rule14 },
    { start: 126635, length: 17, convRule: rule14 },
    { start: 126704, length: 2, convRule: rule6 },
    { start: 126976, length: 44, convRule: rule13 },
    { start: 127024, length: 100, convRule: rule13 },
    { start: 127136, length: 15, convRule: rule13 },
    { start: 127153, length: 15, convRule: rule13 },
    { start: 127169, length: 15, convRule: rule13 },
    { start: 127185, length: 37, convRule: rule13 },
    { start: 127232, length: 13, convRule: rule17 },
    { start: 127245, length: 161, convRule: rule13 },
    { start: 127462, length: 29, convRule: rule13 },
    { start: 127504, length: 44, convRule: rule13 },
    { start: 127552, length: 9, convRule: rule13 },
    { start: 127568, length: 2, convRule: rule13 },
    { start: 127584, length: 6, convRule: rule13 },
    { start: 127744, length: 251, convRule: rule13 },
    { start: 127995, length: 5, convRule: rule10 },
    { start: 128e3, length: 728, convRule: rule13 },
    { start: 128736, length: 13, convRule: rule13 },
    { start: 128752, length: 13, convRule: rule13 },
    { start: 128768, length: 116, convRule: rule13 },
    { start: 128896, length: 89, convRule: rule13 },
    { start: 128992, length: 12, convRule: rule13 },
    { start: 129024, length: 12, convRule: rule13 },
    { start: 129040, length: 56, convRule: rule13 },
    { start: 129104, length: 10, convRule: rule13 },
    { start: 129120, length: 40, convRule: rule13 },
    { start: 129168, length: 30, convRule: rule13 },
    { start: 129200, length: 2, convRule: rule13 },
    { start: 129280, length: 121, convRule: rule13 },
    { start: 129402, length: 82, convRule: rule13 },
    { start: 129485, length: 135, convRule: rule13 },
    { start: 129632, length: 14, convRule: rule13 },
    { start: 129648, length: 5, convRule: rule13 },
    { start: 129656, length: 3, convRule: rule13 },
    { start: 129664, length: 7, convRule: rule13 },
    { start: 129680, length: 25, convRule: rule13 },
    { start: 129712, length: 7, convRule: rule13 },
    { start: 129728, length: 3, convRule: rule13 },
    { start: 129744, length: 7, convRule: rule13 },
    { start: 129792, length: 147, convRule: rule13 },
    { start: 129940, length: 55, convRule: rule13 },
    { start: 130032, length: 10, convRule: rule8 },
    { start: 131072, length: 42718, convRule: rule14 },
    { start: 173824, length: 4149, convRule: rule14 },
    { start: 177984, length: 222, convRule: rule14 },
    { start: 178208, length: 5762, convRule: rule14 },
    { start: 183984, length: 7473, convRule: rule14 },
    { start: 194560, length: 542, convRule: rule14 },
    { start: 196608, length: 4939, convRule: rule14 },
    { start: 917505, length: 1, convRule: rule16 },
    { start: 917536, length: 96, convRule: rule16 },
    { start: 917760, length: 240, convRule: rule92 },
    { start: 983040, length: 65534, convRule: rule200 },
    { start: 1048576, length: 65534, convRule: rule200 }
  ];
  var checkAttr = (categories) => ($$char) => {
    const maybeConversionRule = getRule(allchars)($$char)($$char < 256 ? 63 : 3396);
    if (maybeConversionRule.tag === "Nothing") {
      return false;
    }
    if (maybeConversionRule.tag === "Just") {
      const $0 = maybeConversionRule._1.category;
      const $1 = findIndexImpl(Just, Nothing, (v) => v === $0, categories);
      if ($1.tag === "Nothing") {
        return false;
      }
      if ($1.tag === "Just") {
        return true;
      }
    }
    fail();
  };

  // output-es/DataType/index.js
  var $DataType = (_1, _2) => ({ tag: "DataType", _1, _2 });
  var fromFoldable3 = /* @__PURE__ */ fromFoldable(foldableArray);
  var fromFoldable1 = /* @__PURE__ */ (() => foldableSet.foldl((m) => (a) => insert3(ordString)(a)()(m))(Leaf))();
  var toUnfoldable3 = /* @__PURE__ */ (() => {
    const $0 = toUnfoldable2(unfoldableList);
    return (x2) => $0(keys2(x2));
  })();
  var show = /* @__PURE__ */ (() => showSet(showString).show)();
  var DataType = (value0) => (value1) => $DataType(value0, value1);
  var typeName2 = (v) => v._1;
  var eqDataType = { eq: (x2) => (y2) => x2._1 === y2._1 };
  var showDataType = { show: typeName2 };
  var isCtrName = (str) => checkAttr([512, 524288])(toCharCode(definitely("absurd")(charAt2(0)(str))));
  var showCtr = (c) => {
    if (isCtrName(c)) {
      return c;
    }
    if (":" === definitely("absurd")(charAt2(0)(c))) {
      return "(" + c + ")";
    }
    return throwException(error("absurd"))();
  };
  var dataType = (name3) => {
    const $0 = arrayMap((v) => $Tuple(v._1, v._2));
    const $1 = DataType(name3);
    return (x2) => $1(fromFoldable3($0(x2)));
  };
  var dataTypes = /* @__PURE__ */ foldrArray(Cons)(Nil)([
    /* @__PURE__ */ dataType("Bool")([/* @__PURE__ */ $Tuple("True", 0), /* @__PURE__ */ $Tuple("False", 0)]),
    /* @__PURE__ */ dataType("InfNum")([/* @__PURE__ */ $Tuple("FNum", 1), /* @__PURE__ */ $Tuple("Infty", 0)]),
    /* @__PURE__ */ dataType("List")([/* @__PURE__ */ $Tuple("Nil", 0), /* @__PURE__ */ $Tuple(":", 2)]),
    /* @__PURE__ */ dataType("Option")([/* @__PURE__ */ $Tuple("None", 0), /* @__PURE__ */ $Tuple("Some", 1)]),
    /* @__PURE__ */ dataType("Ordering")([/* @__PURE__ */ $Tuple("GT", 0), /* @__PURE__ */ $Tuple("LT", 0), /* @__PURE__ */ $Tuple("EQ", 0)]),
    /* @__PURE__ */ dataType("Pair")([/* @__PURE__ */ $Tuple("Pair", 2)]),
    /* @__PURE__ */ dataType("Tree")([/* @__PURE__ */ $Tuple("Empty", 0), /* @__PURE__ */ $Tuple("NonEmpty", 3)]),
    /* @__PURE__ */ dataType("LinePlot")([/* @__PURE__ */ $Tuple("LinePlot", 1)]),
    /* @__PURE__ */ dataType("Orientation")([/* @__PURE__ */ $Tuple("Default", 0), /* @__PURE__ */ $Tuple("Rotated", 0)]),
    /* @__PURE__ */ dataType("View")([
      /* @__PURE__ */ $Tuple("BarChart", 1),
      /* @__PURE__ */ $Tuple("LineChart", 1),
      /* @__PURE__ */ $Tuple("LinkedText", 1),
      /* @__PURE__ */ $Tuple("MultiView", 1),
      /* @__PURE__ */ $Tuple("ScatterPlot", 1)
    ]),
    /* @__PURE__ */ dataType("Point")([/* @__PURE__ */ $Tuple("Point", 2)]),
    /* @__PURE__ */ dataType("Orient")([/* @__PURE__ */ $Tuple("Horiz", 0), /* @__PURE__ */ $Tuple("Vert", 0)]),
    /* @__PURE__ */ dataType("GraphicsElement")([
      /* @__PURE__ */ $Tuple("Circle", 4),
      /* @__PURE__ */ $Tuple("Group", 1),
      /* @__PURE__ */ $Tuple("Line", 4),
      /* @__PURE__ */ $Tuple("Polyline", 3),
      /* @__PURE__ */ $Tuple("Polymarkers", 2),
      /* @__PURE__ */ $Tuple("Rect", 5),
      /* @__PURE__ */ $Tuple("Text", 5),
      /* @__PURE__ */ $Tuple("Viewport", 9)
    ]),
    /* @__PURE__ */ dataType("Transform")([/* @__PURE__ */ $Tuple("Scale", 2), /* @__PURE__ */ $Tuple("Translate", 2)]),
    /* @__PURE__ */ dataType("Marker")([/* @__PURE__ */ $Tuple("Arrowhead", 0)])
  ]);
  var ctrToDataType = /* @__PURE__ */ (() => fromFoldable(foldableList)(bindList.bind(listMap((d) => listMap((v) => $Tuple(
    v,
    d
  ))(toUnfoldable3(fromFoldable1(mapObjectString.keys(d._2)))))(dataTypes))(identity13)))();
  var dataTypeForCtr = {
    dataTypeFor: (dictMonadThrow) => (c) => orElse(dictMonadThrow)("Unknown constructor " + showCtr(c))(_lookup(
      Nothing,
      Just,
      c,
      ctrToDataType
    ))
  };
  var dataTypeForSetCtr = {
    dataTypeFor: (dictMonadThrow) => (cs) => {
      const v = toUnfoldable3(cs);
      if (v.tag === "Cons") {
        return dataTypeForCtr.dataTypeFor(dictMonadThrow)(v._1);
      }
      fail();
    }
  };
  var consistentWith = (dictMonadError) => {
    const MonadThrow0 = dictMonadError.MonadThrow0();
    const Bind1 = MonadThrow0.Monad0().Bind1();
    const $$void = Bind1.Apply0().Functor0().map((v) => {
    });
    const withMsg2 = withMsg(dictMonadError);
    return (cs) => (cs$p) => $$void(Bind1.bind(dataTypeForSetCtr.dataTypeFor(MonadThrow0)(cs$p))((d) => Bind1.bind(dataTypeForSetCtr.dataTypeFor(MonadThrow0)(cs$p))((d$p) => withMsg2("constructors of " + d$p._1 + " do not include " + show(map2(ordString)(showCtr)(cs)))(mayFailEq(MonadThrow0)(showDataType)(eqDataType)(d)(d$p)))));
  };
  var arity = (dictMonadThrow) => (c) => dictMonadThrow.Monad0().Bind1().bind(dataTypeForCtr.dataTypeFor(dictMonadThrow)(c))((v) => orElse(dictMonadThrow)("absurd")(_lookup(
    Nothing,
    Just,
    c,
    v._2
  )));
  var checkArity = (dictMonadError) => {
    const MonadThrow0 = dictMonadError.MonadThrow0();
    const Monad0 = MonadThrow0.Monad0();
    const $$void = Monad0.Bind1().Apply0().Functor0().map((v) => {
    });
    const withMsg2 = withMsg(dictMonadError);
    const bind2Flipped2 = bind2Flipped(Monad0);
    return (c) => (n) => $$void(withMsg2("Checking arity of " + showCtr(c))(bind2Flipped2(mayFailEq(MonadThrow0)(showInt)(eqInt))(arity(MonadThrow0)(c))(Monad0.Applicative0().pure(n))));
  };

  // output-es/Graph/index.js
  var fromFoldable22 = /* @__PURE__ */ (() => foldableSet.foldr(Cons)(Nil))();
  var Vertex = (x2) => x2;
  var eqVertex = { eq: (x2) => (y2) => x2 === y2 };
  var ordVertex = { compare: (x2) => (y2) => ordString.compare(x2)(y2), Eq0: () => eqVertex };
  var mempty = /* @__PURE__ */ (() => monoidSet(ordVertex).mempty)();
  var member2 = /* @__PURE__ */ (() => setSet(ordVertex).member)();
  var select\u03B1s\u{1D539}Vertex = (dictApply) => {
    const $0 = dictApply.Functor0();
    return (dictFoldable) => {
      const unions13 = unions(dictFoldable)(ordVertex);
      return {
        "select\u03B1s": (v\u{1D539}) => (v\u03B1) => unions13(dictApply.apply($0.map((v) => {
          if (v) {
            return singleton3;
          }
          return (v$1) => mempty;
        })(v\u{1D539}))(v\u03B1)),
        "select\u{1D539}s": (v\u03B1) => (\u03B1s) => $0.map((v) => member2(v)(\u03B1s))(v\u03B1)
      };
    };
  };
  var verticesVertex = (dictFunctor) => (dictFoldable) => ({
    vertices: (() => {
      const $0 = unions(dictFoldable)(ordVertex);
      return (x2) => $0(dictFunctor.map(singleton3)(x2));
    })()
  });
  var showVertices = (\u03B1s) => "{" + joinWith(", ")(fromFoldableImpl(
    foldableSet.foldr,
    map2(ordString)(unsafeCoerce)(\u03B1s)
  )) + "}";
  var showEdgeList = (es) => joinWith("\n")([
    "digraph G {",
    ...arrayMap((v) => "   " + v)([
      "rankdir = RL",
      ...arrayMap((v) => v._1 + " -> {" + joinWith(", ")(fromFoldableImpl(
        foldableSet.foldr,
        map2(ordString)(unsafeCoerce)(v._2)
      )) + "}")(fromFoldableImpl(foldableList.foldr, reverse2(es)))
    ]),
    "}"
  ]);
  var toEdgeList = (dictGraph) => (g) => {
    const $0 = (v) => {
      if (v._1.tag === "Nil") {
        return $Step("Done", v._2);
      }
      if (v._1.tag === "Cons") {
        return $Step("Loop", $Tuple(v._1._2, $List("Cons", $Tuple(v._1._1, dictGraph.outN(g)(v._1._1)), v._2)));
      }
      fail();
    };
    const go = (go$a0$copy) => {
      let go$a0 = go$a0$copy, go$c = true, go$r;
      while (go$c) {
        const v = go$a0;
        if (v.tag === "Loop") {
          go$a0 = $0(v._1);
          continue;
        }
        if (v.tag === "Done") {
          go$c = false;
          go$r = v._1;
          continue;
        }
        fail();
      }
      return go$r;
    };
    return go($0($Tuple(dictGraph.topologicalSort(g), Nil)));
  };
  var showGraph = (dictGraph) => (x2) => showEdgeList(toEdgeList(dictGraph)(x2));
  var inEdges$p = (dictGraph) => (g) => (\u03B1) => fromFoldable22(map2(ordTuple(ordVertex)(ordVertex))((v) => $Tuple(v, \u03B1))(dictGraph.inN(g)(\u03B1)));
  var inEdges = (dictGraph) => (g) => (\u03B1s) => {
    const $0 = (v) => {
      if (v._1.tag === "Nil") {
        return $Step("Done", v._2);
      }
      if (v._1.tag === "Cons") {
        return $Step(
          "Loop",
          $Tuple(v._1._2, foldableList.foldr(Cons)(v._2)(inEdges$p(dictGraph)(g)(v._1._1)))
        );
      }
      fail();
    };
    const go = (go$a0$copy) => {
      let go$a0 = go$a0$copy, go$c = true, go$r;
      while (go$c) {
        const v = go$a0;
        if (v.tag === "Loop") {
          go$a0 = $0(v._1);
          continue;
        }
        if (v.tag === "Done") {
          go$c = false;
          go$r = v._1;
          continue;
        }
        fail();
      }
      return go$r;
    };
    return go($0($Tuple(fromFoldable22(\u03B1s), Nil)));
  };

  // output-es/Data.CatQueue/index.js
  var $CatQueue = (_1, _2) => ({ tag: "CatQueue", _1, _2 });
  var uncons3 = (uncons$a0$copy) => {
    let uncons$a0 = uncons$a0$copy, uncons$c = true, uncons$r;
    while (uncons$c) {
      const v = uncons$a0;
      if (v._1.tag === "Nil") {
        if (v._2.tag === "Nil") {
          uncons$c = false;
          uncons$r = Nothing;
          continue;
        }
        uncons$a0 = $CatQueue(reverse2(v._2), Nil);
        continue;
      }
      if (v._1.tag === "Cons") {
        uncons$c = false;
        uncons$r = $Maybe("Just", $Tuple(v._1._1, $CatQueue(v._1._2, v._2)));
        continue;
      }
      fail();
    }
    return uncons$r;
  };

  // output-es/Data.CatList/index.js
  var $CatList = (tag, _1, _2) => ({ tag, _1, _2 });
  var CatNil = /* @__PURE__ */ $CatList("CatNil");
  var link = (v) => (v1) => {
    if (v.tag === "CatNil") {
      return v1;
    }
    if (v1.tag === "CatNil") {
      return v;
    }
    if (v.tag === "CatCons") {
      return $CatList("CatCons", v._1, $CatQueue(v._2._1, $List("Cons", v1, v._2._2)));
    }
    fail();
  };
  var foldr = (k) => (b) => (q) => {
    const foldl = (foldl$a0$copy) => (foldl$a1$copy) => (foldl$a2$copy) => {
      let foldl$a0 = foldl$a0$copy, foldl$a1 = foldl$a1$copy, foldl$a2 = foldl$a2$copy, foldl$c = true, foldl$r;
      while (foldl$c) {
        const v = foldl$a0, v1 = foldl$a1, v2 = foldl$a2;
        if (v2.tag === "Nil") {
          foldl$c = false;
          foldl$r = v1;
          continue;
        }
        if (v2.tag === "Cons") {
          foldl$a0 = v;
          foldl$a1 = v(v1)(v2._1);
          foldl$a2 = v2._2;
          continue;
        }
        fail();
      }
      return foldl$r;
    };
    const go = (go$a0$copy) => (go$a1$copy) => {
      let go$a0 = go$a0$copy, go$a1 = go$a1$copy, go$c = true, go$r;
      while (go$c) {
        const xs = go$a0, ys = go$a1;
        const v = uncons3(xs);
        if (v.tag === "Nothing") {
          go$c = false;
          go$r = foldl((x2) => (i) => i(x2))(b)(ys);
          continue;
        }
        if (v.tag === "Just") {
          go$a0 = v._1._2;
          go$a1 = $List("Cons", k(v._1._1), ys);
          continue;
        }
        fail();
      }
      return go$r;
    };
    return go(q)(Nil);
  };
  var uncons4 = (v) => {
    if (v.tag === "CatNil") {
      return Nothing;
    }
    if (v.tag === "CatCons") {
      return $Maybe("Just", $Tuple(v._1, v._2._1.tag === "Nil" && v._2._2.tag === "Nil" ? CatNil : foldr(link)(CatNil)(v._2)));
    }
    fail();
  };
  var singleton5 = (a) => $CatList("CatCons", a, $CatQueue(Nil, Nil));
  var semigroupCatList = { append: link };
  var monoidCatList = { mempty: CatNil, Semigroup0: () => semigroupCatList };

  // output-es/Data.Graph/index.js
  var $SortStep = (tag, _1) => ({ tag, _1 });
  var fromFoldable4 = /* @__PURE__ */ (() => {
    const foldMap1 = foldableList.foldMap(monoidCatList);
    return (f) => foldMap1(singleton5)(f);
  })();
  var fromFoldable12 = /* @__PURE__ */ (() => {
    const foldMap1 = foldableArray.foldMap(monoidCatList);
    return (f) => foldMap1(singleton5)(f);
  })();
  var Visit = (value0) => $SortStep("Visit", value0);
  var topologicalSort = (dictOrd) => (v) => {
    const visit = (visit$a0$copy) => (visit$a1$copy) => {
      let visit$a0 = visit$a0$copy, visit$a1 = visit$a1$copy, visit$c = true, visit$r;
      while (visit$c) {
        const state = visit$a0, stack = visit$a1;
        const v1 = uncons4(stack);
        if (v1.tag === "Nothing") {
          visit$c = false;
          visit$r = state;
          continue;
        }
        if (v1.tag === "Just") {
          if (v1._1._1.tag === "Emit") {
            visit$a0 = { result: $List("Cons", v1._1._1._1, state.result), unvisited: state.unvisited };
            visit$a1 = v1._1._2;
            continue;
          }
          if (v1._1._1.tag === "Visit") {
            if ((() => {
              const $0 = v1._1._1._1;
              const go2 = (go$a0$copy) => {
                let go$a0 = go$a0$copy, go$c = true, go$r;
                while (go$c) {
                  const v$1 = go$a0;
                  if (v$1.tag === "Leaf") {
                    go$c = false;
                    go$r = false;
                    continue;
                  }
                  if (v$1.tag === "Node") {
                    const v1$1 = dictOrd.compare($0)(v$1._3);
                    if (v1$1 === "LT") {
                      go$a0 = v$1._5;
                      continue;
                    }
                    if (v1$1 === "GT") {
                      go$a0 = v$1._6;
                      continue;
                    }
                    if (v1$1 === "EQ") {
                      go$c = false;
                      go$r = true;
                      continue;
                    }
                  }
                  fail();
                }
                return go$r;
              };
              return go2(state.unvisited);
            })()) {
              visit$a0 = { result: state.result, unvisited: $$delete2(dictOrd)(v1._1._1._1)(state.unvisited) };
              visit$a1 = (() => {
                const $0 = fromFoldable4(listMap(Visit)((() => {
                  const $02 = lookup2(dictOrd)(v1._1._1._1)(v);
                  if ($02.tag === "Nothing") {
                    return Nil;
                  }
                  if ($02.tag === "Just") {
                    return $02._1._2;
                  }
                  fail();
                })()));
                const $1 = v1._1._2.tag === "CatNil" ? $CatList("CatCons", $SortStep("Emit", v1._1._1._1), $CatQueue(Nil, Nil)) : $CatList(
                  "CatCons",
                  $SortStep("Emit", v1._1._1._1),
                  $CatQueue(Nil, $List("Cons", v1._1._2, Nil))
                );
                if ($0.tag === "CatNil") {
                  return $1;
                }
                if ($1.tag === "CatNil") {
                  return $0;
                }
                if ($0.tag === "CatCons") {
                  return $CatList("CatCons", $0._1, $CatQueue($0._2._1, $List("Cons", $1, $0._2._2)));
                }
                fail();
              })();
              continue;
            }
            visit$a0 = state;
            visit$a1 = v1._1._2;
            continue;
          }
        }
        fail();
      }
      return visit$r;
    };
    const go = (go$a0$copy) => {
      let go$a0 = go$a0$copy, go$c = true, go$r;
      while (go$c) {
        const v1 = go$a0;
        const v2 = findMin(v1.unvisited);
        if (v2.tag === "Just") {
          go$a0 = visit(v1)(fromFoldable12([$SortStep("Visit", v2._1.key)]));
          continue;
        }
        if (v2.tag === "Nothing") {
          go$c = false;
          go$r = v1.result;
          continue;
        }
        fail();
      }
      return go$r;
    };
    return go({ unvisited: v, result: Nil });
  };

  // output-es/Foreign.Object.ST/foreign.js
  function peekImpl2(just) {
    return function(nothing) {
      return function(k) {
        return function(m) {
          return function() {
            return {}.hasOwnProperty.call(m, k) ? just(m[k]) : nothing;
          };
        };
      };
    };
  }

  // output-es/Foreign.Object.ST/index.js
  var peek = /* @__PURE__ */ peekImpl2(Just)(Nothing);

  // output-es/Graph.GraphImpl/index.js
  var $GraphImpl = (_1) => ({ tag: "GraphImpl", _1 });
  var eqSet = { eq: (v) => (v1) => eqMap(eqVertex)(eqUnit).eq(v)(v1) };
  var eq = /* @__PURE__ */ (() => eqObject(eqSet).eq)();
  var fromFoldable5 = /* @__PURE__ */ foldlArray((m) => (a) => insert3(ordVertex)(a)()(m))(Leaf);
  var mempty2 = /* @__PURE__ */ (() => monoidSet(ordVertex).mempty)();
  var toUnfoldable4 = /* @__PURE__ */ (() => {
    const $0 = toUnfoldable2(unfoldableList);
    return (x2) => $0(keys2(x2));
  })();
  var fromFoldable13 = /* @__PURE__ */ (() => foldableSet.foldr(Cons)(Nil))();
  var fromFoldable23 = /* @__PURE__ */ (() => foldableSet.foldl((m) => (a) => insert3(ordVertex)(a)()(m))(Leaf))();
  var toUnfoldable12 = /* @__PURE__ */ toAscUnfoldable(unfoldableArray);
  var fromFoldable32 = /* @__PURE__ */ fromFoldable2(ordVertex)(foldableArray);
  var verticesGraphImpl = { vertices: (v) => v._1.vertices };
  var eqGraphImpl = { eq: (v) => (v1) => eq(v._1.out)(v1._1.out) };
  var sinks$p = (m) => fromFoldable5(arrayMap((x2) => x2._1)(filterImpl((x2) => x2._2.tag === "Leaf", toArrayWithKey(Tuple)(m))));
  var init4 = (\u03B1s) => () => {
    const obj = {};
    return monadRecST.tailRecM((v) => {
      if (v._1.tag === "Nil") {
        return () => $Step("Done", v._2);
      }
      if (v._1.tag === "Cons") {
        const $0 = v._2;
        const $1 = v._1._1;
        const $2 = v._1._2;
        return () => {
          $0[$1] = mempty2;
          return $Step("Loop", $Tuple($2, $0));
        };
      }
      fail();
    })($Tuple(\u03B1s, obj))();
  };
  var assertPresent = (v) => (v1) => {
    if (v1.tag === "Nil") {
      return () => $Step("Done", void 0);
    }
    if (v1.tag === "Cons") {
      const $0 = v1._1;
      const $1 = v1._2;
      const $2 = peek($0)(v);
      return () => {
        const $3 = $2();
        const present = (() => {
          if ($3.tag === "Nothing") {
            return false;
          }
          if ($3.tag === "Just") {
            return true;
          }
          fail();
        })();
        return assertWhen(true)($0 + " is an existing vertex")((v2) => present)(() => $Step("Loop", $1))();
      };
    }
    fail();
  };
  var addIfMissing = (acc) => (v) => {
    const $0 = peek(v)(acc);
    return () => {
      const v1 = $0();
      if (v1.tag === "Nothing") {
        acc[v] = mempty2;
        return acc;
      }
      if (v1.tag === "Just") {
        return acc;
      }
      fail();
    };
  };
  var addIfMissing$p = (\u03B1s) => (acc) => monadRecST.tailRecM((v) => {
    if (v._1.tag === "Nil") {
      return () => $Step("Done", v._2);
    }
    if (v._1.tag === "Cons") {
      const $0 = v._1._2;
      const $1 = addIfMissing(v._2)(v._1._1);
      return () => {
        const acc$p$p = $1();
        return $Step("Loop", $Tuple($0, acc$p$p));
      };
    }
    fail();
  })($Tuple(\u03B1s, acc));
  var outMap = (\u03B1s) => (es) => {
    const $0 = init4(\u03B1s);
    return () => {
      const out = $0();
      return monadRecST.tailRecM((v) => {
        if (v._1.tag === "Nil") {
          return () => $Step("Done", v._2);
        }
        if (v._1.tag === "Cons") {
          const $1 = v._2;
          const $2 = v._1._2;
          const $3 = v._1._1._1;
          const $4 = v._1._1._2;
          const $5 = peek($3)($1);
          return () => {
            const $6 = $5();
            if ((() => {
              if ($6.tag === "Nothing") {
                return true;
              }
              if ($6.tag === "Just") {
                return eqMap(eqVertex)(eqUnit).eq($6._1)(mempty2);
              }
              fail();
            })()) {
              const \u03B2s$p = toUnfoldable4($4);
              monadRecST.tailRecM(assertPresent($1))(\u03B2s$p)();
              $1[$3] = $4;
              const acc$p = addIfMissing$p(\u03B2s$p)($1)();
              return $Step("Loop", $Tuple($2, acc$p));
            }
            return throwException(error("Duplicate edge list entry for " + showStringImpl($3)))()();
          };
        }
        fail();
      })($Tuple(es, out))();
    };
  };
  var inMap = (\u03B1s) => (es) => {
    const $0 = init4(\u03B1s);
    return () => {
      const in_ = $0();
      return monadRecST.tailRecM((v) => {
        if (v._1.tag === "Nil") {
          return () => $Step("Done", v._2);
        }
        if (v._1.tag === "Cons") {
          const $1 = v._1._2;
          const $2 = v._1._1._1;
          const $3 = monadRecST.tailRecM((v1) => {
            if (v1._1.tag === "Nil") {
              return () => $Step("Done", v1._2);
            }
            if (v1._1.tag === "Cons") {
              const $32 = v1._2;
              const $4 = v1._1._1;
              const $5 = v1._1._2;
              const $6 = peek($4)($32);
              return () => {
                const v1$1 = $6();
                const acc$p = (() => {
                  if (v1$1.tag === "Nothing") {
                    $32[$4] = $$$Map("Node", 1, 1, $2, void 0, Leaf, Leaf);
                    return $32;
                  }
                  if (v1$1.tag === "Just") {
                    $32[$4] = insert3(ordVertex)($2)()(v1$1._1);
                    return $32;
                  }
                  fail();
                })();
                return $Step("Loop", $Tuple($5, acc$p));
              };
            }
            fail();
          })($Tuple(toUnfoldable4(v._1._1._2), v._2));
          return () => {
            const a = $3();
            const acc$p = addIfMissing(a)($2)();
            return $Step("Loop", $Tuple($1, acc$p));
          };
        }
        fail();
      })($Tuple(es, in_))();
    };
  };
  var graphGraphImpl = {
    outN: (v) => (\u03B1) => definitely("in graph")(_lookup(Nothing, Just, \u03B1, v._1.out)),
    inN: (g) => graphGraphImpl.outN(graphGraphImpl.op(g)),
    elem: (\u03B1) => (v) => {
      const $0 = _lookup(Nothing, Just, \u03B1, v._1.out);
      if ($0.tag === "Nothing") {
        return false;
      }
      if ($0.tag === "Just") {
        return true;
      }
      fail();
    },
    size: (v) => size(v._1.out),
    sinks: (v) => v._1.sinks,
    sources: (v) => v._1.sources,
    op: (v) => $GraphImpl({ out: v._1.in_, in_: v._1.out, sinks: v._1.sources, sources: v._1.sinks, vertices: v._1.vertices }),
    empty: /* @__PURE__ */ $GraphImpl({ out: empty2, in_: empty2, sinks: mempty2, sources: mempty2, vertices: mempty2 }),
    fromEdgeList: (\u03B1s) => (es) => {
      const \u03B1s$p = fromFoldable13(\u03B1s);
      const es$p = reverse2(es);
      const in_ = inMap(\u03B1s$p)(es$p)();
      const out = outMap(\u03B1s$p)(es$p)();
      return $GraphImpl({
        out,
        in_,
        sinks: sinks$p(out),
        sources: sinks$p(in_),
        vertices: fromFoldable23(map2(ordVertex)(Vertex)(mapObjectString.keys(out)))
      });
    },
    topologicalSort: (v) => reverse2(topologicalSort(ordVertex)(fromFoldable32(arrayMap((x2) => $Tuple(
      x2._1,
      $Tuple(void 0, x2._2)
    ))(toUnfoldable12(_fmapObject(v._1.out, toUnfoldable4)))))),
    Eq0: () => eqGraphImpl,
    Vertices1: () => verticesGraphImpl
  };

  // output-es/Data.Lazy/foreign.js
  var defer = function(thunk) {
    var v = null;
    return function() {
      if (thunk === void 0)
        return v;
      v = thunk();
      thunk = void 0;
      return v;
    };
  };
  var force = function(l) {
    return l();
  };

  // output-es/Parsing/index.js
  var $ParseError = (_1, _2) => ({ tag: "ParseError", _1, _2 });
  var $ParseState = (_1, _2, _3) => ({ tag: "ParseState", _1, _2, _3 });
  var $RunParser = (tag, _1, _2) => ({ tag, _1, _2 });
  var More = (value0) => $RunParser("More", value0);
  var Lift = (value0) => $RunParser("Lift", value0);
  var lazyParserT = {
    defer: (f) => {
      const m = defer(f);
      return (state1, more, lift12, $$throw2, done) => force(m)(state1, more, lift12, $$throw2, done);
    }
  };
  var genericShow = /* @__PURE__ */ (() => {
    const $0 = genericShowConstructor({
      genericShowArgs: (v) => ["{ column: " + showIntImpl(v.column) + ", index: " + showIntImpl(v.index) + ", line: " + showIntImpl(v.line) + " }"]
    })({ reflectSymbol: () => "Position" });
    return (x2) => $0["genericShow'"](x2);
  })();
  var functorParserT = { map: (f) => (v) => (state1, more, lift12, $$throw2, done) => more((v1) => v(state1, more, lift12, $$throw2, (state2, a) => more((v2) => done(state2, f(a))))) };
  var applyParserT = {
    apply: (v) => (v1) => (state1, more, lift12, $$throw2, done) => more((v2) => v(
      state1,
      more,
      lift12,
      $$throw2,
      (state2, f) => more((v3) => v1(state2, more, lift12, $$throw2, (state3, a) => more((v4) => done(state3, f(a)))))
    )),
    Functor0: () => functorParserT
  };
  var bindParserT = {
    bind: (v) => (next) => (state1, more, lift12, $$throw2, done) => more((v1) => v(state1, more, lift12, $$throw2, (state2, a) => more((v2) => next(a)(state2, more, lift12, $$throw2, done)))),
    Apply0: () => applyParserT
  };
  var applicativeParserT = { pure: (a) => (state1, v, v1, v2, done) => done(state1, a), Apply0: () => applyParserT };
  var monadParserT = { Applicative0: () => applicativeParserT, Bind1: () => bindParserT };
  var monadRecParserT = {
    tailRecM: (next) => (initArg) => (state1, more, lift12, $$throw2, done) => {
      const loop = (state2, arg, gas) => next(arg)(
        state2,
        more,
        lift12,
        $$throw2,
        (state3, step) => {
          if (step.tag === "Loop") {
            if (gas === 0) {
              return more((v1) => loop(state3, step._1, 30));
            }
            return loop(state3, step._1, gas - 1 | 0);
          }
          if (step.tag === "Done") {
            return done(state3, step._1);
          }
          fail();
        }
      );
      return loop(state1, initArg, 30);
    },
    Monad0: () => monadParserT
  };
  var altParserT = {
    alt: (v) => (v1) => (v2, $0, $1, $2, $3) => {
      const $4 = v2._1;
      const $5 = v2._2;
      return $0((v3) => v(
        $ParseState($4, $5, false),
        $0,
        $1,
        (v4, $6) => {
          const $7 = v4._3;
          return $0((v5) => {
            if ($7) {
              return $2(v4, $6);
            }
            return v1(v2, $0, $1, $2, $3);
          });
        },
        $3
      ));
    },
    Functor0: () => functorParserT
  };
  var showParseError = { show: (v) => "(ParseError " + showStringImpl(v._1) + " " + genericShow(v._2) + ")" };
  var runParserT$p = (dictMonadRec) => {
    const Monad0 = dictMonadRec.Monad0();
    return (state1) => (v) => {
      const go = (go$a0$copy) => {
        let go$a0 = go$a0$copy, go$c = true, go$r;
        while (go$c) {
          const step = go$a0;
          const v1 = step();
          if (v1.tag === "More") {
            go$a0 = v1._1;
            continue;
          }
          if (v1.tag === "Lift") {
            go$c = false;
            go$r = Monad0.Bind1().Apply0().Functor0().map(Loop)(v1._1);
            continue;
          }
          if (v1.tag === "Stop") {
            go$c = false;
            go$r = Monad0.Applicative0().pure($Step("Done", $Tuple(v1._2, v1._1)));
            continue;
          }
          fail();
        }
        return go$r;
      };
      return dictMonadRec.tailRecM(go)((v1) => v(
        state1,
        More,
        Lift,
        (state2, err) => $RunParser("Stop", state2, $Either("Left", err)),
        (state2, res) => $RunParser("Stop", state2, $Either("Right", res))
      ));
    };
  };
  var position = (state1, v, v1, v2, done) => done(state1, state1._2);
  var initialPos = { index: 0, line: 1, column: 1 };
  var runParserT = (dictMonadRec) => {
    const runParserT$p1 = runParserT$p(dictMonadRec);
    return (s) => (p) => dictMonadRec.Monad0().Bind1().Apply0().Functor0().map(fst)(runParserT$p1($ParseState(s, initialPos, false))(p));
  };
  var runParserT1 = /* @__PURE__ */ runParserT(monadRecIdentity);
  var fail2 = (message2) => (state1, more, lift12, $$throw2, done) => more((v1) => position(
    state1,
    more,
    lift12,
    $$throw2,
    (state2, a) => more((v2) => $$throw2(state2, $ParseError(message2, a)))
  ));
  var plusParserT = { empty: /* @__PURE__ */ fail2("No alternative"), Alt0: () => altParserT };
  var alternativeParserT = { Applicative0: () => applicativeParserT, Plus1: () => plusParserT };

  // output-es/Parsing.Combinators/index.js
  var manyRec2 = /* @__PURE__ */ manyRec(monadRecParserT)(alternativeParserT);
  var withLazyErrorMessage = (p) => (msg) => {
    const $0 = lazyParserT.defer((v) => fail2("Expected " + msg()));
    return (v2, $1, $2, $3, $4) => {
      const $5 = v2._1;
      const $6 = v2._2;
      return $1((v3) => p(
        $ParseState($5, $6, false),
        $1,
        $2,
        (v4, $7) => {
          const $8 = v4._3;
          return $1((v5) => {
            if ($8) {
              return $3(v4, $7);
            }
            return $0(v2, $1, $2, $3, $4);
          });
        },
        $4
      ));
    };
  };
  var withErrorMessage = (p) => (msg) => {
    const $0 = fail2("Expected " + msg);
    return (v2, $1, $2, $3, $4) => {
      const $5 = v2._1;
      const $6 = v2._2;
      return $1((v3) => p(
        $ParseState($5, $6, false),
        $1,
        $2,
        (v4, $7) => {
          const $8 = v4._3;
          return $1((v5) => {
            if ($8) {
              return $3(v4, $7);
            }
            return $0(v2, $1, $2, $3, $4);
          });
        },
        $4
      ));
    };
  };
  var skipMany1 = (p) => (state1, more, lift12, $$throw2, done) => more((v2) => more((v1) => p(
    state1,
    more,
    lift12,
    $$throw2,
    (state2, a) => more((v2$1) => more((v3) => {
      const loop = (state2$1, arg, gas) => {
        const $0 = (state3, step) => {
          if (step.tag === "Loop") {
            if (gas === 0) {
              return more((v1$1) => loop(state3, step._1, 30));
            }
            return loop(state3, step._1, gas - 1 | 0);
          }
          if (step.tag === "Done") {
            const $02 = step._1;
            return more((v4) => done(state3, $02));
          }
          fail();
        };
        const $1 = state2$1._1;
        const $2 = state2$1._2;
        return more((v3$1) => more((v1$1) => p(
          $ParseState($1, $2, false),
          more,
          lift12,
          (v4, $3) => {
            const $4 = v4._3;
            return more((v5) => {
              if ($4) {
                return $$throw2(v4, $3);
              }
              return $0(state2$1, $Step("Done", void 0));
            });
          },
          (state2$2, a$1) => more((v2$2) => $0(state2$2, $Step("Loop", void 0)))
        )));
      };
      return loop(state2, void 0, 30);
    }))
  )));
  var skipMany = (p) => (v2, $0, $1, $2, $3) => {
    const $4 = v2._1;
    const $5 = v2._2;
    return $0((v3) => skipMany1(p)(
      $ParseState($4, $5, false),
      $0,
      $1,
      (v4, $6) => {
        const $7 = v4._3;
        return $0((v5) => {
          if ($7) {
            return $2(v4, $6);
          }
          return $3(v2, void 0);
        });
      },
      $3
    ));
  };
  var sepBy1 = (p) => (sep) => (state1, more, lift12, $$throw2, done) => more((v1) => p(
    state1,
    more,
    lift12,
    $$throw2,
    (state2, a) => more((v2) => {
      const $0 = manyRec2((state1$1, more$1, lift1$1, throw$1, done$1) => more$1((v2$1) => more$1((v1$1) => sep(
        state1$1,
        more$1,
        lift1$1,
        throw$1,
        (state2$1, a$1) => more$1((v2$2) => more$1((v3) => p(state2$1, more$1, lift1$1, throw$1, (state3, a$2) => more$1((v4) => done$1(state3, a$2)))))
      ))));
      return more((v1$1) => $0(state2, more, lift12, $$throw2, (state2$1, a$1) => more((v2$1) => done(state2$1, $NonEmpty(a, a$1)))));
    })
  ));
  var sepBy = (p) => (sep) => (v2, $0, $1, $2, $3) => {
    const $4 = v2._1;
    const $5 = v2._2;
    return $0((v3) => $0((v1) => sepBy1(p)(sep)(
      $ParseState($4, $5, false),
      $0,
      $1,
      (v4, $6) => {
        const $7 = v4._3;
        return $0((v5) => {
          if ($7) {
            return $2(v4, $6);
          }
          return $3(v2, Nil);
        });
      },
      (state2, a) => $0((v2$1) => $3(state2, $List("Cons", a._1, a._2)))
    )));
  };
  var notFollowedBy = (p) => (v1, $0, $1, $2, $3) => {
    const $4 = v1._3;
    const $5 = v1._1;
    const $6 = v1._2;
    return $0((v3) => {
      const $7 = (v4, $72) => {
        const $8 = v4._3;
        return $0((v5) => {
          if ($8) {
            return $2($ParseState(v4._1, v4._2, $4), $72);
          }
          return $3(v1, void 0);
        });
      };
      return $0((v2) => $0((v1$1) => p(
        $ParseState($5, $6, false),
        $0,
        $1,
        (v2$1, $8) => $7($ParseState(v2$1._1, v2$1._2, false), $8),
        (state2, a) => $0((v2$1) => $0((v3$1) => fail2("Negated parser succeeded")(state2, $0, $1, $7, (state3, a$1) => $0((v4) => $3(state3, a$1)))))
      )));
    });
  };
  var choice = (dictFoldable) => {
    const $0 = dictFoldable.foldr((p1) => (v) => {
      if (v.tag === "Nothing") {
        return $Maybe("Just", p1);
      }
      if (v.tag === "Just") {
        return $Maybe(
          "Just",
          (v2, $02, $1, $2, $3) => {
            const $4 = v2._1;
            const $5 = v2._2;
            return $02((v3) => p1(
              $ParseState($4, $5, false),
              $02,
              $1,
              (v4, $6) => {
                const $7 = v4._3;
                return $02((v5) => {
                  if ($7) {
                    return $2(v4, $6);
                  }
                  return v._1(v2, $02, $1, $2, $3);
                });
              },
              $3
            ));
          }
        );
      }
      fail();
    })(Nothing);
    return (x2) => {
      const $1 = $0(x2);
      if ($1.tag === "Nothing") {
        return fail2("No alternative");
      }
      if ($1.tag === "Just") {
        return $1._1;
      }
      fail();
    };
  };
  var between = (open) => (close) => (p) => (state1, more, lift12, $$throw2, done) => more((v2) => more((v1) => more((v2$1) => more((v1$1) => open(
    state1,
    more,
    lift12,
    $$throw2,
    (state2, a) => more((v2$2) => more((v3) => p(
      state2,
      more,
      lift12,
      $$throw2,
      (state3, a$1) => more((v4) => more((v2$3) => more((v3$1) => close(state3, more, lift12, $$throw2, (state3$1, a$2) => more((v4$1) => done(state3$1, a$1))))))
    )))
  )))));

  // output-es/Parsing.Expr/index.js
  var $Assoc = (tag) => tag;
  var $Operator = (tag, _1, _2) => ({ tag, _1, _2 });
  var choice2 = /* @__PURE__ */ choice(foldableList);
  var identity20 = (x2) => x2;
  var AssocNone = /* @__PURE__ */ $Assoc("AssocNone");
  var AssocLeft = /* @__PURE__ */ $Assoc("AssocLeft");
  var AssocRight = /* @__PURE__ */ $Assoc("AssocRight");
  var splitOp = (v) => (v1) => {
    if (v.tag === "Infix") {
      if (v._2 === "AssocNone") {
        return { ...v1, nassoc: $List("Cons", v._1, v1.nassoc) };
      }
      if (v._2 === "AssocLeft") {
        return { ...v1, lassoc: $List("Cons", v._1, v1.lassoc) };
      }
      if (v._2 === "AssocRight") {
        return { ...v1, rassoc: $List("Cons", v._1, v1.rassoc) };
      }
      fail();
    }
    if (v.tag === "Prefix") {
      return { ...v1, prefix: $List("Cons", v._1, v1.prefix) };
    }
    if (v.tag === "Postfix") {
      return { ...v1, postfix: $List("Cons", v._1, v1.postfix) };
    }
    fail();
  };
  var rassocP1 = (x2) => (rassocOp) => (prefixP) => (term) => (postfixP) => {
    const $0 = rassocP(x2)(rassocOp)(prefixP)(term)(postfixP);
    return (v2, $1, $2, $3, $4) => {
      const $5 = v2._1;
      const $6 = v2._2;
      return $1((v3) => $0(
        $ParseState($5, $6, false),
        $1,
        $2,
        (v4, $7) => {
          const $8 = v4._3;
          return $1((v5) => {
            if ($8) {
              return $3(v4, $7);
            }
            return $4(v2, x2);
          });
        },
        $4
      ));
    };
  };
  var rassocP = (x2) => (rassocOp) => (prefixP) => (term) => (postfixP) => (state1, more, lift12, $$throw2, done) => more((v1) => rassocOp(
    state1,
    more,
    lift12,
    $$throw2,
    (state2, a) => more((v2) => more((v1$1) => more((v1$2) => more((v1$3) => prefixP(
      state2,
      more,
      lift12,
      $$throw2,
      (state2$1, a$1) => more((v2$1) => more((v1$4) => term(
        state2$1,
        more,
        lift12,
        $$throw2,
        (state2$2, a$2) => more((v2$2) => more((v1$5) => postfixP(
          state2$2,
          more,
          lift12,
          $$throw2,
          (state2$3, a$3) => more((v2$3) => {
            const $0 = a$3(a$1(a$2));
            return more((v2$4) => rassocP1($0)(rassocOp)(prefixP)(term)(postfixP)(state2$3, more, lift12, $$throw2, (state2$4, a$4) => more((v2$5) => done(state2$4, a(x2)(a$4)))));
          })
        )))
      )))
    )))))
  ));
  var nassocP = (x2) => (nassocOp) => (prefixP) => (term) => (postfixP) => (state1, more, lift12, $$throw2, done) => more((v1) => nassocOp(
    state1,
    more,
    lift12,
    $$throw2,
    (state2, a) => more((v2) => more((v1$1) => more((v1$2) => prefixP(
      state2,
      more,
      lift12,
      $$throw2,
      (state2$1, a$1) => more((v2$1) => more((v1$3) => term(
        state2$1,
        more,
        lift12,
        $$throw2,
        (state2$2, a$2) => more((v2$2) => more((v1$4) => postfixP(
          state2$2,
          more,
          lift12,
          $$throw2,
          (state2$3, a$3) => more((v2$3) => {
            const $0 = a$3(a$1(a$2));
            return more((v2$4) => done(state2$3, a(x2)($0)));
          })
        )))
      )))
    ))))
  ));
  var lassocP1 = (x2) => (lassocOp) => (prefixP) => (term) => (postfixP) => {
    const $0 = lassocP(x2)(lassocOp)(prefixP)(term)(postfixP);
    return (v2, $1, $2, $3, $4) => {
      const $5 = v2._1;
      const $6 = v2._2;
      return $1((v3) => $0(
        $ParseState($5, $6, false),
        $1,
        $2,
        (v4, $7) => {
          const $8 = v4._3;
          return $1((v5) => {
            if ($8) {
              return $3(v4, $7);
            }
            return $4(v2, x2);
          });
        },
        $4
      ));
    };
  };
  var lassocP = (x2) => (lassocOp) => (prefixP) => (term) => (postfixP) => (state1, more, lift12, $$throw2, done) => more((v1) => lassocOp(
    state1,
    more,
    lift12,
    $$throw2,
    (state2, a) => more((v2) => more((v1$1) => more((v1$2) => prefixP(
      state2,
      more,
      lift12,
      $$throw2,
      (state2$1, a$1) => more((v2$1) => more((v1$3) => term(
        state2$1,
        more,
        lift12,
        $$throw2,
        (state2$2, a$2) => more((v2$2) => more((v1$4) => postfixP(
          state2$2,
          more,
          lift12,
          $$throw2,
          (state2$3, a$3) => more((v2$3) => {
            const $0 = a$3(a$1(a$2));
            return more((v2$4) => lassocP1(a(x2)($0))(lassocOp)(prefixP)(term)(postfixP)(state2$3, more, lift12, $$throw2, done));
          })
        )))
      )))
    ))))
  ));
  var makeParser = (term) => (ops) => {
    const accum = foldrArray(splitOp)({
      rassoc: Nil,
      lassoc: Nil,
      nassoc: Nil,
      prefix: Nil,
      postfix: Nil
    })(ops);
    const lassocOp = choice2(accum.lassoc);
    const nassocOp = choice2(accum.nassoc);
    const postfixOp = withErrorMessage(choice2(accum.postfix))("");
    const prefixOp = withErrorMessage(choice2(accum.prefix))("");
    const rassocOp = choice2(accum.rassoc);
    return (state1, more, lift12, $$throw2, done) => more((v1) => {
      const $0 = (state2, a) => more((v2) => {
        const $02 = rassocP(a)(rassocOp)((v2$1, $03, $12, $22, $32) => {
          const $42 = v2$1._1;
          const $52 = v2$1._2;
          return $03((v3) => prefixOp(
            $ParseState($42, $52, false),
            $03,
            $12,
            (v4, $6) => {
              const $7 = v4._3;
              return $03((v5) => {
                if ($7) {
                  return $22(v4, $6);
                }
                return $32(v2$1, identity20);
              });
            },
            $32
          ));
        })(term)((v2$1, $03, $12, $22, $32) => {
          const $42 = v2$1._1;
          const $52 = v2$1._2;
          return $03((v3) => postfixOp(
            $ParseState($42, $52, false),
            $03,
            $12,
            (v4, $6) => {
              const $7 = v4._3;
              return $03((v5) => {
                if ($7) {
                  return $22(v4, $6);
                }
                return $32(v2$1, identity20);
              });
            },
            $32
          ));
        });
        const $1 = lassocP(a)(lassocOp)((v2$1, $12, $22, $32, $42) => {
          const $52 = v2$1._1;
          const $6 = v2$1._2;
          return $12((v3) => prefixOp(
            $ParseState($52, $6, false),
            $12,
            $22,
            (v4, $7) => {
              const $8 = v4._3;
              return $12((v5) => {
                if ($8) {
                  return $32(v4, $7);
                }
                return $42(v2$1, identity20);
              });
            },
            $42
          ));
        })(term)((v2$1, $12, $22, $32, $42) => {
          const $52 = v2$1._1;
          const $6 = v2$1._2;
          return $12((v3) => postfixOp(
            $ParseState($52, $6, false),
            $12,
            $22,
            (v4, $7) => {
              const $8 = v4._3;
              return $12((v5) => {
                if ($8) {
                  return $32(v4, $7);
                }
                return $42(v2$1, identity20);
              });
            },
            $42
          ));
        });
        const $2 = nassocP(a)(nassocOp)((v2$1, $22, $32, $42, $52) => {
          const $6 = v2$1._1;
          const $7 = v2$1._2;
          return $22((v3) => prefixOp(
            $ParseState($6, $7, false),
            $22,
            $32,
            (v4, $8) => {
              const $9 = v4._3;
              return $22((v5) => {
                if ($9) {
                  return $42(v4, $8);
                }
                return $52(v2$1, identity20);
              });
            },
            $52
          ));
        })(term)((v2$1, $22, $32, $42, $52) => {
          const $6 = v2$1._1;
          const $7 = v2$1._2;
          return $22((v3) => postfixOp(
            $ParseState($6, $7, false),
            $22,
            $32,
            (v4, $8) => {
              const $9 = v4._3;
              return $22((v5) => {
                if ($9) {
                  return $42(v4, $8);
                }
                return $52(v2$1, identity20);
              });
            },
            $52
          ));
        });
        const $3 = withErrorMessage((state1$1, v, v1$1, v2$1, done$1) => done$1(state1$1, a))("operator");
        const $4 = state2._1;
        const $5 = state2._2;
        return more((v3) => $02(
          $ParseState($4, $5, false),
          more,
          lift12,
          (v4, $6) => {
            const $7 = v4._3;
            return more((v5) => {
              if ($7) {
                return $$throw2(v4, $6);
              }
              const $8 = state2._1;
              const $9 = state2._2;
              return more((v3$1) => $1(
                $ParseState($8, $9, false),
                more,
                lift12,
                (v4$1, $10) => {
                  const $11 = v4$1._3;
                  return more((v5$1) => {
                    if ($11) {
                      return $$throw2(v4$1, $10);
                    }
                    const $12 = state2._1;
                    const $13 = state2._2;
                    return more((v3$2) => $2(
                      $ParseState($12, $13, false),
                      more,
                      lift12,
                      (v4$2, $14) => {
                        const $15 = v4$2._3;
                        return more((v5$2) => {
                          if ($15) {
                            return $$throw2(v4$2, $14);
                          }
                          return $3(state2, more, lift12, $$throw2, done);
                        });
                      },
                      done
                    ));
                  });
                },
                done
              ));
            });
          },
          done
        ));
      });
      return more((v1$1) => {
        const $1 = (state2, a) => more((v2) => more((v1$2) => term(
          state2,
          more,
          lift12,
          $$throw2,
          (state2$1, a$1) => more((v2$1) => more((v1$3) => {
            const $12 = state2$1._1;
            const $22 = state2$1._2;
            return more((v3) => postfixOp(
              $ParseState($12, $22, false),
              more,
              lift12,
              (v4, $32) => {
                const $4 = v4._3;
                return more((v5) => {
                  if ($4) {
                    return $$throw2(v4, $32);
                  }
                  return more((v2$2) => $0(state2$1, a(a$1)));
                });
              },
              (state2$2, a$2) => more((v2$2) => $0(state2$2, a$2(a(a$1))))
            ));
          }))
        )));
        const $2 = state1._1;
        const $3 = state1._2;
        return more((v3) => prefixOp(
          $ParseState($2, $3, false),
          more,
          lift12,
          (v4, $4) => {
            const $5 = v4._3;
            return more((v5) => {
              if ($5) {
                return $$throw2(v4, $4);
              }
              return $1(state1, identity20);
            });
          },
          $1
        ));
      });
    });
  };
  var buildExprParser = (operators2) => (simpleExpr) => foldlArray(makeParser)(simpleExpr)(operators2);

  // output-es/Primitive.Parse/index.js
  var opDefs = /* @__PURE__ */ fromFoldable2(ordString)(foldableArray)([
    /* @__PURE__ */ $Tuple(".", { op: ".", prec: 8, assoc: AssocLeft }),
    /* @__PURE__ */ $Tuple("!", { op: "!", prec: 8, assoc: AssocLeft }),
    /* @__PURE__ */ $Tuple("**", { op: "**", prec: 8, assoc: AssocRight }),
    /* @__PURE__ */ $Tuple("*", { op: "*", prec: 7, assoc: AssocLeft }),
    /* @__PURE__ */ $Tuple("/", { op: "/", prec: 7, assoc: AssocLeft }),
    /* @__PURE__ */ $Tuple("+", { op: "+", prec: 6, assoc: AssocLeft }),
    /* @__PURE__ */ $Tuple("-", { op: "-", prec: 6, assoc: AssocLeft }),
    /* @__PURE__ */ $Tuple(":", { op: ":", prec: 6, assoc: AssocRight }),
    /* @__PURE__ */ $Tuple("++", { op: "++", prec: 5, assoc: AssocRight }),
    /* @__PURE__ */ $Tuple("==", { op: "==", prec: 4, assoc: AssocNone }),
    /* @__PURE__ */ $Tuple("/=", { op: "/=", prec: 4, assoc: AssocNone }),
    /* @__PURE__ */ $Tuple("<", { op: "<", prec: 4, assoc: AssocLeft }),
    /* @__PURE__ */ $Tuple(">", { op: ">", prec: 4, assoc: AssocLeft }),
    /* @__PURE__ */ $Tuple("<=", { op: "<=", prec: 4, assoc: AssocLeft }),
    /* @__PURE__ */ $Tuple(">=", { op: ">=", prec: 4, assoc: AssocLeft })
  ]);

  // output-es/Bind/index.js
  var union3 = /* @__PURE__ */ (() => setSet(ordString).union)();
  var keys3 = (v) => {
    if (v.tag === "Nil") {
      return Leaf;
    }
    if (v.tag === "Cons") {
      return union3($$$Map("Node", 1, 1, v._1._1, void 0, Leaf, Leaf))(keys3(v._2));
    }
    fail();
  };

  // output-es/Data.Bifoldable/index.js
  var bifoldableTuple = {
    bifoldMap: (dictMonoid) => (f) => (g) => (v) => dictMonoid.Semigroup0().append(f(v._1))(g(v._2)),
    bifoldr: (f) => (g) => (z) => (v) => f(v._1)(g(v._2)(z)),
    bifoldl: (f) => (g) => (z) => (v) => g(f(z)(v._1))(v._2)
  };

  // output-es/Data.Bifunctor/index.js
  var bifunctorTuple = { bimap: (f) => (g) => (v) => $Tuple(f(v._1), g(v._2)) };

  // output-es/Data.Bitraversable/index.js
  var bitraversableTuple = {
    bitraverse: (dictApplicative) => {
      const Apply0 = dictApplicative.Apply0();
      return (f) => (g) => (v) => Apply0.apply(Apply0.Functor0().map(Tuple)(f(v._1)))(g(v._2));
    },
    bisequence: (dictApplicative) => {
      const Apply0 = dictApplicative.Apply0();
      return (v) => Apply0.apply(Apply0.Functor0().map(Tuple)(v._1))(v._2);
    },
    Bifunctor0: () => bifunctorTuple,
    Bifoldable1: () => bifoldableTuple
  };

  // output-es/Expr/index.js
  var $Cont = (tag, _1) => ({ tag, _1 });
  var $Elim = (tag, _1, _2) => ({ tag, _1, _2 });
  var $Expr = (tag, _1, _2, _3, _4) => ({ tag, _1, _2, _3, _4 });
  var $RecDefs = (_1, _2) => ({ tag: "RecDefs", _1, _2 });
  var $VarDef = (_1, _2) => ({ tag: "VarDef", _1, _2 });
  var eqSet2 = { eq: (v) => (v1) => eqMap(eqString)(eqUnit).eq(v)(v1) };
  var identity23 = (x2) => x2;
  var setSet2 = /* @__PURE__ */ setSet(ordString);
  var unions2 = /* @__PURE__ */ unions(foldableDict)(ordString);
  var fromFoldable6 = /* @__PURE__ */ (() => foldableSet.foldl((m) => (a) => insert3(ordString)(a)()(m))(Leaf))();
  var asMaplet2 = /* @__PURE__ */ asMaplet(mapDictString);
  var unions1 = /* @__PURE__ */ unions(foldableList)(ordString);
  var ContExpr = (value0) => $Cont("ContExpr", value0);
  var Record = (value0) => (value1) => $Expr("Record", value0, value1);
  var Dictionary = (value0) => (value1) => $Expr("Dictionary", value0, value1);
  var Constr = (value0) => (value1) => (value2) => $Expr("Constr", value0, value1, value2);
  var Matrix = (value0) => (value1) => (value2) => (value3) => $Expr("Matrix", value0, value1, value2, value3);
  var Lambda = (value0) => (value1) => $Expr("Lambda", value0, value1);
  var Project = (value0) => (value1) => $Expr("Project", value0, value1);
  var App2 = (value0) => (value1) => $Expr("App", value0, value1);
  var Let = (value0) => (value1) => $Expr("Let", value0, value1);
  var LetRec = (value0) => (value1) => $Expr("LetRec", value0, value1);
  var ElimVar = (value0) => (value1) => $Elim("ElimVar", value0, value1);
  var ElimRecord = (value0) => (value1) => $Elim("ElimRecord", value0, value1);
  var VarDef = (value0) => (value1) => $VarDef(value0, value1);
  var RecDefs = (value0) => (value1) => $RecDefs(value0, value1);
  var Module = (x2) => x2;
  var joinSemilatticeVarDef = (dictJoinSemilattice) => ({ join: (v) => (v1) => $VarDef(joinSemilatticeElim(dictJoinSemilattice).join(v._1)(v1._1), joinSemilatticeExpr(dictJoinSemilattice).join(v._2)(v1._2)) });
  var joinSemilatticeRecDefs = (dictJoinSemilattice) => ({ join: (v) => (v1) => $RecDefs(dictJoinSemilattice.join(v._1)(v1._1), unionWith(joinSemilatticeElim(dictJoinSemilattice).join)(v._2)(v1._2)) });
  var joinSemilatticeExpr = (dictJoinSemilattice) => ({
    join: (v) => (v1) => {
      if (v.tag === "Var") {
        if (v1.tag === "Var") {
          return $Expr("Var", mustEq(eqString)(showString)(v._1)(v1._1));
        }
        return throwException(error("Shape mismatch"))();
      }
      if (v.tag === "Op") {
        if (v1.tag === "Op") {
          return $Expr("Op", mustEq(eqString)(showString)(v._1)(v1._1));
        }
        return throwException(error("Shape mismatch"))();
      }
      if (v.tag === "Int") {
        if (v1.tag === "Int") {
          return $Expr("Int", dictJoinSemilattice.join(v._1)(v1._1), mustEq(eqInt)(showInt)(v._2)(v1._2));
        }
        return throwException(error("Shape mismatch"))();
      }
      if (v.tag === "Str") {
        if (v1.tag === "Str") {
          return $Expr("Str", dictJoinSemilattice.join(v._1)(v1._1), mustEq(eqString)(showString)(v._2)(v1._2));
        }
        return throwException(error("Shape mismatch"))();
      }
      if (v.tag === "Float") {
        if (v1.tag === "Float") {
          return $Expr("Float", dictJoinSemilattice.join(v._1)(v1._1), mustEq(eqNumber)(showNumber)(v._2)(v1._2));
        }
        return throwException(error("Shape mismatch"))();
      }
      if (v.tag === "Record") {
        if (v1.tag === "Record") {
          return $Expr("Record", dictJoinSemilattice.join(v._1)(v1._1), unionWith(joinSemilatticeExpr(dictJoinSemilattice).join)(v._2)(v1._2));
        }
        return throwException(error("Shape mismatch"))();
      }
      if (v.tag === "Dictionary") {
        if (v1.tag === "Dictionary") {
          return $Expr(
            "Dictionary",
            dictJoinSemilattice.join(v._1)(v1._1),
            joinSemilatticeList((() => {
              const $0 = joinSemilatticeExpr(dictJoinSemilattice);
              return { join: (v$1) => (v1$1) => $Pair($0.join(v$1._1)(v1$1._1), $0.join(v$1._2)(v1$1._2)) };
            })()).join(v._2)(v1._2)
          );
        }
        return throwException(error("Shape mismatch"))();
      }
      if (v.tag === "Constr") {
        if (v1.tag === "Constr") {
          return $Expr(
            "Constr",
            dictJoinSemilattice.join(v._1)(v1._1),
            mustEq(eqString)(showString)(v._2)(v1._2),
            joinSemilatticeList(joinSemilatticeExpr(dictJoinSemilattice)).join(v._3)(v1._3)
          );
        }
        return throwException(error("Shape mismatch"))();
      }
      if (v.tag === "Matrix") {
        if (v1.tag === "Matrix") {
          return $Expr(
            "Matrix",
            dictJoinSemilattice.join(v._1)(v1._1),
            joinSemilatticeExpr(dictJoinSemilattice).join(v._2)(v1._2),
            $Tuple(mustEq(eqString)(showString)(v._3._1)(v1._3._1), mustEq(eqString)(showString)(v._3._2)(v1._3._2)),
            joinSemilatticeExpr(dictJoinSemilattice).join(v._4)(v1._4)
          );
        }
        return throwException(error("Shape mismatch"))();
      }
      if (v.tag === "Lambda") {
        if (v1.tag === "Lambda") {
          return $Expr("Lambda", dictJoinSemilattice.join(v._1)(v1._1), joinSemilatticeElim(dictJoinSemilattice).join(v._2)(v1._2));
        }
        return throwException(error("Shape mismatch"))();
      }
      if (v.tag === "Project") {
        if (v1.tag === "Project") {
          return $Expr("Project", joinSemilatticeExpr(dictJoinSemilattice).join(v._1)(v1._1), mustEq(eqString)(showString)(v._2)(v1._2));
        }
        return throwException(error("Shape mismatch"))();
      }
      if (v.tag === "App") {
        if (v1.tag === "App") {
          return $Expr("App", joinSemilatticeExpr(dictJoinSemilattice).join(v._1)(v1._1), joinSemilatticeExpr(dictJoinSemilattice).join(v._2)(v1._2));
        }
        return throwException(error("Shape mismatch"))();
      }
      if (v.tag === "Let") {
        if (v1.tag === "Let") {
          return $Expr("Let", joinSemilatticeVarDef(dictJoinSemilattice).join(v._1)(v1._1), joinSemilatticeExpr(dictJoinSemilattice).join(v._2)(v1._2));
        }
        return throwException(error("Shape mismatch"))();
      }
      if (v.tag === "LetRec" && v1.tag === "LetRec") {
        return $Expr("LetRec", joinSemilatticeRecDefs(dictJoinSemilattice).join(v._1)(v1._1), joinSemilatticeExpr(dictJoinSemilattice).join(v._2)(v1._2));
      }
      return throwException(error("Shape mismatch"))();
    }
  });
  var joinSemilatticeElim = (dictJoinSemilattice) => ({
    join: (v) => (v1) => {
      if (v.tag === "ElimVar") {
        if (v1.tag === "ElimVar") {
          return $Elim("ElimVar", mustEq(eqString)(showString)(v._1)(v1._1), joinSemilatticeCont(dictJoinSemilattice).join(v._2)(v1._2));
        }
        return throwException(error("Shape mismatch"))();
      }
      if (v.tag === "ElimConstr") {
        if (v1.tag === "ElimConstr") {
          return $Elim("ElimConstr", unionWith(joinSemilatticeCont(dictJoinSemilattice).join)(v._1)(v1._1));
        }
        return throwException(error("Shape mismatch"))();
      }
      if (v.tag === "ElimRecord" && v1.tag === "ElimRecord") {
        return $Elim("ElimRecord", mustEq(eqSet2)(showSet(showString))(v._1)(v1._1), joinSemilatticeCont(dictJoinSemilattice).join(v._2)(v1._2));
      }
      return throwException(error("Shape mismatch"))();
    }
  });
  var joinSemilatticeCont = (dictJoinSemilattice) => ({
    join: (v) => (v1) => {
      if (v.tag === "ContExpr") {
        if (v1.tag === "ContExpr") {
          return $Cont("ContExpr", joinSemilatticeExpr(dictJoinSemilattice).join(v._1)(v1._1));
        }
        return throwException(error("Shape mismatch"))();
      }
      if (v.tag === "ContElim" && v1.tag === "ContElim") {
        return $Cont("ContElim", joinSemilatticeElim(dictJoinSemilattice).join(v._1)(v1._1));
      }
      return throwException(error("Shape mismatch"))();
    }
  });
  var functorVarDef = { map: (f) => (m) => $VarDef(functorElim.map(f)(m._1), functorExpr.map(f)(m._2)) };
  var functorRecDefs = { map: (f) => (m) => $RecDefs(f(m._1), _fmapObject(m._2, functorElim.map(f))) };
  var functorExpr = {
    map: (f) => (m) => {
      if (m.tag === "Var") {
        return $Expr("Var", m._1);
      }
      if (m.tag === "Op") {
        return $Expr("Op", m._1);
      }
      if (m.tag === "Int") {
        return $Expr("Int", f(m._1), m._2);
      }
      if (m.tag === "Float") {
        return $Expr("Float", f(m._1), m._2);
      }
      if (m.tag === "Str") {
        return $Expr("Str", f(m._1), m._2);
      }
      if (m.tag === "Record") {
        return $Expr("Record", f(m._1), _fmapObject(m._2, functorExpr.map(f)));
      }
      if (m.tag === "Dictionary") {
        return $Expr(
          "Dictionary",
          f(m._1),
          listMap((() => {
            const $0 = functorExpr.map(f);
            return (v) => $Pair($0(v._1), $0(v._2));
          })())(m._2)
        );
      }
      if (m.tag === "Constr") {
        return $Expr("Constr", f(m._1), m._2, listMap(functorExpr.map(f))(m._3));
      }
      if (m.tag === "Matrix") {
        return $Expr("Matrix", f(m._1), functorExpr.map(f)(m._2), m._3, functorExpr.map(f)(m._4));
      }
      if (m.tag === "Lambda") {
        return $Expr("Lambda", f(m._1), functorElim.map(f)(m._2));
      }
      if (m.tag === "Project") {
        return $Expr("Project", functorExpr.map(f)(m._1), m._2);
      }
      if (m.tag === "App") {
        return $Expr("App", functorExpr.map(f)(m._1), functorExpr.map(f)(m._2));
      }
      if (m.tag === "Let") {
        return $Expr("Let", functorVarDef.map(f)(m._1), functorExpr.map(f)(m._2));
      }
      if (m.tag === "LetRec") {
        return $Expr("LetRec", functorRecDefs.map(f)(m._1), functorExpr.map(f)(m._2));
      }
      fail();
    }
  };
  var functorElim = {
    map: (f) => (m) => {
      if (m.tag === "ElimVar") {
        return $Elim("ElimVar", m._1, functorCont.map(f)(m._2));
      }
      if (m.tag === "ElimConstr") {
        return $Elim("ElimConstr", _fmapObject(m._1, functorCont.map(f)));
      }
      if (m.tag === "ElimRecord") {
        return $Elim("ElimRecord", m._1, functorCont.map(f)(m._2));
      }
      fail();
    }
  };
  var functorCont = {
    map: (f) => (m) => {
      if (m.tag === "ContExpr") {
        return $Cont("ContExpr", functorExpr.map(f)(m._1));
      }
      if (m.tag === "ContElim") {
        return $Cont("ContElim", functorElim.map(f)(m._1));
      }
      fail();
    }
  };
  var functorModule = {
    map: (f) => (m) => listMap((v2) => {
      if (v2.tag === "Left") {
        return $Either("Left", functorVarDef.map(f)(v2._1));
      }
      if (v2.tag === "Right") {
        return $Either("Right", functorRecDefs.map(f)(v2._1));
      }
      fail();
    })(m)
  };
  var foldableVarDef = {
    foldl: (f) => (z) => (m) => foldableExpr.foldl(f)(foldableElim.foldl(f)(z)(m._1))(m._2),
    foldr: (f) => (z) => (m) => foldableElim.foldr(f)(foldableExpr.foldr(f)(z)(m._2))(m._1),
    foldMap: (dictMonoid) => (f) => (m) => dictMonoid.Semigroup0().append(foldableElim.foldMap(dictMonoid)(f)(m._1))(foldableExpr.foldMap(dictMonoid)(f)(m._2))
  };
  var foldableRecDefs = {
    foldl: (f) => (z) => (m) => {
      const $0 = foldableElim.foldl(f);
      return fold((z$1) => (v) => $0(z$1))(f(z)(m._1))(m._2);
    },
    foldr: (f) => (z) => (m) => f(m._1)((() => {
      const $0 = foldableElim.foldr(f);
      return foldrArray((b) => (a) => $0(a)(b))(z)(values(m._2));
    })()),
    foldMap: (dictMonoid) => {
      const foldMap1 = foldMap(dictMonoid);
      return (f) => (m) => dictMonoid.Semigroup0().append(f(m._1))((() => {
        const $0 = foldableElim.foldMap(dictMonoid)(f);
        return foldMap1((v) => $0)(m._2);
      })());
    }
  };
  var foldableExpr = {
    foldl: (f) => (z) => (m) => {
      if (m.tag === "Var") {
        return z;
      }
      if (m.tag === "Op") {
        return z;
      }
      if (m.tag === "Int") {
        return f(z)(m._1);
      }
      if (m.tag === "Float") {
        return f(z)(m._1);
      }
      if (m.tag === "Str") {
        return f(z)(m._1);
      }
      if (m.tag === "Record") {
        const $0 = foldableExpr.foldl(f);
        return fold((z$1) => (v) => $0(z$1))(f(z)(m._1))(m._2);
      }
      if (m.tag === "Dictionary") {
        const $0 = foldableExpr.foldl(f);
        const go = (go$a0$copy) => (go$a1$copy) => {
          let go$a0 = go$a0$copy, go$a1 = go$a1$copy, go$c = true, go$r;
          while (go$c) {
            const b = go$a0, v = go$a1;
            if (v.tag === "Nil") {
              go$c = false;
              go$r = b;
              continue;
            }
            if (v.tag === "Cons") {
              go$a0 = $0($0(b)(v._1._1))(v._1._2);
              go$a1 = v._2;
              continue;
            }
            fail();
          }
          return go$r;
        };
        return go(f(z)(m._1))(m._2);
      }
      if (m.tag === "Constr") {
        const $0 = foldableExpr.foldl(f);
        const go = (go$a0$copy) => (go$a1$copy) => {
          let go$a0 = go$a0$copy, go$a1 = go$a1$copy, go$c = true, go$r;
          while (go$c) {
            const b = go$a0, v = go$a1;
            if (v.tag === "Nil") {
              go$c = false;
              go$r = b;
              continue;
            }
            if (v.tag === "Cons") {
              go$a0 = $0(b)(v._1);
              go$a1 = v._2;
              continue;
            }
            fail();
          }
          return go$r;
        };
        return go(f(z)(m._1))(m._3);
      }
      if (m.tag === "Matrix") {
        return foldableExpr.foldl(f)(foldableExpr.foldl(f)(f(z)(m._1))(m._2))(m._4);
      }
      if (m.tag === "Lambda") {
        return foldableElim.foldl(f)(f(z)(m._1))(m._2);
      }
      if (m.tag === "Project") {
        return foldableExpr.foldl(f)(z)(m._1);
      }
      if (m.tag === "App") {
        return foldableExpr.foldl(f)(foldableExpr.foldl(f)(z)(m._1))(m._2);
      }
      if (m.tag === "Let") {
        return foldableExpr.foldl(f)(foldableVarDef.foldl(f)(z)(m._1))(m._2);
      }
      if (m.tag === "LetRec") {
        return foldableExpr.foldl(f)(foldableRecDefs.foldl(f)(z)(m._1))(m._2);
      }
      fail();
    },
    foldr: (f) => (z) => (m) => {
      if (m.tag === "Var") {
        return z;
      }
      if (m.tag === "Op") {
        return z;
      }
      if (m.tag === "Int") {
        return f(m._1)(z);
      }
      if (m.tag === "Float") {
        return f(m._1)(z);
      }
      if (m.tag === "Str") {
        return f(m._1)(z);
      }
      if (m.tag === "Record") {
        return f(m._1)((() => {
          const $0 = foldableExpr.foldr(f);
          return foldrArray((b) => (a) => $0(a)(b))(z)(values(m._2));
        })());
      }
      if (m.tag === "Dictionary") {
        return f(m._1)(foldableList.foldr((() => {
          const $0 = foldableExpr.foldr(f);
          const $1 = foldrDefault(foldablePair)((b) => (a) => $0(a)(b));
          return (b) => (a) => $1(a)(b);
        })())(z)(m._2));
      }
      if (m.tag === "Constr") {
        return f(m._1)(foldableList.foldr((() => {
          const $0 = foldableExpr.foldr(f);
          return (b) => (a) => $0(a)(b);
        })())(z)(m._3));
      }
      if (m.tag === "Matrix") {
        return f(m._1)(foldableExpr.foldr(f)(foldableExpr.foldr(f)(z)(m._4))(m._2));
      }
      if (m.tag === "Lambda") {
        return f(m._1)(foldableElim.foldr(f)(z)(m._2));
      }
      if (m.tag === "Project") {
        return foldableExpr.foldr(f)(z)(m._1);
      }
      if (m.tag === "App") {
        return foldableExpr.foldr(f)(foldableExpr.foldr(f)(z)(m._2))(m._1);
      }
      if (m.tag === "Let") {
        return foldableVarDef.foldr(f)(foldableExpr.foldr(f)(z)(m._2))(m._1);
      }
      if (m.tag === "LetRec") {
        return foldableRecDefs.foldr(f)(foldableExpr.foldr(f)(z)(m._2))(m._1);
      }
      fail();
    },
    foldMap: (dictMonoid) => {
      const mempty5 = dictMonoid.mempty;
      const $0 = dictMonoid.Semigroup0();
      const foldMap1 = foldMap(dictMonoid);
      const foldMap4 = foldableList.foldMap(dictMonoid);
      return (f) => (m) => {
        if (m.tag === "Var") {
          return mempty5;
        }
        if (m.tag === "Op") {
          return mempty5;
        }
        if (m.tag === "Int") {
          return f(m._1);
        }
        if (m.tag === "Float") {
          return f(m._1);
        }
        if (m.tag === "Str") {
          return f(m._1);
        }
        if (m.tag === "Record") {
          return $0.append(f(m._1))((() => {
            const $1 = foldableExpr.foldMap(dictMonoid)(f);
            return foldMap1((v) => $1)(m._2);
          })());
        }
        if (m.tag === "Dictionary") {
          return $0.append(f(m._1))(foldMap4(foldablePair.foldMap(dictMonoid)(foldableExpr.foldMap(dictMonoid)(f)))(m._2));
        }
        if (m.tag === "Constr") {
          return $0.append(f(m._1))(foldMap4(foldableExpr.foldMap(dictMonoid)(f))(m._3));
        }
        if (m.tag === "Matrix") {
          return $0.append(f(m._1))($0.append(foldableExpr.foldMap(dictMonoid)(f)(m._2))(foldableExpr.foldMap(dictMonoid)(f)(m._4)));
        }
        if (m.tag === "Lambda") {
          return $0.append(f(m._1))(foldableElim.foldMap(dictMonoid)(f)(m._2));
        }
        if (m.tag === "Project") {
          return foldableExpr.foldMap(dictMonoid)(f)(m._1);
        }
        if (m.tag === "App") {
          return $0.append(foldableExpr.foldMap(dictMonoid)(f)(m._1))(foldableExpr.foldMap(dictMonoid)(f)(m._2));
        }
        if (m.tag === "Let") {
          return $0.append(foldableVarDef.foldMap(dictMonoid)(f)(m._1))(foldableExpr.foldMap(dictMonoid)(f)(m._2));
        }
        if (m.tag === "LetRec") {
          return $0.append(foldableRecDefs.foldMap(dictMonoid)(f)(m._1))(foldableExpr.foldMap(dictMonoid)(f)(m._2));
        }
        fail();
      };
    }
  };
  var foldableElim = {
    foldl: (f) => (z) => (m) => {
      if (m.tag === "ElimVar") {
        return foldableCont.foldl(f)(z)(m._2);
      }
      if (m.tag === "ElimConstr") {
        const $0 = foldableCont.foldl(f);
        return fold((z$1) => (v) => $0(z$1))(z)(m._1);
      }
      if (m.tag === "ElimRecord") {
        return foldableCont.foldl(f)(z)(m._2);
      }
      fail();
    },
    foldr: (f) => (z) => (m) => {
      if (m.tag === "ElimVar") {
        return foldableCont.foldr(f)(z)(m._2);
      }
      if (m.tag === "ElimConstr") {
        const $0 = foldableCont.foldr(f);
        return foldrArray((b) => (a) => $0(a)(b))(z)(values(m._1));
      }
      if (m.tag === "ElimRecord") {
        return foldableCont.foldr(f)(z)(m._2);
      }
      fail();
    },
    foldMap: (dictMonoid) => {
      const foldMap1 = foldMap(dictMonoid);
      return (f) => (m) => {
        if (m.tag === "ElimVar") {
          return foldableCont.foldMap(dictMonoid)(f)(m._2);
        }
        if (m.tag === "ElimConstr") {
          const $0 = foldableCont.foldMap(dictMonoid)(f);
          return foldMap1((v) => $0)(m._1);
        }
        if (m.tag === "ElimRecord") {
          return foldableCont.foldMap(dictMonoid)(f)(m._2);
        }
        fail();
      };
    }
  };
  var foldableCont = {
    foldl: (f) => (z) => (m) => {
      if (m.tag === "ContExpr") {
        return foldableExpr.foldl(f)(z)(m._1);
      }
      if (m.tag === "ContElim") {
        return foldableElim.foldl(f)(z)(m._1);
      }
      fail();
    },
    foldr: (f) => (z) => (m) => {
      if (m.tag === "ContExpr") {
        return foldableExpr.foldr(f)(z)(m._1);
      }
      if (m.tag === "ContElim") {
        return foldableElim.foldr(f)(z)(m._1);
      }
      fail();
    },
    foldMap: (dictMonoid) => (f) => (m) => {
      if (m.tag === "ContExpr") {
        return foldableExpr.foldMap(dictMonoid)(f)(m._1);
      }
      if (m.tag === "ContElim") {
        return foldableElim.foldMap(dictMonoid)(f)(m._1);
      }
      fail();
    }
  };
  var traversableVarDef = {
    traverse: (dictApplicative) => {
      const Apply0 = dictApplicative.Apply0();
      return (f) => (m) => Apply0.apply(Apply0.Functor0().map((v2) => (v3) => $VarDef(v2, v3))(traversableElim.traverse(dictApplicative)(f)(m._1)))(traversableExpr.traverse(dictApplicative)(f)(m._2));
    },
    sequence: (dictApplicative) => (v) => traversableVarDef.traverse(dictApplicative)(identity23)(v),
    Functor0: () => functorVarDef,
    Foldable1: () => foldableVarDef
  };
  var traversableRecDefs = {
    traverse: (dictApplicative) => {
      const Apply0 = dictApplicative.Apply0();
      const traverse5 = traversableDict.traverse(dictApplicative);
      return (f) => (m) => Apply0.apply(Apply0.Functor0().map((v2) => (v3) => $RecDefs(v2, v3))(f(m._1)))(traverse5(traversableElim.traverse(dictApplicative)(f))(m._2));
    },
    sequence: (dictApplicative) => (v) => traversableRecDefs.traverse(dictApplicative)(identity23)(v),
    Functor0: () => functorRecDefs,
    Foldable1: () => foldableRecDefs
  };
  var traversableExpr = {
    traverse: (dictApplicative) => {
      const Apply0 = dictApplicative.Apply0();
      const $0 = Apply0.Functor0();
      const traverse5 = traversableDict.traverse(dictApplicative);
      const traverse6 = traversableList.traverse(dictApplicative);
      const traverse7 = traversablePair.traverse(dictApplicative);
      return (f) => (m) => {
        if (m.tag === "Var") {
          return dictApplicative.pure($Expr("Var", m._1));
        }
        if (m.tag === "Op") {
          return dictApplicative.pure($Expr("Op", m._1));
        }
        if (m.tag === "Int") {
          const $1 = m._2;
          return $0.map((v2) => $Expr("Int", v2, $1))(f(m._1));
        }
        if (m.tag === "Float") {
          const $1 = m._2;
          return $0.map((v2) => $Expr("Float", v2, $1))(f(m._1));
        }
        if (m.tag === "Str") {
          const $1 = m._2;
          return $0.map((v2) => $Expr("Str", v2, $1))(f(m._1));
        }
        if (m.tag === "Record") {
          return Apply0.apply($0.map((v2) => (v3) => $Expr("Record", v2, v3))(f(m._1)))(traverse5(traversableExpr.traverse(dictApplicative)(f))(m._2));
        }
        if (m.tag === "Dictionary") {
          return Apply0.apply($0.map((v2) => (v3) => $Expr("Dictionary", v2, v3))(f(m._1)))(traverse6(traverse7(traversableExpr.traverse(dictApplicative)(f)))(m._2));
        }
        if (m.tag === "Constr") {
          const $1 = m._2;
          return Apply0.apply($0.map((v3) => (v4) => $Expr("Constr", v3, $1, v4))(f(m._1)))(traverse6(traversableExpr.traverse(dictApplicative)(f))(m._3));
        }
        if (m.tag === "Matrix") {
          const $1 = m._3;
          return Apply0.apply(Apply0.apply($0.map((v4) => (v5) => (v6) => $Expr("Matrix", v4, v5, $1, v6))(f(m._1)))(traversableExpr.traverse(dictApplicative)(f)(m._2)))(traversableExpr.traverse(dictApplicative)(f)(m._4));
        }
        if (m.tag === "Lambda") {
          return Apply0.apply($0.map((v2) => (v3) => $Expr("Lambda", v2, v3))(f(m._1)))(traversableElim.traverse(dictApplicative)(f)(m._2));
        }
        if (m.tag === "Project") {
          const $1 = m._2;
          return $0.map((v2) => $Expr("Project", v2, $1))(traversableExpr.traverse(dictApplicative)(f)(m._1));
        }
        if (m.tag === "App") {
          return Apply0.apply($0.map((v2) => (v3) => $Expr("App", v2, v3))(traversableExpr.traverse(dictApplicative)(f)(m._1)))(traversableExpr.traverse(dictApplicative)(f)(m._2));
        }
        if (m.tag === "Let") {
          return Apply0.apply($0.map((v2) => (v3) => $Expr("Let", v2, v3))(traversableVarDef.traverse(dictApplicative)(f)(m._1)))(traversableExpr.traverse(dictApplicative)(f)(m._2));
        }
        if (m.tag === "LetRec") {
          return Apply0.apply($0.map((v2) => (v3) => $Expr("LetRec", v2, v3))(traversableRecDefs.traverse(dictApplicative)(f)(m._1)))(traversableExpr.traverse(dictApplicative)(f)(m._2));
        }
        fail();
      };
    },
    sequence: (dictApplicative) => (v) => traversableExpr.traverse(dictApplicative)(identity23)(v),
    Functor0: () => functorExpr,
    Foldable1: () => foldableExpr
  };
  var traversableElim = {
    traverse: (dictApplicative) => {
      const $0 = dictApplicative.Apply0().Functor0();
      const traverse5 = traversableDict.traverse(dictApplicative);
      return (f) => (m) => {
        if (m.tag === "ElimVar") {
          const $1 = m._1;
          return $0.map((v2) => $Elim("ElimVar", $1, v2))(traversableCont.traverse(dictApplicative)(f)(m._2));
        }
        if (m.tag === "ElimConstr") {
          return $0.map((v1) => $Elim("ElimConstr", v1))(traverse5(traversableCont.traverse(dictApplicative)(f))(m._1));
        }
        if (m.tag === "ElimRecord") {
          const $1 = m._1;
          return $0.map((v2) => $Elim("ElimRecord", $1, v2))(traversableCont.traverse(dictApplicative)(f)(m._2));
        }
        fail();
      };
    },
    sequence: (dictApplicative) => (v) => traversableElim.traverse(dictApplicative)(identity23)(v),
    Functor0: () => functorElim,
    Foldable1: () => foldableElim
  };
  var traversableCont = {
    traverse: (dictApplicative) => {
      const $0 = dictApplicative.Apply0().Functor0();
      return (f) => (m) => {
        if (m.tag === "ContExpr") {
          return $0.map((v1) => $Cont("ContExpr", v1))(traversableExpr.traverse(dictApplicative)(f)(m._1));
        }
        if (m.tag === "ContElim") {
          return $0.map((v1) => $Cont("ContElim", v1))(traversableElim.traverse(dictApplicative)(f)(m._1));
        }
        fail();
      };
    },
    sequence: (dictApplicative) => (v) => traversableCont.traverse(dictApplicative)(identity23)(v),
    Functor0: () => functorCont,
    Foldable1: () => foldableCont
  };
  var expandableVarDefRawVarDef = (dictBoundedJoinSemilattice) => ({ expand: (v) => (v1) => $VarDef(expandableElimRawElim(dictBoundedJoinSemilattice).expand(v._1)(v1._1), expandableExprRawExpr(dictBoundedJoinSemilattice).expand(v._2)(v1._2)) });
  var expandableRecDefsRawRecDe = (dictBoundedJoinSemilattice) => {
    const expandableDictDict2 = expandableDictDict({
      botOf: functorElim.map((() => {
        const $0 = dictBoundedJoinSemilattice.bot;
        return (v) => $0;
      })())
    });
    return { expand: (v) => (v1) => $RecDefs(v._1, expandableDictDict2(expandableElimRawElim(dictBoundedJoinSemilattice)).expand(v._2)(v1._2)) };
  };
  var expandableExprRawExpr = (dictBoundedJoinSemilattice) => {
    const expandableDictDict2 = expandableDictDict({
      botOf: functorExpr.map((() => {
        const $0 = dictBoundedJoinSemilattice.bot;
        return (v) => $0;
      })())
    });
    return {
      expand: (v) => (v1) => {
        if (v.tag === "Var") {
          if (v1.tag === "Var") {
            return $Expr("Var", mustEq(eqString)(showString)(v._1)(v1._1));
          }
          return throwException(error("Shape mismatch"))();
        }
        if (v.tag === "Op") {
          if (v1.tag === "Op") {
            return $Expr("Op", mustEq(eqString)(showString)(v._1)(v1._1));
          }
          return throwException(error("Shape mismatch"))();
        }
        if (v.tag === "Int") {
          if (v1.tag === "Int") {
            return $Expr("Int", v._1, mustEq(eqInt)(showInt)(v._2)(v1._2));
          }
          return throwException(error("Shape mismatch"))();
        }
        if (v.tag === "Str") {
          if (v1.tag === "Str") {
            return $Expr("Str", v._1, mustEq(eqString)(showString)(v._2)(v1._2));
          }
          return throwException(error("Shape mismatch"))();
        }
        if (v.tag === "Float") {
          if (v1.tag === "Float") {
            return $Expr("Float", v._1, mustEq(eqNumber)(showNumber)(v._2)(v1._2));
          }
          return throwException(error("Shape mismatch"))();
        }
        if (v.tag === "Record") {
          if (v1.tag === "Record") {
            return $Expr("Record", v._1, expandableDictDict2(expandableExprRawExpr(dictBoundedJoinSemilattice)).expand(v._2)(v1._2));
          }
          return throwException(error("Shape mismatch"))();
        }
        if (v.tag === "Dictionary") {
          if (v1.tag === "Dictionary") {
            return $Expr(
              "Dictionary",
              v._1,
              (() => {
                const $0 = expandableExprRawExpr(dictBoundedJoinSemilattice);
                return zipWith2((v$1) => (v1$1) => $Pair($0.expand(v$1._1)(v1$1._1), $0.expand(v$1._2)(v1$1._2)))(v._2)(v1._2);
              })()
            );
          }
          return throwException(error("Shape mismatch"))();
        }
        if (v.tag === "Constr") {
          if (v1.tag === "Constr") {
            return $Expr(
              "Constr",
              v._1,
              mustEq(eqString)(showString)(v._2)(v1._2),
              zipWith2(expandableExprRawExpr(dictBoundedJoinSemilattice).expand)(v._3)(v1._3)
            );
          }
          return throwException(error("Shape mismatch"))();
        }
        if (v.tag === "Matrix") {
          if (v1.tag === "Matrix") {
            return $Expr(
              "Matrix",
              v._1,
              expandableExprRawExpr(dictBoundedJoinSemilattice).expand(v._2)(v1._2),
              $Tuple(mustEq(eqString)(showString)(v._3._1)(v1._3._1), mustEq(eqString)(showString)(v._3._2)(v1._3._2)),
              expandableExprRawExpr(dictBoundedJoinSemilattice).expand(v._4)(v1._4)
            );
          }
          return throwException(error("Shape mismatch"))();
        }
        if (v.tag === "Lambda") {
          if (v1.tag === "Lambda") {
            return $Expr("Lambda", v._1, expandableElimRawElim(dictBoundedJoinSemilattice).expand(v._2)(v1._2));
          }
          return throwException(error("Shape mismatch"))();
        }
        if (v.tag === "Project") {
          if (v1.tag === "Project") {
            return $Expr("Project", expandableExprRawExpr(dictBoundedJoinSemilattice).expand(v._1)(v1._1), mustEq(eqString)(showString)(v._2)(v1._2));
          }
          return throwException(error("Shape mismatch"))();
        }
        if (v.tag === "App") {
          if (v1.tag === "App") {
            return $Expr("App", expandableExprRawExpr(dictBoundedJoinSemilattice).expand(v._1)(v1._1), expandableExprRawExpr(dictBoundedJoinSemilattice).expand(v._2)(v1._2));
          }
          return throwException(error("Shape mismatch"))();
        }
        if (v.tag === "Let") {
          if (v1.tag === "Let") {
            return $Expr("Let", expandableVarDefRawVarDef(dictBoundedJoinSemilattice).expand(v._1)(v1._1), expandableExprRawExpr(dictBoundedJoinSemilattice).expand(v._2)(v1._2));
          }
          return throwException(error("Shape mismatch"))();
        }
        if (v.tag === "LetRec" && v1.tag === "LetRec") {
          return $Expr("LetRec", expandableRecDefsRawRecDe(dictBoundedJoinSemilattice).expand(v._1)(v1._1), expandableExprRawExpr(dictBoundedJoinSemilattice).expand(v._2)(v1._2));
        }
        return throwException(error("Shape mismatch"))();
      }
    };
  };
  var expandableElimRawElim = (dictBoundedJoinSemilattice) => {
    const expandableDictDict2 = expandableDictDict({
      botOf: functorCont.map((() => {
        const $0 = dictBoundedJoinSemilattice.bot;
        return (v) => $0;
      })())
    });
    return {
      expand: (v) => (v1) => {
        if (v.tag === "ElimVar") {
          if (v1.tag === "ElimVar") {
            return $Elim("ElimVar", mustEq(eqString)(showString)(v._1)(v1._1), expandableContRawCont(dictBoundedJoinSemilattice).expand(v._2)(v1._2));
          }
          return throwException(error("Shape mismatch"))();
        }
        if (v.tag === "ElimConstr") {
          if (v1.tag === "ElimConstr") {
            return $Elim("ElimConstr", expandableDictDict2(expandableContRawCont(dictBoundedJoinSemilattice)).expand(v._1)(v1._1));
          }
          return throwException(error("Shape mismatch"))();
        }
        if (v.tag === "ElimRecord" && v1.tag === "ElimRecord") {
          return $Elim("ElimRecord", mustEq(eqSet2)(showSet(showString))(v._1)(v1._1), expandableContRawCont(dictBoundedJoinSemilattice).expand(v._2)(v1._2));
        }
        return throwException(error("Shape mismatch"))();
      }
    };
  };
  var expandableContRawCont = (dictBoundedJoinSemilattice) => ({
    expand: (v) => (v1) => {
      if (v.tag === "ContExpr") {
        if (v1.tag === "ContExpr") {
          return $Cont("ContExpr", expandableExprRawExpr(dictBoundedJoinSemilattice).expand(v._1)(v1._1));
        }
        return throwException(error("Shape mismatch"))();
      }
      if (v.tag === "ContElim" && v1.tag === "ContElim") {
        return $Cont("ContElim", expandableElimRawElim(dictBoundedJoinSemilattice).expand(v._1)(v1._1));
      }
      return throwException(error("Shape mismatch"))();
    }
  });
  var applyRecDefs = {
    apply: (v) => (v1) => $RecDefs(v._1(v1._1), intersectionWith_Object(apply)(_fmapObject(v._2, applyElim.apply))(v1._2)),
    Functor0: () => functorRecDefs
  };
  var applyExpr = {
    apply: (v) => (v1) => {
      if (v.tag === "Var") {
        if (v1.tag === "Var") {
          return $Expr("Var", mustEq(eqString)(showString)(v._1)(v1._1));
        }
        return throwException(error("Shape mismatch"))();
      }
      if (v.tag === "Op") {
        if (v1.tag === "Op") {
          return $Expr("Op", v._1);
        }
        return throwException(error("Shape mismatch"))();
      }
      if (v.tag === "Int") {
        if (v1.tag === "Int") {
          return $Expr("Int", v._1(v1._1), mustEq(eqInt)(showInt)(v._2)(v1._2));
        }
        return throwException(error("Shape mismatch"))();
      }
      if (v.tag === "Float") {
        if (v1.tag === "Float") {
          return $Expr("Float", v._1(v1._1), mustEq(eqNumber)(showNumber)(v._2)(v1._2));
        }
        return throwException(error("Shape mismatch"))();
      }
      if (v.tag === "Str") {
        if (v1.tag === "Str") {
          return $Expr("Str", v._1(v1._1), mustEq(eqString)(showString)(v._2)(v1._2));
        }
        return throwException(error("Shape mismatch"))();
      }
      if (v.tag === "Record") {
        if (v1.tag === "Record") {
          return $Expr("Record", v._1(v1._1), intersectionWith_Object(apply)(_fmapObject(v._2, applyExpr.apply))(v1._2));
        }
        return throwException(error("Shape mismatch"))();
      }
      if (v.tag === "Dictionary") {
        if (v1.tag === "Dictionary") {
          return $Expr("Dictionary", v._1(v1._1), zipWith2((a) => (b) => $Pair(applyExpr.apply(a._1)(b._1), applyExpr.apply(a._2)(b._2)))(v._2)(v1._2));
        }
        return throwException(error("Shape mismatch"))();
      }
      if (v.tag === "Constr") {
        if (v1.tag === "Constr") {
          return $Expr("Constr", v._1(v1._1), mustEq(eqString)(showString)(v._2)(v1._2), zipWith2(applyExpr.apply)(v._3)(v1._3));
        }
        return throwException(error("Shape mismatch"))();
      }
      if (v.tag === "Matrix") {
        if (v1.tag === "Matrix") {
          return $Expr(
            "Matrix",
            v._1(v1._1),
            applyExpr.apply(v._2)(v1._2),
            $Tuple(mustEq(eqString)(showString)(v._3._1)(v1._3._1), mustEq(eqString)(showString)(v._3._2)(v1._3._2)),
            applyExpr.apply(v._4)(v1._4)
          );
        }
        return throwException(error("Shape mismatch"))();
      }
      if (v.tag === "Lambda") {
        if (v1.tag === "Lambda") {
          return $Expr("Lambda", v._1(v1._1), applyElim.apply(v._2)(v1._2));
        }
        return throwException(error("Shape mismatch"))();
      }
      if (v.tag === "Project") {
        if (v1.tag === "Project") {
          return $Expr("Project", applyExpr.apply(v._1)(v1._1), v._2);
        }
        return throwException(error("Shape mismatch"))();
      }
      if (v.tag === "App") {
        if (v1.tag === "App") {
          return $Expr("App", applyExpr.apply(v._1)(v1._1), applyExpr.apply(v._2)(v1._2));
        }
        return throwException(error("Shape mismatch"))();
      }
      if (v.tag === "Let") {
        if (v1.tag === "Let") {
          return $Expr("Let", $VarDef(applyElim.apply(v._1._1)(v1._1._1), applyExpr.apply(v._1._2)(v1._1._2)), applyExpr.apply(v._2)(v1._2));
        }
        return throwException(error("Shape mismatch"))();
      }
      if (v.tag === "LetRec" && v1.tag === "LetRec") {
        return $Expr("LetRec", applyRecDefs.apply(v._1)(v1._1), applyExpr.apply(v._2)(v1._2));
      }
      return throwException(error("Shape mismatch"))();
    },
    Functor0: () => functorExpr
  };
  var applyElim = {
    apply: (v) => (v1) => {
      if (v.tag === "ElimVar") {
        if (v1.tag === "ElimVar") {
          return $Elim("ElimVar", v._1, applyCont.apply(v._2)(v1._2));
        }
        return throwException(error("Shape mismatch"))();
      }
      if (v.tag === "ElimConstr") {
        if (v1.tag === "ElimConstr") {
          return $Elim("ElimConstr", intersectionWith_Object(apply)(_fmapObject(v._1, applyCont.apply))(v1._1));
        }
        return throwException(error("Shape mismatch"))();
      }
      if (v.tag === "ElimRecord" && v1.tag === "ElimRecord") {
        return $Elim("ElimRecord", v._1, applyCont.apply(v._2)(v1._2));
      }
      return throwException(error("Shape mismatch"))();
    },
    Functor0: () => functorElim
  };
  var applyCont = {
    apply: (v) => (v1) => {
      if (v.tag === "ContExpr") {
        if (v1.tag === "ContExpr") {
          return $Cont("ContExpr", applyExpr.apply(v._1)(v1._1));
        }
        return throwException(error("Shape mismatch"))();
      }
      if (v.tag === "ContElim" && v1.tag === "ContElim") {
        return $Cont("ContElim", applyElim.apply(v._1)(v1._1));
      }
      return throwException(error("Shape mismatch"))();
    },
    Functor0: () => functorCont
  };
  var fVDict = (dictFV) => {
    const fv1 = dictFV.fv;
    return { fv: (\u03C1) => setSet2.difference(unions2(_fmapObject(\u03C1, fv1)))(fromFoldable6(mapObjectString.keys(\u03C1))) };
  };
  var foldlModuleDef = (v) => (v1) => (v2) => {
    if (v2.tag === "Left") {
      return foldableVarDef.foldl(v)(v1)(v2._1);
    }
    if (v2.tag === "Right") {
      return foldableRecDefs.foldl(v)(v1)(v2._1);
    }
    fail();
  };
  var foldableModule = {
    foldl: (v) => (v1) => (v2) => {
      if (v2.tag === "Nil") {
        return v1;
      }
      if (v2.tag === "Cons") {
        if (v2._1.tag === "Left") {
          const go = (go$a0$copy) => (go$a1$copy) => {
            let go$a0 = go$a0$copy, go$a1 = go$a1$copy, go$c = true, go$r;
            while (go$c) {
              const b = go$a0, v$1 = go$a1;
              if (v$1.tag === "Nil") {
                go$c = false;
                go$r = b;
                continue;
              }
              if (v$1.tag === "Cons") {
                go$a0 = foldlModuleDef(v)(b)(v$1._1);
                go$a1 = v$1._2;
                continue;
              }
              fail();
            }
            return go$r;
          };
          return go(foldableVarDef.foldl(v)(v1)(v2._1._1))(v2._2);
        }
        if (v2._1.tag === "Right") {
          const go = (go$a0$copy) => (go$a1$copy) => {
            let go$a0 = go$a0$copy, go$a1 = go$a1$copy, go$c = true, go$r;
            while (go$c) {
              const b = go$a0, v$1 = go$a1;
              if (v$1.tag === "Nil") {
                go$c = false;
                go$r = b;
                continue;
              }
              if (v$1.tag === "Cons") {
                go$a0 = foldlModuleDef(v)(b)(v$1._1);
                go$a1 = v$1._2;
                continue;
              }
              fail();
            }
            return go$r;
          };
          return go(foldableRecDefs.foldl(v)(v1)(v2._1._1))(v2._2);
        }
      }
      fail();
    },
    foldr: (f) => foldrDefault(foldableModule)(f),
    foldMap: (dictMonoid) => (f) => foldableModule.foldl((acc) => (x2) => dictMonoid.Semigroup0().append(acc)(f(x2)))(dictMonoid.mempty)
  };
  var traversableModule = {
    traverse: (dictApplicative) => {
      const Apply0 = dictApplicative.Apply0();
      const $0 = Apply0.Functor0();
      const traverse5 = traversableVarDef.traverse(dictApplicative);
      const traverse6 = traversableRecDefs.traverse(dictApplicative);
      return (v) => (v1) => {
        if (v1.tag === "Nil") {
          return dictApplicative.pure(Nil);
        }
        if (v1.tag === "Cons") {
          if (v1._1.tag === "Left") {
            return $0.map(Module)(Apply0.apply(Apply0.Functor0().map(Cons)($0.map(Left)(traverse5(v)(v1._1._1))))($0.map(unsafeCoerce)(traversableModule.traverse(dictApplicative)(v)(v1._2))));
          }
          if (v1._1.tag === "Right") {
            return $0.map(Module)(Apply0.apply(Apply0.Functor0().map(Cons)($0.map(Right)(traverse6(v)(v1._1._1))))($0.map(unsafeCoerce)(traversableModule.traverse(dictApplicative)(v)(v1._2))));
          }
        }
        fail();
      };
    },
    sequence: (dictApplicative) => traversableModule.traverse(dictApplicative)(identity7),
    Functor0: () => functorModule,
    Foldable1: () => foldableModule
  };
  var bVElim = {
    bv: (v) => {
      if (v.tag === "ElimVar") {
        return setSet2.union($$$Map("Node", 1, 1, v._1, void 0, Leaf, Leaf))(bVCont.bv(v._2));
      }
      if (v.tag === "ElimConstr") {
        return bVCont.bv(asMaplet2(v._1)._2);
      }
      if (v.tag === "ElimRecord") {
        return bVCont.bv(v._2);
      }
      fail();
    }
  };
  var bVCont = {
    bv: (v) => {
      if (v.tag === "ContElim") {
        return bVElim.bv(v._1);
      }
      if (v.tag === "ContExpr") {
        return Leaf;
      }
      fail();
    }
  };
  var fVExpr = {
    fv: (v) => {
      if (v.tag === "Var") {
        return $$$Map("Node", 1, 1, v._1, void 0, Leaf, Leaf);
      }
      if (v.tag === "Op") {
        return $$$Map("Node", 1, 1, v._1, void 0, Leaf, Leaf);
      }
      if (v.tag === "Int") {
        return Leaf;
      }
      if (v.tag === "Float") {
        return Leaf;
      }
      if (v.tag === "Str") {
        return Leaf;
      }
      if (v.tag === "Record") {
        return unions2(_fmapObject(v._2, fVExpr.fv));
      }
      if (v.tag === "Dictionary") {
        return unions1(listMap((v1) => setSet2.union(fVExpr.fv(v1._1))(fVExpr.fv(v1._2)))(v._2));
      }
      if (v.tag === "Constr") {
        return unions1(listMap(fVExpr.fv)(v._3));
      }
      if (v.tag === "Matrix") {
        return setSet2.union(fVExpr.fv(v._2))(fVExpr.fv(v._4));
      }
      if (v.tag === "Lambda") {
        return fVElim.fv(v._2);
      }
      if (v.tag === "Project") {
        return fVExpr.fv(v._1);
      }
      if (v.tag === "App") {
        return setSet2.union(fVExpr.fv(v._1))(fVExpr.fv(v._2));
      }
      if (v.tag === "Let") {
        return setSet2.union(fVExpr.fv(v._1._2))(setSet2.difference(fVExpr.fv(v._2))(bVElim.bv(v._1._1)));
      }
      if (v.tag === "LetRec") {
        return setSet2.union(fVDict(fVElim).fv(v._1._2))(fVExpr.fv(v._2));
      }
      fail();
    }
  };
  var fVElim = {
    fv: (v) => {
      if (v.tag === "ElimVar") {
        return setSet2.difference(fVCont.fv(v._2))($$$Map("Node", 1, 1, v._1, void 0, Leaf, Leaf));
      }
      if (v.tag === "ElimConstr") {
        return unions2(_fmapObject(v._1, fVCont.fv));
      }
      if (v.tag === "ElimRecord") {
        return fVCont.fv(v._2);
      }
      fail();
    }
  };
  var fVCont = {
    fv: (v) => {
      if (v.tag === "ContElim") {
        return fVElim.fv(v._1);
      }
      if (v.tag === "ContExpr") {
        return fVExpr.fv(v._1);
      }
      fail();
    }
  };
  var asElim = (v) => {
    if (v.tag === "ContElim") {
      return v._1;
    }
    return throwException(error("Eliminator expected"))();
  };

  // output-es/SExpr/index.js
  var $Expr2 = (tag, _1, _2, _3, _4) => ({ tag, _1, _2, _3, _4 });
  var $ListRest = (tag, _1, _2, _3) => ({ tag, _1, _2, _3 });
  var $ListRestPattern = (tag, _1, _2) => ({ tag, _1, _2 });
  var $Module = (_1) => ({ tag: "Module", _1 });
  var $Pattern = (tag, _1, _2) => ({ tag, _1, _2 });
  var $Qualifier = (tag, _1, _2) => ({ tag, _1, _2 });
  var $VarDef2 = (_1, _2) => ({ tag: "VarDef", _1, _2 });
  var genericShowArgsArgument = { genericShowArgs: (v) => [showStringImpl(v)] };
  var genericShowSum = /* @__PURE__ */ (() => {
    const $0 = genericShowConstructor(genericShowArgsArgument)({ reflectSymbol: () => "PVar" });
    return (dictGenericShow1) => ({
      "genericShow'": (v) => {
        if (v.tag === "Inl") {
          return $0["genericShow'"](v._1);
        }
        if (v.tag === "Inr") {
          return dictGenericShow1["genericShow'"](v._1);
        }
        fail();
      }
    });
  })();
  var PConstrIsSymbol = { reflectSymbol: () => "PConstr" };
  var showTuple = (dictShow1) => ({ show: (v) => "(Tuple " + showStringImpl(v._1) + " " + dictShow1.show(v._2) + ")" });
  var PRecordIsSymbol = { reflectSymbol: () => "PRecord" };
  var genericShowSum1 = /* @__PURE__ */ (() => {
    const $0 = genericShowConstructor(genericShowArgsNoArguments)({ reflectSymbol: () => "PListEmpty" });
    return (dictGenericShow1) => ({
      "genericShow'": (v) => {
        if (v.tag === "Inl") {
          return $0["genericShow'"](v._1);
        }
        if (v.tag === "Inr") {
          return dictGenericShow1["genericShow'"](v._1);
        }
        fail();
      }
    });
  })();
  var PListNonEmptyIsSymbol = { reflectSymbol: () => "PListNonEmpty" };
  var genericShowSum2 = /* @__PURE__ */ (() => {
    const $0 = genericShowConstructor(genericShowArgsArgument)({ reflectSymbol: () => "PListVar" });
    return (dictGenericShow1) => ({
      "genericShow'": (v) => {
        if (v.tag === "Inl") {
          return $0["genericShow'"](v._1);
        }
        if (v.tag === "Inr") {
          return dictGenericShow1["genericShow'"](v._1);
        }
        fail();
      }
    });
  })();
  var genericShowSum3 = /* @__PURE__ */ (() => {
    const $0 = genericShowConstructor(genericShowArgsNoArguments)({ reflectSymbol: () => "PListEnd" });
    return (dictGenericShow1) => ({
      "genericShow'": (v) => {
        if (v.tag === "Inl") {
          return $0["genericShow'"](v._1);
        }
        if (v.tag === "Inr") {
          return dictGenericShow1["genericShow'"](v._1);
        }
        fail();
      }
    });
  })();
  var PListNextIsSymbol = { reflectSymbol: () => "PListNext" };
  var difference2 = /* @__PURE__ */ difference(eqString);
  var toUnfoldable5 = /* @__PURE__ */ (() => {
    const $0 = toUnfoldable2(unfoldableList);
    return (x2) => $0(keys2(x2));
  })();
  var monadThrowExceptT2 = /* @__PURE__ */ monadThrowExceptT(monadIdentity);
  var fromFoldable7 = /* @__PURE__ */ fromFoldable(foldableArray);
  var fromFoldable14 = /* @__PURE__ */ fromFoldable(foldableNonEmptyList);
  var fromFoldable24 = /* @__PURE__ */ fromFoldable(foldableList);
  var monadErrorExceptT2 = /* @__PURE__ */ monadErrorExceptT(monadIdentity);
  var PListEnd = /* @__PURE__ */ $ListRestPattern("PListEnd");
  var PListNext = (value0) => (value1) => $ListRestPattern("PListNext", value0, value1);
  var PConstr = (value0) => (value1) => $Pattern("PConstr", value0, value1);
  var PListEmpty = /* @__PURE__ */ $Pattern("PListEmpty");
  var PListNonEmpty = (value0) => (value1) => $Pattern("PListNonEmpty", value0, value1);
  var Clause = (x2) => x2;
  var Int = (value0) => (value1) => $Expr2("Int", value0, value1);
  var Float = (value0) => (value1) => $Expr2("Float", value0, value1);
  var Str = (value0) => (value1) => $Expr2("Str", value0, value1);
  var Constr2 = (value0) => (value1) => (value2) => $Expr2("Constr", value0, value1, value2);
  var Record2 = (value0) => (value1) => $Expr2("Record", value0, value1);
  var Dictionary2 = (value0) => (value1) => $Expr2("Dictionary", value0, value1);
  var Matrix2 = (value0) => (value1) => (value2) => (value3) => $Expr2("Matrix", value0, value1, value2, value3);
  var Project2 = (value0) => (value1) => $Expr2("Project", value0, value1);
  var App3 = (value0) => (value1) => $Expr2("App", value0, value1);
  var MatchAs = (value0) => (value1) => $Expr2("MatchAs", value0, value1);
  var IfElse = (value0) => (value1) => (value2) => $Expr2("IfElse", value0, value1, value2);
  var ListNonEmpty = (value0) => (value1) => (value2) => $Expr2("ListNonEmpty", value0, value1, value2);
  var ListEnum = (value0) => (value1) => $Expr2("ListEnum", value0, value1);
  var ListComp = (value0) => (value1) => (value2) => $Expr2("ListComp", value0, value1, value2);
  var Let2 = (value0) => (value1) => $Expr2("Let", value0, value1);
  var LetRec2 = (value0) => (value1) => $Expr2("LetRec", value0, value1);
  var Next = (value0) => (value1) => (value2) => $ListRest("Next", value0, value1, value2);
  var ListCompGen = (value0) => (value1) => $Qualifier("ListCompGen", value0, value1);
  var VarDef2 = (value0) => (value1) => $VarDef2(value0, value1);
  var RecDef = (x2) => x2;
  var genericPattern_ = {
    to: (x2) => {
      if (x2.tag === "Inl") {
        return $Pattern("PVar", x2._1);
      }
      if (x2.tag === "Inr") {
        if (x2._1.tag === "Inl") {
          return $Pattern("PConstr", x2._1._1._1, x2._1._1._2);
        }
        if (x2._1.tag === "Inr") {
          if (x2._1._1.tag === "Inl") {
            return $Pattern("PRecord", x2._1._1._1);
          }
          if (x2._1._1.tag === "Inr") {
            if (x2._1._1._1.tag === "Inl") {
              return PListEmpty;
            }
            if (x2._1._1._1.tag === "Inr") {
              return $Pattern("PListNonEmpty", x2._1._1._1._1._1, x2._1._1._1._1._2);
            }
          }
        }
      }
      fail();
    },
    from: (x2) => {
      if (x2.tag === "PVar") {
        return $Sum("Inl", x2._1);
      }
      if (x2.tag === "PConstr") {
        return $Sum("Inr", $Sum("Inl", $Product(x2._1, x2._2)));
      }
      if (x2.tag === "PRecord") {
        return $Sum("Inr", $Sum("Inr", $Sum("Inl", x2._1)));
      }
      if (x2.tag === "PListEmpty") {
        return $Sum("Inr", $Sum("Inr", $Sum("Inr", $Sum("Inl", NoArguments))));
      }
      if (x2.tag === "PListNonEmpty") {
        return $Sum("Inr", $Sum("Inr", $Sum("Inr", $Sum("Inr", $Product(x2._1, x2._2)))));
      }
      fail();
    }
  };
  var genericListRestPattern_ = {
    to: (x2) => {
      if (x2.tag === "Inl") {
        return $ListRestPattern("PListVar", x2._1);
      }
      if (x2.tag === "Inr") {
        if (x2._1.tag === "Inl") {
          return PListEnd;
        }
        if (x2._1.tag === "Inr") {
          return $ListRestPattern("PListNext", x2._1._1._1, x2._1._1._2);
        }
      }
      fail();
    },
    from: (x2) => {
      if (x2.tag === "PListVar") {
        return $Sum("Inl", x2._1);
      }
      if (x2.tag === "PListEnd") {
        return $Sum("Inr", $Sum("Inl", NoArguments));
      }
      if (x2.tag === "PListNext") {
        return $Sum("Inr", $Sum("Inr", $Product(x2._1, x2._2)));
      }
      fail();
    }
  };
  var showPattern1 = {
    show: (c) => genericShowSum((() => {
      const $0 = genericShowConstructor(genericShowArgsProduct(genericShowArgsArgument)((() => {
        const $02 = showList(showPattern1);
        return { genericShowArgs: (v) => [$02.show(v)] };
      })()))(PConstrIsSymbol);
      const $1 = genericShowConstructor((() => {
        const $12 = showList(showTuple(showPattern1));
        return { genericShowArgs: (v) => [$12.show(v)] };
      })())(PRecordIsSymbol);
      const $2 = (() => {
        const $22 = genericShowSum1(genericShowConstructor(genericShowArgsProduct({ genericShowArgs: (v) => [showPattern1.show(v)] })({
          genericShowArgs: (v) => [showListRestPattern.show(v)]
        }))(PListNonEmptyIsSymbol));
        return {
          "genericShow'": (v) => {
            if (v.tag === "Inl") {
              return $1["genericShow'"](v._1);
            }
            if (v.tag === "Inr") {
              return $22["genericShow'"](v._1);
            }
            fail();
          }
        };
      })();
      return {
        "genericShow'": (v) => {
          if (v.tag === "Inl") {
            return $0["genericShow'"](v._1);
          }
          if (v.tag === "Inr") {
            return $2["genericShow'"](v._1);
          }
          fail();
        }
      };
    })())["genericShow'"](genericPattern_.from(c))
  };
  var showListRestPattern = {
    show: (c) => genericShowSum2(genericShowSum3(genericShowConstructor(genericShowArgsProduct({ genericShowArgs: (v) => [showPattern1.show(v)] })({
      genericShowArgs: (v) => [showListRestPattern.show(v)]
    }))(PListNextIsSymbol)))["genericShow'"](genericListRestPattern_.from(c))
  };
  var functorVarDef2 = { map: (f) => (m) => $VarDef2(m._1, functorExpr2.map(f)(m._2)) };
  var functorQualifier = {
    map: (f) => (m) => {
      if (m.tag === "ListCompGuard") {
        return $Qualifier("ListCompGuard", functorExpr2.map(f)(m._1));
      }
      if (m.tag === "ListCompGen") {
        return $Qualifier("ListCompGen", m._1, functorExpr2.map(f)(m._2));
      }
      if (m.tag === "ListCompDecl") {
        return $Qualifier("ListCompDecl", $VarDef2(m._1._1, functorExpr2.map(f)(m._1._2)));
      }
      fail();
    }
  };
  var functorListRest = {
    map: (f) => (m) => {
      if (m.tag === "End") {
        return $ListRest("End", f(m._1));
      }
      if (m.tag === "Next") {
        return $ListRest("Next", f(m._1), functorExpr2.map(f)(m._2), functorListRest.map(f)(m._3));
      }
      fail();
    }
  };
  var functorExpr2 = {
    map: (f) => (m) => {
      if (m.tag === "Var") {
        return $Expr2("Var", m._1);
      }
      if (m.tag === "Op") {
        return $Expr2("Op", m._1);
      }
      if (m.tag === "Int") {
        return $Expr2("Int", f(m._1), m._2);
      }
      if (m.tag === "Float") {
        return $Expr2("Float", f(m._1), m._2);
      }
      if (m.tag === "Str") {
        return $Expr2("Str", f(m._1), m._2);
      }
      if (m.tag === "Constr") {
        return $Expr2("Constr", f(m._1), m._2, listMap(functorExpr2.map(f))(m._3));
      }
      if (m.tag === "Record") {
        return $Expr2(
          "Record",
          f(m._1),
          listMap((() => {
            const $0 = functorExpr2.map(f);
            return (m$1) => $Tuple(m$1._1, $0(m$1._2));
          })())(m._2)
        );
      }
      if (m.tag === "Dictionary") {
        return $Expr2(
          "Dictionary",
          f(m._1),
          listMap((() => {
            const $0 = functorExpr2.map(f);
            return (v) => $Pair($0(v._1), $0(v._2));
          })())(m._2)
        );
      }
      if (m.tag === "Matrix") {
        return $Expr2("Matrix", f(m._1), functorExpr2.map(f)(m._2), m._3, functorExpr2.map(f)(m._4));
      }
      if (m.tag === "Lambda") {
        return $Expr2("Lambda", functorClauses.map(f)(m._1));
      }
      if (m.tag === "Project") {
        return $Expr2("Project", functorExpr2.map(f)(m._1), m._2);
      }
      if (m.tag === "App") {
        return $Expr2("App", functorExpr2.map(f)(m._1), functorExpr2.map(f)(m._2));
      }
      if (m.tag === "BinaryApp") {
        return $Expr2("BinaryApp", functorExpr2.map(f)(m._1), m._2, functorExpr2.map(f)(m._3));
      }
      if (m.tag === "MatchAs") {
        return $Expr2(
          "MatchAs",
          functorExpr2.map(f)(m._1),
          (() => {
            const $0 = functorExpr2.map(f);
            return $NonEmpty($Tuple(m._2._1._1, $0(m._2._1._2)), listMap((m$1) => $Tuple(m$1._1, $0(m$1._2)))(m._2._2));
          })()
        );
      }
      if (m.tag === "IfElse") {
        return $Expr2("IfElse", functorExpr2.map(f)(m._1), functorExpr2.map(f)(m._2), functorExpr2.map(f)(m._3));
      }
      if (m.tag === "ListEmpty") {
        return $Expr2("ListEmpty", f(m._1));
      }
      if (m.tag === "ListNonEmpty") {
        return $Expr2("ListNonEmpty", f(m._1), functorExpr2.map(f)(m._2), functorListRest.map(f)(m._3));
      }
      if (m.tag === "ListEnum") {
        return $Expr2("ListEnum", functorExpr2.map(f)(m._1), functorExpr2.map(f)(m._2));
      }
      if (m.tag === "ListComp") {
        return $Expr2("ListComp", f(m._1), functorExpr2.map(f)(m._2), listMap(functorQualifier.map(f))(m._3));
      }
      if (m.tag === "Let") {
        return $Expr2(
          "Let",
          $NonEmpty($VarDef2(m._1._1._1, functorExpr2.map(f)(m._1._1._2)), listMap(functorVarDef2.map(f))(m._1._2)),
          functorExpr2.map(f)(m._2)
        );
      }
      if (m.tag === "LetRec") {
        return $Expr2(
          "LetRec",
          (() => {
            const $0 = functorClause.map(f);
            return $NonEmpty($Tuple(m._1._1._1, $0(m._1._1._2)), listMap((m$1) => $Tuple(m$1._1, $0(m$1._2)))(m._1._2));
          })(),
          functorExpr2.map(f)(m._2)
        );
      }
      fail();
    }
  };
  var functorClauses = {
    map: (f) => (m) => {
      const $0 = functorClause.map(f);
      return $NonEmpty($0(m._1), listMap($0)(m._2));
    }
  };
  var functorClause = { map: (f) => (m) => $Tuple(m._1, functorExpr2.map(f)(m._2)) };
  var eqPattern = {
    eq: (x2) => (y2) => {
      if (x2.tag === "PVar") {
        return y2.tag === "PVar" && x2._1 === y2._1;
      }
      if (x2.tag === "PConstr") {
        return y2.tag === "PConstr" && x2._1 === y2._1 && (() => {
          const go = (v) => (v1) => (v2) => {
            if (!v2) {
              return false;
            }
            if (v.tag === "Nil") {
              return v1.tag === "Nil" && v2;
            }
            return v.tag === "Cons" && v1.tag === "Cons" && go(v._2)(v1._2)(v2 && eqPattern.eq(v1._1)(v._1));
          };
          return go(x2._2)(y2._2)(true);
        })();
      }
      if (x2.tag === "PRecord") {
        return y2.tag === "PRecord" && (() => {
          const go = (v) => (v1) => (v2) => {
            if (!v2) {
              return false;
            }
            if (v.tag === "Nil") {
              return v1.tag === "Nil" && v2;
            }
            return v.tag === "Cons" && v1.tag === "Cons" && go(v._2)(v1._2)(v2 && v1._1._1 === v._1._1 && eqPattern.eq(v1._1._2)(v._1._2));
          };
          return go(x2._1)(y2._1)(true);
        })();
      }
      if (x2.tag === "PListEmpty") {
        return y2.tag === "PListEmpty";
      }
      return x2.tag === "PListNonEmpty" && y2.tag === "PListNonEmpty" && eqPattern.eq(x2._1)(y2._1) && eqListRestPattern.eq(x2._2)(y2._2);
    }
  };
  var eqListRestPattern = {
    eq: (x2) => (y2) => {
      if (x2.tag === "PListVar") {
        return y2.tag === "PListVar" && x2._1 === y2._1;
      }
      if (x2.tag === "PListEnd") {
        return y2.tag === "PListEnd";
      }
      return x2.tag === "PListNext" && y2.tag === "PListNext" && eqPattern.eq(x2._1)(y2._1) && eqListRestPattern.eq(x2._2)(y2._2);
    }
  };
  var eqList = {
    eq: (xs) => (ys) => {
      const go = (v) => (v1) => (v2) => {
        if (!v2) {
          return false;
        }
        if (v.tag === "Nil") {
          return v1.tag === "Nil" && v2;
        }
        return v.tag === "Cons" && v1.tag === "Cons" && go(v._2)(v1._2)(v1._1.tag === "Left" ? v2 && v._1.tag === "Left" && eqPattern.eq(v1._1._1)(v._1._1) : v2 && v1._1.tag === "Right" && v._1.tag === "Right" && eqListRestPattern.eq(v1._1._1)(v._1._1));
      };
      return go(xs)(ys)(true);
    }
  };
  var eq8 = (xs) => (ys) => {
    const go = (v) => (v1) => (v2) => {
      if (!v2) {
        return false;
      }
      if (v.tag === "Nil") {
        return v1.tag === "Nil" && v2;
      }
      return v.tag === "Cons" && v1.tag === "Cons" && go(v._2)(v1._2)(v2 && eqPattern.eq(v1._1)(v._1));
    };
    return go(xs)(ys)(true);
  };
  var toClausesStateFwd = (v) => listMap((v1) => $Tuple(
    $List("Cons", $Either("Left", v1._1._1), Nil),
    $Tuple(v1._1._2, v1._2)
  ))($List("Cons", v._1, v._2));
  var toClausesStateBwd = (v) => {
    if (v.tag === "Nil") {
      return throwException(error(throwException(error("Shape mismatch"))()))();
    }
    if (v.tag === "Cons") {
      return $NonEmpty(
        v._1._1.tag === "Cons" && v._1._1._1.tag === "Left" && v._1._1._2.tag === "Nil" ? $Tuple($NonEmpty(v._1._1._1._1, v._1._2._1), v._1._2._2) : throwException(error(throwException(error("Shape mismatch"))()))(),
        listMap((v1) => {
          if (v1._1.tag === "Cons" && v1._1._1.tag === "Left" && v1._1._2.tag === "Nil") {
            return $Tuple($NonEmpty(v1._1._1._1, v1._2._1), v1._2._2);
          }
          return throwException(error(throwException(error("Shape mismatch"))()))();
        })(v._2)
      );
    }
    fail();
  };
  var subpatts = (v) => {
    if (v.tag === "Left") {
      if (v._1.tag === "PVar") {
        return Nil;
      }
      if (v._1.tag === "PConstr") {
        return listMap(Left)(v._1._2);
      }
      if (v._1.tag === "PRecord") {
        return listMap(Left)(listMap(snd)(v._1._1));
      }
      if (v._1.tag === "PListEmpty") {
        return Nil;
      }
      if (v._1.tag === "PListNonEmpty") {
        return $List("Cons", $Either("Left", v._1._1), $List("Cons", $Either("Right", v._1._2), Nil));
      }
      fail();
    }
    if (v.tag === "Right") {
      if (v._1.tag === "PListVar") {
        return Nil;
      }
      if (v._1.tag === "PListEnd") {
        return Nil;
      }
      if (v._1.tag === "PListNext") {
        return $List("Cons", $Either("Left", v._1._1), $List("Cons", $Either("Right", v._1._2), Nil));
      }
    }
    fail();
  };
  var showPattern = (v) => {
    if (v.tag === "Left") {
      return showPattern1.show(v._1);
    }
    if (v.tag === "Right") {
      return showListRestPattern.show(v._1);
    }
    fail();
  };
  var popVarFwd = (dictMonadError) => {
    const MonadThrow0 = dictMonadError.MonadThrow0();
    const Monad0 = MonadThrow0.Monad0();
    return (v) => (v1) => {
      if (v1.tag === "Cons") {
        if (v1._1._1.tag === "Cons" && v1._1._1._1.tag === "Left" && v1._1._1._1._1.tag === "PVar") {
          const $0 = v1._1._2._2;
          const $1 = v1._1._1._2;
          const $2 = v1._1._2._1;
          return Monad0.Bind1().Apply0().Functor0().map((v2) => $List("Cons", $Tuple($1, $Tuple($2, $0)), v2))(popVarFwd(dictMonadError)(mustEq(eqString)(showString)(v)(v1._1._1._1._1._1))(v1._2));
        }
        return MonadThrow0.throwError(error(throwException(error("Shape mismatch"))()));
      }
      if (v1.tag === "Nil") {
        return Monad0.Applicative0().pure(Nil);
      }
      return MonadThrow0.throwError(error(throwException(error("Shape mismatch"))()));
    };
  };
  var popVarFwd1 = /* @__PURE__ */ popVarFwd(monadErrorExceptT2);
  var popVarBwd = (v) => (v1) => {
    if (v1.tag === "Cons") {
      return $List(
        "Cons",
        $Tuple($List("Cons", $Either("Left", $Pattern("PVar", v)), v1._1._1), $Tuple(v1._1._2._1, v1._1._2._2)),
        popVarBwd(v)(v1._2)
      );
    }
    if (v1.tag === "Nil") {
      return Nil;
    }
    fail();
  };
  var popRecordFwd = (dictMonadError) => {
    const MonadThrow0 = dictMonadError.MonadThrow0();
    const Monad0 = MonadThrow0.Monad0();
    return (v) => (v1) => {
      if (v1.tag === "Cons") {
        if (v1._1._1.tag === "Cons" && v1._1._1._1.tag === "Left" && v1._1._1._1._1.tag === "PRecord") {
          const $0 = v1._1._2._2;
          const $1 = v1._1._1._1._1._1;
          const $2 = v1._1._1._2;
          const $3 = v1._1._2._1;
          return assertWith("")((() => {
            const go = (v$1) => (v1$1) => (v2) => {
              if (!v2) {
                return false;
              }
              if (v$1.tag === "Nil") {
                return v1$1.tag === "Nil" && v2;
              }
              return v$1.tag === "Cons" && v1$1.tag === "Cons" && go(v$1._2)(v1$1._2)(v2 && v1$1._1 === v$1._1);
            };
            return go(listMap(fst)($1))(v)(true);
          })())(Monad0.Bind1().Apply0().Functor0().map((v2) => $List(
            "Cons",
            $Tuple(
              foldableList.foldr(Cons)($2)(listMap((x2) => $Either("Left", x2._2))($1)),
              $Tuple($3, $0)
            ),
            v2
          ))(popRecordFwd(dictMonadError)(v)(v1._2)));
        }
        return MonadThrow0.throwError(error(throwException(error("Shape mismatch"))()));
      }
      if (v1.tag === "Nil") {
        return Monad0.Applicative0().pure(Nil);
      }
      return MonadThrow0.throwError(error(throwException(error("Shape mismatch"))()));
    };
  };
  var popRecordFwd1 = /* @__PURE__ */ popRecordFwd(monadErrorExceptT2);
  var popRecordBwd = (v) => (v1) => {
    if (v1.tag === "Cons") {
      return $List(
        "Cons",
        $Tuple(
          $List(
            "Cons",
            $Either(
              "Left",
              $Pattern(
                "PRecord",
                zipWith2(Tuple)(v)(listMap((v2) => {
                  if (v2.tag === "Left") {
                    return v2._1;
                  }
                  fail();
                })(take2((() => {
                  const go = (go$a0$copy) => (go$a1$copy) => {
                    let go$a0 = go$a0$copy, go$a1 = go$a1$copy, go$c = true, go$r;
                    while (go$c) {
                      const b = go$a0, v$1 = go$a1;
                      if (v$1.tag === "Nil") {
                        go$c = false;
                        go$r = b;
                        continue;
                      }
                      if (v$1.tag === "Cons") {
                        go$a0 = 1 + b | 0;
                        go$a1 = v$1._2;
                        continue;
                      }
                      fail();
                    }
                    return go$r;
                  };
                  return go(0)(v);
                })())(v1._1._1)))
              )
            ),
            drop2((() => {
              const go = (go$a0$copy) => (go$a1$copy) => {
                let go$a0 = go$a0$copy, go$a1 = go$a1$copy, go$c = true, go$r;
                while (go$c) {
                  const b = go$a0, v$1 = go$a1;
                  if (v$1.tag === "Nil") {
                    go$c = false;
                    go$r = b;
                    continue;
                  }
                  if (v$1.tag === "Cons") {
                    go$a0 = 1 + b | 0;
                    go$a1 = v$1._2;
                    continue;
                  }
                  fail();
                }
                return go$r;
              };
              return go(0)(v);
            })())(v1._1._1)
          ),
          $Tuple(v1._1._2._1, v1._1._2._2)
        ),
        popRecordBwd(v)(v1._2)
      );
    }
    if (v1.tag === "Nil") {
      return Nil;
    }
    fail();
  };
  var popListVarFwd = (dictMonadError) => {
    const MonadThrow0 = dictMonadError.MonadThrow0();
    const Monad0 = MonadThrow0.Monad0();
    return (v) => (v1) => {
      if (v1.tag === "Cons") {
        if (v1._1._1.tag === "Cons" && v1._1._1._1.tag === "Right" && v1._1._1._1._1.tag === "PListVar") {
          const $0 = v1._1._2._2;
          const $1 = v1._1._1._2;
          const $2 = v1._1._2._1;
          return Monad0.Bind1().Apply0().Functor0().map((v2) => $List("Cons", $Tuple($1, $Tuple($2, $0)), v2))(popListVarFwd(dictMonadError)(mustEq(eqString)(showString)(v)(v1._1._1._1._1._1))(v1._2));
        }
        return MonadThrow0.throwError(error(throwException(error("Shape mismatch"))()));
      }
      if (v1.tag === "Nil") {
        return Monad0.Applicative0().pure(Nil);
      }
      return MonadThrow0.throwError(error(throwException(error("Shape mismatch"))()));
    };
  };
  var popListVarFwd1 = /* @__PURE__ */ popListVarFwd(monadErrorExceptT2);
  var popListVarBwd = (v) => (v1) => {
    if (v1.tag === "Cons") {
      return $List(
        "Cons",
        $Tuple($List("Cons", $Either("Left", $Pattern("PVar", v)), v1._1._1), $Tuple(v1._1._2._1, v1._1._2._2)),
        popListVarBwd(v)(v1._2)
      );
    }
    if (v1.tag === "Nil") {
      return Nil;
    }
    fail();
  };
  var popArgFwd = (dictMonadError) => {
    const MonadThrow0 = dictMonadError.MonadThrow0();
    const Monad0 = MonadThrow0.Monad0();
    return (v) => {
      if (v.tag === "Cons") {
        if (v._1._1.tag === "Nil" && v._1._2._1.tag === "Cons") {
          const $0 = v._1._2._1._1;
          const $1 = v._1._2._2;
          const $2 = v._1._2._1._2;
          return Monad0.Bind1().Apply0().Functor0().map((v1) => $List(
            "Cons",
            $Tuple($List("Cons", $Either("Left", $0), Nil), $Tuple($2, $1)),
            v1
          ))(popArgFwd(dictMonadError)(v._2));
        }
        return MonadThrow0.throwError(error(throwException(error("Shape mismatch"))()));
      }
      if (v.tag === "Nil") {
        return Monad0.Applicative0().pure(Nil);
      }
      return MonadThrow0.throwError(error(throwException(error("Shape mismatch"))()));
    };
  };
  var popArgFwd1 = /* @__PURE__ */ popArgFwd(monadErrorExceptT2);
  var popArgBwd = (v) => {
    if (v.tag === "Cons") {
      if (v._1._1.tag === "Cons" && v._1._1._1.tag === "Left" && v._1._1._2.tag === "Nil") {
        return $List(
          "Cons",
          $Tuple(Nil, $Tuple($List("Cons", v._1._1._1._1, v._1._2._1), v._1._2._2)),
          popArgBwd(v._2)
        );
      }
      return throwException(error("absurd"))();
    }
    if (v.tag === "Nil") {
      return Nil;
    }
    return throwException(error("absurd"))();
  };
  var unless = (v) => {
    if (v.tag === "Left") {
      if (v._1.tag === "PVar") {
        return Nil;
      }
      if (v._1.tag === "PRecord") {
        return Nil;
      }
      if (v._1.tag === "PConstr") {
        return listMap((c$p) => $Either(
          "Left",
          $Pattern("PConstr", c$p, replicate(unfoldableList)(defined(arity(monadThrowExceptT2)(c$p)))($Pattern("PVar", "_")))
        ))(difference2(toUnfoldable5(fromFoldable1(mapObjectString.keys(defined(dataTypeForCtr.dataTypeFor(monadThrowExceptT2)(v._1._1))._2))))($List(
          "Cons",
          v._1._1,
          Nil
        )));
      }
      if (v._1.tag === "PListEmpty") {
        return $List(
          "Cons",
          $Either("Left", $Pattern("PConstr", ":", replicate(unfoldableList)(2)($Pattern("PVar", "_")))),
          Nil
        );
      }
      if (v._1.tag === "PListNonEmpty") {
        return $List("Cons", $Either("Left", PListEmpty), Nil);
      }
      fail();
    }
    if (v.tag === "Right") {
      if (v._1.tag === "PListVar") {
        return Nil;
      }
      if (v._1.tag === "PListNext") {
        return $List("Cons", $Either("Right", PListEnd), Nil);
      }
      if (v._1.tag === "PListEnd") {
        return $List(
          "Cons",
          $Either("Right", $ListRestPattern("PListNext", $Pattern("PVar", "_"), $ListRestPattern("PListVar", "_"))),
          Nil
        );
      }
    }
    fail();
  };
  var forConstrFwd = (v) => (v1) => (v2) => {
    if (v2.tag === "Nil") {
      return $List("Cons", $Tuple(v, $List("Cons", v1, Nil)), Nil);
    }
    if (v2.tag === "Cons") {
      if (v === v2._1._1) {
        return $List("Cons", $Tuple(v2._1._1, $List("Cons", v1, v2._1._2)), v2._2);
      }
      return $List("Cons", $Tuple(v2._1._1, v2._1._2), forConstrFwd(v)(v1)(v2._2));
    }
    fail();
  };
  var forConstrBwd = (v) => (v1) => {
    if (v1.tag === "Nil") {
      return Nothing;
    }
    if (v1.tag === "Cons") {
      if (v === v1._1._1) {
        if (v1._1._2.tag === "Nil") {
          return Nothing;
        }
        if (v1._1._2.tag === "Cons") {
          return $Maybe("Just", $Tuple(v1._1._2._1, $List("Cons", $Tuple(v1._1._1, v1._1._2._2), v1._2)));
        }
        fail();
      }
      const $0 = forConstrBwd(v)(v1._2);
      if ($0.tag === "Just") {
        return $Maybe("Just", $Tuple($0._1._1, $List("Cons", $Tuple(v1._1._1, v1._1._2), $0._1._2)));
      }
      return Nothing;
    }
    fail();
  };
  var elimBool = (\u03BA) => (\u03BA$p) => $Elim("ElimConstr", fromFoldable7([$Tuple("True", \u03BA), $Tuple("False", \u03BA$p)]));
  var econs = (\u03B1) => (e) => (e$p) => $Expr("Constr", \u03B1, ":", $List("Cons", e, $List("Cons", e$p, Nil)));
  var ctrFor = (v) => {
    if (v.tag === "Left") {
      if (v._1.tag === "PVar") {
        return Nothing;
      }
      if (v._1.tag === "PConstr") {
        return $Maybe("Just", v._1._1);
      }
      if (v._1.tag === "PRecord") {
        return Nothing;
      }
      if (v._1.tag === "PListEmpty") {
        return $Maybe("Just", "Nil");
      }
      if (v._1.tag === "PListNonEmpty") {
        return $Maybe("Just", ":");
      }
      fail();
    }
    if (v.tag === "Right") {
      if (v._1.tag === "PListVar") {
        return Nothing;
      }
      if (v._1.tag === "PListEnd") {
        return $Maybe("Just", "Nil");
      }
      if (v._1.tag === "PListNext") {
        return $Maybe("Just", ":");
      }
    }
    fail();
  };
  var popConstrBwd = (v) => (v1) => {
    if (v1.tag === "Cons") {
      if (v1._1._1.tag === "Nil") {
        return throwException(error("absurd"))();
      }
      if (v1._1._1.tag === "Cons") {
        const v2 = forConstrBwd(definitely("absurd")(ctrFor(v1._1._1._1)))(v);
        if (v2.tag === "Nothing") {
          return popConstrBwd(v)(v1._2);
        }
        if (v2.tag === "Just") {
          if (eqList.eq(v2._1._1._1)(foldableList.foldr(Cons)(v1._1._1._2)(subpatts(v1._1._1._1))) && eq8(v2._1._1._2._1)(v1._1._2._1)) {
            return $List(
              "Cons",
              $Tuple($List("Cons", v1._1._1._1, v1._1._1._2), $Tuple(v1._1._2._1, v2._1._1._2._2)),
              popConstrBwd(v2._1._2)(v1._2)
            );
          }
          return popConstrBwd(v)(v1._2);
        }
      }
      fail();
    }
    if (v1.tag === "Nil") {
      return Nil;
    }
    fail();
  };
  var popConstrFwd = (dictMonadError) => {
    const Monad0 = dictMonadError.MonadThrow0().Monad0();
    return (v) => (v1) => {
      if (v1.tag === "Cons") {
        if (v1._1._1.tag === "Nil") {
          return throwException(error("absurd"))();
        }
        if (v1._1._1.tag === "Cons") {
          const \u03C0 = subpatts(v1._1._1._1);
          const c = definitely("Failed to distinguish constructor: " + showPattern(v1._1._1._1))(ctrFor(v1._1._1._1));
          return assertWith("")((() => {
            const go = (go$a0$copy) => (go$a1$copy) => {
              let go$a0 = go$a0$copy, go$a1 = go$a1$copy, go$c = true, go$r;
              while (go$c) {
                const b = go$a0, v$1 = go$a1;
                if (v$1.tag === "Nil") {
                  go$c = false;
                  go$r = b;
                  continue;
                }
                if (v$1.tag === "Cons") {
                  go$a0 = 1 + b | 0;
                  go$a1 = v$1._2;
                  continue;
                }
                fail();
              }
              return go$r;
            };
            return go(0)(\u03C0) === defined(arity(monadThrowExceptT2)(c)) && defined(dataTypeForCtr.dataTypeFor(monadThrowExceptT2)(c))._1 === v._1;
          })())(Monad0.Bind1().Apply0().Functor0().map(forConstrFwd(c)($Tuple(
            foldableList.foldr(Cons)(v1._1._1._2)(\u03C0),
            $Tuple(v1._1._2._1, v1._1._2._2)
          )))(popConstrFwd(dictMonadError)(v)(v1._2)));
        }
        fail();
      }
      if (v1.tag === "Nil") {
        return Monad0.Applicative0().pure(Nil);
      }
      fail();
    };
  };
  var popConstrFwd1 = /* @__PURE__ */ popConstrFwd(monadErrorExceptT2);
  var anon = (v) => {
    if (v.tag === "Left") {
      return $Either("Left", $Pattern("PVar", "_"));
    }
    if (v.tag === "Right") {
      return $Either("Right", $ListRestPattern("PListVar", "_"));
    }
    fail();
  };
  var orElseBwd = (dictBoundedJoinSemilattice) => {
    const bot = dictBoundedJoinSemilattice.bot;
    const $0 = dictBoundedJoinSemilattice.JoinSemilattice0();
    return (v) => (ks) => {
      if (v._1.tag === "Nil") {
        if (ks._1._1.tag === "Nil" && ks._2.tag === "Nil") {
          return $Tuple(bot, ks._1._2);
        }
        fail();
      }
      if (v._1.tag === "Cons") {
        const $1 = v._1._2;
        const popIfPresent = (v1) => (v2) => {
          if (v1.tag === "Nil") {
            return $Tuple(bot, v2);
          }
          const v3 = unsnoc3(v2);
          const v4 = unsnoc3(nonEmptyListNonEmptyList.nonEmpty(v1));
          if (!eqList.eq($List("Cons", v4.last, listMap(anon)($1)))(v3.last._1)) {
            return popIfPresent(v4.init)(v2);
          }
          const $22 = popIfPresent(v4.init)(nonEmptyListNonEmptyList.nonEmpty(v3.init));
          return $Tuple(
            $0.join($22._1)((() => {
              if (v3.last._2.tag === "ListEmpty") {
                return v3.last._2._1;
              }
              fail();
            })()),
            $22._2
          );
        };
        const $2 = popIfPresent(unless(v._1._1))(ks);
        const $3 = orElseBwd(dictBoundedJoinSemilattice)($Tuple(foldableList.foldr(Cons)($1)(subpatts(v._1._1)), v._2))($NonEmpty(
          (() => {
            if ($2._2._1._1.tag === "Cons") {
              return $Tuple(foldableList.foldr(Cons)($2._2._1._1._2)(subpatts($2._2._1._1._1)), $2._2._1._2);
            }
            fail();
          })(),
          listMap((v2) => {
            if (v2._1.tag === "Cons") {
              return $Tuple(foldableList.foldr(Cons)(v2._1._2)(subpatts(v2._1._1)), v2._2);
            }
            fail();
          })($2._2._2)
        ));
        return $Tuple($0.join($3._1)($2._1), $3._2);
      }
      fail();
    };
  };
  var orElseFwd = (\u03B1) => (v) => {
    if (v._1.tag === "Nil") {
      return $NonEmpty($Tuple(Nil, v._2), Nil);
    }
    if (v._1.tag === "Cons") {
      const $0 = v._1._2;
      const \u03C0$p = subpatts(v._1._1);
      const $1 = orElseFwd(\u03B1)($Tuple(foldableList.foldr(Cons)($0)(\u03C0$p), v._2));
      const go = (go$a0$copy) => (go$a1$copy) => {
        let go$a0 = go$a0$copy, go$a1 = go$a1$copy, go$c = true, go$r;
        while (go$c) {
          const b = go$a0, v$1 = go$a1;
          if (v$1.tag === "Nil") {
            go$c = false;
            go$r = b;
            continue;
          }
          if (v$1.tag === "Cons") {
            go$a0 = 1 + b | 0;
            go$a1 = v$1._2;
            continue;
          }
          fail();
        }
        return go$r;
      };
      const $2 = go(0)(\u03C0$p);
      const $3 = (v$1) => $Tuple(take2($2)(v$1._1), $Tuple(drop2($2)(v$1._1), v$1._2));
      const $4 = (() => {
        if (v._1._1.tag === "Left") {
          if (v._1._1._1.tag === "PVar") {
            const $42 = v._1._1._1._1;
            return (v1) => $Tuple($List("Cons", $Either("Left", $Pattern("PVar", $42)), v1._2._1), v1._2._2);
          }
          if (v._1._1._1.tag === "PRecord") {
            const $42 = v._1._1._1._1;
            return (v1) => $Tuple(
              $List(
                "Cons",
                $Either(
                  "Left",
                  $Pattern(
                    "PRecord",
                    zipWith2(Tuple)(listMap(fst)($42))(listMap((v2) => {
                      if (v2.tag === "Left") {
                        return v2._1;
                      }
                      fail();
                    })(v1._1))
                  )
                ),
                v1._2._1
              ),
              v1._2._2
            );
          }
          if (v._1._1._1.tag === "PConstr") {
            const $42 = v._1._1._1._1;
            return (v1) => $Tuple(
              $List(
                "Cons",
                $Either(
                  "Left",
                  $Pattern(
                    "PConstr",
                    $42,
                    listMap((v2) => {
                      if (v2.tag === "Left") {
                        return v2._1;
                      }
                      fail();
                    })(v1._1)
                  )
                ),
                v1._2._1
              ),
              v1._2._2
            );
          }
          if (v._1._1._1.tag === "PListEmpty") {
            return (v1) => $Tuple($List("Cons", $Either("Left", PListEmpty), v1._2._1), v1._2._2);
          }
          if (v._1._1._1.tag === "PListNonEmpty") {
            return (v1) => {
              if (v1._1.tag === "Cons" && v1._1._1.tag === "Left" && v1._1._2.tag === "Cons" && v1._1._2._1.tag === "Right" && v1._1._2._2.tag === "Nil") {
                return $Tuple($List("Cons", $Either("Left", $Pattern("PListNonEmpty", v1._1._1._1, v1._1._2._1._1)), v1._2._1), v1._2._2);
              }
              fail();
            };
          }
          fail();
        }
        if (v._1._1.tag === "Right") {
          if (v._1._1._1.tag === "PListVar") {
            const $42 = v._1._1._1._1;
            return (v1) => $Tuple($List("Cons", $Either("Right", $ListRestPattern("PListVar", $42)), v1._2._1), v1._2._2);
          }
          if (v._1._1._1.tag === "PListNext") {
            return (v1) => {
              if (v1._1.tag === "Cons" && v1._1._1.tag === "Left" && v1._1._2.tag === "Cons" && v1._1._2._1.tag === "Right" && v1._1._2._2.tag === "Nil") {
                return $Tuple(
                  $List("Cons", $Either("Right", $ListRestPattern("PListNext", v1._1._1._1, v1._1._2._1._1)), v1._2._1),
                  v1._2._2
                );
              }
              fail();
            };
          }
          if (v._1._1._1.tag === "PListEnd") {
            return (v1) => $Tuple($List("Cons", $Either("Right", PListEnd), v1._2._1), v1._2._2);
          }
        }
        fail();
      })();
      return $NonEmpty(
        $4($3($1._1)),
        foldableList.foldr(Cons)(listMap((p$p) => $Tuple(
          $List("Cons", p$p, listMap(anon)($0)),
          $Expr2("ListEmpty", \u03B1)
        ))(unless(v._1._1)))(listMap($4)(listMap(($5) => $3($5))($1._2)))
      );
    }
    fail();
  };
  var desugarableListRestExpr = {
    desug: (dictMonadError) => (dictBoundedLattice) => {
      const Monad0 = dictMonadError.MonadThrow0().Monad0();
      const Apply0 = Monad0.Bind1().Apply0();
      return (v) => {
        if (v.tag === "End") {
          return Monad0.Applicative0().pure($Expr("Constr", v._1, "Nil", Nil));
        }
        if (v.tag === "Next") {
          return Apply0.apply(Apply0.Functor0().map(econs(v._1))(desugarableExprExpr.desug(dictMonadError)(dictBoundedLattice)(v._2)))(desugarableListRestExpr.desug(dictMonadError)(dictBoundedLattice)(v._3));
        }
        fail();
      };
    },
    desugBwd: (dictBoundedJoinSemilattice) => (v) => (v1) => {
      if (v.tag === "Constr") {
        if (v1.tag === "End") {
          return $ListRest("End", v._1);
        }
        if (v._3.tag === "Cons" && v._3._2.tag === "Cons" && v._3._2._2.tag === "Nil" && v1.tag === "Next") {
          return $ListRest(
            "Next",
            v._1,
            desugarableExprExpr.desugBwd(dictBoundedJoinSemilattice)(v._3._1)(v1._2),
            desugarableListRestExpr.desugBwd(dictBoundedJoinSemilattice)(v._3._2._1)(v1._3)
          );
        }
      }
      return throwException(error("absurd"))();
    },
    Functor0: () => functorListRest,
    Functor1: () => functorExpr
  };
  var desugarableExprExpr = {
    desug: (dictMonadError) => (dictBoundedLattice) => exprFwd(dictBoundedLattice)(dictMonadError)(dictBoundedLattice.BoundedJoinSemilattice0().JoinSemilattice0()),
    desugBwd: (dictBoundedJoinSemilattice) => exprBwd(dictBoundedJoinSemilattice),
    Functor0: () => functorExpr2,
    Functor1: () => functorExpr
  };
  var desugarableClausesElim = {
    desug: (dictMonadError) => (dictBoundedLattice) => {
      const $0 = dictMonadError.MonadThrow0().Monad0().Bind1().Apply0().Functor0();
      return (\u03BC) => $0.map(asElim)(clausesStateFwd(dictBoundedLattice)(dictMonadError)(toClausesStateFwd(\u03BC)));
    },
    desugBwd: (dictBoundedJoinSemilattice) => (\u03C3) => (\u03BC) => toClausesStateBwd(clausesStateBwd(dictBoundedJoinSemilattice)($Cont("ContElim", \u03C3))(toClausesStateFwd(\u03BC))),
    Functor0: () => functorClauses,
    Functor1: () => functorElim
  };
  var varDefsFwd = (dictMonadError) => {
    const Apply0 = dictMonadError.MonadThrow0().Monad0().Bind1().Apply0();
    const $0 = Apply0.Functor0();
    return (dictBoundedLattice) => (v) => {
      if (v._1._2.tag === "Nil") {
        return Apply0.apply($0.map(Let)(varDefFwd(dictMonadError)(dictBoundedLattice)(v._1._1)))(exprFwd(dictBoundedLattice)(dictMonadError)(dictBoundedLattice.BoundedJoinSemilattice0().JoinSemilattice0())(v._2));
      }
      if (v._1._2.tag === "Cons") {
        return Apply0.apply($0.map(Let)(varDefFwd(dictMonadError)(dictBoundedLattice)(v._1._1)))(varDefsFwd(dictMonadError)(dictBoundedLattice)($Tuple(
          $NonEmpty(v._1._2._1, v._1._2._2),
          v._2
        )));
      }
      fail();
    };
  };
  var varDefsBwd = (dictBoundedJoinSemilattice) => (v) => (v1) => {
    if (v.tag === "Let") {
      if (v1._1._2.tag === "Nil") {
        return $Tuple(
          $NonEmpty($VarDef2(v1._1._1._1, exprBwd(dictBoundedJoinSemilattice)(v._1._2)(v1._1._1._2)), Nil),
          exprBwd(dictBoundedJoinSemilattice)(v._2)(v1._2)
        );
      }
      if (v1._1._2.tag === "Cons") {
        const v2 = varDefsBwd(dictBoundedJoinSemilattice)(v._2)($Tuple($NonEmpty(v1._1._2._1, v1._1._2._2), v1._2));
        return $Tuple(
          $NonEmpty($VarDef2(v1._1._1._1, exprBwd(dictBoundedJoinSemilattice)(v._1._2)(v1._1._1._2)), $List("Cons", v2._1._1, v2._1._2)),
          v2._2
        );
      }
    }
    return throwException(error("absurd"))();
  };
  var varDefFwd = (dictMonadError) => {
    const Apply0 = dictMonadError.MonadThrow0().Monad0().Bind1().Apply0();
    return (dictBoundedLattice) => {
      const top3 = dictBoundedLattice.BoundedMeetSemilattice1().top;
      return (v) => Apply0.apply(Apply0.Functor0().map(VarDef)(desugarableClausesElim.desug(dictMonadError)(dictBoundedLattice)($NonEmpty(
        $Tuple($NonEmpty(v._1, Nil), $Expr2("Record", top3, Nil)),
        Nil
      ))))(exprFwd(dictBoundedLattice)(dictMonadError)(dictBoundedLattice.BoundedJoinSemilattice0().JoinSemilattice0())(v._2));
    };
  };
  var recDefsFwd = (dictMonadError) => {
    const Monad0 = dictMonadError.MonadThrow0().Monad0();
    const traverse4 = traversableNonEmptyList.traverse(Monad0.Applicative0());
    return (dictBoundedLattice) => {
      const top3 = dictBoundedLattice.BoundedMeetSemilattice1().top;
      return (xcs) => Monad0.Bind1().Apply0().Functor0().map((() => {
        const $0 = RecDefs(top3);
        return (x2) => $0(fromFoldable14(x2));
      })())(traverse4(recDefFwd(dictMonadError)(dictBoundedLattice))((() => {
        const $0 = wrappedOperation("groupBy")(groupBy2((x2) => (y2) => x2._1 === y2._1))(xcs);
        return $NonEmpty($0._1, listMap(RecDef)($0._2));
      })()));
    };
  };
  var recDefsBwd = (dictBoundedJoinSemilattice) => (v) => (xcs) => {
    const $0 = v._2;
    const go = (v1) => $NonEmpty(
      recDefBwd(dictBoundedJoinSemilattice)($Tuple(v1._1._1._1, $$get(showString)(mapDictString)(v1._1._1._1)($0)))(v1._1),
      (() => {
        if (v1._2.tag === "Nil") {
          return Nil;
        }
        if (v1._2.tag === "Cons") {
          const $1 = go($NonEmpty(v1._2._1, v1._2._2));
          return $List("Cons", $1._1, $1._2);
        }
        fail();
      })()
    );
    return bindNonEmptyList.bind(go(wrappedOperation("groupBy")(groupBy2((x2) => (y2) => x2._1 === y2._1))(xcs)))(identity5);
  };
  var recDefFwd = (dictMonadError) => (dictBoundedLattice) => (xcs) => dictMonadError.MonadThrow0().Monad0().Bind1().Apply0().Functor0().map((v) => $Tuple(xcs._1._1, v))(desugarableClausesElim.desug(dictMonadError)(dictBoundedLattice)($NonEmpty(
    xcs._1._2,
    listMap(snd)(xcs._2)
  )));
  var recDefBwd = (dictBoundedJoinSemilattice) => (v) => (v1) => {
    const $0 = v._1;
    const $1 = toClausesStateBwd(clausesStateBwd(dictBoundedJoinSemilattice)($Cont("ContElim", v._2))(toClausesStateFwd($NonEmpty(
      v1._1._2,
      listMap(snd)(v1._2)
    ))));
    return $NonEmpty($Tuple($0, $1._1), listMap((v2) => $Tuple($0, v2))($1._2));
  };
  var listCompFwd = (dictMonadError) => {
    const Bind1 = dictMonadError.MonadThrow0().Monad0().Bind1();
    const Functor0 = Bind1.Apply0().Functor0();
    return (dictBoundedLattice) => (v) => {
      if (v._2._1.tag === "Nil") {
        return Functor0.map((f) => f($Expr("Constr", v._1, "Nil", Nil)))(Functor0.map(econs(v._1))(exprFwd(dictBoundedLattice)(dictMonadError)(dictBoundedLattice.BoundedJoinSemilattice0().JoinSemilattice0())(v._2._2)));
      }
      if (v._2._1.tag === "Cons") {
        if (v._2._1._1.tag === "ListCompGuard") {
          const $0 = v._2._1._1._1;
          const $1 = v._1;
          return Bind1.bind(listCompFwd(dictMonadError)(dictBoundedLattice)($Tuple($1, $Tuple(v._2._1._2, v._2._2))))((e) => Functor0.map(App2($Expr(
            "Lambda",
            $1,
            $Elim(
              "ElimConstr",
              fromFoldable7([
                $Tuple("True", $Cont("ContExpr", e)),
                $Tuple("False", $Cont("ContExpr", $Expr("Constr", $1, "Nil", Nil)))
              ])
            )
          )))(exprFwd(dictBoundedLattice)(dictMonadError)(dictBoundedLattice.BoundedJoinSemilattice0().JoinSemilattice0())($0)));
        }
        if (v._2._1._1.tag === "ListCompDecl") {
          const $0 = v._2._1._1._1._2;
          const $1 = v._1;
          return Bind1.bind(clausesStateFwd(dictBoundedLattice)(dictMonadError)($List(
            "Cons",
            $Tuple(
              $List("Cons", $Either("Left", v._2._1._1._1._1), Nil),
              $Tuple(Nil, $Expr2("ListComp", $1, v._2._2, v._2._1._2))
            ),
            Nil
          )))((\u03C3) => Functor0.map(App2($Expr("Lambda", $1, \u03C3.tag === "ContElim" ? \u03C3._1 : throwException(error("Eliminator expected"))())))(exprFwd(dictBoundedLattice)(dictMonadError)(dictBoundedLattice.BoundedJoinSemilattice0().JoinSemilattice0())($0)));
        }
        if (v._2._1._1.tag === "ListCompGen") {
          const $0 = v._2._1._1._2;
          const $1 = v._1;
          return Bind1.bind(clausesStateFwd(dictBoundedLattice)(dictMonadError)((() => {
            const $2 = orElseFwd($1)($Tuple(
              $List("Cons", $Either("Left", v._2._1._1._1), Nil),
              $Expr2("ListComp", $1, v._2._2, v._2._1._2)
            ));
            return $List(
              "Cons",
              $Tuple($2._1._1, $Tuple(Nil, $2._1._2)),
              listMap((m) => $Tuple(m._1, $Tuple(Nil, m._2)))($2._2)
            );
          })()))((\u03C3) => Functor0.map(App2($Expr(
            "App",
            $Expr("Var", "concatMap"),
            $Expr("Lambda", $1, \u03C3.tag === "ContElim" ? \u03C3._1 : throwException(error("Eliminator expected"))())
          )))(exprFwd(dictBoundedLattice)(dictMonadError)(dictBoundedLattice.BoundedJoinSemilattice0().JoinSemilattice0())($0)));
        }
      }
      fail();
    };
  };
  var listCompBwd = (dictBoundedJoinSemilattice) => {
    const $0 = dictBoundedJoinSemilattice.JoinSemilattice0();
    const orElseBwd1 = orElseBwd(dictBoundedJoinSemilattice);
    return (v) => (v1) => {
      const $1 = (e, p, qs, s0, s0$p, \u03B1$p, \u03C3) => {
        const $12 = clausesStateBwd(dictBoundedJoinSemilattice)($Cont("ContElim", \u03C3))($List(
          "Cons",
          $Tuple(
            $List("Cons", $Either("Left", p), Nil),
            $Tuple(Nil, $Expr2("ListComp", void 0, s0$p, qs))
          ),
          Nil
        ));
        if ($12.tag === "Cons" && $12._1._1.tag === "Cons" && $12._1._1._1.tag === "Left" && $12._1._1._2.tag === "Nil" && $12._1._2._1.tag === "Nil" && $12._1._2._2.tag === "ListComp" && $12._2.tag === "Nil") {
          return $Tuple(
            $0.join($12._1._2._2._1)(\u03B1$p),
            $Tuple($List("Cons", $Qualifier("ListCompDecl", $VarDef2(p, exprBwd(dictBoundedJoinSemilattice)(e)(s0))), $12._1._2._2._3), $12._1._2._2._2)
          );
        }
        fail();
      };
      if (v.tag === "Constr") {
        if (v._3.tag === "Cons" && v._3._2.tag === "Cons" && v._3._2._1.tag === "Constr" && v._3._2._1._3.tag === "Nil" && v._3._2._2.tag === "Nil" && v1._1.tag === "Nil" && v._2 === ":" && v._3._2._1._2 === "Nil") {
          return $Tuple($0.join(v._3._2._1._1)(v._1), $Tuple(Nil, exprBwd(dictBoundedJoinSemilattice)(v._3._1)(v1._2)));
        }
        return throwException(error("absurd"))();
      }
      if (v.tag === "App" && v1._1.tag === "Cons") {
        if (v._1.tag === "Lambda") {
          if (v._1._2.tag === "ElimConstr" && v1._1._1.tag === "ListCompGuard") {
            const $2 = listCompBwd(dictBoundedJoinSemilattice)((() => {
              const $22 = $$get(showString)(mapDictString)("True")(v._1._2._1);
              if ($22.tag === "ContExpr") {
                return $22._1;
              }
              return throwException(error("Expression expected"))();
            })())($Tuple(v1._1._2, v1._2));
            const $3 = $$get(showString)(mapDictString)("False")(v._1._2._1);
            const $4 = $3.tag === "ContExpr" ? $3._1 : throwException(error("Expression expected"))();
            if ($4.tag === "Constr" && $4._3.tag === "Nil" && $4._2 === "Nil") {
              return $Tuple(
                $0.join($0.join($2._1)(v._1._1))($4._1),
                $Tuple($List("Cons", $Qualifier("ListCompGuard", exprBwd(dictBoundedJoinSemilattice)(v._2)(v1._1._1._1)), $2._2._1), $2._2._2)
              );
            }
            fail();
          }
          if (v1._1._1.tag === "ListCompDecl") {
            return $1(v._2, v1._1._1._1._1, v1._1._2, v1._1._1._1._2, v1._2, v._1._1, v._1._2);
          }
          return throwException(error("absurd"))();
        }
        if (v._1.tag === "App" && v._1._1.tag === "Var" && v._1._1._1 === "concatMap" && v._1._2.tag === "Lambda" && v1._1._1.tag === "ListCompGen") {
          const $2 = orElseBwd1($Tuple(
            $List("Cons", $Either("Left", v1._1._1._1), Nil),
            $Expr2("ListComp", void 0, v1._2, v1._1._2)
          ))((() => {
            const $22 = nonEmptyListNonEmptyList.nonEmpty(clausesStateBwd(dictBoundedJoinSemilattice)($Cont("ContElim", v._1._2._2))((() => {
              const $23 = orElseFwd()($Tuple(
                $List("Cons", $Either("Left", v1._1._1._1), Nil),
                $Expr2("ListComp", void 0, v1._2, v1._1._2)
              ));
              return $List(
                "Cons",
                $Tuple($23._1._1, $Tuple(Nil, $23._1._2)),
                listMap((m) => $Tuple(m._1, $Tuple(Nil, m._2)))($23._2)
              );
            })()));
            return $NonEmpty(
              (() => {
                if ($22._1._2._1.tag === "Nil") {
                  return $Tuple($22._1._1, $22._1._2._2);
                }
                fail();
              })(),
              listMap((v2) => {
                if (v2._2._1.tag === "Nil") {
                  return $Tuple(v2._1, v2._2._2);
                }
                fail();
              })($22._2)
            );
          })());
          if ($2._2.tag === "ListComp") {
            return $Tuple(
              $0.join($0.join($2._2._1)(v._1._2._1))($2._1),
              $Tuple($List("Cons", $Qualifier("ListCompGen", v1._1._1._1, exprBwd(dictBoundedJoinSemilattice)(v._2)(v1._1._1._2)), $2._2._3), $2._2._2)
            );
          }
          fail();
        }
      }
      return throwException(error("absurd"))();
    };
  };
  var exprFwd = (dictBoundedLattice) => {
    const top3 = dictBoundedLattice.BoundedMeetSemilattice1().top;
    return (dictMonadError) => {
      const Monad0 = dictMonadError.MonadThrow0().Monad0();
      const Applicative0 = Monad0.Applicative0();
      const Apply0 = Monad0.Bind1().Apply0();
      const Functor0 = Apply0.Functor0();
      const traverse4 = traversableList.traverse(Applicative0);
      const traverse6 = traversablePair.traverse(Applicative0);
      return (dictJoinSemilattice) => (v) => {
        if (v.tag === "Var") {
          return Applicative0.pure($Expr("Var", v._1));
        }
        if (v.tag === "Op") {
          return Applicative0.pure($Expr("Op", v._1));
        }
        if (v.tag === "Int") {
          return Applicative0.pure($Expr("Int", v._1, v._2));
        }
        if (v.tag === "Float") {
          return Applicative0.pure($Expr("Float", v._1, v._2));
        }
        if (v.tag === "Str") {
          return Applicative0.pure($Expr("Str", v._1, v._2));
        }
        if (v.tag === "Constr") {
          return Functor0.map(Constr(v._1)(v._2))(traverse4(exprFwd(dictBoundedLattice)(dictMonadError)(dictBoundedLattice.BoundedJoinSemilattice0().JoinSemilattice0()))(v._3));
        }
        if (v.tag === "Record") {
          return Functor0.map((() => {
            const $0 = Record(v._1);
            return (x2) => $0(fromFoldable24(x2));
          })())(traverse4(traversableTuple.traverse(Applicative0)(exprFwd(dictBoundedLattice)(dictMonadError)(dictBoundedLattice.BoundedJoinSemilattice0().JoinSemilattice0())))(v._2));
        }
        if (v.tag === "Dictionary") {
          return Functor0.map(Dictionary(v._1))(traverse4(traverse6(exprFwd(dictBoundedLattice)(dictMonadError)(dictBoundedLattice.BoundedJoinSemilattice0().JoinSemilattice0())))(v._2));
        }
        if (v.tag === "Matrix") {
          return Apply0.apply(Functor0.map((f) => f($Tuple(v._3._1, v._3._2)))(Functor0.map(Matrix(v._1))(exprFwd(dictBoundedLattice)(dictMonadError)(dictBoundedLattice.BoundedJoinSemilattice0().JoinSemilattice0())(v._2))))(exprFwd(dictBoundedLattice)(dictMonadError)(dictBoundedLattice.BoundedJoinSemilattice0().JoinSemilattice0())(v._4));
        }
        if (v.tag === "Lambda") {
          return Functor0.map(Lambda(top3))(desugarableClausesElim.desug(dictMonadError)(dictBoundedLattice)(v._1));
        }
        if (v.tag === "Project") {
          const $0 = v._2;
          return Functor0.map((f) => f($0))(Functor0.map(Project)(exprFwd(dictBoundedLattice)(dictMonadError)(dictBoundedLattice.BoundedJoinSemilattice0().JoinSemilattice0())(v._1)));
        }
        if (v.tag === "App") {
          return Apply0.apply(Functor0.map(App2)(exprFwd(dictBoundedLattice)(dictMonadError)(dictBoundedLattice.BoundedJoinSemilattice0().JoinSemilattice0())(v._1)))(exprFwd(dictBoundedLattice)(dictMonadError)(dictBoundedLattice.BoundedJoinSemilattice0().JoinSemilattice0())(v._2));
        }
        if (v.tag === "BinaryApp") {
          return Apply0.apply(Functor0.map(App2)(Functor0.map(App2($Expr("Op", v._2)))(exprFwd(dictBoundedLattice)(dictMonadError)(dictBoundedLattice.BoundedJoinSemilattice0().JoinSemilattice0())(v._1))))(exprFwd(dictBoundedLattice)(dictMonadError)(dictBoundedLattice.BoundedJoinSemilattice0().JoinSemilattice0())(v._3));
        }
        if (v.tag === "MatchAs") {
          return Apply0.apply(Functor0.map(App2)(Functor0.map(Lambda(top3))(desugarableClausesElim.desug(dictMonadError)(dictBoundedLattice)($NonEmpty(
            $Tuple($NonEmpty(v._2._1._1, Nil), v._2._1._2),
            listMap((x2) => $Tuple($NonEmpty(x2._1, Nil), x2._2))(v._2._2)
          )))))(exprFwd(dictBoundedLattice)(dictMonadError)(dictBoundedLattice.BoundedJoinSemilattice0().JoinSemilattice0())(v._1));
        }
        if (v.tag === "IfElse") {
          return Apply0.apply(Functor0.map(App2)(Functor0.map(Lambda(top3))(Apply0.apply(Functor0.map(elimBool)(Functor0.map(ContExpr)(exprFwd(dictBoundedLattice)(dictMonadError)(dictBoundedLattice.BoundedJoinSemilattice0().JoinSemilattice0())(v._2))))(Functor0.map(ContExpr)(exprFwd(dictBoundedLattice)(dictMonadError)(dictBoundedLattice.BoundedJoinSemilattice0().JoinSemilattice0())(v._3))))))(exprFwd(dictBoundedLattice)(dictMonadError)(dictBoundedLattice.BoundedJoinSemilattice0().JoinSemilattice0())(v._1));
        }
        if (v.tag === "ListEmpty") {
          return Applicative0.pure($Expr("Constr", v._1, "Nil", Nil));
        }
        if (v.tag === "ListNonEmpty") {
          return Apply0.apply(Functor0.map(econs(v._1))(exprFwd(dictBoundedLattice)(dictMonadError)(dictBoundedLattice.BoundedJoinSemilattice0().JoinSemilattice0())(v._2)))(desugarableListRestExpr.desug(dictMonadError)(dictBoundedLattice)(v._3));
        }
        if (v.tag === "ListEnum") {
          return Apply0.apply(Functor0.map(App2)(Functor0.map(App2($Expr("Var", "enumFromTo")))(exprFwd(dictBoundedLattice)(dictMonadError)(dictBoundedLattice.BoundedJoinSemilattice0().JoinSemilattice0())(v._1))))(exprFwd(dictBoundedLattice)(dictMonadError)(dictBoundedLattice.BoundedJoinSemilattice0().JoinSemilattice0())(v._2));
        }
        if (v.tag === "ListComp") {
          return listCompFwd(dictMonadError)(dictBoundedLattice)($Tuple(v._1, $Tuple(v._3, v._2)));
        }
        if (v.tag === "Let") {
          return varDefsFwd(dictMonadError)(dictBoundedLattice)($Tuple(v._1, v._2));
        }
        if (v.tag === "LetRec") {
          return Apply0.apply(Functor0.map(LetRec)(recDefsFwd(dictMonadError)(dictBoundedLattice)(v._1)))(exprFwd(dictBoundedLattice)(dictMonadError)(dictBoundedLattice.BoundedJoinSemilattice0().JoinSemilattice0())(v._2));
        }
        fail();
      };
    };
  };
  var exprBwd = (dictBoundedJoinSemilattice) => {
    const $0 = functorExpr2.map((() => {
      const $02 = dictBoundedJoinSemilattice.bot;
      return (v) => $02;
    })());
    return (v) => (v1) => {
      const $1 = (e, qs, s) => {
        const v2 = listCompBwd(dictBoundedJoinSemilattice)(e)($Tuple(qs, s));
        return $Expr2("ListComp", v2._1, v2._2._2, v2._2._1);
      };
      if (v.tag === "Var") {
        if (v1.tag === "Var") {
          return $Expr2("Var", v1._1);
        }
        if (v1.tag === "ListComp") {
          return $1(v, v1._3, v1._2);
        }
        return throwException(error("absurd"))();
      }
      if (v.tag === "Op") {
        if (v1.tag === "Op") {
          return $Expr2("Op", v1._1);
        }
        if (v1.tag === "ListComp") {
          return $1(v, v1._3, v1._2);
        }
        return throwException(error("absurd"))();
      }
      if (v.tag === "Int") {
        if (v1.tag === "Int") {
          return $Expr2("Int", v._1, v1._2);
        }
        if (v1.tag === "ListComp") {
          return $1(v, v1._3, v1._2);
        }
        return throwException(error("absurd"))();
      }
      if (v.tag === "Float") {
        if (v1.tag === "Float") {
          return $Expr2("Float", v._1, v1._2);
        }
        if (v1.tag === "ListComp") {
          return $1(v, v1._3, v1._2);
        }
        return throwException(error("absurd"))();
      }
      if (v.tag === "Str") {
        if (v1.tag === "Str") {
          return $Expr2("Str", v._1, v1._2);
        }
        if (v1.tag === "ListComp") {
          return $1(v, v1._3, v1._2);
        }
        return throwException(error("absurd"))();
      }
      if (v.tag === "Constr") {
        if (v1.tag === "Constr") {
          return $Expr2(
            "Constr",
            v._1,
            v1._2,
            listMap((() => {
              const $2 = exprBwd(dictBoundedJoinSemilattice);
              return (v$1) => $2(v$1._1)(v$1._2);
            })())(zipWith2(Tuple)(v._3)(v1._3))
          );
        }
        if (v._3.tag === "Nil") {
          if (v1.tag === "ListEmpty") {
            return $Expr2("ListEmpty", v._1);
          }
          if (v1.tag === "ListComp") {
            return $1(v, v1._3, v1._2);
          }
          return throwException(error("absurd"))();
        }
        if (v._3.tag === "Cons" && v._3._2.tag === "Cons" && v._3._2._2.tag === "Nil" && v1.tag === "ListNonEmpty") {
          return $Expr2("ListNonEmpty", v._1, exprBwd(dictBoundedJoinSemilattice)(v._3._1)(v1._2), desugarableListRestExpr.desugBwd(dictBoundedJoinSemilattice)(v._3._2._1)(v1._3));
        }
        if (v1.tag === "ListComp") {
          return $1(v, v1._3, v1._2);
        }
        return throwException(error("absurd"))();
      }
      if (v.tag === "Record") {
        if (v1.tag === "Record") {
          const $2 = v._2;
          return $Expr2(
            "Record",
            v._1,
            mapMaybe2((v2) => {
              const $3 = _lookup(Nothing, Just, v2._1, $2);
              if ($3.tag === "Just") {
                return $Maybe("Just", $Tuple(v2._1, exprBwd(dictBoundedJoinSemilattice)($3._1)(v2._2)));
              }
              return Nothing;
            })(v1._2)
          );
        }
        if (v1.tag === "ListComp") {
          return $1(v, v1._3, v1._2);
        }
        return throwException(error("absurd"))();
      }
      if (v.tag === "Dictionary") {
        if (v1.tag === "Dictionary") {
          return $Expr2(
            "Dictionary",
            v._1,
            zipWith2((v2) => {
              const $2 = v2._1;
              const $3 = v2._2;
              return (v3) => $Pair(exprBwd(dictBoundedJoinSemilattice)($2)(v3._1), exprBwd(dictBoundedJoinSemilattice)($3)(v3._2));
            })(v._2)(v1._2)
          );
        }
        if (v1.tag === "ListComp") {
          return $1(v, v1._3, v1._2);
        }
        return throwException(error("absurd"))();
      }
      if (v.tag === "Matrix") {
        if (v1.tag === "Matrix") {
          return $Expr2("Matrix", v._1, exprBwd(dictBoundedJoinSemilattice)(v._2)(v1._2), $Tuple(v1._3._1, v1._3._2), exprBwd(dictBoundedJoinSemilattice)(v._4)(v1._4));
        }
        if (v1.tag === "ListComp") {
          return $1(v, v1._3, v1._2);
        }
        return throwException(error("absurd"))();
      }
      if (v.tag === "Lambda") {
        if (v1.tag === "Lambda") {
          return $Expr2("Lambda", toClausesStateBwd(clausesStateBwd(dictBoundedJoinSemilattice)($Cont("ContElim", v._2))(toClausesStateFwd(v1._1))));
        }
        if (v1.tag === "ListComp") {
          return $1(v, v1._3, v1._2);
        }
        return throwException(error("absurd"))();
      }
      if (v.tag === "Project") {
        if (v1.tag === "Project") {
          return $Expr2("Project", exprBwd(dictBoundedJoinSemilattice)(v._1)(v1._1), v1._2);
        }
        if (v1.tag === "ListComp") {
          return $1(v, v1._3, v1._2);
        }
        return throwException(error("absurd"))();
      }
      if (v.tag === "App") {
        if (v1.tag === "App") {
          return $Expr2("App", exprBwd(dictBoundedJoinSemilattice)(v._1)(v1._1), exprBwd(dictBoundedJoinSemilattice)(v._2)(v1._2));
        }
        if (v._1.tag === "App") {
          if (v._1._1.tag === "Op") {
            if (v1.tag === "BinaryApp") {
              return $Expr2("BinaryApp", exprBwd(dictBoundedJoinSemilattice)(v._1._2)(v1._1), v1._2, exprBwd(dictBoundedJoinSemilattice)(v._2)(v1._3));
            }
            if (v1.tag === "ListComp") {
              return $1(v, v1._3, v1._2);
            }
            return throwException(error("absurd"))();
          }
          if (v._1._1.tag === "Var" && v._1._1._1 === "enumFromTo" && v1.tag === "ListEnum") {
            return $Expr2("ListEnum", exprBwd(dictBoundedJoinSemilattice)(v._1._2)(v1._1), exprBwd(dictBoundedJoinSemilattice)(v._2)(v1._2));
          }
          if (v1.tag === "ListComp") {
            return $1(v, v1._3, v1._2);
          }
          return throwException(error("absurd"))();
        }
        if (v._1.tag === "Lambda") {
          if (v1.tag === "MatchAs") {
            return $Expr2(
              "MatchAs",
              exprBwd(dictBoundedJoinSemilattice)(v._2)(v1._1),
              (() => {
                const $2 = toClausesStateBwd(clausesStateBwd(dictBoundedJoinSemilattice)($Cont("ContElim", v._1._2))(toClausesStateFwd($NonEmpty(
                  $Tuple($NonEmpty(v1._2._1._1, Nil), v1._2._1._2),
                  listMap((x2) => $Tuple($NonEmpty(x2._1, Nil), x2._2))(v1._2._2)
                ))));
                return $NonEmpty($Tuple($2._1._1._1, $2._1._2), listMap((x2) => $Tuple(x2._1._1, x2._2))($2._2));
              })()
            );
          }
          if (v._1._2.tag === "ElimConstr" && v1.tag === "IfElse") {
            return $Expr2(
              "IfElse",
              exprBwd(dictBoundedJoinSemilattice)(v._2)(v1._1),
              Object.hasOwn(v._1._2._1, "True") ? exprBwd(dictBoundedJoinSemilattice)((() => {
                const $2 = $$get(showString)(mapDictString)("True")(v._1._2._1);
                if ($2.tag === "ContExpr") {
                  return $2._1;
                }
                return throwException(error("Expression expected"))();
              })())(v1._2) : $0(v1._2),
              Object.hasOwn(v._1._2._1, "False") ? exprBwd(dictBoundedJoinSemilattice)((() => {
                const $2 = $$get(showString)(mapDictString)("False")(v._1._2._1);
                if ($2.tag === "ContExpr") {
                  return $2._1;
                }
                return throwException(error("Expression expected"))();
              })())(v1._3) : $0(v1._3)
            );
          }
        }
        if (v1.tag === "ListComp") {
          return $1(v, v1._3, v1._2);
        }
        return throwException(error("absurd"))();
      }
      if (v1.tag === "ListComp") {
        return $1(v, v1._3, v1._2);
      }
      if (v.tag === "Let") {
        if (v1.tag === "Let") {
          const $2 = varDefsBwd(dictBoundedJoinSemilattice)($Expr("Let", v._1, v._2))($Tuple(v1._1, v1._2));
          return $Expr2("Let", $2._1, $2._2);
        }
        return throwException(error("absurd"))();
      }
      if (v.tag === "LetRec" && v1.tag === "LetRec") {
        return $Expr2("LetRec", recDefsBwd(dictBoundedJoinSemilattice)(v._1)(v1._1), exprBwd(dictBoundedJoinSemilattice)(v._2)(v1._2));
      }
      return throwException(error("absurd"))();
    };
  };
  var clausesStateFwd = (dictBoundedLattice) => {
    const top3 = dictBoundedLattice.BoundedMeetSemilattice1().top;
    return (dictMonadError) => {
      const Monad0 = dictMonadError.MonadThrow0().Monad0();
      const Bind1 = Monad0.Bind1();
      const $0 = Bind1.Apply0().Functor0();
      const popArgFwd2 = popArgFwd(dictMonadError);
      const popVarFwd2 = popVarFwd(dictMonadError);
      const popRecordFwd2 = popRecordFwd(dictMonadError);
      const popListVarFwd2 = popListVarFwd(dictMonadError);
      const popConstrFwd2 = popConstrFwd(dictMonadError);
      const Applicative0 = Monad0.Applicative0();
      const sequence1 = traversableList.traverse(Applicative0)(identity10);
      const rtraverse1 = bitraversableTuple.bitraverse(Applicative0)(Applicative0.pure);
      return (ks) => {
        const $1 = (p) => Bind1.bind(popConstrFwd2(defined(dataTypeForCtr.dataTypeFor(monadThrowExceptT2)(definitely("clausesStateFwd ctrFor failed for: " + showPattern(p))(ctrFor(p)))))(ks))((kss) => $0.map((x2) => $Cont(
          "ContElim",
          $Elim("ElimConstr", fromFoldable24(x2))
        ))(sequence1(listMap(rtraverse1(clausesStateFwd(dictBoundedLattice)(dictMonadError)))(kss))));
        if (ks.tag === "Nil") {
          return throwException(error("absurd"))();
        }
        if (ks.tag === "Cons") {
          if (ks._1._1.tag === "Nil") {
            if (ks._1._2._1.tag === "Nil" && ks._2.tag === "Nil") {
              return $0.map(ContExpr)(exprFwd(dictBoundedLattice)(dictMonadError)(dictBoundedLattice.BoundedJoinSemilattice0().JoinSemilattice0())(ks._1._2._2));
            }
            return $0.map((() => {
              const $2 = Lambda(top3);
              return (x2) => $Cont("ContExpr", $2(x2.tag === "ContElim" ? x2._1 : throwException(error("Eliminator expected"))()));
            })())(Bind1.bind(popArgFwd2(ks))(clausesStateFwd(dictBoundedLattice)(dictMonadError)));
          }
          if (ks._1._1.tag === "Cons") {
            if (ks._1._1._1.tag === "Left") {
              if (ks._1._1._1._1.tag === "PVar") {
                const $2 = ks._1._1._1._1._1;
                return $0.map((() => {
                  const $3 = ElimVar($2);
                  return (x2) => $Cont("ContElim", $3(x2));
                })())(Bind1.bind(popVarFwd2($2)(ks))(clausesStateFwd(dictBoundedLattice)(dictMonadError)));
              }
              if (ks._1._1._1._1.tag === "PRecord") {
                const $2 = ks._1._1._1._1._1;
                return $0.map((() => {
                  const $3 = ElimRecord(keys3($2));
                  return (x2) => $Cont("ContElim", $3(x2));
                })())(Bind1.bind(popRecordFwd2(listMap(fst)($2))(ks))(clausesStateFwd(dictBoundedLattice)(dictMonadError)));
              }
              return $1(ks._1._1._1);
            }
            if (ks._1._1._1.tag === "Right" && ks._1._1._1._1.tag === "PListVar") {
              const $2 = ks._1._1._1._1._1;
              return $0.map((() => {
                const $3 = ElimVar($2);
                return (x2) => $Cont("ContElim", $3(x2));
              })())(Bind1.bind(popListVarFwd2($2)(ks))(clausesStateFwd(dictBoundedLattice)(dictMonadError)));
            }
            return $1(ks._1._1._1);
          }
        }
        fail();
      };
    };
  };
  var clausesStateBwd = (dictBoundedJoinSemilattice) => (\u03BA0) => (ks) => {
    const $0 = (\u03C3) => popArgBwd(clausesStateBwd(dictBoundedJoinSemilattice)($Cont("ContElim", \u03C3))(defined(popArgFwd1(ks))));
    const $1 = (m, p) => popConstrBwd(mapMaybe2((v1) => {
      const $12 = clausesStateBwd(dictBoundedJoinSemilattice);
      const $2 = _lookup(Nothing, Just, v1._1, m);
      if ($2.tag === "Just") {
        return $Maybe("Just", $Tuple(v1._1, $12($2._1)(v1._2)));
      }
      return Nothing;
    })(defined(popConstrFwd1(defined(dataTypeForCtr.dataTypeFor(monadThrowExceptT2)(definitely("absurd")(ctrFor(p)))))(ks))))(ks);
    if (ks.tag === "Nil") {
      return throwException(error("absurd"))();
    }
    if (\u03BA0.tag === "ContExpr") {
      if (ks.tag === "Cons" && ks._1._1.tag === "Nil") {
        if (ks._1._2._1.tag === "Nil" && ks._2.tag === "Nil") {
          return $List(
            "Cons",
            $Tuple(Nil, $Tuple(Nil, exprBwd(dictBoundedJoinSemilattice)(\u03BA0._1)(ks._1._2._2))),
            Nil
          );
        }
        if (\u03BA0._1.tag === "Lambda") {
          return $0(\u03BA0._1._2);
        }
      }
      return throwException(error("absurd"))();
    }
    if (\u03BA0.tag === "ContElim") {
      if (ks.tag === "Cons" && ks._1._1.tag === "Cons") {
        if (ks._1._1._1.tag === "Left") {
          if (ks._1._1._1._1.tag === "PVar") {
            if (\u03BA0._1.tag === "ElimVar") {
              return popVarBwd(\u03BA0._1._1)(clausesStateBwd(dictBoundedJoinSemilattice)(\u03BA0._1._2)(defined(popVarFwd1(\u03BA0._1._1)(ks))));
            }
            if (\u03BA0._1.tag === "ElimConstr") {
              return $1(\u03BA0._1._1, ks._1._1._1);
            }
            return throwException(error(throwException(error("Shape mismatch"))()))();
          }
          if (ks._1._1._1._1.tag === "PRecord" && \u03BA0._1.tag === "ElimRecord") {
            const $2 = ks._1._1._1._1._1;
            return popRecordBwd(listMap(fst)($2))(clausesStateBwd(dictBoundedJoinSemilattice)(\u03BA0._1._2)(defined(popRecordFwd1(listMap(fst)($2))(ks))));
          }
          if (\u03BA0._1.tag === "ElimConstr") {
            return $1(\u03BA0._1._1, ks._1._1._1);
          }
          return throwException(error(throwException(error("Shape mismatch"))()))();
        }
        if (ks._1._1._1.tag === "Right" && ks._1._1._1._1.tag === "PListVar" && \u03BA0._1.tag === "ElimVar") {
          return popListVarBwd(\u03BA0._1._1)(clausesStateBwd(dictBoundedJoinSemilattice)(\u03BA0._1._2)(defined(popListVarFwd1(\u03BA0._1._1)(ks))));
        }
        if (\u03BA0._1.tag === "ElimConstr") {
          return $1(\u03BA0._1._1, ks._1._1._1);
        }
      }
      return throwException(error(throwException(error("Shape mismatch"))()))();
    }
    fail();
  };
  var moduleFwd = (dictMonadError) => {
    const Monad0 = dictMonadError.MonadThrow0().Monad0();
    const $0 = Monad0.Bind1().Apply0().Functor0();
    const varDefFwd1 = varDefFwd(dictMonadError);
    const recDefsFwd1 = recDefsFwd(dictMonadError);
    const traverse4 = traversableList.traverse(Monad0.Applicative0());
    return (dictBoundedLattice) => {
      const varDefFwd2 = varDefFwd1(dictBoundedLattice);
      const recDefsFwd2 = recDefsFwd1(dictBoundedLattice);
      return (v) => $0.map(Module)(traverse4((v1) => {
        if (v1.tag === "Left") {
          return $0.map(Left)(varDefFwd2(v1._1));
        }
        if (v1.tag === "Right") {
          return $0.map(Right)(recDefsFwd2(v1._1));
        }
        fail();
      })(bindList.bind(listMap((v1) => {
        if (v1.tag === "Left") {
          return listMap(Left)($List("Cons", v1._1._1, v1._1._2));
        }
        if (v1.tag === "Right") {
          return $List("Cons", $Either("Right", v1._1), Nil);
        }
        fail();
      })(v._1))(identity5)));
    };
  };

  // output-es/Util.Pretty/index.js
  var intercalate3 = (sep) => (xs) => foldlArray((v) => (v1) => {
    if (v.init) {
      return { init: false, acc: v1 };
    }
    return { init: false, acc: v.acc + sep + v1 };
  })({ init: true, acc: "" })(xs).acc;
  var max3 = (x2) => (y2) => {
    const v = ordInt.compare(x2)(y2);
    if (v === "LT") {
      return y2;
    }
    if (v === "EQ") {
      return x2;
    }
    if (v === "GT") {
      return x2;
    }
    fail();
  };
  var empty3 = { width: 0, height: 1, lines: [""] };
  var checkOneLine = (xs) => {
    const v = unconsImpl((v2) => Nothing, (x2) => (xs$1) => $Maybe("Just", { head: x2, tail: xs$1 }), xs);
    if (v.tag === "Just") {
      if (v._1.tail.length === 0) {
        return { width: toCodePointArray(v._1.head).length, height: 1, lines: [v._1.head] };
      }
      return throwException(error("absurd"))();
    }
    if (v.tag === "Nothing") {
      return throwException(error("absurd"))();
    }
    fail();
  };
  var text = (s) => checkOneLine(split("\n")(" " + s));
  var atop = (v) => (v1) => ({ width: max3(v.width)(v1.width), height: v.height + v1.height | 0, lines: [...v.lines, ...v1.lines] });
  var allButLast = (v) => {
    const $0 = v.lines.length - 1 | 0;
    if ($0 < 1) {
      return [];
    }
    return sliceImpl(0, $0, v.lines);
  };
  var indentedExpression = (v) => (v1) => {
    const $0 = last(v.lines);
    return zipWithImpl(
      concatString,
      replicateImpl(
        sliceImpl(1, v1.lines.length, v1.lines).length,
        foldlArray(concatString)("")(replicateImpl(
          toCodePointArray((() => {
            if ($0.tag === "Just") {
              return $0._1;
            }
            if ($0.tag === "Nothing") {
              return "";
            }
            fail();
          })()).length,
          " "
        ))
      ),
      sliceImpl(1, v1.lines.length, v1.lines)
    );
  };
  var beside = (v) => (v1) => ({
    width: v.width + v1.width | 0,
    height: v.height + v1.height | 0,
    lines: [
      ...allButLast(v),
      ...(() => {
        const $0 = last(v.lines);
        return [
          (() => {
            if ($0.tag === "Just") {
              return $0._1 + "";
            }
            if ($0.tag === "Nothing") {
              return "";
            }
            fail();
          })() + (0 < v1.lines.length ? v1.lines[0] : "")
        ];
      })(),
      ...indentedExpression(v)(v1)
    ]
  });
  var semigroupColumns = { append: (v) => (v1) => beside(v)(v1) };
  var monoidColumns = { mempty: empty3, Semigroup0: () => semigroupColumns };

  // output-es/Pretty/index.js
  var $ExprType = (tag) => tag;
  var hcat = /* @__PURE__ */ (() => foldableList.foldMap(monoidColumns)(unsafeCoerce))();
  var hcat1 = /* @__PURE__ */ (() => foldableArray.foldMap(monoidColumns)(unsafeCoerce))();
  var toUnfoldable6 = /* @__PURE__ */ toAscUnfoldable(unfoldableList);
  var toUnfoldable13 = /* @__PURE__ */ (() => {
    const $0 = toUnfoldable2(unfoldableList);
    return (x2) => $0(keys2(x2));
  })();
  var Simple = /* @__PURE__ */ $ExprType("Simple");
  var Expression = /* @__PURE__ */ $ExprType("Expression");
  var vert = (dictFoldable) => {
    const fromFoldable26 = dictFoldable.foldr(Cons)(Nil);
    return (delim) => {
      const vert$p = (v) => {
        if (v.tag === "Nil") {
          return empty3;
        }
        if (v.tag === "Cons") {
          if (v._2.tag === "Nil") {
            return v._1;
          }
          if (v._2.tag === "Cons") {
            return atop(beside(v._1)(delim))(vert$p($List("Cons", v._2._1, v._2._2)));
          }
        }
        fail();
      };
      return (x2) => vert$p(fromFoldable26(x2));
    };
  };
  var vert1 = /* @__PURE__ */ vert(foldableArray);
  var semi = /* @__PURE__ */ checkOneLine(/* @__PURE__ */ split("\n")(" ;"));
  var replacement = [
    /* @__PURE__ */ $Tuple("( ", "("),
    /* @__PURE__ */ $Tuple(" )", ")"),
    /* @__PURE__ */ $Tuple("[ ", "["),
    /* @__PURE__ */ $Tuple(" ]", "]"),
    /* @__PURE__ */ $Tuple("{ ", "{"),
    /* @__PURE__ */ $Tuple(" }", "}"),
    /* @__PURE__ */ $Tuple(". ", "."),
    /* @__PURE__ */ $Tuple(" .", "."),
    /* @__PURE__ */ $Tuple(". ", "."),
    /* @__PURE__ */ $Tuple(" ,", ","),
    /* @__PURE__ */ $Tuple(" ;", ";"),
    /* @__PURE__ */ $Tuple("| ", "|"),
    /* @__PURE__ */ $Tuple(" |", "|"),
    /* @__PURE__ */ $Tuple("\u2E28 ", "\u2E28"),
    /* @__PURE__ */ $Tuple(" \u2E29", "\u2E29")
  ];
  var pattRepPairs = /* @__PURE__ */ arrayMap((v) => $Tuple(v._1, v._2))(replacement);
  var removeDocWS = (v) => ({
    width: v.width,
    height: v.height,
    lines: arrayMap((x2) => foldlArray((curr) => (v$1) => replaceAll(v$1._1)(v$1._2)(curr))(drop(length2(take3(1)(x2)))(x2))(pattRepPairs))(v.lines)
  });
  var prettyP = (dictPretty) => (x2) => intercalate3("\n")(removeDocWS(dictPretty.pretty(x2)).lines);
  var nil = /* @__PURE__ */ checkOneLine(/* @__PURE__ */ split("\n")(" []"));
  var intersperse$p = (v) => (v1) => {
    if (v.tag === "Cons") {
      if (v._2.tag === "Nil") {
        return v._1;
      }
      return atop(beside(v._1)(v1))(intersperse$p(v._2)(v1));
    }
    if (v.tag === "Nil") {
      return empty3;
    }
    fail();
  };
  var helperMatch = (pss) => $NonEmpty(
    $Tuple($NonEmpty(pss._1._1, Nil), pss._1._2),
    listMap((v) => $Tuple($NonEmpty(v._1, Nil), v._2))(pss._2)
  );
  var getPrec = (x2) => {
    const v = lookup2(ordString)(x2)(opDefs);
    if (v.tag === "Just") {
      return v._1.prec;
    }
    if (v.tag === "Nothing") {
      return -1;
    }
    fail();
  };
  var exprType = (v) => {
    if (v.tag === "Var") {
      return Simple;
    }
    if (v.tag === "Op") {
      return Simple;
    }
    if (v.tag === "Int") {
      return Simple;
    }
    if (v.tag === "Float") {
      return Simple;
    }
    if (v.tag === "Str") {
      return Simple;
    }
    if (v.tag === "Constr") {
      if (v._3.tag === "Nil") {
        return Simple;
      }
      return Expression;
    }
    if (v.tag === "Record") {
      return Simple;
    }
    if (v.tag === "Dictionary") {
      return Simple;
    }
    if (v.tag === "Matrix") {
      return Simple;
    }
    if (v.tag === "Lambda") {
      return Simple;
    }
    if (v.tag === "Project") {
      return Simple;
    }
    if (v.tag === "App") {
      return Expression;
    }
    if (v.tag === "BinaryApp") {
      return Expression;
    }
    if (v.tag === "MatchAs") {
      return Simple;
    }
    if (v.tag === "IfElse") {
      return Simple;
    }
    if (v.tag === "ListEmpty") {
      return Simple;
    }
    if (v.tag === "ListNonEmpty") {
      return Simple;
    }
    if (v.tag === "ListEnum") {
      return Simple;
    }
    if (v.tag === "ListComp") {
      return Simple;
    }
    if (v.tag === "Let") {
      return Expression;
    }
    if (v.tag === "LetRec") {
      return Expression;
    }
    fail();
  };
  var comma = /* @__PURE__ */ checkOneLine(/* @__PURE__ */ split("\n")(" ,"));
  var hcomma = (dictFoldable) => {
    const $0 = dictFoldable.foldr(Cons)(Nil);
    return (x2) => hcat(intercalate2($List("Cons", comma, Nil))(listMap(applicativeList.pure)($0(x2))));
  };
  var hcomma1 = /* @__PURE__ */ hcomma(foldableList);
  var hcomma2 = /* @__PURE__ */ hcomma(foldableArray);
  var hcomma3 = /* @__PURE__ */ hcomma(foldableDict);
  var prettyRecordOrDict = (dictPretty) => (sep) => (bracify) => (prettyKey) => (xvs) => bracify(hcomma1(listMap((v) => hcat1([
    beside(v._1)(sep),
    dictPretty.pretty(v._2)
  ]))(listMap((v) => $Tuple(prettyKey(v._1), v._2))(xvs))));
  var between2 = (l) => (r) => (doc2) => beside(beside(l)(doc2))(r);
  var brackets = /* @__PURE__ */ between2(/* @__PURE__ */ checkOneLine(/* @__PURE__ */ split("\n")(" [")))(/* @__PURE__ */ checkOneLine(/* @__PURE__ */ split("\n")(" ]")));
  var curlyBraces = /* @__PURE__ */ between2(/* @__PURE__ */ checkOneLine(/* @__PURE__ */ split("\n")(" {")))(/* @__PURE__ */ checkOneLine(/* @__PURE__ */ split("\n")(" }")));
  var dictBrackets = /* @__PURE__ */ between2(/* @__PURE__ */ checkOneLine(/* @__PURE__ */ split("\n")(" {|")))(/* @__PURE__ */ checkOneLine(/* @__PURE__ */ split("\n")(" |}")));
  var parens = /* @__PURE__ */ between2(/* @__PURE__ */ checkOneLine(/* @__PURE__ */ split("\n")(" (")))(/* @__PURE__ */ checkOneLine(/* @__PURE__ */ split("\n")(" )")));
  var prettyParensOpt = (dictPretty) => (x2) => {
    const doc2 = dictPretty.pretty(x2);
    if (contains2(" ")(intercalate3("\n")(doc2.lines))) {
      return parens(doc2);
    }
    return doc2;
  };
  var prettyConstr = (dictPretty) => (v) => (v1) => {
    const $0 = (c, xs) => hcat($List(
      "Cons",
      checkOneLine(split("\n")(" " + showCtr(c))),
      listMap(prettyParensOpt(dictPretty))(xs)
    ));
    if (v1.tag === "Cons") {
      if (v1._2.tag === "Cons") {
        if (v === "Pair") {
          return assertWith("")(v1._2._2.tag === "Nil")(parens(hcomma2([dictPretty.pretty(v1._1), dictPretty.pretty(v1._2._1)])));
        }
        if (v === "Nil") {
          return assertWith("")(v1.tag === "Nil")(nil);
        }
        if (v === ":") {
          return assertWith("")(v1._2._2.tag === "Nil")(parens(hcat1([
            dictPretty.pretty(v1._1),
            checkOneLine(split("\n")(" :")),
            dictPretty.pretty(v1._2._1)
          ])));
        }
        return $0(v, v1);
      }
      if (v === "Nil") {
        return assertWith("")(v1.tag === "Nil")(nil);
      }
      if (v1._2.tag === "Nil") {
        return beside(checkOneLine(split("\n")(" " + showCtr(v))))(dictPretty.pretty(v1._1));
      }
      return $0(v, v1);
    }
    if (v === "Nil") {
      return assertWith("")(v1.tag === "Nil")(nil);
    }
    return $0(v, v1);
  };
  var parentheses = /* @__PURE__ */ between2(/* @__PURE__ */ checkOneLine(/* @__PURE__ */ split("\n")(" (")))(/* @__PURE__ */ checkOneLine(/* @__PURE__ */ split("\n")(" )")));
  var prettyPattern = {
    pretty: (v) => {
      if (v.tag === "PVar") {
        return checkOneLine(split("\n")(" " + v._1));
      }
      if (v.tag === "PRecord") {
        return curlyBraces(prettyListBindPattern.pretty(v._1));
      }
      if (v.tag === "PConstr") {
        if (v._2.tag === "Nil") {
          return parentheses((() => {
            if (v._1 === "Pair") {
              return prettyPattConstr(checkOneLine(split("\n")(" ,")))(v._2);
            }
            if (v._1 === ":") {
              return prettyPattConstr(checkOneLine(split("\n")(" :")))(v._2);
            }
            return beside(checkOneLine(split("\n")(" " + v._1)))(prettyPattConstr(empty3)(v._2));
          })());
        }
        if (v._2.tag === "Cons") {
          if (v._2._2.tag === "Nil") {
            return beside(checkOneLine(split("\n")(" " + v._1)))(prettyPattern.pretty(v._2._1));
          }
          return parentheses((() => {
            if (v._1 === "Pair") {
              return prettyPattConstr(checkOneLine(split("\n")(" ,")))(v._2);
            }
            if (v._1 === ":") {
              return prettyPattConstr(checkOneLine(split("\n")(" :")))(v._2);
            }
            return beside(checkOneLine(split("\n")(" " + v._1)))(prettyPattConstr(empty3)(v._2));
          })());
        }
        fail();
      }
      if (v.tag === "PListEmpty") {
        return brackets(empty3);
      }
      if (v.tag === "PListNonEmpty") {
        return beside(beside(checkOneLine(split("\n")(" [")))(prettyPattern.pretty(v._1)))(prettyListRestPattern.pretty(v._2));
      }
      fail();
    }
  };
  var prettyListRestPattern = {
    pretty: (v) => {
      if (v.tag === "PListVar") {
        return checkOneLine(split("\n")(" " + v._1));
      }
      if (v.tag === "PListNext") {
        return beside(beside(checkOneLine(split("\n")(" ,")))(prettyPattern.pretty(v._1)))(prettyListRestPattern.pretty(v._2));
      }
      if (v.tag === "PListEnd") {
        return checkOneLine(split("\n")(" ]"));
      }
      fail();
    }
  };
  var prettyListBindPattern = {
    pretty: (v) => {
      if (v.tag === "Cons") {
        if (v._2.tag === "Nil") {
          return beside(beside(checkOneLine(split("\n")(" " + v._1._1)))(checkOneLine(split("\n")(" :"))))(prettyPattern.pretty(v._1._2));
        }
        return atop(beside(beside(beside(checkOneLine(split("\n")(" " + v._1._1)))(checkOneLine(split("\n")(" :"))))(prettyPattern.pretty(v._1._2)))(checkOneLine(split("\n")(" ,"))))(prettyListBindPattern.pretty(v._2));
      }
      if (v.tag === "Nil") {
        return empty3;
      }
      fail();
    }
  };
  var prettyPattConstr = (v) => (v1) => {
    if (v1.tag === "Nil") {
      return empty3;
    }
    if (v1.tag === "Cons") {
      if (v1._2.tag === "Nil") {
        return prettyPattern.pretty(v1._1);
      }
      return beside(beside(prettyPattern.pretty(v1._1))(v))(prettyPattConstr(v)(v1._2));
    }
    fail();
  };
  var prettyDict = (dictPretty) => prettyRecordOrDict(dictPretty)(checkOneLine(split("\n")(" :=")))(between2(checkOneLine(split("\n")(" {|")))(checkOneLine(split("\n")(" |}"))));
  var arrayBrackets = /* @__PURE__ */ between2(/* @__PURE__ */ checkOneLine(/* @__PURE__ */ split("\n")(" [|")))(/* @__PURE__ */ checkOneLine(/* @__PURE__ */ split("\n")(" |]")));
  var prettyExpr = (dictHighlightable) => ({
    pretty: (v) => {
      if (v.tag === "Var") {
        return checkOneLine(split("\n")(" " + v._1));
      }
      if (v.tag === "Int") {
        return dictHighlightable.highlightIf(v._1)(checkOneLine(split("\n")(" " + showIntImpl(v._2))));
      }
      if (v.tag === "Float") {
        return dictHighlightable.highlightIf(v._1)(checkOneLine(split("\n")(" " + showNumberImpl(v._2))));
      }
      if (v.tag === "Str") {
        return dictHighlightable.highlightIf(v._1)(checkOneLine(split("\n")(" " + showStringImpl(v._2))));
      }
      if (v.tag === "Record") {
        return dictHighlightable.highlightIf(v._1)(prettyRecordOrDict(prettyExpr(dictHighlightable))(checkOneLine(split("\n")(" :")))(curlyBraces)(text)(toUnfoldable6(v._2)));
      }
      if (v.tag === "Dictionary") {
        return dictHighlightable.highlightIf(v._1)(prettyDict(prettyExpr(dictHighlightable))(prettyExpr(dictHighlightable).pretty)(listMap(toTuple)(v._2)));
      }
      if (v.tag === "Constr") {
        return dictHighlightable.highlightIf(v._1)(prettyConstr(prettyExpr(dictHighlightable))(v._2)(v._3));
      }
      if (v.tag === "Matrix") {
        return dictHighlightable.highlightIf(v._1)(prettyMatrix(dictHighlightable)(v._2)(v._3._1)(v._3._2)(v._4));
      }
      if (v.tag === "Lambda") {
        return hcat1([dictHighlightable.highlightIf(v._1)(checkOneLine(split("\n")(" fun"))), prettyElim(dictHighlightable).pretty(v._2)]);
      }
      if (v.tag === "Op") {
        return parens(checkOneLine(split("\n")(" " + v._1)));
      }
      if (v.tag === "Let") {
        return atop(hcat1([
          checkOneLine(split("\n")(" let")),
          prettyElim(dictHighlightable).pretty(v._1._1),
          checkOneLine(split("\n")(" =")),
          prettyExpr(dictHighlightable).pretty(v._1._2),
          checkOneLine(split("\n")(" in"))
        ]))(prettyExpr(dictHighlightable).pretty(v._2));
      }
      if (v.tag === "LetRec") {
        return atop(hcat1([
          checkOneLine(split("\n")(" let")),
          prettyDictElim(dictHighlightable).pretty(v._1._2),
          checkOneLine(split("\n")(" in"))
        ]))(prettyExpr(dictHighlightable).pretty(v._2));
      }
      if (v.tag === "Project") {
        return beside(beside(prettyExpr(dictHighlightable).pretty(v._1))(checkOneLine(split("\n")(" ."))))(checkOneLine(split("\n")(" " + v._2)));
      }
      if (v.tag === "App") {
        return hcat1([prettyExpr(dictHighlightable).pretty(v._1), prettyExpr(dictHighlightable).pretty(v._2)]);
      }
      fail();
    }
  });
  var prettyElim = (dictHighlightable) => ({
    pretty: (v) => {
      if (v.tag === "ElimVar") {
        return hcat1([
          checkOneLine(split("\n")(" " + v._1)),
          checkOneLine(split("\n")(" ->")),
          prettyCont(dictHighlightable).pretty(v._2)
        ]);
      }
      if (v.tag === "ElimConstr") {
        return hcomma3(_fmapObject(v._1, prettyCont(dictHighlightable).pretty));
      }
      if (v.tag === "ElimRecord") {
        return hcat1([
          curlyBraces(hcomma1(listMap(text)(toUnfoldable13(v._1)))),
          checkOneLine(split("\n")(" ->")),
          curlyBraces(prettyCont(dictHighlightable).pretty(v._2))
        ]);
      }
      fail();
    }
  });
  var prettyDictElim = (dictHighlightable) => ({
    pretty: (\u03C1) => {
      const go = (v) => {
        if (v.tag === "Nil") {
          return empty3;
        }
        if (v.tag === "Cons") {
          if (v._2.tag === "Nil") {
            return prettyBindElim(dictHighlightable).pretty(v._1);
          }
          return atop(beside(go(v._2))(semi))(prettyBindElim(dictHighlightable).pretty(v._1));
        }
        fail();
      };
      return go(toUnfoldable6(\u03C1));
    }
  });
  var prettyCont = (dictHighlightable) => ({
    pretty: (v) => {
      if (v.tag === "ContExpr") {
        return prettyExpr(dictHighlightable).pretty(v._1);
      }
      if (v.tag === "ContElim") {
        return prettyElim(dictHighlightable).pretty(v._1);
      }
      fail();
    }
  });
  var prettyBindElim = (dictHighlightable) => ({
    pretty: (v) => hcat1([
      checkOneLine(split("\n")(" " + v._1)),
      checkOneLine(split("\n")(" =")),
      prettyElim(dictHighlightable).pretty(v._2)
    ])
  });
  var prettyMatrix = (dictHighlightable) => (e1) => (i) => (j) => (e22) => arrayBrackets(beside(beside(beside(beside(prettyExpr(dictHighlightable).pretty(e1))(checkOneLine(split("\n")(" <-"))))(checkOneLine(split("\n")(" " + i + "\xD7" + j))))(checkOneLine(split("\n")(" in"))))(prettyExpr(dictHighlightable).pretty(e22)));
  var prettyVal = (dictHighlightable) => ({ pretty: (v) => dictHighlightable.highlightIf(v._1)(prettyBaseVal(dictHighlightable).pretty(v._2)) });
  var prettyFun = (dictHighlightable) => ({
    pretty: (v) => {
      if (v.tag === "Closure") {
        return beside(checkOneLine(split("\n")(" cl")))(parentheses(beside(beside(beside(beside(prettyEnv(dictHighlightable).pretty(v._1))(checkOneLine(split("\n")(" ,"))))(prettyDictElim(dictHighlightable).pretty(v._2)))(checkOneLine(split("\n")(" ,"))))(prettyElim(dictHighlightable).pretty(v._3))));
      }
      if (v.tag === "Foreign") {
        return checkOneLine(split("\n")(" " + v._1._1));
      }
      if (v.tag === "PartialConstr") {
        return prettyConstr(prettyVal(dictHighlightable))(v._1)(v._2);
      }
      fail();
    }
  });
  var prettyEnv = (dictHighlightable) => ({
    pretty: (v) => {
      const go = (v1) => {
        if (v1.tag === "Nil") {
          return empty3;
        }
        if (v1.tag === "Cons") {
          return atop(beside(beside(beside(checkOneLine(split("\n")(" " + v1._1._1)))(checkOneLine(split("\n")(" ->"))))(prettyVal(dictHighlightable).pretty(v1._1._2)))(checkOneLine(split("\n")(" ,"))))(go(v1._2));
        }
        fail();
      };
      return brackets(go(toUnfoldable6(v)));
    }
  });
  var prettyBaseVal = (dictHighlightable) => ({
    pretty: (v) => {
      if (v.tag === "Int") {
        return checkOneLine(split("\n")(" " + showIntImpl(v._1)));
      }
      if (v.tag === "Float") {
        return checkOneLine(split("\n")(" " + showNumberImpl(v._1)));
      }
      if (v.tag === "Str") {
        return checkOneLine(split("\n")(" " + showStringImpl(v._1)));
      }
      if (v.tag === "Record") {
        return prettyRecordOrDict(prettyVal(dictHighlightable))(checkOneLine(split("\n")(" :")))(curlyBraces)(text)(toUnfoldable6(v._1));
      }
      if (v.tag === "Dictionary") {
        return prettyDict(prettyVal(dictHighlightable))((v1) => dictHighlightable.highlightIf(v1._2)(checkOneLine(split("\n")(" " + showStringImpl(v1._1)))))(listMap((v1) => $Tuple(
          $Tuple(v1._1, v1._2._1),
          v1._2._2
        ))(toUnfoldable6(v._1)));
      }
      if (v.tag === "Constr") {
        return prettyConstr(prettyVal(dictHighlightable))(v._1)(v._2);
      }
      if (v.tag === "Matrix") {
        return vert1(comma)(arrayMap((() => {
          const $0 = arrayMap(prettyVal(dictHighlightable).pretty);
          return (x2) => hcomma2($0(x2));
        })())(v._1._1));
      }
      if (v.tag === "Fun") {
        return prettyFun(dictHighlightable).pretty(v._1);
      }
      fail();
    }
  });
  var prettyVarDefs = (dictAnn) => ({
    pretty: (ds) => intersperse$p((() => {
      const $0 = prettyVarDef(dictAnn);
      return $List("Cons", $0.pretty(ds._1), listMap($0.pretty)(ds._2));
    })())(checkOneLine(split("\n")(" ;")))
  });
  var prettyVarDef = (dictAnn) => ({
    pretty: (v) => beside(beside(prettyPattern.pretty(v._1))(checkOneLine(split("\n")(" ="))))(prettyExpr1(dictAnn).pretty(v._2))
  });
  var prettyNonEmptyListPattern = (dictAnn) => ({
    pretty: (pss) => intersperse$p(listMap(prettyClause(dictAnn)(checkOneLine(split("\n")(" ->"))))(listMap(Clause)((() => {
      const $0 = helperMatch(pss);
      return $List("Cons", $0._1, $0._2);
    })())))(checkOneLine(split("\n")(" ;")))
  });
  var prettyNonEmptyListNonEmpt = (dictAnn) => ({
    pretty: (hs) => intersperse$p((() => {
      const $0 = prettyNonEmptyListBranch(dictAnn);
      return $List("Cons", $0.pretty(hs._1), listMap($0.pretty)(hs._2));
    })())(checkOneLine(split("\n")(" ;")))
  });
  var prettyNonEmptyListBranch = (dictAnn) => ({
    pretty: (h) => intersperse$p((() => {
      const $0 = prettyBranch(dictAnn);
      return $List("Cons", $0.pretty(h._1), listMap($0.pretty)(h._2));
    })())(checkOneLine(split("\n")(" ;")))
  });
  var prettyListRest = (dictAnn) => {
    const $0 = dictAnn.Highlightable0();
    return {
      pretty: (v) => {
        if (v.tag === "Next") {
          if (v._2.tag === "Record") {
            return atop(beside($0.highlightIf(v._1)(checkOneLine(split("\n")(" ,"))))($0.highlightIf(v._1)(curlyBraces(prettyOperator(dictAnn)(beside)(v._2._2)))))(prettyListRest(dictAnn).pretty(v._3));
          }
          return beside(beside($0.highlightIf(v._1)(checkOneLine(split("\n")(" ,"))))(prettyExpr1(dictAnn).pretty(v._2)))(prettyListRest(dictAnn).pretty(v._3));
        }
        if (v.tag === "End") {
          return $0.highlightIf(v._1)(checkOneLine(split("\n")(" ]")));
        }
        fail();
      }
    };
  };
  var prettyListQualifier = (dictAnn) => ({
    pretty: (v) => {
      const $0 = (q, qs) => beside(beside(prettyListQualifier(dictAnn).pretty($List("Cons", q, Nil)))(checkOneLine(split("\n")(" ,"))))(prettyListQualifier(dictAnn).pretty(qs));
      if (v.tag === "Cons") {
        if (v._2.tag === "Nil") {
          if (v._1.tag === "ListCompGuard") {
            return prettyExpr1(dictAnn).pretty(v._1._1);
          }
          if (v._1.tag === "ListCompDecl") {
            return beside(checkOneLine(split("\n")(" let")))(prettyVarDef(dictAnn).pretty(v._1._1));
          }
          if (v._1.tag === "ListCompGen") {
            return beside(beside(prettyPattern.pretty(v._1._1))(checkOneLine(split("\n")(" <-"))))(prettyExpr1(dictAnn).pretty(v._1._2));
          }
        }
        return $0(v._1, v._2);
      }
      if (v.tag === "Nil") {
        return empty3;
      }
      fail();
    }
  });
  var prettyListPairExpr = (dictAnn) => ({
    pretty: (v) => {
      if (v.tag === "Cons") {
        if (v._2.tag === "Nil") {
          return prettyPairs(dictAnn)($Pair(v._1._1, v._1._2));
        }
        return beside(beside(prettyPairs(dictAnn)($Pair(v._1._1, v._1._2)))(checkOneLine(split("\n")(" ,"))))(prettyListPairExpr(dictAnn).pretty(v._2));
      }
      if (v.tag === "Nil") {
        return empty3;
      }
      fail();
    }
  });
  var prettyFirstGroup = (dictAnn) => ({ pretty: (v) => prettyNonEmptyListNonEmpt(dictAnn).pretty(wrappedOperation("groupBy")(groupBy2((p) => (q) => p._1 === q._1))(v)) });
  var prettyExpr1 = (dictAnn) => {
    const $0 = dictAnn.Highlightable0();
    return {
      pretty: (v) => {
        if (v.tag === "Var") {
          return checkOneLine(split("\n")(" " + v._1));
        }
        if (v.tag === "Op") {
          return parentheses(checkOneLine(split("\n")(" " + v._1)));
        }
        if (v.tag === "Int") {
          return $0.highlightIf(v._1)(checkOneLine(split("\n")(" " + showIntImpl(v._2))));
        }
        if (v.tag === "Float") {
          return $0.highlightIf(v._1)(checkOneLine(split("\n")(" " + showNumberImpl(v._2))));
        }
        if (v.tag === "Str") {
          return $0.highlightIf(v._1)(checkOneLine(split("\n")(' "' + v._2 + '"')));
        }
        if (v.tag === "Constr") {
          return $0.highlightIf(v._1)(prettyConstr(prettyExpr1(dictAnn))(v._2)(v._3));
        }
        if (v.tag === "Record") {
          return $0.highlightIf(v._1)(curlyBraces(prettyOperator(dictAnn)(atop)(v._2)));
        }
        if (v.tag === "Dictionary") {
          return $0.highlightIf(v._1)(dictBrackets(prettyListPairExpr(dictAnn).pretty(v._2)));
        }
        if (v.tag === "Matrix") {
          return $0.highlightIf(v._1)(arrayBrackets(beside(beside(beside(beside(prettyExpr1(dictAnn).pretty(v._2))(checkOneLine(split("\n")(" |"))))(parentheses(beside(beside(checkOneLine(split("\n")(" " + v._3._1)))(checkOneLine(split("\n")(" ,"))))(checkOneLine(split("\n")(" " + v._3._2))))))(checkOneLine(split("\n")(" in"))))(prettyExpr1(dictAnn).pretty(v._4))));
        }
        if (v.tag === "Lambda") {
          return parentheses(beside(checkOneLine(split("\n")(" fun")))(prettyClauses(dictAnn).pretty(v._1)));
        }
        if (v.tag === "Project") {
          return beside(beside(prettySimple(dictAnn)(v._1))(checkOneLine(split("\n")(" ."))))(checkOneLine(split("\n")(" " + v._2)));
        }
        if (v.tag === "App") {
          return prettyAppChain(dictAnn)($Expr2("App", v._1, v._2));
        }
        if (v.tag === "BinaryApp") {
          return prettyBinApp(dictAnn)(0)($Expr2("BinaryApp", v._1, v._2, v._3));
        }
        if (v.tag === "MatchAs") {
          return atop(beside(beside(checkOneLine(split("\n")(" match")))(prettyExpr1(dictAnn).pretty(v._1)))(checkOneLine(split("\n")(" as"))))(curlyBraces(prettyNonEmptyListPattern(dictAnn).pretty(v._2)));
        }
        if (v.tag === "IfElse") {
          return beside(beside(beside(beside(beside(checkOneLine(split("\n")(" if")))(prettyExpr1(dictAnn).pretty(v._1)))(checkOneLine(split("\n")(" then"))))(prettyExpr1(dictAnn).pretty(v._2)))(checkOneLine(split("\n")(" else"))))(prettyExpr1(dictAnn).pretty(v._3));
        }
        if (v.tag === "ListEmpty") {
          return $0.highlightIf(v._1)(brackets(empty3));
        }
        if (v.tag === "ListNonEmpty") {
          if (v._2.tag === "Record") {
            return atop(beside($0.highlightIf(v._1)(checkOneLine(split("\n")(" ["))))($0.highlightIf(v._1)(curlyBraces(prettyOperator(dictAnn)(beside)(v._2._2)))))(prettyListRest(dictAnn).pretty(v._3));
          }
          return beside(beside($0.highlightIf(v._1)(checkOneLine(split("\n")(" ["))))(prettyExpr1(dictAnn).pretty(v._2)))(prettyListRest(dictAnn).pretty(v._3));
        }
        if (v.tag === "ListEnum") {
          return brackets(beside(beside(prettyExpr1(dictAnn).pretty(v._1))(checkOneLine(split("\n")(" .."))))(prettyExpr1(dictAnn).pretty(v._2)));
        }
        if (v.tag === "ListComp") {
          return $0.highlightIf(v._1)(brackets(beside(beside(prettyExpr1(dictAnn).pretty(v._2))(checkOneLine(split("\n")(" |"))))(prettyListQualifier(dictAnn).pretty(v._3))));
        }
        if (v.tag === "Let") {
          return atop(beside(beside(checkOneLine(split("\n")(" let")))(prettyVarDefs(dictAnn).pretty(v._1)))(checkOneLine(split("\n")(" in"))))(prettyExpr1(dictAnn).pretty(v._2));
        }
        if (v.tag === "LetRec") {
          return atop(beside(beside(checkOneLine(split("\n")(" let")))(prettyFirstGroup(dictAnn).pretty(v._1)))(checkOneLine(split("\n")(" in"))))(prettyExpr1(dictAnn).pretty(v._2));
        }
        fail();
      }
    };
  };
  var prettyClauses = (dictAnn) => ({
    pretty: (v) => intersperse$p((() => {
      const $0 = prettyClause(dictAnn)(checkOneLine(split("\n")(" =")));
      return $List("Cons", $0(v._1), listMap($0)(v._2));
    })())(checkOneLine(split("\n")(" ;")))
  });
  var prettyBranch = (dictAnn) => ({
    pretty: (v) => beside(checkOneLine(split("\n")(" " + v._1)))(prettyClause(dictAnn)(checkOneLine(split("\n")(" =")))($Tuple(
      v._2._1,
      v._2._2
    )))
  });
  var prettySimple = (dictAnn) => (s) => {
    const v = exprType(s);
    if (v === "Simple") {
      return prettyExpr1(dictAnn).pretty(s);
    }
    if (v === "Expression") {
      return parentheses(prettyExpr1(dictAnn).pretty(s));
    }
    fail();
  };
  var prettyPairs = (dictAnn) => (v) => beside(beside(prettyExpr1(dictAnn).pretty(v._1))(checkOneLine(split("\n")(" :="))))(prettyExpr1(dictAnn).pretty(v._2));
  var prettyOperator = (dictAnn) => (v) => (v1) => {
    if (v1.tag === "Cons") {
      if (v1._2.tag === "Nil") {
        return beside(beside(checkOneLine(split("\n")(" " + v1._1._1)))(checkOneLine(split("\n")(" :"))))(prettyExpr1(dictAnn).pretty(v1._1._2));
      }
      return v(beside(prettyOperator(dictAnn)(v)($List("Cons", v1._1, Nil)))(checkOneLine(split("\n")(" ,"))))(prettyOperator(dictAnn)(v)(v1._2));
    }
    if (v1.tag === "Nil") {
      return empty3;
    }
    fail();
  };
  var prettyClause = (dictAnn) => (sep) => (v) => beside(beside(prettyPattConstr(empty3)($List("Cons", v._1._1, v._1._2)))(sep))(prettyExpr1(dictAnn).pretty(v._2));
  var prettyBinApp = (dictAnn) => (v) => (v1) => {
    if (v1.tag === "BinaryApp") {
      const prec$p = getPrec(v1._2);
      if (getPrec(v1._2) === -1) {
        return beside(beside(prettyBinApp(dictAnn)(prec$p)(v1._1))(checkOneLine(split("\n")(" `" + v1._2 + "`"))))(prettyBinApp(dictAnn)(prec$p)(v1._3));
      }
      if (prec$p <= v) {
        return parentheses(beside(beside(prettyBinApp(dictAnn)(prec$p)(v1._1))(checkOneLine(split("\n")(" " + v1._2))))(prettyBinApp(dictAnn)(prec$p)(v1._3)));
      }
      return beside(beside(prettyBinApp(dictAnn)(prec$p)(v1._1))(checkOneLine(split("\n")(" " + v1._2))))(prettyBinApp(dictAnn)(prec$p)(v1._3));
    }
    return prettyAppChain(dictAnn)(v1);
  };
  var prettyAppChain = (dictAnn) => (v) => {
    if (v.tag === "App") {
      return beside(prettyAppChain(dictAnn)(v._1))(prettySimple(dictAnn)(v._2));
    }
    return prettySimple(dictAnn)(v);
  };

  // output-es/Val/index.js
  var $BaseVal = (tag, _1, _2) => ({ tag, _1, _2 });
  var $EnvExpr = (_1, _2) => ({ tag: "EnvExpr", _1, _2 });
  var $ForeignOp$p = (_1) => ({ tag: "ForeignOp'", _1 });
  var $Fun = (tag, _1, _2, _3) => ({ tag, _1, _2, _3 });
  var $Val = (_1, _2) => ({ tag: "Val", _1, _2 });
  var identity24 = (x2) => x2;
  var boundedLattice = { BoundedJoinSemilattice0: () => boundedJoinSemilatticeUni, BoundedMeetSemilattice1: () => boundedMeetSemilatticeUni };
  var show2 = /* @__PURE__ */ (() => showSet(showString).show)();
  var fromFoldable8 = /* @__PURE__ */ (() => foldableSet.foldl((m) => (a) => insert3(ordString)(a)()(m))(Leaf))();
  var setSet3 = /* @__PURE__ */ setSet(ordString);
  var toUnfoldable14 = /* @__PURE__ */ (() => {
    const $0 = toUnfoldable2(unfoldableList);
    return (x2) => $0(keys2(x2));
  })();
  var Val = (value0) => (value1) => $Val(value0, value1);
  var Int2 = (value0) => $BaseVal("Int", value0);
  var Float2 = (value0) => $BaseVal("Float", value0);
  var Str2 = (value0) => $BaseVal("Str", value0);
  var Dictionary3 = (value0) => $BaseVal("Dictionary", value0);
  var DictRep = (x2) => x2;
  var MatrixRep = (x2) => x2;
  var Env = (x2) => x2;
  var isEmptyEnv = { isEmpty: (v) => isEmpty(v) };
  var setEnvString = {
    empty: empty2,
    filter: (p) => (v) => filterWithKey((x2) => {
      const $0 = p(x2);
      return (v$1) => $0;
    })(v),
    size: (v) => size(v),
    member: (x2) => (v) => Object.hasOwn(v, x2),
    difference: (v) => (v1) => setObjectString.difference(v)(v1),
    union: (v) => (v1) => union(v)(v1),
    IsEmpty0: () => isEmptyEnv
  };
  var mapEnvStringVal = {
    maplet: (k) => (v) => {
      const $0 = {};
      $0[k] = v;
      return $0;
    },
    keys: (v) => mapObjectString.keys(v),
    values: (v) => mapObjectString.values(v),
    filterKeys: (p) => (v) => filterWithKey((x2) => {
      const $0 = p(x2);
      return (v$1) => $0;
    })(v),
    unionWith: (f) => (v) => (v1) => unionWith(f)(v)(v1),
    lookup: (k) => (v) => _lookup(Nothing, Just, k, v),
    delete: (k) => (v) => mutate(($0) => () => {
      delete $0[k];
      return $0;
    })(v),
    insert: (k) => (v) => (v1) => mutate(($0) => () => {
      $0[k] = v;
      return $0;
    })(v1),
    toUnfoldable: (dictUnfoldable) => toAscUnfoldable(dictUnfoldable),
    Set0: () => setEnvString
  };
  var highlightableVertex = {
    highlightIf: (v) => (doc2) => beside(beside(doc2)(checkOneLine(split("\n")(" _"))))(checkOneLine(split("\n")(" \u27E8" + v + "\u27E9")))
  };
  var highlightableUnit = { highlightIf: (v) => identity24 };
  var highlightableBoolean = {
    highlightIf: (v) => {
      if (!v) {
        return identity24;
      }
      if (v) {
        return (doc2) => beside(beside(checkOneLine(split("\n")(" \u2E28")))(doc2))(checkOneLine(split("\n")(" \u2E29")));
      }
      fail();
    }
  };
  var functorVal = { map: (f) => (m) => $Val(f(m._1), functorBaseVal.map(f)(m._2)) };
  var functorMatrixRep = {
    map: (f) => (m) => $Tuple(
      arrayMap(arrayMap(functorVal.map(f)))(m._1),
      $Tuple($Tuple(m._2._1._1, f(m._2._1._2)), $Tuple(m._2._2._1, f(m._2._2._2)))
    )
  };
  var functorFun = {
    map: (f) => (m) => {
      if (m.tag === "Closure") {
        return $Fun("Closure", functorEnv.map(f)(m._1), _fmapObject(m._2, functorElim.map(f)), functorElim.map(f)(m._3));
      }
      if (m.tag === "Foreign") {
        return $Fun("Foreign", m._1, listMap(functorVal.map(f))(m._2));
      }
      if (m.tag === "PartialConstr") {
        return $Fun("PartialConstr", m._1, listMap(functorVal.map(f))(m._2));
      }
      fail();
    }
  };
  var functorEnv = { map: (f) => (m) => _fmapObject(m, functorVal.map(f)) };
  var functorDictRep = { map: (f) => (m) => _fmapObject(m, (v) => $Tuple(f(v._1), $Val(f(v._2._1), functorBaseVal.map(f)(v._2._2)))) };
  var functorBaseVal = {
    map: (f) => (m) => {
      if (m.tag === "Int") {
        return $BaseVal("Int", m._1);
      }
      if (m.tag === "Float") {
        return $BaseVal("Float", m._1);
      }
      if (m.tag === "Str") {
        return $BaseVal("Str", m._1);
      }
      if (m.tag === "Constr") {
        return $BaseVal("Constr", m._1, listMap(functorVal.map(f))(m._2));
      }
      if (m.tag === "Record") {
        return $BaseVal("Record", _fmapObject(m._1, functorVal.map(f)));
      }
      if (m.tag === "Dictionary") {
        return $BaseVal("Dictionary", functorDictRep.map(f)(m._1));
      }
      if (m.tag === "Matrix") {
        return $BaseVal("Matrix", functorMatrixRep.map(f)(m._1));
      }
      if (m.tag === "Fun") {
        return $BaseVal("Fun", functorFun.map(f)(m._1));
      }
      fail();
    }
  };
  var botOfUnit$x215Raw$x215 = (dictBoundedJoinSemilattice) => ({
    botOf: (() => {
      const $0 = dictBoundedJoinSemilattice.bot;
      const $1 = functorVal.map((() => {
        const $12 = dictBoundedJoinSemilattice.bot;
        return (v) => $12;
      })());
      return (x2) => $Tuple($0, $1(x2._2));
    })()
  });
  var functorEnvExpr = { map: (f) => (m) => $EnvExpr(_fmapObject(m._1, functorVal.map(f)), functorExpr.map(f)(m._2)) };
  var foldableVal = {
    foldl: (f) => (z) => (m) => foldableBaseVal.foldl(f)(f(z)(m._1))(m._2),
    foldr: (f) => (z) => (m) => f(m._1)(foldableBaseVal.foldr(f)(z)(m._2)),
    foldMap: (dictMonoid) => (f) => (m) => dictMonoid.Semigroup0().append(f(m._1))(foldableBaseVal.foldMap(dictMonoid)(f)(m._2))
  };
  var foldableMatrixRep = {
    foldl: (f) => (acc) => (v) => foldlArray(foldlArray(foldableVal.foldl(f)))(f(f(acc)(v._2._1._2))(v._2._2._2))(v._1),
    foldr: (f) => foldrDefault(foldableMatrixRep)(f),
    foldMap: (dictMonoid) => (f) => foldableMatrixRep.foldl((acc) => (x2) => dictMonoid.Semigroup0().append(acc)(f(x2)))(dictMonoid.mempty)
  };
  var foldableFun = {
    foldl: (f) => (z) => (m) => {
      if (m.tag === "Closure") {
        return foldableElim.foldl(f)(fold((z$1) => (v) => foldableElim.foldl(f)(z$1))(foldableEnv.foldl(f)(z)(m._1))(m._2))(m._3);
      }
      if (m.tag === "Foreign") {
        const go = (go$a0$copy) => (go$a1$copy) => {
          let go$a0 = go$a0$copy, go$a1 = go$a1$copy, go$c = true, go$r;
          while (go$c) {
            const b = go$a0, v = go$a1;
            if (v.tag === "Nil") {
              go$c = false;
              go$r = b;
              continue;
            }
            if (v.tag === "Cons") {
              go$a0 = foldableBaseVal.foldl(f)(f(b)(v._1._1))(v._1._2);
              go$a1 = v._2;
              continue;
            }
            fail();
          }
          return go$r;
        };
        return go(z)(m._2);
      }
      if (m.tag === "PartialConstr") {
        const go = (go$a0$copy) => (go$a1$copy) => {
          let go$a0 = go$a0$copy, go$a1 = go$a1$copy, go$c = true, go$r;
          while (go$c) {
            const b = go$a0, v = go$a1;
            if (v.tag === "Nil") {
              go$c = false;
              go$r = b;
              continue;
            }
            if (v.tag === "Cons") {
              go$a0 = foldableBaseVal.foldl(f)(f(b)(v._1._1))(v._1._2);
              go$a1 = v._2;
              continue;
            }
            fail();
          }
          return go$r;
        };
        return go(z)(m._2);
      }
      fail();
    },
    foldr: (f) => (z) => (m) => {
      if (m.tag === "Closure") {
        return foldableEnv.foldr(f)(foldrArray((b) => (a) => foldableElim.foldr(f)(a)(b))(foldableElim.foldr(f)(z)(m._3))(values(m._2)))(m._1);
      }
      if (m.tag === "Foreign") {
        return foldableList.foldr((b) => (a) => f(b._1)(foldableBaseVal.foldr(f)(a)(b._2)))(z)(m._2);
      }
      if (m.tag === "PartialConstr") {
        return foldableList.foldr((b) => (a) => f(b._1)(foldableBaseVal.foldr(f)(a)(b._2)))(z)(m._2);
      }
      fail();
    },
    foldMap: (dictMonoid) => {
      const $0 = dictMonoid.Semigroup0();
      const foldMap1 = foldMap(dictMonoid);
      const foldMap6 = foldableElim.foldMap(dictMonoid);
      const foldMap7 = foldableList.foldMap(dictMonoid);
      return (f) => (m) => {
        if (m.tag === "Closure") {
          return $0.append(foldableEnv.foldMap(dictMonoid)(f)(m._1))($0.append((() => {
            const $1 = foldMap6(f);
            return foldMap1((v) => $1)(m._2);
          })())(foldMap6(f)(m._3)));
        }
        if (m.tag === "Foreign") {
          return foldMap7(foldableVal.foldMap(dictMonoid)(f))(m._2);
        }
        if (m.tag === "PartialConstr") {
          return foldMap7(foldableVal.foldMap(dictMonoid)(f))(m._2);
        }
        fail();
      };
    }
  };
  var foldableEnv = {
    foldl: (f) => (z) => (m) => fold((z$1) => (v) => foldableVal.foldl(f)(z$1))(z)(m),
    foldr: (f) => (z) => (m) => foldrArray((b) => (a) => f(b._1)(foldableBaseVal.foldr(f)(a)(b._2)))(z)(values(m)),
    foldMap: (dictMonoid) => {
      const foldMap1 = foldMap(dictMonoid);
      return (f) => (m) => foldMap1((v) => foldableVal.foldMap(dictMonoid)(f))(m);
    }
  };
  var foldableDictRep = {
    foldl: (f) => (acc) => (v) => fold((z) => (v$1) => (v1) => foldableBaseVal.foldl(f)(f(f(z)(v1._1))(v1._2._1))(v1._2._2))(acc)(v),
    foldr: (f) => foldrDefault(foldableDictRep)(f),
    foldMap: (dictMonoid) => (f) => foldableDictRep.foldl((acc) => (x2) => dictMonoid.Semigroup0().append(acc)(f(x2)))(dictMonoid.mempty)
  };
  var foldableBaseVal = {
    foldl: (f) => (z) => (m) => {
      if (m.tag === "Int") {
        return z;
      }
      if (m.tag === "Float") {
        return z;
      }
      if (m.tag === "Str") {
        return z;
      }
      if (m.tag === "Constr") {
        const go = (go$a0$copy) => (go$a1$copy) => {
          let go$a0 = go$a0$copy, go$a1 = go$a1$copy, go$c = true, go$r;
          while (go$c) {
            const b = go$a0, v = go$a1;
            if (v.tag === "Nil") {
              go$c = false;
              go$r = b;
              continue;
            }
            if (v.tag === "Cons") {
              go$a0 = foldableBaseVal.foldl(f)(f(b)(v._1._1))(v._1._2);
              go$a1 = v._2;
              continue;
            }
            fail();
          }
          return go$r;
        };
        return go(z)(m._2);
      }
      if (m.tag === "Record") {
        return fold((z$1) => (v) => foldableVal.foldl(f)(z$1))(z)(m._1);
      }
      if (m.tag === "Dictionary") {
        return foldableDictRep.foldl(f)(z)(m._1);
      }
      if (m.tag === "Matrix") {
        return foldableMatrixRep.foldl(f)(z)(m._1);
      }
      if (m.tag === "Fun") {
        return foldableFun.foldl(f)(z)(m._1);
      }
      fail();
    },
    foldr: (f) => (z) => (m) => {
      if (m.tag === "Int") {
        return z;
      }
      if (m.tag === "Float") {
        return z;
      }
      if (m.tag === "Str") {
        return z;
      }
      if (m.tag === "Constr") {
        return foldableList.foldr((b) => (a) => f(b._1)(foldableBaseVal.foldr(f)(a)(b._2)))(z)(m._2);
      }
      if (m.tag === "Record") {
        return foldrArray((b) => (a) => f(b._1)(foldableBaseVal.foldr(f)(a)(b._2)))(z)(values(m._1));
      }
      if (m.tag === "Dictionary") {
        return foldrDefault(foldableDictRep)(f)(z)(m._1);
      }
      if (m.tag === "Matrix") {
        return foldrDefault(foldableMatrixRep)(f)(z)(m._1);
      }
      if (m.tag === "Fun") {
        return foldableFun.foldr(f)(z)(m._1);
      }
      fail();
    },
    foldMap: (dictMonoid) => {
      const mempty5 = dictMonoid.mempty;
      const foldMap5 = foldableList.foldMap(dictMonoid);
      const foldMap1 = foldMap(dictMonoid);
      return (f) => (m) => {
        if (m.tag === "Int") {
          return mempty5;
        }
        if (m.tag === "Float") {
          return mempty5;
        }
        if (m.tag === "Str") {
          return mempty5;
        }
        if (m.tag === "Constr") {
          return foldMap5(foldableVal.foldMap(dictMonoid)(f))(m._2);
        }
        if (m.tag === "Record") {
          return foldMap1((v) => foldableVal.foldMap(dictMonoid)(f))(m._1);
        }
        if (m.tag === "Dictionary") {
          return foldableDictRep.foldMap(dictMonoid)(f)(m._1);
        }
        if (m.tag === "Matrix") {
          return foldableMatrixRep.foldMap(dictMonoid)(f)(m._1);
        }
        if (m.tag === "Fun") {
          return foldableFun.foldMap(dictMonoid)(f)(m._1);
        }
        fail();
      };
    }
  };
  var foldableEnvExpr = {
    foldl: (f) => (z) => (m) => foldableExpr.foldl(f)(fold((z$1) => (v) => foldableVal.foldl(f)(z$1))(z)(m._1))(m._2),
    foldr: (f) => (z) => (m) => foldableEnv.foldr(f)(foldableExpr.foldr(f)(z)(m._2))(m._1),
    foldMap: (dictMonoid) => {
      const foldMap5 = foldableEnv.foldMap(dictMonoid);
      const foldMap6 = foldableExpr.foldMap(dictMonoid);
      return (f) => (m) => dictMonoid.Semigroup0().append(foldMap5(f)(m._1))(foldMap6(f)(m._2));
    }
  };
  var traversableVal = {
    traverse: (dictApplicative) => {
      const Apply0 = dictApplicative.Apply0();
      return (f) => (m) => Apply0.apply(Apply0.Functor0().map((v2) => (v3) => $Val(v2, v3))(f(m._1)))(traversableBaseVal.traverse(dictApplicative)(f)(m._2));
    },
    sequence: (dictApplicative) => (v) => traversableVal.traverse(dictApplicative)(identity24)(v),
    Functor0: () => functorVal,
    Foldable1: () => foldableVal
  };
  var traversableMatrixRep = {
    traverse: (dictApplicative) => {
      const bitraverse1 = bitraversableTuple.bitraverse(dictApplicative);
      const traverse7 = traversableArray.traverse(dictApplicative);
      return (f) => (v) => dictApplicative.Apply0().Functor0().map(MatrixRep)(bitraverse1(traverse7(traverse7(traversableVal.traverse(dictApplicative)(f))))(bitraverse1(traversableTuple.traverse(dictApplicative)(f))(traversableTuple.traverse(dictApplicative)(f)))(v));
    },
    sequence: (dictApplicative) => traversableMatrixRep.traverse(dictApplicative)(identity7),
    Functor0: () => functorMatrixRep,
    Foldable1: () => foldableMatrixRep
  };
  var traversableFun = {
    traverse: (dictApplicative) => {
      const Apply0 = dictApplicative.Apply0();
      const $0 = Apply0.Functor0();
      const traverse7 = traversableDict.traverse(dictApplicative);
      const traverse8 = traversableElim.traverse(dictApplicative);
      const traverse9 = traversableList.traverse(dictApplicative);
      return (f) => (m) => {
        if (m.tag === "Closure") {
          return Apply0.apply(Apply0.apply($0.map((v3) => (v4) => (v5) => $Fun("Closure", v3, v4, v5))(traversableEnv.traverse(dictApplicative)(f)(m._1)))(traverse7(traverse8(f))(m._2)))(traverse8(f)(m._3));
        }
        if (m.tag === "Foreign") {
          const $1 = m._1;
          return $0.map((v2) => $Fun("Foreign", $1, v2))(traverse9(traversableVal.traverse(dictApplicative)(f))(m._2));
        }
        if (m.tag === "PartialConstr") {
          const $1 = m._1;
          return $0.map((v2) => $Fun("PartialConstr", $1, v2))(traverse9(traversableVal.traverse(dictApplicative)(f))(m._2));
        }
        fail();
      };
    },
    sequence: (dictApplicative) => (v) => traversableFun.traverse(dictApplicative)(identity24)(v),
    Functor0: () => functorFun,
    Foldable1: () => foldableFun
  };
  var traversableEnv = {
    traverse: (dictApplicative) => {
      const traverse7 = traversableDict.traverse(dictApplicative);
      return (f) => (m) => dictApplicative.Apply0().Functor0().map((v1) => v1)(traverse7(traversableVal.traverse(dictApplicative)(f))(m));
    },
    sequence: (dictApplicative) => (v) => traversableEnv.traverse(dictApplicative)(identity24)(v),
    Functor0: () => functorEnv,
    Foldable1: () => foldableEnv
  };
  var traversableDictRep = {
    traverse: (dictApplicative) => {
      const traverse7 = traversableDict.traverse(dictApplicative);
      const bitraverse1 = bitraversableTuple.bitraverse(dictApplicative);
      return (f) => (v) => dictApplicative.Apply0().Functor0().map(DictRep)(traverse7(bitraverse1(f)(traversableVal.traverse(dictApplicative)(f)))(v));
    },
    sequence: (dictApplicative) => traversableDictRep.traverse(dictApplicative)(identity7),
    Functor0: () => functorDictRep,
    Foldable1: () => foldableDictRep
  };
  var traversableBaseVal = {
    traverse: (dictApplicative) => {
      const $0 = dictApplicative.Apply0().Functor0();
      const traverse7 = traversableList.traverse(dictApplicative);
      const traverse8 = traversableDict.traverse(dictApplicative);
      return (f) => (m) => {
        if (m.tag === "Int") {
          return dictApplicative.pure($BaseVal("Int", m._1));
        }
        if (m.tag === "Float") {
          return dictApplicative.pure($BaseVal("Float", m._1));
        }
        if (m.tag === "Str") {
          return dictApplicative.pure($BaseVal("Str", m._1));
        }
        if (m.tag === "Constr") {
          const $1 = m._1;
          return $0.map((v2) => $BaseVal("Constr", $1, v2))(traverse7(traversableVal.traverse(dictApplicative)(f))(m._2));
        }
        if (m.tag === "Record") {
          return $0.map((v1) => $BaseVal("Record", v1))(traverse8(traversableVal.traverse(dictApplicative)(f))(m._1));
        }
        if (m.tag === "Dictionary") {
          return $0.map((v1) => $BaseVal("Dictionary", v1))(traversableDictRep.traverse(dictApplicative)(f)(m._1));
        }
        if (m.tag === "Matrix") {
          return $0.map((v1) => $BaseVal("Matrix", v1))(traversableMatrixRep.traverse(dictApplicative)(f)(m._1));
        }
        if (m.tag === "Fun") {
          return $0.map((v1) => $BaseVal("Fun", v1))(traversableFun.traverse(dictApplicative)(f)(m._1));
        }
        fail();
      };
    },
    sequence: (dictApplicative) => (v) => traversableBaseVal.traverse(dictApplicative)(identity24)(v),
    Functor0: () => functorBaseVal,
    Foldable1: () => foldableBaseVal
  };
  var expandableValRawVal = (dictBoundedJoinSemilattice) => ({ expand: (v) => (v1) => $Val(v._1, expandableBaseValRawBaseV(dictBoundedJoinSemilattice).expand(v._2)(v1._2)) });
  var expandableMatrixRepRawMat = (dictBoundedJoinSemilattice) => ({
    expand: (v) => (v1) => $Tuple(
      (() => {
        const expand1 = expandableValRawVal(dictBoundedJoinSemilattice).expand;
        return zipWithImpl((xs) => zipWith(expand1)(xs), v._1, v1._1);
      })(),
      $Tuple(
        $Tuple(mustEq(eqInt)(showInt)(v._2._1._1)(v1._2._1._1), v._2._1._2),
        $Tuple(mustEq(eqInt)(showInt)(v._2._2._1)(v1._2._2._1), v._2._2._2)
      )
    )
  });
  var expandableFunRawFun = (dictBoundedJoinSemilattice) => {
    const expandableElimRawElim2 = expandableElimRawElim(dictBoundedJoinSemilattice);
    return {
      expand: (v) => (v1) => {
        if (v.tag === "Closure") {
          if (v1.tag === "Closure") {
            return $Fun(
              "Closure",
              expandableEnvRawEnv(dictBoundedJoinSemilattice).expand(v._1)(v1._1),
              expandableDictDict({
                botOf: functorElim.map((() => {
                  const $0 = dictBoundedJoinSemilattice.bot;
                  return (v$1) => $0;
                })())
              })(expandableElimRawElim2).expand(v._2)(v1._2),
              expandableElimRawElim2.expand(v._3)(v1._3)
            );
          }
          return throwException(error("Shape mismatch"))();
        }
        if (v.tag === "Foreign") {
          if (v1.tag === "Foreign") {
            return $Fun("Foreign", v._1, zipWith2(expandableValRawVal(dictBoundedJoinSemilattice).expand)(v._2)(v1._2));
          }
          return throwException(error("Shape mismatch"))();
        }
        if (v.tag === "PartialConstr" && v1.tag === "PartialConstr") {
          return $Fun(
            "PartialConstr",
            mustEq(eqString)(showString)(v._1)(v1._1),
            zipWith2(expandableValRawVal(dictBoundedJoinSemilattice).expand)(v._2)(v1._2)
          );
        }
        return throwException(error("Shape mismatch"))();
      }
    };
  };
  var expandableEnvRawEnv = (dictBoundedJoinSemilattice) => {
    const expandableDictDict2 = expandableDictDict({
      botOf: functorVal.map((() => {
        const $0 = dictBoundedJoinSemilattice.bot;
        return (v) => $0;
      })())
    });
    return { expand: (v) => (v1) => expandableDictDict2(expandableValRawVal(dictBoundedJoinSemilattice)).expand(v)(v1) };
  };
  var expandableDictRepRawDictR = (dictBoundedJoinSemilattice) => {
    const expandableDictDict2 = expandableDictDict(botOfUnit$x215Raw$x215(dictBoundedJoinSemilattice));
    return {
      expand: (v) => (v1) => expandableDictDict2((() => {
        const $0 = expandableValRawVal(dictBoundedJoinSemilattice);
        return { expand: (v$1) => (v1$1) => $Tuple(v$1._1, $0.expand(v$1._2)(v1$1._2)) };
      })()).expand(v)(v1)
    };
  };
  var expandableBaseValRawBaseV = (dictBoundedJoinSemilattice) => {
    const expandableDictDict2 = expandableDictDict({
      botOf: functorVal.map((() => {
        const $0 = dictBoundedJoinSemilattice.bot;
        return (v) => $0;
      })())
    });
    return {
      expand: (v) => (v1) => {
        if (v.tag === "Int") {
          if (v1.tag === "Int") {
            return $BaseVal("Int", mustEq(eqInt)(showInt)(v._1)(v1._1));
          }
          return throwException(error("Shape mismatch"))();
        }
        if (v.tag === "Float") {
          if (v1.tag === "Float") {
            return $BaseVal("Float", mustEq(eqNumber)(showNumber)(v._1)(v1._1));
          }
          return throwException(error("Shape mismatch"))();
        }
        if (v.tag === "Str") {
          if (v1.tag === "Str") {
            return $BaseVal("Str", mustEq(eqString)(showString)(v._1)(v1._1));
          }
          return throwException(error("Shape mismatch"))();
        }
        if (v.tag === "Record") {
          if (v1.tag === "Record") {
            return $BaseVal("Record", expandableDictDict2(expandableValRawVal(dictBoundedJoinSemilattice)).expand(v._1)(v1._1));
          }
          return throwException(error("Shape mismatch"))();
        }
        if (v.tag === "Dictionary") {
          if (v1.tag === "Dictionary") {
            return $BaseVal("Dictionary", expandableDictRepRawDictR(dictBoundedJoinSemilattice).expand(v._1)(v1._1));
          }
          return throwException(error("Shape mismatch"))();
        }
        if (v.tag === "Constr") {
          if (v1.tag === "Constr") {
            return $BaseVal(
              "Constr",
              mustEq(eqString)(showString)(v._1)(v1._1),
              zipWith2(expandableValRawVal(dictBoundedJoinSemilattice).expand)(v._2)(v1._2)
            );
          }
          return throwException(error("Shape mismatch"))();
        }
        if (v.tag === "Matrix") {
          if (v1.tag === "Matrix") {
            return $BaseVal("Matrix", expandableMatrixRepRawMat(dictBoundedJoinSemilattice).expand(v._1)(v1._1));
          }
          return throwException(error("Shape mismatch"))();
        }
        if (v.tag === "Fun" && v1.tag === "Fun") {
          return $BaseVal("Fun", expandableFunRawFun(dictBoundedJoinSemilattice).expand(v._1)(v1._1));
        }
        return throwException(error("Shape mismatch"))();
      }
    };
  };
  var applyVal = { apply: (v) => (v1) => $Val(v._1(v1._1), applyBaseVal.apply(v._2)(v1._2)), Functor0: () => functorVal };
  var applyMatrixRep = {
    apply: (v) => (v1) => $Tuple(
      zipWithImpl(zipWith(applyVal.apply), v._1, v1._1),
      $Tuple(
        $Tuple(mustEq(eqInt)(showInt)(v._2._1._1)(v1._2._1._1), v._2._1._2(v1._2._1._2)),
        $Tuple(mustEq(eqInt)(showInt)(v._2._2._1)(v1._2._2._1), v._2._2._2(v1._2._2._2))
      )
    ),
    Functor0: () => functorMatrixRep
  };
  var applyFun = {
    apply: (v) => (v1) => {
      if (v.tag === "Closure") {
        if (v1.tag === "Closure") {
          return $Fun(
            "Closure",
            applyEnv.apply(v._1)(v1._1),
            intersectionWith_Object(apply)(_fmapObject(v._2, applyElim.apply))(v1._2),
            applyElim.apply(v._3)(v1._3)
          );
        }
        return throwException(error("Shape mismatch"))();
      }
      if (v.tag === "Foreign") {
        if (v1.tag === "Foreign") {
          return $Fun("Foreign", v._1, zipWith2(applyVal.apply)(v._2)(v1._2));
        }
        return throwException(error("Shape mismatch"))();
      }
      if (v.tag === "PartialConstr" && v1.tag === "PartialConstr") {
        return $Fun("PartialConstr", mustEq(eqString)(showString)(v._1)(v1._1), zipWith2(applyVal.apply)(v._2)(v1._2));
      }
      return throwException(error("Shape mismatch"))();
    },
    Functor0: () => functorFun
  };
  var applyEnv = { apply: (v) => (v1) => intersectionWith_Object(apply)(_fmapObject(v, applyVal.apply))(v1), Functor0: () => functorEnv };
  var applyDictRep = {
    apply: (v) => (v1) => intersectionWith_Object((v2) => {
      const $0 = v2._2;
      return (v3) => $Tuple(v2._1(v3._1), applyVal.apply($0)(v3._2));
    })(v)(v1),
    Functor0: () => functorDictRep
  };
  var applyBaseVal = {
    apply: (v) => (v1) => {
      if (v.tag === "Int") {
        if (v1.tag === "Int") {
          return $BaseVal("Int", mustEq(eqInt)(showInt)(v._1)(v1._1));
        }
        return throwException(error("Shape mismatch"))();
      }
      if (v.tag === "Float") {
        if (v1.tag === "Float") {
          return $BaseVal("Float", mustEq(eqNumber)(showNumber)(v._1)(v1._1));
        }
        return throwException(error("Shape mismatch"))();
      }
      if (v.tag === "Str") {
        if (v1.tag === "Str") {
          return $BaseVal("Str", mustEq(eqString)(showString)(v._1)(v1._1));
        }
        return throwException(error("Shape mismatch"))();
      }
      if (v.tag === "Constr") {
        if (v1.tag === "Constr") {
          return $BaseVal("Constr", mustEq(eqString)(showString)(v._1)(v1._1), zipWith2(applyVal.apply)(v._2)(v1._2));
        }
        return throwException(error("Shape mismatch"))();
      }
      if (v.tag === "Record") {
        if (v1.tag === "Record") {
          return $BaseVal("Record", intersectionWith_Object(apply)(_fmapObject(v._1, applyVal.apply))(v1._1));
        }
        return throwException(error("Shape mismatch"))();
      }
      if (v.tag === "Dictionary") {
        if (v1.tag === "Dictionary") {
          return $BaseVal("Dictionary", applyDictRep.apply(v._1)(v1._1));
        }
        return throwException(error("Shape mismatch"))();
      }
      if (v.tag === "Matrix") {
        if (v1.tag === "Matrix") {
          return $BaseVal("Matrix", applyMatrixRep.apply(v._1)(v1._1));
        }
        return throwException(error("Shape mismatch"))();
      }
      if (v.tag === "Fun" && v1.tag === "Fun") {
        return $BaseVal("Fun", applyFun.apply(v._1)(v1._1));
      }
      return throwException(error("Shape mismatch"))();
    },
    Functor0: () => functorBaseVal
  };
  var applyEnvExpr = {
    apply: (v) => (v1) => $EnvExpr(intersectionWith_Object(apply)(_fmapObject(v._1, applyVal.apply))(v1._1), applyExpr.apply(v._2)(v1._2)),
    Functor0: () => functorEnvExpr
  };
  var joinSemilatticeVal = (dictJoinSemilattice) => ({ join: (v) => (v1) => $Val(dictJoinSemilattice.join(v._1)(v1._1), joinSemilatticeBaseVal(dictJoinSemilattice).join(v._2)(v1._2)) });
  var joinSemilatticeMatrixRep = (dictJoinSemilattice) => ({
    join: (v) => (v1) => $Tuple(
      joinSemilatticeArray(joinSemilatticeArray(joinSemilatticeVal(dictJoinSemilattice))).join(v._1)(v1._1),
      $Tuple(
        $Tuple(mustEq(eqInt)(showInt)(v._2._1._1)(v1._2._1._1), dictJoinSemilattice.join(v._2._1._2)(v1._2._1._2)),
        $Tuple(mustEq(eqInt)(showInt)(v._2._2._1)(v1._2._2._1), dictJoinSemilattice.join(v._2._2._2)(v1._2._2._2))
      )
    )
  });
  var joinSemilatticeFun = (dictJoinSemilattice) => {
    const joinSemilatticeElim2 = joinSemilatticeElim(dictJoinSemilattice);
    return {
      join: (v) => (v1) => {
        if (v.tag === "Closure") {
          if (v1.tag === "Closure") {
            return $Fun(
              "Closure",
              joinSemilatticeEnv(dictJoinSemilattice).join(v._1)(v1._1),
              unionWith(joinSemilatticeElim2.join)(v._2)(v1._2),
              joinSemilatticeElim2.join(v._3)(v1._3)
            );
          }
          return throwException(error("Shape mismatch"))();
        }
        if (v.tag === "Foreign") {
          if (v1.tag === "Foreign") {
            return $Fun("Foreign", v._1, joinSemilatticeList(joinSemilatticeVal(dictJoinSemilattice)).join(v._2)(v1._2));
          }
          return throwException(error("Shape mismatch"))();
        }
        if (v.tag === "PartialConstr" && v1.tag === "PartialConstr") {
          return $Fun(
            "PartialConstr",
            mustEq(eqString)(showString)(v._1)(v1._1),
            joinSemilatticeList(joinSemilatticeVal(dictJoinSemilattice)).join(v._2)(v1._2)
          );
        }
        return throwException(error("Shape mismatch"))();
      }
    };
  };
  var joinSemilatticeEnv = (dictJoinSemilattice) => ({ join: (v) => (v1) => unionWith(joinSemilatticeVal(dictJoinSemilattice).join)(v)(v1) });
  var joinSemilatticeDictRep = (dictJoinSemilattice) => ({
    join: (v) => (v1) => {
      const $0 = joinSemilatticeVal(dictJoinSemilattice);
      return unionWith((v$1) => (v1$1) => $Tuple(dictJoinSemilattice.join(v$1._1)(v1$1._1), $0.join(v$1._2)(v1$1._2)))(v)(v1);
    }
  });
  var joinSemilatticeBaseVal = (dictJoinSemilattice) => {
    const join3 = dictJoinSemilattice.join;
    return {
      join: (v) => (v1) => {
        if (v.tag === "Int") {
          if (v1.tag === "Int") {
            return $BaseVal("Int", mustEq(eqInt)(showInt)(v._1)(v1._1));
          }
          return applyBaseVal.apply(functorBaseVal.map(join3)(v))(v1);
        }
        if (v.tag === "Float") {
          if (v1.tag === "Float") {
            return $BaseVal("Float", mustEq(eqNumber)(showNumber)(v._1)(v1._1));
          }
          return applyBaseVal.apply(functorBaseVal.map(join3)(v))(v1);
        }
        if (v.tag === "Str") {
          if (v1.tag === "Str") {
            return $BaseVal("Str", mustEq(eqString)(showString)(v._1)(v1._1));
          }
          return applyBaseVal.apply(functorBaseVal.map(join3)(v))(v1);
        }
        if (v.tag === "Record") {
          if (v1.tag === "Record") {
            return $BaseVal("Record", unionWith(joinSemilatticeVal(dictJoinSemilattice).join)(v._1)(v1._1));
          }
          return applyBaseVal.apply(functorBaseVal.map(join3)(v))(v1);
        }
        if (v.tag === "Dictionary") {
          if (v1.tag === "Dictionary") {
            return $BaseVal("Dictionary", joinSemilatticeDictRep(dictJoinSemilattice).join(v._1)(v1._1));
          }
          return applyBaseVal.apply(functorBaseVal.map(join3)(v))(v1);
        }
        if (v.tag === "Constr") {
          if (v1.tag === "Constr") {
            return $BaseVal(
              "Constr",
              mustEq(eqString)(showString)(v._1)(v1._1),
              joinSemilatticeList(joinSemilatticeVal(dictJoinSemilattice)).join(v._2)(v1._2)
            );
          }
          return applyBaseVal.apply(functorBaseVal.map(join3)(v))(v1);
        }
        if (v.tag === "Matrix") {
          if (v1.tag === "Matrix") {
            return $BaseVal("Matrix", joinSemilatticeMatrixRep(dictJoinSemilattice).join(v._1)(v1._1));
          }
          return applyBaseVal.apply(functorBaseVal.map(join3)(v))(v1);
        }
        if (v.tag === "Fun" && v1.tag === "Fun") {
          return $BaseVal("Fun", joinSemilatticeFun(dictJoinSemilattice).join(v._1)(v1._1));
        }
        return applyBaseVal.apply(functorBaseVal.map(join3)(v))(v1);
      }
    };
  };
  var annUnit = { Highlightable0: () => highlightableUnit, BoundedLattice1: () => boundedLattice };
  var unrestrictGC = (dictBoundedMeetSemilattice) => (\u03B3) => (xs) => assertWith(show2(xs) + " are in environment ")(unsafeDifference(
    ordString.compare,
    xs,
    mapObjectString.keys(\u03B3)
  ).tag === "Leaf")({
    fwd: (\u03B3$p) => assertWith("")(unsafeDifference(ordString.compare, mapObjectString.keys(\u03B3$p), mapObjectString.keys(\u03B3)).tag === "Leaf")(union(\u03B3$p)(setObjectString.difference((() => {
      const $0 = dictBoundedMeetSemilattice.top;
      return _fmapObject(\u03B3, functorVal.map((v) => $0));
    })())(\u03B3$p))),
    bwd: (\u03B3$p) => assertWith("")(eqMap(eqString)(eqUnit).eq(mapObjectString.keys(\u03B3$p))(mapObjectString.keys(\u03B3)))(filterWithKey((x2) => {
      const $0 = setSet(ordString).member(x2)(xs);
      return (v) => $0;
    })(\u03B3$p))
  });
  var reaches = (\u03C1) => (xs) => {
    const dom_\u03C1 = fromFoldable8(mapObjectString.keys(\u03C1));
    const go = (go$a0$copy) => (go$a1$copy) => {
      let go$a0 = go$a0$copy, go$a1 = go$a1$copy, go$c = true, go$r;
      while (go$c) {
        const v = go$a0, v1 = go$a1;
        if (v.tag === "Nil") {
          go$c = false;
          go$r = v1;
          continue;
        }
        if (v.tag === "Cons") {
          if (setSet3.member(v._1)(v1)) {
            go$a0 = v._2;
            go$a1 = v1;
            continue;
          }
          go$a0 = foldableList.foldr(Cons)(v._2)(toUnfoldable14(unsafeIntersectionWith(
            ordString.compare,
            $$const,
            fVElim.fv($$get(showString)(mapDictString)(v._1)(\u03C1)),
            dom_\u03C1
          )));
          go$a1 = setSet3.union($$$Map("Node", 1, 1, v._1, void 0, Leaf, Leaf))(v1);
          continue;
        }
        fail();
      }
      return go$r;
    };
    return go(toUnfoldable14(xs))(setSet3.empty);
  };
  var matrixPut = (i) => (j) => (\u03B4v) => (v) => {
    const vs_i = unsafeIndex(v._1)(i - 1 | 0);
    return $Tuple(
      definitely("index within bounds")(_updateAt(
        Just,
        Nothing,
        i - 1 | 0,
        definitely("index within bounds")(_updateAt(Just, Nothing, j - 1 | 0, \u03B4v(unsafeIndex(vs_i)(j - 1 | 0)), vs_i)),
        v._1
      )),
      $Tuple(v._2._1, v._2._2)
    );
  };
  var matrixGet = (i) => (j) => (v) => definitely("index out of bounds!")((() => {
    const $0 = i - 1 | 0;
    if ($0 >= 0 && $0 < v._1.length) {
      const $1 = v._1[$0];
      const $2 = j - 1 | 0;
      if ($2 >= 0 && $2 < $1.length) {
        return $Maybe("Just", $1[$2]);
      }
    }
    return Nothing;
  })());
  var forDefs = (\u03C1) => (\u03C3) => {
    const $0 = reaches(\u03C1)(unsafeIntersectionWith(
      ordString.compare,
      $$const,
      fVElim.fv(\u03C3),
      fromFoldable8(mapObjectString.keys(\u03C1))
    ));
    return filterWithKey((x2) => {
      const $1 = setSet(ordString).member(x2)($0);
      return (v) => $1;
    })(\u03C1);
  };

  // output-es/Primitive/index.js
  var fanin2 = /* @__PURE__ */ fanin(categoryFn)(choiceFn);
  var isZeroNumber = { isZero: ($0) => 0 === $0 };
  var isZeroInt = { isZero: ($0) => 0 === $0 };
  var typeError = (v) => (typeName3) => throwException(error(typeName3 + " expected; got " + intercalate3("\n")(removeDocWS(prettyBaseVal(highlightableUnit).pretty(functorBaseVal.map((v$1) => {
  })(v))).lines)))();
  var string2 = {
    pack: Str2,
    unpack: (v) => {
      if (v.tag === "Str") {
        return v._1;
      }
      return typeError(v)("Str");
    }
  };
  var unary = (dictBoundedJoinSemilattice) => {
    const bot = dictBoundedJoinSemilattice.bot;
    return (id3) => (f) => $Tuple(
      id3,
      $Val(
        bot,
        $BaseVal(
          "Fun",
          $Fun(
            "Foreign",
            $Tuple(
              id3,
              $ForeignOp$p({
                arity: 1,
                "op'": (dictMonadWithGraphAlloc) => (dictMonadError) => {
                  const $0 = dictMonadError.MonadThrow0().Monad0().Bind1().Apply0().Functor0();
                  return (v) => {
                    if (v.tag === "Cons" && v._2.tag === "Nil") {
                      const $1 = v._1._2;
                      return $0.map((() => {
                        const $2 = f.o;
                        return (v$1) => $Val(v$1._2, $2.pack(v$1._1));
                      })())($0.map((v2) => $Tuple(f.fwd(f.i.unpack($1)), v2))(dictMonadWithGraphAlloc.new($$$Map(
                        "Node",
                        1,
                        1,
                        v._1._1,
                        void 0,
                        Leaf,
                        Leaf
                      ))));
                    }
                    fail();
                  };
                },
                op: (dictAnn) => (dictMonadError) => (v) => {
                  if (v.tag === "Cons" && v._2.tag === "Nil") {
                    return dictMonadError.MonadThrow0().Monad0().Applicative0().pure($Tuple(
                      functorBaseVal.map((v$1) => {
                      })(v._1._2),
                      $Val(v._1._1, f.o.pack(f.fwd(f.i.unpack(v._1._2))))
                    ));
                  }
                  fail();
                },
                op_bwd: (dictAnn) => (v) => $List("Cons", $Val(v._2._1, f.i.pack(f.i.unpack(v._1))), Nil)
              })
            ),
            Nil
          )
        )
      )
    );
  };
  var number5 = {
    pack: Float2,
    unpack: (v) => {
      if (v.tag === "Float") {
        return v._1;
      }
      return typeError(v)("Float");
    }
  };
  var intOrNumberOrString = {
    pack: (v) => {
      if (v.tag === "Left") {
        return $BaseVal("Int", v._1);
      }
      if (v.tag === "Right") {
        if (v._1.tag === "Left") {
          return $BaseVal("Float", v._1._1);
        }
        if (v._1.tag === "Right") {
          return $BaseVal("Str", v._1._1);
        }
      }
      fail();
    },
    unpack: (v) => {
      if (v.tag === "Int") {
        return $Either("Left", v._1);
      }
      if (v.tag === "Float") {
        return $Either("Right", $Either("Left", v._1));
      }
      if (v.tag === "Str") {
        return $Either("Right", $Either("Right", v._1));
      }
      return typeError(v)("Int, Float or Str");
    }
  };
  var intOrNumber = {
    pack: (v) => {
      if (v.tag === "Left") {
        return $BaseVal("Int", v._1);
      }
      if (v.tag === "Right") {
        return $BaseVal("Float", v._1);
      }
      fail();
    },
    unpack: (v) => {
      if (v.tag === "Int") {
        return $Either("Left", v._1);
      }
      if (v.tag === "Float") {
        return $Either("Right", v._1);
      }
      return typeError(v)("Int or Float");
    }
  };
  var $$int = {
    pack: Int2,
    unpack: (v) => {
      if (v.tag === "Int") {
        return v._1;
      }
      return typeError(v)("Int");
    }
  };
  var intPair = {
    pack: (v) => $BaseVal(
      "Constr",
      "Pair",
      $List(
        "Cons",
        $Val(v._1._2, $BaseVal("Int", v._1._1)),
        $List("Cons", $Val(v._2._2, $BaseVal("Int", v._2._1)), Nil)
      )
    ),
    unpack: (v) => {
      if (v.tag === "Constr" && v._2.tag === "Cons" && v._2._2.tag === "Cons" && v._2._2._2.tag === "Nil" && v._1 === "Pair") {
        return $Tuple(
          $Tuple(v._2._1._2.tag === "Int" ? v._2._1._2._1 : typeError(v._2._1._2)("Int"), v._2._1._1),
          $Tuple(v._2._2._1._2.tag === "Int" ? v._2._2._1._2._1 : typeError(v._2._2._1._2)("Int"), v._2._2._1._1)
        );
      }
      return typeError(v)("Pair");
    }
  };
  var $$boolean = {
    pack: (v) => {
      if (v) {
        return $BaseVal("Constr", "True", Nil);
      }
      return $BaseVal("Constr", "False", Nil);
    },
    unpack: (v) => {
      if (v.tag === "Constr" && v._2.tag === "Nil") {
        if (v._1 === "True") {
          return true;
        }
        if (v._1 === "False") {
          return false;
        }
      }
      return typeError(v)("Boolean");
    }
  };
  var binaryZero = (dictBoundedJoinSemilattice) => {
    const bot = dictBoundedJoinSemilattice.bot;
    return (dictIsZero) => (id3) => (f) => $Tuple(
      id3,
      $Val(
        bot,
        $BaseVal(
          "Fun",
          $Fun(
            "Foreign",
            $Tuple(
              id3,
              $ForeignOp$p({
                arity: 2,
                "op'": (dictMonadWithGraphAlloc) => (dictMonadError) => {
                  const $0 = dictMonadError.MonadThrow0().Monad0().Bind1().Apply0().Functor0();
                  return (v) => {
                    if (v.tag === "Cons" && v._2.tag === "Cons" && v._2._2.tag === "Nil") {
                      const $1 = f.i.unpack(v._1._2);
                      const $2 = f.i.unpack(v._2._1._2);
                      return $0.map((() => {
                        const $3 = f.o;
                        return (v$1) => $Val(v$1._2, $3.pack(v$1._1));
                      })())($0.map((v4) => $Tuple(f.fwd($1)($2), v4))(dictMonadWithGraphAlloc.new((() => {
                        if (dictIsZero.isZero($1)) {
                          return $$$Map("Node", 1, 1, v._1._1, void 0, Leaf, Leaf);
                        }
                        if (dictIsZero.isZero($2)) {
                          return $$$Map("Node", 1, 1, v._2._1._1, void 0, Leaf, Leaf);
                        }
                        return insert3(ordVertex)(v._2._1._1)()($$$Map(
                          "Node",
                          1,
                          1,
                          v._1._1,
                          void 0,
                          Leaf,
                          Leaf
                        ));
                      })())));
                    }
                    fail();
                  };
                },
                op: (dictAnn) => (dictMonadError) => (v) => {
                  if (v.tag === "Cons" && v._2.tag === "Cons" && v._2._2.tag === "Nil") {
                    const $0 = f.i.unpack(v._1._2);
                    const $1 = f.i.unpack(v._2._1._2);
                    return dictMonadError.MonadThrow0().Monad0().Applicative0().pure($Tuple(
                      $Tuple(functorBaseVal.map((v$1) => {
                      })(v._1._2), functorBaseVal.map((v$1) => {
                      })(v._2._1._2)),
                      $Val(
                        (() => {
                          if (dictIsZero.isZero($0)) {
                            return v._1._1;
                          }
                          if (dictIsZero.isZero($1)) {
                            return v._2._1._1;
                          }
                          return dictAnn.BoundedLattice1().BoundedMeetSemilattice1().MeetSemilattice0().meet(v._1._1)(v._2._1._1);
                        })(),
                        f.o.pack(f.fwd($0)($1))
                      )
                    ));
                  }
                  fail();
                },
                op_bwd: (dictAnn) => {
                  const bot1 = dictAnn.BoundedLattice1().BoundedJoinSemilattice0().bot;
                  return (v) => {
                    const $0 = f.i.unpack(v._1._1);
                    const $1 = f.i.unpack(v._1._2);
                    if (dictIsZero.isZero($0)) {
                      return $List("Cons", $Val(v._2._1, f.i.pack($0)), $List("Cons", $Val(bot1, f.i.pack($1)), Nil));
                    }
                    if (dictIsZero.isZero($1)) {
                      return $List("Cons", $Val(bot1, f.i.pack($0)), $List("Cons", $Val(v._2._1, f.i.pack($1)), Nil));
                    }
                    return $List("Cons", $Val(v._2._1, f.i.pack($0)), $List("Cons", $Val(v._2._1, f.i.pack($1)), Nil));
                  };
                }
              })
            ),
            Nil
          )
        )
      )
    );
  };
  var binary = (dictBoundedJoinSemilattice) => {
    const bot = dictBoundedJoinSemilattice.bot;
    return (id3) => (f) => $Tuple(
      id3,
      $Val(
        bot,
        $BaseVal(
          "Fun",
          $Fun(
            "Foreign",
            $Tuple(
              id3,
              $ForeignOp$p({
                arity: 2,
                "op'": (dictMonadWithGraphAlloc) => (dictMonadError) => {
                  const $0 = dictMonadError.MonadThrow0().Monad0().Bind1().Apply0().Functor0();
                  return (v) => {
                    if (v.tag === "Cons" && v._2.tag === "Cons" && v._2._2.tag === "Nil") {
                      const $1 = v._1._2;
                      const $2 = v._2._1._2;
                      return $0.map((() => {
                        const $3 = f.o;
                        return (v$1) => $Val(v$1._2, $3.pack(v$1._1));
                      })())($0.map((v3) => $Tuple(f.fwd(f.i1.unpack($1))(f.i2.unpack($2)), v3))(dictMonadWithGraphAlloc.new(insert3(ordVertex)(v._2._1._1)()($$$Map(
                        "Node",
                        1,
                        1,
                        v._1._1,
                        void 0,
                        Leaf,
                        Leaf
                      )))));
                    }
                    fail();
                  };
                },
                op: (dictAnn) => (dictMonadError) => (v) => {
                  if (v.tag === "Cons" && v._2.tag === "Cons" && v._2._2.tag === "Nil") {
                    return dictMonadError.MonadThrow0().Monad0().Applicative0().pure($Tuple(
                      $Tuple(functorBaseVal.map((v$1) => {
                      })(v._1._2), functorBaseVal.map((v$1) => {
                      })(v._2._1._2)),
                      $Val(
                        dictAnn.BoundedLattice1().BoundedMeetSemilattice1().MeetSemilattice0().meet(v._1._1)(v._2._1._1),
                        f.o.pack(f.fwd(f.i1.unpack(v._1._2))(f.i2.unpack(v._2._1._2)))
                      )
                    ));
                  }
                  fail();
                },
                op_bwd: (dictAnn) => (v) => $List(
                  "Cons",
                  $Val(v._2._1, f.i1.pack(f.i1.unpack(v._1._1))),
                  $List("Cons", $Val(v._2._1, f.i2.pack(f.i2.unpack(v._1._2))), Nil)
                )
              })
            ),
            Nil
          )
        )
      )
    );
  };
  var asNumberString = { as: (v) => throwException(error("Non-uniform argument types"))() };
  var asNumberIntOrNumber = { as: Right };
  var asIntNumberOrString = { as: (x2) => $Either("Left", toNumber(x2)) };
  var asIntNumber = { as: toNumber };
  var asIntIntOrNumber = { as: Left };
  var asBooleanBoolean = { as: (x2) => x2 };
  var union4 = (dictAs) => (dictAs1) => (dictAs2) => (dictAs3) => (v) => (v1) => (v2) => (v3) => {
    if (v2.tag === "Left") {
      if (v3.tag === "Left") {
        return dictAs.as(v(v2._1)(v3._1));
      }
      if (v3.tag === "Right") {
        return dictAs1.as(v1(dictAs2.as(v2._1))(v3._1));
      }
      fail();
    }
    if (v2.tag === "Right") {
      if (v3.tag === "Right") {
        return dictAs1.as(v1(v2._1)(v3._1));
      }
      if (v3.tag === "Left") {
        return dictAs1.as(v1(v2._1)(dictAs3.as(v3._1)));
      }
    }
    fail();
  };
  var unionStr = (dictAs) => (dictAs1) => union4(dictAs)(dictAs)(dictAs1)(dictAs1);

  // output-es/Web.Event.Event/foreign.js
  function _target(e) {
    return e.target;
  }
  function type_(e) {
    return e.type;
  }

  // output-es/App.Util/index.js
  var $SelState = (tag, _1) => ({ tag, _1 });
  var $\u{1D54A} = (tag) => tag;
  var genericShowSum4 = /* @__PURE__ */ (() => {
    const $0 = genericShowConstructor(genericShowArgsNoArguments)({ reflectSymbol: () => "Inert" });
    return (dictGenericShow1) => ({
      "genericShow'": (v) => {
        if (v.tag === "Inl") {
          return $0["genericShow'"](v._1);
        }
        if (v.tag === "Inr") {
          return dictGenericShow1["genericShow'"](v._1);
        }
        fail();
      }
    });
  })();
  var ReactiveIsSymbol = { reflectSymbol: () => "Reactive" };
  var sequence = /* @__PURE__ */ (() => traversableArray.traverse(applicativeAff)(identity7))();
  var sequence_ = /* @__PURE__ */ traverse_(applicativeEffect)(foldableArray)(identity6);
  var clamp = (low) => (hi) => (x2) => {
    const v = ordInt.compare(low)(x2);
    const $0 = (() => {
      if (v === "LT") {
        return x2;
      }
      if (v === "EQ") {
        return low;
      }
      if (v === "GT") {
        return low;
      }
      fail();
    })();
    const v$1 = ordInt.compare(hi)($0);
    if (v$1 === "LT") {
      return hi;
    }
    if (v$1 === "EQ") {
      return hi;
    }
    if (v$1 === "GT") {
      return $0;
    }
    fail();
  };
  var None = /* @__PURE__ */ $\u{1D54A}("None");
  var Secondary = /* @__PURE__ */ $\u{1D54A}("Secondary");
  var Primary = /* @__PURE__ */ $\u{1D54A}("Primary");
  var Inert = /* @__PURE__ */ $SelState("Inert");
  var reflectDictValSelState\u{1D54A}Di = {
    from: () => (r) => ({
      width: (() => {
        const $0 = $$get(showString)(mapDictString)("width")(r);
        return $Tuple($0._2.tag === "Int" ? $0._2._1 : typeError($0._2)("Int"), $0._1);
      })(),
      height: (() => {
        const $0 = $$get(showString)(mapDictString)("height")(r);
        return $Tuple($0._2.tag === "Int" ? $0._2._1 : typeError($0._2)("Int"), $0._1);
      })()
    })
  };
  var highlightableSelState = (dictHighlightable) => (dictJoinSemilattice) => ({
    highlightIf: (v) => {
      if (v.tag === "Inert") {
        return highlightableBoolean.highlightIf(false);
      }
      if (v.tag === "Reactive") {
        return dictHighlightable.highlightIf(dictJoinSemilattice.join(v._1.persistent)(v._1.transient));
      }
      fail();
    }
  });
  var prettyP2 = /* @__PURE__ */ prettyP(/* @__PURE__ */ prettyVal(/* @__PURE__ */ highlightableSelState(highlightableBoolean)(joinSemilatticeBoolean)));
  var genericShow2 = (dictGenericShow) => (x2) => dictGenericShow["genericShow'"]((() => {
    if (x2.tag === "Inert") {
      return $Sum("Inl", NoArguments);
    }
    if (x2.tag === "Reactive") {
      return $Sum("Inr", x2._1);
    }
    fail();
  })());
  var showSelState = (dictShow) => ({
    show: genericShow2(genericShowSum4(genericShowConstructor({
      genericShowArgs: (v) => ["{ persistent: " + dictShow.show(v.persistent) + ", transient: " + dictShow.show(v.transient) + " }"]
    })(ReactiveIsSymbol)))
  });
  var show1 = /* @__PURE__ */ (() => showSelState(showBoolean).show)();
  var functorSelState = {
    map: (f) => (m) => {
      if (m.tag === "Inert") {
        return Inert;
      }
      if (m.tag === "Reactive") {
        return $SelState("Reactive", { ...m._1, persistent: f(m._1.persistent), transient: f(m._1.transient) });
      }
      fail();
    }
  };
  var applySelState = {
    apply: (v) => (v1) => {
      if (v.tag === "Inert") {
        if (v1.tag === "Inert") {
          return Inert;
        }
        return throwException(error("Shape mismatch"))();
      }
      if (v.tag === "Reactive" && v1.tag === "Reactive") {
        return $SelState("Reactive", { persistent: v._1.persistent(v1._1.persistent), transient: v._1.transient(v1._1.transient) });
      }
      return throwException(error("Shape mismatch"))();
    },
    Functor0: () => functorSelState
  };
  var joinSemilatticeSelState = (dictJoinSemilattice) => ({
    join: (() => {
      const $0 = dictJoinSemilattice.join;
      return (a) => (b) => applySelState.apply(functorSelState.map($0)(a))(b);
    })()
  });
  var to\u{1D54A} = (v) => {
    if (v) {
      return Primary;
    }
    return None;
  };
  var selector = (v) => (v1) => {
    const $0 = (v3) => {
      if (v3.tag === "Inert") {
        return Inert;
      }
      if (v3.tag === "Reactive") {
        if (v === "mousedown") {
          return $SelState("Reactive", { ...v3._1, persistent: !v3._1.persistent });
        }
        if (v === "mouseenter") {
          return $SelState("Reactive", { ...v3._1, transient: true });
        }
        if (v === "mouseleave") {
          return $SelState("Reactive", { ...v3._1, transient: false });
        }
        return throwException(error("Unsupported event type"))();
      }
      fail();
    };
    const $1 = spyWhen(false)("Setting selState of ")(prettyP2)(v1);
    return $Val(spyWhen(false)("to ")(show1)($0($1._1)), functorBaseVal.map((x2) => spyWhen(false)("to ")(show1)($0(x2)))($1._2));
  };
  var selState = (v) => (v1) => (v2) => {
    if (v) {
      return Inert;
    }
    return $SelState("Reactive", { persistent: v1, transient: v2 });
  };
  var runAffs_ = (f) => (as1) => {
    const $0 = runAff((v) => {
      if (v.tag === "Left") {
        return log2(showErrorImpl(v._1));
      }
      if (v.tag === "Right") {
        return sequence_(arrayMap(f)(v._1));
      }
      fail();
    })(sequence(as1));
    return () => {
      $0();
    };
  };
  var record = (toRecord) => (v) => toRecord(v._2.tag === "Record" ? v._2._1 : typeError(v._2)("Record"));
  var get_intOrNumber = (x2) => (r) => {
    const $0 = $$get(showString)(mapDictString)(x2)(r);
    const $1 = intOrNumber.unpack($0._2);
    return $Tuple(
      (() => {
        if ($1.tag === "Left") {
          return toNumber($1._1);
        }
        if ($1.tag === "Right") {
          return $1._1;
        }
        fail();
      })(),
      $0._1
    );
  };
  var reflectValSelState\u{1D54A}ArrayV = {
    from: () => (v) => {
      if (v._2.tag === "Constr") {
        if (v._2._2.tag === "Nil") {
          if (v._2._1 === "Nil") {
            return [];
          }
          fail();
        }
        if (v._2._2.tag === "Cons" && v._2._2._2.tag === "Cons" && v._2._2._2._2.tag === "Nil" && v._2._1 === ":") {
          return [v._2._2._1, ...reflectValSelState\u{1D54A}ArrayV.from()(v._2._2._2._1)];
        }
      }
      fail();
    }
  };
  var eventData = (x2) => definitely("absurd")(nullable(_target(x2), Nothing, Just)).__data__;
  var selectionEventData = /* @__PURE__ */ fanout(categoryFn)(strongFn)(eventData)((x2) => selector(type_(x2)));
  var css = {
    sel: {
      transient: { primary: "selected-primary-transient", secondary: "selected-secondary-transient" },
      persistent: { primary: "selected-primary-persistent", secondary: "selected-secondary-persistent" }
    },
    inert: "inert"
  };
  var selClasses = /* @__PURE__ */ (() => joinWith(" ")([
    css.sel.transient.primary,
    css.sel.transient.secondary,
    css.sel.persistent.primary,
    css.sel.persistent.secondary,
    "inert"
  ]))();
  var compare$p = (v) => (v1) => {
    if (v === "None") {
      if (v1 === "None") {
        return EQ;
      }
      return LT;
    }
    if (v === "Secondary") {
      if (v1 === "Secondary") {
        return EQ;
      }
      if (v1 === "Primary") {
        return LT;
      }
      if (v1 === "None") {
        return GT;
      }
      fail();
    }
    if (v === "Primary") {
      if (v1 === "Primary") {
        return EQ;
      }
      return GT;
    }
    fail();
  };
  var isPrimary = (v) => {
    if (v.tag === "Inert") {
      return false;
    }
    if (v.tag === "Reactive") {
      return compare$p(v._1.persistent)(Primary) === "EQ" || compare$p(v._1.transient)(Primary) === "EQ";
    }
    fail();
  };
  var isSecondary = (v) => {
    if (v.tag === "Inert") {
      return false;
    }
    if (v.tag === "Reactive") {
      return compare$p(v._1.persistent)(Secondary) === "EQ" || compare$p(v._1.transient)(Secondary) === "EQ";
    }
    fail();
  };
  var joinSemilattice\u{1D54A} = {
    join: (x2) => (y2) => {
      const v = compare$p(x2)(y2);
      if (v === "LT") {
        return y2;
      }
      if (v === "EQ") {
        return x2;
      }
      if (v === "GT") {
        return x2;
      }
      fail();
    }
  };
  var isPersistent = (x2) => compare$p((() => {
    if (x2.tag === "Inert") {
      return None;
    }
    if (x2.tag === "Reactive") {
      return x2._1.persistent;
    }
    fail();
  })())(None) !== "EQ";
  var isTransient = (x2) => compare$p((() => {
    if (x2.tag === "Inert") {
      return None;
    }
    if (x2.tag === "Reactive") {
      return x2._1.transient;
    }
    fail();
  })())(None) !== "EQ";
  var selClassesFor = (v) => {
    if (v.tag === "Inert") {
      return "inert";
    }
    return joinWith(" ")(concat([
      (() => {
        const v1 = (() => {
          if (v.tag === "Inert") {
            return None;
          }
          if (v.tag === "Reactive") {
            return v._1.persistent;
          }
          fail();
        })();
        if (v1 === "Secondary") {
          return [css.sel.persistent.secondary];
        }
        if (v1 === "Primary") {
          return [css.sel.persistent.primary];
        }
        if (v1 === "None") {
          return [];
        }
        fail();
      })(),
      (() => {
        const v1 = (() => {
          if (v.tag === "Inert") {
            return None;
          }
          if (v.tag === "Reactive") {
            return v._1.transient;
          }
          fail();
        })();
        if (v1 === "Secondary") {
          return [css.sel.transient.secondary];
        }
        if (v1 === "Primary") {
          return [css.sel.transient.primary];
        }
        if (v1 === "None") {
          return [];
        }
        fail();
      })()
    ]));
  };
  var meetSemilattice\u{1D54A} = {
    meet: (x2) => (y2) => {
      const v = compare$p(x2)(y2);
      if (v === "LT") {
        return x2;
      }
      if (v === "EQ") {
        return x2;
      }
      if (v === "GT") {
        return y2;
      }
      fail();
    }
  };
  var colorShade = (col) => (n) => {
    const shade = (rgbComponent) => toStringAs(16)(clamp(0)(255)(definitely("absurd")(fromStringAs(16)(rgbComponent)) + n | 0));
    return "#" + shade(take(2)(drop(1)(col))) + shade(take(2)(drop(3)(col))) + shade(take(2)(drop(5)(col)));
  };
  var classes = /* @__PURE__ */ (() => {
    const $0 = joinWith(" ");
    return (x2) => $Tuple("class", $0(x2));
  })();
  var as\u{1D54A} = (v) => (v1) => {
    if (!v) {
      if (!v1) {
        return None;
      }
      if (v1) {
        return Secondary;
      }
      fail();
    }
    if (v) {
      if (!v1) {
        return None;
      }
      if (v1) {
        return Primary;
      }
    }
    fail();
  };

  // output-es/App.Util.Selector/index.js
  var matrixElement = (v) => (v1) => (v2) => (v3) => {
    if (v3._2.tag === "Matrix") {
      return $Val(v3._1, $BaseVal("Matrix", matrixPut(v)(v1)(v2)(v3._2._1)));
    }
    return throwException(error("absurd"))();
  };
  var listElement = (n) => (\u03B4v) => (v) => {
    if (v._2.tag === "Constr" && v._2._2.tag === "Cons" && v._2._2._2.tag === "Cons" && v._2._2._2._2.tag === "Nil") {
      if (n === 0 && v._2._1 === ":") {
        return $Val(v._1, $BaseVal("Constr", v._2._1, $List("Cons", \u03B4v(v._2._2._1), $List("Cons", v._2._2._2._1, Nil))));
      }
      if (v._2._1 === ":") {
        return $Val(
          v._1,
          $BaseVal(
            "Constr",
            v._2._1,
            $List("Cons", v._2._2._1, $List("Cons", listElement(n - 1 | 0)(\u03B4v)(v._2._2._2._1), Nil))
          )
        );
      }
    }
    fail();
  };
  var field = (f) => (\u03B4v) => (v) => {
    if (v._2.tag === "Record") {
      return $Val(v._1, $BaseVal("Record", update2(showString)(mapDictString)(\u03B4v)(f)(v._2._1)));
    }
    fail();
  };
  var scatterPoint = (i) => (x2) => field("points")(listElement(i)(x2));
  var envVal = (x2) => (\u03B4v) => (\u03B3) => assertWith("")(Object.hasOwn(\u03B3, x2))(update2(showString)(mapEnvStringVal)(\u03B4v)(x2)(\u03B3));
  var dictVal = (s) => (\u03B4v) => (v) => {
    if (v._2.tag === "Dictionary") {
      return $Val(v._1, $BaseVal("Dictionary", update2(showString)(mapDictString)((m) => $Tuple(m._1, \u03B4v(m._2)))(s)(v._2._1)));
    }
    fail();
  };
  var constrArg = (c) => (n) => (\u03B4v) => (v) => {
    if (v._2.tag === "Constr" && c === v._2._1) {
      return $Val(
        v._1,
        $BaseVal(
          "Constr",
          c,
          definitely("constrArg out of bounds")((() => {
            const $0 = index2(v._2._2)(n);
            if ($0.tag === "Just") {
              return updateAt(n)(\u03B4v($0._1))(v._2._2);
            }
            if ($0.tag === "Nothing") {
              return Nothing;
            }
            fail();
          })())
        )
      );
    }
    fail();
  };
  var linePoint = (i) => (x2) => constrArg("LinePlot")(0)(field("points")(listElement(i)(x2)));
  var multiViewEntry = (x2) => (x$1) => constrArg("MultiView")(0)(dictVal(x2)(x$1));
  var barSegment = (i) => (j) => (x2) => field("stackedBars")(listElement(i)(field("bars")(listElement(j)(field("z")(x2)))));

  // output-es/App.View.Util.D3/foreign.js
  selection_default.prototype.attrs = function(m) {
    for (const k in m) {
      this.attr(k, m[k]);
    }
    return this;
  };
  selection_default.prototype.styles = function(m) {
    for (const k in m) {
      this.style(k, m[k]);
    }
    return this;
  };
  function computed(element, prop) {
    return window.getComputedStyle(element, null).getPropertyValue(prop);
  }
  function canvasFont(el) {
    return `${computed(el, "font-weight")} ${computed(el, "font-size")} ${computed(el, "font-family")}`;
  }
  function textDimensions(class_) {
    return (text2) => {
      const element = document.createElement("text");
      element.textContent = text2;
      element.classList.add(class_);
      element.style.visibility = "hidden";
      document.body.appendChild(element);
      const canvas = textDimensions.canvas || (textDimensions.canvas = document.createElement("canvas"));
      const context = canvas.getContext("2d");
      context.font = canvasFont(element);
      const width = Math.ceil(context.measureText(text2).width);
      const height = Math.ceil(element.offsetHeight);
      element.remove();
      return { width, height };
    };
  }
  function createChild(parent) {
    return (elementType) => {
      return (as) => {
        return () => {
          return attrs(parent.append(elementType))(as)();
        };
      };
    };
  }
  function remove3(element) {
    return () => {
      element.remove();
    };
  }
  function line(to) {
    return (points) => {
      const line2 = line_default().x((d) => to.x(d.x)).y((d) => to.y(d.y));
      return line2(points);
    };
  }
  function xAxis(to) {
    return (ticks2) => {
      return (parent) => {
        return () => {
          return parent.call(axisBottom(to.x).tickValues(ticks2).tickFormat(format("d")));
        };
      };
    };
  }
  function yAxis(to) {
    return (nTicks) => {
      return (parent) => {
        return () => {
          return parent.call(axisLeft(to.y).tickSizeOuter(0).ticks(nTicks).tickFormat(format(".1f")));
        };
      };
    };
  }
  function setText(string4) {
    return (sel) => {
      return () => {
        return sel.text(string4);
      };
    };
  }
  var colScale = ordinal(Pastel1_default);
  function nameCol(key) {
    return (keys4) => {
      return colScale(keys4.indexOf(key));
    };
  }
  function dimensions(sel) {
    return () => {
      if (sel.nodes().length != 1) {
        throw "Expected singleton selection";
      }
      [node] = sel.nodes();
      let { width, height } = node.getBBox();
      return { width: Math.ceil(width), height: Math.ceil(height) };
    };
  }
  function isEmpty3(sel) {
    return () => {
      return sel.empty();
    };
  }
  function rootSelect(selector2) {
    return () => {
      return select_default2(selector2);
    };
  }
  function select(selector2) {
    return (sel) => {
      return () => {
        return sel.select(selector2);
      };
    };
  }
  function selectAll2(selector2) {
    return (sel) => {
      return () => {
        const sels = [];
        sel.selectAll(selector2).each(function() {
          sels.push(select_default2(this));
        });
        return sels;
      };
    };
  }
  function attrs(sel) {
    return (attrs2) => {
      return () => {
        if (typeof attrs2 == "function") {
          return sel.each(function(d) {
            const attrs_ = attrs2(d);
            const sel_ = select_default2(this);
            for (const k in attrs_) {
              sel_.attr(k, attrs_[k]);
            }
          });
        } else {
          for (const k in attrs2) {
            sel.attr(k, attrs2[k]);
          }
          return sel;
        }
      };
    };
  }
  function styles(sel) {
    return (styles2) => {
      return () => {
        return sel.styles(styles2);
      };
    };
  }
  function classed(classes2) {
    return (hasClass) => {
      return (sel) => {
        return () => {
          return sel.classed(classes2, hasClass);
        };
      };
    };
  }
  function scaleLinear(x1) {
    return (x2) => {
      return linear2().domain([x1.min, x1.max]).range([x2.min, x2.max]);
    };
  }
  function datum2(sel) {
    return () => {
      return sel.datum();
    };
  }
  function setDatum(d) {
    return (sel) => {
      return () => {
        return sel.data([d]);
      };
    };
  }
  function on(eventType) {
    return (listener) => {
      return (sel) => {
        return () => {
          return sel.on(eventType, (e) => {
            if (e.button == 0) {
              listener(e);
            }
          });
        };
      };
    };
  }

  // output-es/App.View.Util.D3/index.js
  var $ElementType = (tag) => tag;
  var fromFoldable9 = /* @__PURE__ */ fromFoldable(foldableArray);
  var Caption = /* @__PURE__ */ $ElementType("Caption");
  var Circle = /* @__PURE__ */ $ElementType("Circle");
  var G = /* @__PURE__ */ $ElementType("G");
  var Path2 = /* @__PURE__ */ $ElementType("Path");
  var Rect = /* @__PURE__ */ $ElementType("Rect");
  var SVG = /* @__PURE__ */ $ElementType("SVG");
  var Table = /* @__PURE__ */ $ElementType("Table");
  var Text2 = /* @__PURE__ */ $ElementType("Text");
  var TBody = /* @__PURE__ */ $ElementType("TBody");
  var TD = /* @__PURE__ */ $ElementType("TD");
  var TH = /* @__PURE__ */ $ElementType("TH");
  var THead = /* @__PURE__ */ $ElementType("THead");
  var TR = /* @__PURE__ */ $ElementType("TR");
  var genericElementType_ = {
    to: (x2) => {
      if (x2.tag === "Inl") {
        return Caption;
      }
      if (x2.tag === "Inr") {
        if (x2._1.tag === "Inl") {
          return Circle;
        }
        if (x2._1.tag === "Inr") {
          if (x2._1._1.tag === "Inl") {
            return G;
          }
          if (x2._1._1.tag === "Inr") {
            if (x2._1._1._1.tag === "Inl") {
              return Path2;
            }
            if (x2._1._1._1.tag === "Inr") {
              if (x2._1._1._1._1.tag === "Inl") {
                return Rect;
              }
              if (x2._1._1._1._1.tag === "Inr") {
                if (x2._1._1._1._1._1.tag === "Inl") {
                  return SVG;
                }
                if (x2._1._1._1._1._1.tag === "Inr") {
                  if (x2._1._1._1._1._1._1.tag === "Inl") {
                    return Table;
                  }
                  if (x2._1._1._1._1._1._1.tag === "Inr") {
                    if (x2._1._1._1._1._1._1._1.tag === "Inl") {
                      return Text2;
                    }
                    if (x2._1._1._1._1._1._1._1.tag === "Inr") {
                      if (x2._1._1._1._1._1._1._1._1.tag === "Inl") {
                        return TBody;
                      }
                      if (x2._1._1._1._1._1._1._1._1.tag === "Inr") {
                        if (x2._1._1._1._1._1._1._1._1._1.tag === "Inl") {
                          return TD;
                        }
                        if (x2._1._1._1._1._1._1._1._1._1.tag === "Inr") {
                          if (x2._1._1._1._1._1._1._1._1._1._1.tag === "Inl") {
                            return TH;
                          }
                          if (x2._1._1._1._1._1._1._1._1._1._1.tag === "Inr") {
                            if (x2._1._1._1._1._1._1._1._1._1._1._1.tag === "Inl") {
                              return THead;
                            }
                            if (x2._1._1._1._1._1._1._1._1._1._1._1.tag === "Inr") {
                              return TR;
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      fail();
    },
    from: (x2) => {
      if (x2 === "Caption") {
        return $Sum("Inl", NoArguments);
      }
      if (x2 === "Circle") {
        return $Sum("Inr", $Sum("Inl", NoArguments));
      }
      if (x2 === "G") {
        return $Sum("Inr", $Sum("Inr", $Sum("Inl", NoArguments)));
      }
      if (x2 === "Path") {
        return $Sum("Inr", $Sum("Inr", $Sum("Inr", $Sum("Inl", NoArguments))));
      }
      if (x2 === "Rect") {
        return $Sum(
          "Inr",
          $Sum("Inr", $Sum("Inr", $Sum("Inr", $Sum("Inl", NoArguments))))
        );
      }
      if (x2 === "SVG") {
        return $Sum(
          "Inr",
          $Sum(
            "Inr",
            $Sum("Inr", $Sum("Inr", $Sum("Inr", $Sum("Inl", NoArguments))))
          )
        );
      }
      if (x2 === "Table") {
        return $Sum(
          "Inr",
          $Sum(
            "Inr",
            $Sum(
              "Inr",
              $Sum("Inr", $Sum("Inr", $Sum("Inr", $Sum("Inl", NoArguments))))
            )
          )
        );
      }
      if (x2 === "Text") {
        return $Sum(
          "Inr",
          $Sum(
            "Inr",
            $Sum(
              "Inr",
              $Sum(
                "Inr",
                $Sum("Inr", $Sum("Inr", $Sum("Inr", $Sum("Inl", NoArguments))))
              )
            )
          )
        );
      }
      if (x2 === "TBody") {
        return $Sum(
          "Inr",
          $Sum(
            "Inr",
            $Sum(
              "Inr",
              $Sum(
                "Inr",
                $Sum(
                  "Inr",
                  $Sum("Inr", $Sum("Inr", $Sum("Inr", $Sum("Inl", NoArguments))))
                )
              )
            )
          )
        );
      }
      if (x2 === "TD") {
        return $Sum(
          "Inr",
          $Sum(
            "Inr",
            $Sum(
              "Inr",
              $Sum(
                "Inr",
                $Sum(
                  "Inr",
                  $Sum(
                    "Inr",
                    $Sum("Inr", $Sum("Inr", $Sum("Inr", $Sum("Inl", NoArguments))))
                  )
                )
              )
            )
          )
        );
      }
      if (x2 === "TH") {
        return $Sum(
          "Inr",
          $Sum(
            "Inr",
            $Sum(
              "Inr",
              $Sum(
                "Inr",
                $Sum(
                  "Inr",
                  $Sum(
                    "Inr",
                    $Sum(
                      "Inr",
                      $Sum("Inr", $Sum("Inr", $Sum("Inr", $Sum("Inl", NoArguments))))
                    )
                  )
                )
              )
            )
          )
        );
      }
      if (x2 === "THead") {
        return $Sum(
          "Inr",
          $Sum(
            "Inr",
            $Sum(
              "Inr",
              $Sum(
                "Inr",
                $Sum(
                  "Inr",
                  $Sum(
                    "Inr",
                    $Sum(
                      "Inr",
                      $Sum(
                        "Inr",
                        $Sum("Inr", $Sum("Inr", $Sum("Inr", $Sum("Inl", NoArguments))))
                      )
                    )
                  )
                )
              )
            )
          )
        );
      }
      if (x2 === "TR") {
        return $Sum(
          "Inr",
          $Sum(
            "Inr",
            $Sum(
              "Inr",
              $Sum(
                "Inr",
                $Sum(
                  "Inr",
                  $Sum(
                    "Inr",
                    $Sum(
                      "Inr",
                      $Sum(
                        "Inr",
                        $Sum("Inr", $Sum("Inr", $Sum("Inr", $Sum("Inr", NoArguments))))
                      )
                    )
                  )
                )
              )
            )
          )
        );
      }
      fail();
    }
  };
  var showElementType = {
    show: /* @__PURE__ */ (() => {
      const $0 = genericShowConstructor(genericShowArgsNoArguments)({ reflectSymbol: () => "Caption" });
      const $1 = genericShowConstructor(genericShowArgsNoArguments)({ reflectSymbol: () => "Circle" });
      const $2 = (() => {
        const $22 = (() => {
          const $23 = (() => {
            const $24 = genericShowConstructor(genericShowArgsNoArguments)({ reflectSymbol: () => "G" });
            const $3 = (() => {
              const $32 = genericShowConstructor(genericShowArgsNoArguments)({ reflectSymbol: () => "Path" });
              const $4 = (() => {
                const $42 = genericShowConstructor(genericShowArgsNoArguments)({ reflectSymbol: () => "Rect" });
                const $5 = (() => {
                  const $52 = genericShowConstructor(genericShowArgsNoArguments)({ reflectSymbol: () => "SVG" });
                  const $6 = (() => {
                    const $62 = genericShowConstructor(genericShowArgsNoArguments)({ reflectSymbol: () => "Table" });
                    const $7 = (() => {
                      const $72 = genericShowConstructor(genericShowArgsNoArguments)({ reflectSymbol: () => "Text" });
                      const $8 = (() => {
                        const $82 = genericShowConstructor(genericShowArgsNoArguments)({ reflectSymbol: () => "TBody" });
                        const $9 = (() => {
                          const $92 = genericShowConstructor(genericShowArgsNoArguments)({ reflectSymbol: () => "TD" });
                          const $10 = (() => {
                            const $102 = genericShowConstructor(genericShowArgsNoArguments)({ reflectSymbol: () => "TH" });
                            const $11 = (() => {
                              const $112 = genericShowConstructor(genericShowArgsNoArguments)({ reflectSymbol: () => "THead" });
                              const $12 = (() => {
                                const $122 = genericShowConstructor(genericShowArgsNoArguments)({ reflectSymbol: () => "TR" });
                                return {
                                  "genericShow'": (v) => {
                                    if (v.tag === "Inl") {
                                      return $112["genericShow'"](v._1);
                                    }
                                    if (v.tag === "Inr") {
                                      return $122["genericShow'"](v._1);
                                    }
                                    fail();
                                  }
                                };
                              })();
                              return {
                                "genericShow'": (v) => {
                                  if (v.tag === "Inl") {
                                    return $102["genericShow'"](v._1);
                                  }
                                  if (v.tag === "Inr") {
                                    return $12["genericShow'"](v._1);
                                  }
                                  fail();
                                }
                              };
                            })();
                            return {
                              "genericShow'": (v) => {
                                if (v.tag === "Inl") {
                                  return $92["genericShow'"](v._1);
                                }
                                if (v.tag === "Inr") {
                                  return $11["genericShow'"](v._1);
                                }
                                fail();
                              }
                            };
                          })();
                          return {
                            "genericShow'": (v) => {
                              if (v.tag === "Inl") {
                                return $82["genericShow'"](v._1);
                              }
                              if (v.tag === "Inr") {
                                return $10["genericShow'"](v._1);
                              }
                              fail();
                            }
                          };
                        })();
                        return {
                          "genericShow'": (v) => {
                            if (v.tag === "Inl") {
                              return $72["genericShow'"](v._1);
                            }
                            if (v.tag === "Inr") {
                              return $9["genericShow'"](v._1);
                            }
                            fail();
                          }
                        };
                      })();
                      return {
                        "genericShow'": (v) => {
                          if (v.tag === "Inl") {
                            return $62["genericShow'"](v._1);
                          }
                          if (v.tag === "Inr") {
                            return $8["genericShow'"](v._1);
                          }
                          fail();
                        }
                      };
                    })();
                    return {
                      "genericShow'": (v) => {
                        if (v.tag === "Inl") {
                          return $52["genericShow'"](v._1);
                        }
                        if (v.tag === "Inr") {
                          return $7["genericShow'"](v._1);
                        }
                        fail();
                      }
                    };
                  })();
                  return {
                    "genericShow'": (v) => {
                      if (v.tag === "Inl") {
                        return $42["genericShow'"](v._1);
                      }
                      if (v.tag === "Inr") {
                        return $6["genericShow'"](v._1);
                      }
                      fail();
                    }
                  };
                })();
                return {
                  "genericShow'": (v) => {
                    if (v.tag === "Inl") {
                      return $32["genericShow'"](v._1);
                    }
                    if (v.tag === "Inr") {
                      return $5["genericShow'"](v._1);
                    }
                    fail();
                  }
                };
              })();
              return {
                "genericShow'": (v) => {
                  if (v.tag === "Inl") {
                    return $24["genericShow'"](v._1);
                  }
                  if (v.tag === "Inr") {
                    return $4["genericShow'"](v._1);
                  }
                  fail();
                }
              };
            })();
            return {
              "genericShow'": (v) => {
                if (v.tag === "Inl") {
                  return $1["genericShow'"](v._1);
                }
                if (v.tag === "Inr") {
                  return $3["genericShow'"](v._1);
                }
                fail();
              }
            };
          })();
          return {
            "genericShow'": (v) => {
              if (v.tag === "Inl") {
                return $0["genericShow'"](v._1);
              }
              if (v.tag === "Inr") {
                return $23["genericShow'"](v._1);
              }
              fail();
            }
          };
        })();
        return (x2) => $22["genericShow'"](genericElementType_.from(x2));
      })();
      return (x2) => toLower($2(x2));
    })()
  };
  var translate = (v) => $Tuple("transform", "translate(" + showIntImpl(v.x) + ", " + showIntImpl(v.y) + ")");

  // output-es/Web.Event.EventTarget/foreign.js
  function eventListener(fn) {
    return function() {
      return function(event) {
        return fn(event)();
      };
    };
  }

  // output-es/App.View.Util/index.js
  var $Direction = (tag) => tag;
  var for_2 = /* @__PURE__ */ for_(applicativeEffect)(foldableArray);
  var LinkedInputs = /* @__PURE__ */ $Direction("LinkedInputs");
  var LinkedOutputs = /* @__PURE__ */ $Direction("LinkedOutputs");
  var uiHelpers = /* @__PURE__ */ (() => ({
    val: fst,
    selState: snd,
    join: joinSemilatticeSelState(joinSemilattice\u{1D54A}).join,
    selClasses,
    selClassesFor
  }))();
  var selListener = (figVal) => (redraw) => (selector2) => eventListener((x2) => {
    const $0 = selectionEventData(x2);
    return redraw(figVal(selector2($0._1)($0._2)));
  });
  var draw$p = (dictDrawable2) => (v) => (v1) => (redraw) => {
    const $0 = v1.divId;
    const $1 = v1.view;
    const childId = $0 + "-" + v1.suffix;
    const $2 = rootSelect("#" + $0);
    return () => {
      const div = $2();
      const a$p = isEmpty3(div)();
      check(monadThrowEffect)(!a$p)("Unable to insert figure: no div found with id " + $0)();
      const maybeRootElement = select("#" + childId)(div)();
      const v2 = isEmpty3(maybeRootElement)();
      const $3 = v2 ? dictDrawable2.createRootElement($1)(div)(childId)() : maybeRootElement;
      return dictDrawable2.setSelState($1)(redraw)($3)();
    };
  };

  // output-es/App.View.BarChart/foreign.js
  selection_default.prototype.attrs = function(m) {
    for (const k in m) {
      this.attr(k, m[k]);
    }
    return this;
  };
  function addHatchPattern(rootElement, j, col_j) {
    pattern = rootElement.append("pattern").attr("id", "diagonalHatch-" + j).attr("patternUnits", "userSpaceOnUse").attr("width", 3.5).attr("height", 3.5).attr("patternTransform", "rotate(45)");
    pattern.append("rect").attr("width", 3.5).attr("height", 3.5).attr("fill", col_j);
    pattern.append("line").attr("x1", 0).attr("y", 0).attr("x2", 0).attr("y2", 3.5).attr("stroke", "rgba(255, 255, 255, 1)").attr("stroke-width", "1");
  }
  function setSelState({ bar_attrs }, indexCol, rootElement, chart, listener) {
    rootElement.selectAll(".bar").each(function(bar2) {
      select_default2(this).attrs(bar_attrs(indexCol)(chart)(bar2)).on("mousedown", (e) => {
        listener(e);
      }).on("mouseenter", (e) => {
        listener(e);
      }).on("mouseleave", (e) => {
        listener(e);
      });
    });
  }
  function drawBarChart_(barChartHelpers2, uiHelpers2, {
    divId,
    suffix,
    view: {
      caption,
      stackedBars
    }
  }, listener) {
    return () => {
      const { val } = uiHelpers2;
      const { tickEvery } = barChartHelpers2;
      const childId = divId + "-" + suffix;
      const margin = { top: 15, right: 75, bottom: 25, left: 40 }, width = 275 - margin.left - margin.right, height = 185 - margin.top - margin.bottom;
      const div = select_default2("#" + divId);
      if (div.empty()) {
        console.error("Unable to insert figure: no div found with id " + divId);
        return;
      }
      const color2 = ordinal(Accent_default);
      let rootElement = div.selectAll("#" + childId);
      if (rootElement.empty()) {
        let barHeight = function(bars) {
          return bars.reduce((acc, bar2) => {
            return val(bar2.z) + acc;
          }, 0);
        };
        rootElement = div.append("svg").attr("width", width + margin.left + margin.right).attr("height", height + margin.top + margin.bottom).attr("id", childId);
        rootElement.append("g").attr("transform", `translate(${margin.left}, ${margin.top})`);
        const x2 = band().range([0, width]).domain(stackedBars.map((bar2) => val(bar2.x))).padding(0.2);
        rootElement.append("g").attr("transform", "translate(0," + height + ")").call(axisBottom(x2)).selectAll("text").style("text-anchor", "middle");
        const nearest = 100, y_max = Math.ceil(Math.max(...stackedBars.map((d) => barHeight(d.bars))) / nearest) * nearest;
        const y2 = linear2().domain([0, y_max]).range([height, 0]);
        const tickEvery_n = tickEvery(y_max), ticks2 = Array.from(Array(Math.ceil(y_max / tickEvery_n + 1)).keys()).map((n) => n * tickEvery_n);
        const yAxis2 = axisLeft(y2).tickValues(ticks2);
        rootElement.append("g").call(yAxis2);
        const stacks = rootElement.selectAll(".stack").data([...stackedBars.entries()]).enter().append("g");
        const strokeWidth = 1;
        const j_max = Math.max(...stackedBars.map((bar2) => bar2.bars.length));
        for (let j = 0; j < j_max; ++j) {
          addHatchPattern(rootElement, j, color2(j));
        }
        stacks.selectAll(".bar").data(([i, { x: x3, bars }]) => bars.slice(1).reduce((acc, bar2) => {
          const prev = acc[acc.length - 1];
          const y3 = prev.y + prev.height;
          acc.push({ i, j: prev.j + 1, x: val(x3), y: y3, height: val(bar2.z) });
          return acc;
        }, [{ i, j: 0, x: val(x3), y: 0, height: val(bars[0].z) }])).enter().append("rect").attr("class", "bar").attr("x", (bar2) => {
          return x2(bar2.x);
        }).attr("y", (bar2) => {
          return y2(bar2.y + bar2.height);
        }).attr("width", x2.bandwidth()).attr("height", (bar2) => {
          return height - y2(bar2.height) - strokeWidth;
        }).attr("stroke-width", (_) => strokeWidth);
        const legendLineHeight = 15, legendStart = width + margin.left / 2;
        names = stackedBars[0].bars.map((bar2) => val(bar2.y));
        rootElement.append("rect").attr("class", "legend-box").attr("transform", `translate(${legendStart}, ${height / 2 - margin.top - 2})`).attr("x", 0).attr("y", 0).attr("height", legendLineHeight * names.length).attr("width", margin.right - 22);
        const legend = rootElement.selectAll("legend").data(names).enter().append("g").attr(
          "transform",
          (d, i) => `translate(${legendStart}, ${height / 2 - margin.top + i * legendLineHeight})`
        );
        legend.append("text").text((d) => d).attr("font-size", 11).attr("transform", "translate(15, 9)").style("user-select", "none");
        const legendSquareSize = 4;
        legend.append("rect").attr("fill", (d) => color2(names.indexOf(d))).attr("width", legendSquareSize).attr("height", legendSquareSize).attr("x", legendLineHeight / 2 - legendSquareSize / 2).attr("y", legendLineHeight / 2 - legendSquareSize);
        rootElement.append("text").text(val(caption)).style("user-select", "none").attr("x", width / 2).attr("y", height + 35).attr("class", "title-text").attr("dominant-baseline", "bottom").attr("text-anchor", "middle");
      }
      setSelState(barChartHelpers2, color2, rootElement, { stackedBars }, listener);
    };
  }
  var drawBarChart = (x1) => (x2) => (x3) => (x4) => drawBarChart_(x1, x2, x3, x4);

  // output-es/App.View.BarChart/index.js
  var fromFoldable10 = /* @__PURE__ */ fromFoldable(foldableArray);
  var reflectDictValSelState\u{1D54A}Ba = {
    from: () => (r) => ({
      y: (() => {
        const $0 = $$get(showString)(mapDictString)("y")(r);
        return $Tuple($0._2.tag === "Str" ? $0._2._1 : typeError($0._2)("Str"), $0._1);
      })(),
      z: get_intOrNumber("z")(r)
    })
  };
  var reflectDictValSelState\u{1D54A}St = {
    from: () => (r) => ({
      x: (() => {
        const $0 = $$get(showString)(mapDictString)("x")(r);
        return $Tuple($0._2.tag === "Str" ? $0._2._1 : typeError($0._2)("Str"), $0._1);
      })(),
      bars: arrayMap(record(reflectDictValSelState\u{1D54A}Ba.from()))(reflectValSelState\u{1D54A}ArrayV.from()($$get(showString)(mapDictString)("bars")(r)))
    })
  };
  var reflectDictValSelState\u{1D54A}Ba1 = {
    from: () => (r) => ({
      caption: (() => {
        const $0 = $$get(showString)(mapDictString)("caption")(r);
        return $Tuple($0._2.tag === "Str" ? $0._2._1 : typeError($0._2)("Str"), $0._1);
      })(),
      stackedBars: arrayMap(record(reflectDictValSelState\u{1D54A}St.from()))(reflectValSelState\u{1D54A}ArrayV.from()($$get(showString)(mapDictString)("stackedBars")(r)))
    })
  };
  var barChartHelpers = {
    bar_attrs: (indexCol) => (v) => (v1) => {
      const $0 = unsafeIndex(unsafeIndex(v.stackedBars)(v1.i).bars)(v1.j).z;
      const $$transient = (() => {
        if ($0._2.tag === "Inert") {
          return None;
        }
        if ($0._2.tag === "Reactive") {
          return $0._2._1.transient;
        }
        fail();
      })();
      const persistent = (() => {
        if ($0._2.tag === "Inert") {
          return None;
        }
        if ($0._2.tag === "Reactive") {
          return $0._2._1.persistent;
        }
        fail();
      })();
      const col = indexCol(v1.j);
      return fromFoldable10([
        $Tuple(
          "fill",
          (() => {
            if (persistent === "None") {
              return col;
            }
            if (persistent === "Secondary") {
              return "url(#diagonalHatch-" + showIntImpl(v1.j) + ")";
            }
            if (persistent === "Primary") {
              return colorShade(col)(-40);
            }
            fail();
          })()
        ),
        $Tuple("stroke-width", "1.5"),
        $Tuple(
          "stroke-dasharray",
          (() => {
            if ($$transient === "None") {
              return "none";
            }
            if ($$transient === "Secondary") {
              return "1 2";
            }
            if ($$transient === "Primary") {
              return "2 2";
            }
            fail();
          })()
        ),
        $Tuple("stroke-linecap", "round"),
        $Tuple(
          "stroke",
          compare$p(persistent)(None) !== "EQ" || compare$p($$transient)(None) !== "EQ" ? colorShade(col)(-70) : col
        )
      ]);
    },
    tickEvery: (n) => {
      const m = unsafeClamp(floor(log(toNumber(n)) / log(10)));
      if (n <= (2 * pow2(10)(m) | 0)) {
        return 2 * pow2(10)(m - 1 | 0) | 0;
      }
      return pow2(10)(m);
    }
  };
  var drawableBarChart = {
    draw: (rSpec) => (figVal) => (v) => (redraw) => {
      const $0 = drawBarChart(barChartHelpers)(uiHelpers)(rSpec);
      const $1 = selListener(figVal)(redraw)((v1) => (x2) => constrArg("BarChart")(0)(barSegment(v1.i)(v1.j)(x2)));
      return () => {
        const $2 = $1();
        return $0($2)();
      };
    }
  };

  // output-es/App.View.Util.Axes/index.js
  var $Orientation = (tag) => tag;
  var Default = /* @__PURE__ */ $Orientation("Default");
  var Rotated = /* @__PURE__ */ $Orientation("Rotated");
  var orientation = {
    pack: (v) => {
      if (v === "Default") {
        return $BaseVal("Constr", "Default", Nil);
      }
      if (v === "Rotated") {
        return $BaseVal("Constr", "Rotated", Nil);
      }
      fail();
    },
    unpack: (v) => {
      if (v.tag === "Constr" && v._2.tag === "Nil") {
        if (v._1 === "Default") {
          return Default;
        }
        if (v._1 === "Rotated") {
          return Rotated;
        }
      }
      return typeError(v)("Orientation");
    }
  };

  // output-es/App.View.Util.Point/index.js
  var reflectDictValSelState\u{1D54A}Po = {
    from: () => (r) => ({
      x: (() => {
        const $0 = $$get(showString)(mapDictString)("x")(r);
        return $Tuple(orientation.unpack($0._2), $0._1);
      })(),
      y: (() => {
        const $0 = $$get(showString)(mapDictString)("y")(r);
        return $Tuple(orientation.unpack($0._2), $0._1);
      })()
    })
  };
  var reflectDictValSelState\u{1D54A}Po1 = { from: () => (r) => ({ x: get_intOrNumber("x")(r), y: get_intOrNumber("y")(r) }) };

  // output-es/App.View.LineChart/index.js
  var identity25 = (x2) => x2;
  var join = /* @__PURE__ */ (() => joinSemilatticeSelState(joinSemilattice\u{1D54A}).join)();
  var for_3 = /* @__PURE__ */ for_(applicativeEffect)(foldableArray);
  var minimum2 = /* @__PURE__ */ minimum(ordNumber)(foldable1NonEmptyArray);
  var maximum2 = /* @__PURE__ */ maximum(ordNumber)(foldable1NonEmptyArray);
  var maximum1 = /* @__PURE__ */ maximum(ordInt)(foldable1NonEmptyArray);
  var length5 = /* @__PURE__ */ foldlArray((c) => (v) => 1 + c | 0)(0);
  var max4 = (x2) => (y2) => {
    const v = ordInt.compare(x2)(y2);
    if (v === "LT") {
      return y2;
    }
    if (v === "EQ") {
      return x2;
    }
    if (v === "GT") {
      return x2;
    }
    fail();
  };
  var reflectDictValSelState\u{1D54A}Li = {
    from: () => (r) => ({
      name: (() => {
        const $0 = $$get(showString)(mapDictString)("name")(r);
        return $Tuple($0._2.tag === "Str" ? $0._2._1 : typeError($0._2)("Str"), $0._1);
      })(),
      points: arrayMap(record(reflectDictValSelState\u{1D54A}Po1.from()))(reflectValSelState\u{1D54A}ArrayV.from()($$get(showString)(mapDictString)("points")(r)))
    })
  };
  var reflectValSelState\u{1D54A}LinePl = {
    from: () => (v) => {
      if (v._2.tag === "Constr" && v._2._2.tag === "Cons" && v._2._2._2.tag === "Nil" && v._2._1 === "LinePlot") {
        return record(reflectDictValSelState\u{1D54A}Li.from())(v._2._2._1);
      }
      fail();
    }
  };
  var reflectDictValSelState\u{1D54A}Li1 = {
    from: () => (r) => ({
      size: record(reflectDictValSelState\u{1D54A}Di.from())($$get(showString)(mapDictString)("size")(r)),
      tickLabels: record(reflectDictValSelState\u{1D54A}Po.from())($$get(showString)(mapDictString)("tickLabels")(r)),
      caption: (() => {
        const $0 = $$get(showString)(mapDictString)("caption")(r);
        return $Tuple($0._2.tag === "Str" ? $0._2._1 : typeError($0._2)("Str"), $0._1);
      })(),
      plots: arrayMap(reflectValSelState\u{1D54A}LinePl.from())(reflectValSelState\u{1D54A}ArrayV.from()($$get(showString)(mapDictString)("plots")(r)))
    })
  };
  var setSelState2 = (v) => (redraw) => (rootElement) => {
    const $0 = v.plots;
    const $1 = selectAll2(".linechart-point")(rootElement);
    return () => {
      const points = $1();
      for_3(points)((point2) => {
        const $2 = datum2(point2);
        return () => {
          const point$p = $2();
          const v2 = unsafeIndex($0)(point$p.i);
          const $3 = attrs(point2)(fromFoldable9((() => {
            const $32 = unsafeIndex(v2.points)(point$p.j);
            const sel = join($32.x._2)($32.y._2);
            const fill$p = (isPersistent(sel) ? (a) => colorShade(a)(-30) : identity25)(nameCol(v2.name._1)(arrayMap((x2) => x2.name._1)($0)));
            return [
              $Tuple(
                "r",
                showNumberImpl(toNumber(2) * (() => {
                  if (isPrimary(sel)) {
                    return 2;
                  }
                  if (isSecondary(sel)) {
                    return 1.4;
                  }
                  return 1;
                })())
              ),
              $Tuple("stroke", isTransient(sel) ? colorShade(fill$p)(-30) : fill$p),
              $Tuple("fill", fill$p)
            ];
          })()))();
          return for_2(["mousedown", "mouseenter", "mouseleave"])((ev) => on(ev)(redraw)($3))();
        };
      })();
      const segments = selectAll2(".linechart-segment")(rootElement)();
      return for_3(segments)((segment) => {
        const $2 = datum2(segment);
        return () => {
          const segment$p = $2();
          const v2 = unsafeIndex($0)(segment$p.i);
          return attrs(segment)(fromFoldable9((() => {
            const $3 = unsafeIndex(v2.points)(segment$p.j1);
            const $4 = unsafeIndex(v2.points)(segment$p.j2);
            const sel = applySelState.apply(functorSelState.map(meetSemilattice\u{1D54A}.meet)(join($3.x._2)($3.y._2)))(join($4.x._2)($4.y._2));
            return [
              $Tuple(
                "stroke",
                (isTransient(sel) ? (a) => colorShade(a)(-30) : identity25)((isPersistent(sel) ? (a) => colorShade(a)(-30) : identity25)(nameCol(v2.name._1)(arrayMap((x2) => x2.name._1)($0))))
              ),
              $Tuple(
                "stroke-width",
                showIntImpl((() => {
                  if (isTransient(sel)) {
                    return 2;
                  }
                  if (isPersistent(sel)) {
                    return 2;
                  }
                  return 1;
                })())
              )
            ];
          })()))();
        };
      })();
    };
  };
  var createRootElement = (v) => (div1) => (childId) => {
    const $0 = v.caption;
    const $1 = v.plots;
    const $2 = v.size;
    const $3 = v.tickLabels;
    const caption_height = textDimensions("title-text")($0._1).height * 2 | 0;
    const $4 = $2.height._1;
    const $5 = $2.width._1;
    const $6 = arrayBind(arrayMap((x2) => x2.points)($1))(identity5);
    const ps = definitely("non-empty")($6.length > 0 ? $Maybe("Just", $6) : Nothing);
    const $7 = arrayMap((x2) => x2.x._1)(ps);
    const $8 = minimum2($7);
    const $9 = maximum2($7);
    const $10 = maximum2(arrayMap((x2) => x2.y._1)(ps));
    const to = (v2) => ({
      x: scaleLinear({ min: $8, max: $9 })({ min: 0, max: toNumber(v2.width) }),
      y: scaleLinear({ min: 0, max: $10 })({ min: toNumber(v2.height), max: 0 })
    });
    const $11 = (15 + maximum1((() => {
      const $112 = textDimensions("legend-text");
      const $122 = arrayMap((x2) => $112(x2.name._1).width)($1);
      return definitely("non-empty")($122.length > 0 ? $Maybe("Just", $122) : Nothing);
    })()) | 0) + 4 | 0;
    const $12 = 15 * length5($1) | 0;
    const createAxes = (range4, parent) => {
      const $132 = $3.x;
      const $14 = $3.y;
      const $15 = xAxis(to(range4))(nubBy(ordNumber.compare)($7));
      const $16 = createChild(parent)(showElementType.show(G))(fromFoldable9([
        classes(["x-axis"]),
        translate({ x: 0, y: range4.height })
      ]));
      return () => {
        const $17 = $16();
        const x2 = $15($17)();
        const $18 = selectAll2("text")(x2);
        if ($132._1 === "Rotated") {
          const labels = $18();
          for_3(labels)((a) => {
            const $192 = attrs(a)(fromFoldable9([$Tuple("transform", "rotate(45)")]));
            return () => {
              const $202 = $192();
              return styles($202)(fromFoldable9([$Tuple("text-anchor", "start")]))();
            };
          })();
        }
        const $19 = createChild(parent)(showElementType.show(G))(fromFoldable9([
          classes(["y-axis"])
        ]))();
        const y2 = yAxis(to(range4))(3)($19)();
        const $20 = selectAll2("text")(y2);
        if ($14._1 === "Rotated") {
          const labels = $20();
          for_3(labels)((a) => {
            const $21 = attrs(a)(fromFoldable9([$Tuple("transform", "rotate(45)")]));
            return () => {
              const $22 = $21();
              return styles($22)(fromFoldable9([$Tuple("text-anchor", "end")]))();
            };
          })();
        }
        return { x: x2, y: y2 };
      };
    };
    const $13 = createChild(div1)(showElementType.show(SVG))(fromFoldable9([
      $Tuple("width", showIntImpl($5)),
      $Tuple("height", showIntImpl($4)),
      $Tuple("id", childId)
    ]));
    return () => {
      const svg = $13();
      const v2 = createAxes({ ...$2, height: $2.height._1, width: $2.width._1 }, svg)();
      const a$p = dimensions(v2.x)();
      const a$p$1 = dimensions(v2.y)();
      remove3(v2.x)();
      remove3(v2.y)();
      const interior = { width: ((($5 - a$p$1.width | 0) - 3 | 0) - $11 | 0) - 15 | 0, height: (($4 - 6 | 0) - a$p.height | 0) - caption_height | 0 };
      const g = createChild(svg)(showElementType.show(G))(fromFoldable9([
        translate({ x: a$p$1.width, y: 6 })
      ]))();
      createAxes(interior, g)();
      for_3(concat(mapWithIndexArray((i) => (v2$1) => {
        if (v2$1.points.length > 0) {
          return zipWithImpl(
            (v4) => {
              const $142 = v4._2;
              const $15 = v4._1;
              return (v5) => $Tuple({ name: v2$1.name._1, start: $15, end: v5._1 }, { i, j1: $142, j2: v5._2 });
            },
            mapWithIndexArray((j) => (point2) => $Tuple({ x: point2.x._1, y: point2.y._1 }, j))((() => {
              if (v2$1.points.length === 0) {
                fail();
              }
              return sliceImpl(0, v2$1.points.length - 1 | 0, v2$1.points);
            })()),
            mapWithIndexArray((j) => (point2) => $Tuple({ x: point2.x._1, y: point2.y._1 }, j + 1 | 0))((() => {
              const $142 = unconsImpl((v$1) => Nothing, (v$1) => (xs) => $Maybe("Just", xs), v2$1.points);
              if ($142.tag === "Just") {
                return $142._1;
              }
              fail();
            })())
          );
        }
        return [];
      })($1)))((v2$1) => {
        const $142 = setDatum(v2$1._2);
        const $15 = createChild(g)(showElementType.show(Path2))(fromFoldable9([
          classes(["linechart-segment"]),
          $Tuple("d", line(to(interior))([v2$1._1.start, v2$1._1.end]))
        ]));
        return () => {
          const $16 = $15();
          return $142($16)();
        };
      })();
      for_3(concat(mapWithIndexArray((i) => (v2$1) => mapWithIndexArray((j) => (p) => $Tuple(p, { i, j }))(v2$1.points))($1)))((v2$1) => {
        const $142 = setDatum({ i: v2$1._2.i, j: v2$1._2.j });
        const $15 = createChild(g)(showElementType.show(Circle))(fromFoldable9([
          classes(["linechart-point"]),
          $Tuple("stroke-width", "1"),
          $Tuple("cx", showNumberImpl(to(interior).x(v2$1._1.x._1))),
          $Tuple("cy", showNumberImpl(to(interior).y(v2$1._1.y._1)))
        ]));
        return () => {
          const $16 = $15();
          return $142($16)();
        };
      })();
      const $14 = createChild(svg)(showElementType.show(Text2))(fromFoldable9([
        $Tuple("x", showIntImpl(intDiv($5, 2))),
        $Tuple("y", showIntImpl($4 - intDiv(caption_height, 2) | 0)),
        classes(["title-text"]),
        $Tuple("dominant-baseline", "middle"),
        $Tuple("text-anchor", "middle")
      ]))();
      setText($0._1)($14)();
      const legend$p = createChild(g)(showElementType.show(G))(fromFoldable9([
        translate({ x: interior.width + 15 | 0, y: max4(0)(intDiv(interior.height - $12 | 0, 2)) })
      ]))();
      createChild(legend$p)(showElementType.show(Rect))(fromFoldable9([
        classes(["legend-box"]),
        $Tuple("x", "0"),
        $Tuple("y", "0"),
        $Tuple("height", showIntImpl($12)),
        $Tuple("width", showIntImpl($11))
      ]))();
      for_3(mapWithIndexArray((i) => (v3) => ({ i, name: v3.name._1 }))($1))((v3) => {
        const $15 = v3.name;
        const $16 = createChild(legend$p)(showElementType.show(G))(fromFoldable9([
          classes(["legend-entry"]),
          translate({ x: 0, y: (v3.i * 15 | 0) + 2 | 0 })
        ]));
        return () => {
          const g$1 = $16();
          const $17 = createChild(g$1)(showElementType.show(Text2))(fromFoldable9([
            classes(["legend-text"]),
            translate({ x: 15, y: 9 })
          ]))();
          setText($15)($17)();
          return createChild(g$1)(showElementType.show(Circle))(fromFoldable9([
            $Tuple("fill", nameCol($15)(arrayMap((x2) => x2.name._1)($1))),
            $Tuple("r", "2"),
            $Tuple("cx", "6"),
            $Tuple("cy", "6")
          ]))();
        };
      })();
      return g;
    };
  };
  var drawable2LineChart = { setSelState: setSelState2, createRootElement };
  var drawableLineChart = {
    draw: (rSpec) => (figVal) => (v) => (redraw) => {
      const $0 = selListener(figVal)(redraw)((v1) => (x2) => constrArg("LineChart")(0)(field("plots")(listElement(v1.i)(linePoint(v1.j)(x2)))));
      return () => {
        const $1 = $0();
        return draw$p(drawable2LineChart)(uiHelpers)(rSpec)($1)();
      };
    }
  };

  // output-es/App.View.LinkedText/foreign.js
  selection_default.prototype.attrs = function(m) {
    for (const k in m) {
      this.attr(k, m[k]);
    }
    return this;
  };
  function setSelState3({}, {
    selState: selState2,
    selClasses: selClasses2,
    selClassesFor: selClassesFor2,
    join: join3
  }, div, view2, selListener2) {
    div.selectAll("span").each(function(textElem) {
      const sel = selState2(view2[textElem.i]);
      select_default2(this).classed(selClasses2, false).classed(selClassesFor2(sel), true).on("mousedown", (e) => {
        selListener2(e);
      }).on("mouseenter", (e) => {
        selListener2(e);
      }).on("mouseleave", (e) => {
        selListener2(e);
      });
    });
  }
  function drawLinkedText_(linkedTextHelpers2, uiHelpers2, {
    divId,
    suffix,
    view: view2
  }, selListener2) {
    return () => {
      const div = select_default2("#" + divId);
      const childId = divId + "-" + suffix;
      let rootElement = div.selectAll("#" + childId);
      if (rootElement.empty()) {
        rootElement = div.append("div").attr("id", childId).text(view2._1).attr("class", "linked-text-parent");
        rootElement.selectAll("span").data([...view2.entries()].map(([i, conts]) => {
          return { i, conts };
        })).enter().append("span").attr("id", childId).text((d) => d.conts._1).attr("class", "linked-text");
      }
      setSelState3(linkedTextHelpers2, uiHelpers2, rootElement, view2, selListener2);
    };
  }
  var drawLinkedText = (x1) => (x2) => (x3) => (x4) => drawLinkedText_(x1, x2, x3, x4);

  // output-es/App.View.LinkedText/index.js
  var reflectValSelState\u{1D54A}Linked = {
    from: () => (r) => arrayMap((v) => $Tuple(v._2.tag === "Str" ? v._2._1 : typeError(v._2)("Str"), v._1))(reflectValSelState\u{1D54A}ArrayV.from()(r))
  };
  var linkedTextHelpers = {};
  var drawableLinkedText = {
    draw: (rSpec) => (figVal) => (v) => (redraw) => {
      const $0 = drawLinkedText(linkedTextHelpers)(uiHelpers)(rSpec);
      const $1 = selListener(figVal)(redraw)((v1) => (x2) => constrArg("LinkedText")(0)(listElement(v1.i)(x2)));
      return () => {
        const $2 = $1();
        return $0($2)();
      };
    }
  };

  // output-es/App.View.MatrixView/foreign.js
  function setSelState4({
    hBorderStyles,
    vBorderStyles
  }, {
    selState: selState2,
    selClasses: selClasses2,
    selClassesFor: selClassesFor2
  }, rootElement, { matrix }, listener) {
    rootElement.selectAll(".matrix-cell").each(function(cellRect) {
      const sel = selState2(matrix.cells[cellRect.i - 1][cellRect.j - 1]);
      select_default2(this).classed(selClasses2, false).classed(selClassesFor2(sel), true).on("mousedown", (e) => {
        listener(e);
      }).on("mouseenter", (e) => {
        listener(e);
      }).on("mouseleave", (e) => {
        listener(e);
      });
    });
    rootElement.selectAll(".matrix-cell-text").each(function(cellText) {
      const sel = selState2(matrix.cells[cellText.i - 1][cellText.j - 1]);
      select_default2(this).classed(selClasses2, false).classed(selClassesFor2(sel), true);
    });
    rootElement.selectAll(".matrix-cell-hBorder").each(function(hBorder) {
      select_default2(this).attr("style", hBorderStyles(matrix)(hBorder));
    });
    rootElement.selectAll(".matrix-cell-vBorder").each(function(vBorder) {
      select_default2(this).attr("style", vBorderStyles(matrix)(vBorder));
    });
  }
  function drawMatrix_(matrixViewHelpers2, uiHelpers2, {
    divId,
    suffix,
    view: {
      title: title2,
      matrix
    }
  }, listener) {
    return () => {
      const { val } = uiHelpers2;
      const childId = divId + "-" + suffix;
      const strokeWidth = 0.5;
      const highlightStrokeWidth = 0.5;
      const highlightStrokeColor = "blue";
      const w = 30, h = 30;
      const div = select_default2("#" + divId);
      if (div.empty()) {
        console.error("Unable to insert figure: no div found with id " + divId);
        return;
      }
      const [width, height] = [w * matrix.j + highlightStrokeWidth, h * matrix.i + highlightStrokeWidth];
      const hMargin = w / 2;
      const vMargin = h / 2;
      let rootElement = div.selectAll("#" + childId);
      if (rootElement.empty()) {
        rootElement = div.append("svg").attr("id", childId);
        rootElement.attr("width", width + hMargin).attr("height", height + vMargin);
        rootElement.append("text").text(title2).attr("x", hMargin / 2).attr("y", vMargin / 2).attr("class", "title-text").attr("dominant-baseline", "middle").attr("text-anchor", "left");
        const matrixGrp = rootElement.append("g").attr("transform", `translate(${highlightStrokeWidth / 2 + hMargin / 2}, ${highlightStrokeWidth / 2 + vMargin})`).attr("fill", "currentColor").attr("stroke", "currentColor").attr("stroke-width", ".25");
        const rowGrp = matrixGrp.selectAll("g").data([...matrix.cells.entries()].map(([i, ns]) => {
          return { i: i + 1, ns };
        })).enter().append("g");
        const cells = rowGrp.selectAll("g").data(({ i, ns }) => [...ns.entries()].map(([j, n]) => {
          return { i, j: j + 1, n };
        })).enter();
        cells.append("rect").attr("x", ({ j }) => (j - 1) * w).attr("y", ({ i }) => (i - 1) * h).attr("width", w).attr("height", h).attr("class", "matrix-cell").attr("stroke-width", strokeWidth);
        cells.append("text").text(({ n }) => val(n)).attr("x", ({ j }) => (j - 0.5) * w).attr("y", ({ i }) => (i - 0.5) * h).attr("class", "matrix-cell-text").attr("text-anchor", "middle").attr("dominant-baseline", "middle").attr("pointer-events", "none");
        const bordersGrp = rootElement.append("g").attr("transform", `translate(${highlightStrokeWidth / 2 + hMargin / 2}, ${highlightStrokeWidth / 2 + vMargin})`).attr("fill", "currentColor").attr("stroke", highlightStrokeColor).attr("stroke-width", highlightStrokeWidth);
        const hBordersGrp = bordersGrp.append("g");
        const hBordersRowGrps = hBordersGrp.selectAll("g").data(range(matrix.i + 1)).enter().append("g");
        hBordersRowGrps.each(function(d) {
          select_default2(this).selectAll("line").data(range(1, matrix.j + 1).map((j) => ({ i: d, j })), (d2) => d2.j).enter().append("line").attr("x1", ({ j }) => (j - 1) * w).attr("y1", ({ i }) => i * h).attr("x2", ({ j }) => j * w).attr("y2", ({ i }) => i * h).attr("class", "matrix-cell-hBorder");
        });
        const vBordersGrp = bordersGrp.append("g");
        const vBordersRowGrps = vBordersGrp.selectAll("g").data(range(1, matrix.i + 1), (i) => i).enter().append("g");
        vBordersRowGrps.each(function(d) {
          select_default2(this).selectAll("line").data(range(matrix.j + 1).map((j) => ({ i: d, j }))).enter().append("line").attr("x1", ({ j }) => j * w).attr("y1", ({ i }) => (i - 1) * h).attr("x2", ({ j }) => j * w).attr("y2", ({ i }) => i * h).attr("class", "matrix-cell-vBorder");
        });
      }
      setSelState4(matrixViewHelpers2, uiHelpers2, rootElement, { matrix }, listener);
    };
  }
  var drawMatrix = (x1) => (x2) => (x3) => (x4) => drawMatrix_(x1, x2, x3, x4);

  // output-es/App.View.MatrixView/index.js
  var matrixViewHelpers = {
    hBorderStyles: (m) => (x2) => {
      if (x2.i === 0) {
        if (isTransient(unsafeIndex(unsafeIndex(m.cells)(x2.i))(x2.j - 1 | 0)._2)) {
          return "filter: drop-shadow(0px 1px 1px blue);";
        }
        return "visibility: hidden;";
      }
      if (x2.i === m.i) {
        if (isTransient(unsafeIndex(unsafeIndex(m.cells)(x2.i - 1 | 0))(x2.j - 1 | 0)._2)) {
          return "filter: drop-shadow(0px -1px 1px blue);";
        }
        return "visibility: hidden;";
      }
      if (isTransient(unsafeIndex(unsafeIndex(m.cells)(x2.i))(x2.j - 1 | 0)._2) && !isTransient(unsafeIndex(unsafeIndex(m.cells)(x2.i - 1 | 0))(x2.j - 1 | 0)._2)) {
        return "filter: drop-shadow(0px 1px 1px blue);";
      }
      if (!isTransient(unsafeIndex(unsafeIndex(m.cells)(x2.i))(x2.j - 1 | 0)._2) && isTransient(unsafeIndex(unsafeIndex(m.cells)(x2.i - 1 | 0))(x2.j - 1 | 0)._2)) {
        return "filter: drop-shadow(0px -1px 1px blue);";
      }
      return "visibility: hidden;";
    },
    vBorderStyles: (m) => (x2) => {
      if (x2.j === 0) {
        if (isTransient(unsafeIndex(unsafeIndex(m.cells)(x2.i - 1 | 0))(x2.j)._2)) {
          return "filter: drop-shadow(1px 0px 1px blue);";
        }
        return "visibility: hidden;";
      }
      if (x2.j === m.j) {
        if (isTransient(unsafeIndex(unsafeIndex(m.cells)(x2.i - 1 | 0))(x2.j - 1 | 0)._2)) {
          return "filter: drop-shadow(-1px 0px 1px blue);";
        }
        return "visibility: hidden;";
      }
      if (isTransient(unsafeIndex(unsafeIndex(m.cells)(x2.i - 1 | 0))(x2.j)._2) && !isTransient(unsafeIndex(unsafeIndex(m.cells)(x2.i - 1 | 0))(x2.j - 1 | 0)._2)) {
        return "filter: drop-shadow(1px 0px 1px blue);";
      }
      if (!isTransient(unsafeIndex(unsafeIndex(m.cells)(x2.i - 1 | 0))(x2.j)._2) && isTransient(unsafeIndex(unsafeIndex(m.cells)(x2.i - 1 | 0))(x2.j - 1 | 0)._2)) {
        return "filter: drop-shadow(-1px 0px 1px blue);";
      }
      return "visibility: hidden;";
    }
  };
  var drawableMatrixView = {
    draw: (rSpec) => (figVal) => (v) => (redraw) => {
      const $0 = drawMatrix(matrixViewHelpers)(uiHelpers)(rSpec);
      const $1 = selListener(figVal)(redraw)((v1) => matrixElement(v1.i)(v1.j));
      return () => {
        const $2 = $1();
        return $0($2)();
      };
    }
  };
  var matrixRep = (v) => ({
    cells: arrayMap((v1) => arrayMap((v$1) => $Tuple(v$1._2.tag === "Int" ? v$1._2._1 : typeError(v$1._2)("Int"), v$1._1))(v1))(v._1),
    i: v._2._1._1,
    j: v._2._2._1
  });

  // output-es/App.View.MultiView/index.js
  var sequence_2 = /* @__PURE__ */ traverse_(applicativeEffect)(foldableDict)(identity6);
  var drawableMultiView = {
    draw: (v) => (figVal) => (figView) => (redraw) => {
      const $0 = v.divId;
      return sequence_2(_mapWithKey(
        v.view,
        (x2) => (view2) => view2((dictDrawable) => (view$1) => dictDrawable.draw({ divId: $0, suffix: x2, view: view$1 })((x$1) => figVal(multiViewEntry(x2)(x$1)))(figView)(redraw))
      ));
    }
  };

  // output-es/App.View.ScatterPlot/foreign.js
  function setSelState5({ point_attrs }, {
    selState: selState2,
    selClasses: selClasses2,
    selClassesFor: selClassesFor2,
    join: join3
  }, rootElement, chart, listener) {
    const { points } = chart;
    rootElement.selectAll(".scatterplot-point").each(function(point2) {
      const sel = join3(selState2(points[point2.i].x))(selState2(points[point2.i].y));
      select_default2(this).classed(selClasses2, false).classed(selClassesFor2(sel), true).attrs(point_attrs(chart)(point2)).on("mousedown", (e) => {
        listener(e);
      }).on("mouseenter", (e) => {
        listener(e);
      }).on("mouseleave", (e) => {
        listener(e);
      });
    });
  }
  function drawScatterPlot_(scatterPlotHelpers2, uiHelpers2, {
    divId,
    suffix,
    view: {
      caption,
      points,
      xlabel,
      ylabel
    }
  }, listener) {
    return () => {
      const { val } = uiHelpers2;
      const childId = divId + "-" + suffix;
      var max_width = 360;
      var max_height = 360;
      const x_max = Math.ceil(Math.max(...points.map((point2) => val(point2.x))));
      const x_min = Math.ceil(Math.min(...points.map((point2) => val(point2.x))));
      const y_max = Math.ceil(Math.max(...points.map((point2) => val(point2.y))));
      const y_min = Math.ceil(Math.min(...points.map((point2) => val(point2.y))));
      const margin = { top: 20, right: 20, bottom: 40, left: 50 };
      const width = max_width - margin.left - margin.right, height = max_height - margin.top - margin.bottom;
      const div = select_default2("#" + divId);
      if (div.empty()) {
        console.error("Unable to insert figure: no div found with id " + divId);
        return;
      }
      let rootElement = div.selectAll("#" + childId);
      if (rootElement.empty()) {
        rootElement = div.append("svg").classed("center", true).attr("width", max_width + margin.left + margin.right).attr("height", max_height + margin.top).attr("id", childId).append("g").attr("transform", `translate(${margin.left}, ${margin.top})`);
        const x2 = linear2().domain([Math.min(0, x_min), x_max]).range([0, width]);
        rootElement.append("g").attr("transform", "translate(0," + height + ")").call(axisBottom(x2)).selectAll("text").style("text-anchor", "middle");
        const y2 = linear2().domain([Math.min(0, y_min), y_max]).range([height, 0]);
        rootElement.append("g").call(axisLeft(y2));
        rootElement.append("text").attr("x", width).attr("y", height + 25).style("text-anchor", "end").style("font-size", "8px").text(val(xlabel));
        rootElement.append("text").attr("transform", "rotate(-90)").attr("x", -margin.top).attr("y", -margin.left + 20).style("text-anchor", "end").style("font-size", "8px").text(val(ylabel));
        rootElement.append("g").selectAll("circle").data([...points.entries()].map(([i, point2]) => {
          return { i, point: point2 };
        })).enter().append("circle").classed("scatterplot-point", true).attr("cx", ({ point: point2 }) => x2(val(point2.x))).attr("cy", ({ point: point2 }) => y2(val(point2.y))).attr("stroke-width", 0.5);
        rootElement.append("text").text(val(caption)).attr("x", width / 2).attr("y", height + 40).attr("class", "title-text").attr("dominant-baseline", "bottom").attr("text-anchor", "middle");
      }
      setSelState5(scatterPlotHelpers2, uiHelpers2, rootElement, { points }, listener);
    };
  }
  var drawScatterPlot = (x1) => (x2) => (x3) => (x4) => drawScatterPlot_(x1, x2, x3, x4);

  // output-es/App.View.ScatterPlot/index.js
  var join2 = /* @__PURE__ */ (() => joinSemilatticeSelState(joinSemilattice\u{1D54A}).join)();
  var fromFoldable11 = /* @__PURE__ */ fromFoldable(foldableArray);
  var reflectDictValSelState\u{1D54A}Sc = {
    from: () => (r) => ({
      caption: (() => {
        const $0 = $$get(showString)(mapDictString)("caption")(r);
        return $Tuple($0._2.tag === "Str" ? $0._2._1 : typeError($0._2)("Str"), $0._1);
      })(),
      points: arrayMap(record(reflectDictValSelState\u{1D54A}Po1.from()))(reflectValSelState\u{1D54A}ArrayV.from()($$get(showString)(mapDictString)("points")(r))),
      xlabel: (() => {
        const $0 = $$get(showString)(mapDictString)("xlabel")(r);
        return $Tuple($0._2.tag === "Str" ? $0._2._1 : typeError($0._2)("Str"), $0._1);
      })(),
      ylabel: (() => {
        const $0 = $$get(showString)(mapDictString)("ylabel")(r);
        return $Tuple($0._2.tag === "Str" ? $0._2._1 : typeError($0._2)("Str"), $0._1);
      })()
    })
  };
  var scatterPlotHelpers = {
    point_attrs: (v) => (v1) => {
      const v2 = unsafeIndex(v.points)(v1.i);
      const sel = join2(v2.x._2)(v2.y._2);
      return fromFoldable11([
        $Tuple(
          "r",
          showNumberImpl(toNumber(2) * (() => {
            if (isPrimary(sel)) {
              return 1.6;
            }
            if (isSecondary(sel)) {
              return 1.25;
            }
            return 1;
          })())
        )
      ]);
    }
  };
  var drawableScatterPlot = {
    draw: (rSpec) => (figVal) => (v) => (redraw) => {
      const $0 = drawScatterPlot(scatterPlotHelpers)(uiHelpers)(rSpec);
      const $1 = selListener(figVal)(redraw)((v1) => (x2) => constrArg("ScatterPlot")(0)(scatterPoint(v1.i)(x2)));
      return () => {
        const $2 = $1();
        return $0($2)();
      };
    }
  };

  // output-es/Data.Number.Format/foreign.js
  function wrap(method) {
    return function(d) {
      return function(num) {
        return method.apply(num, [d]);
      };
    };
  }
  var toPrecisionNative = wrap(Number.prototype.toPrecision);
  var toFixedNative = wrap(Number.prototype.toFixed);
  var toExponentialNative = wrap(Number.prototype.toExponential);

  // output-es/Data.Number.Format/index.js
  var $Format = (tag, _1) => ({ tag, _1 });
  var clamp2 = (low) => (hi) => (x2) => {
    const v = ordInt.compare(low)(x2);
    const $0 = (() => {
      if (v === "LT") {
        return x2;
      }
      if (v === "EQ") {
        return low;
      }
      if (v === "GT") {
        return low;
      }
      fail();
    })();
    const v$1 = ordInt.compare(hi)($0);
    if (v$1 === "LT") {
      return hi;
    }
    if (v$1 === "EQ") {
      return hi;
    }
    if (v$1 === "GT") {
      return $0;
    }
    fail();
  };
  var toStringWith = (v) => {
    if (v.tag === "Precision") {
      return toPrecisionNative(v._1);
    }
    if (v.tag === "Fixed") {
      return toFixedNative(v._1);
    }
    if (v.tag === "Exponential") {
      return toExponentialNative(v._1);
    }
    fail();
  };

  // output-es/App.View.TableView/index.js
  var $Filter = (tag) => tag;
  var toUnfoldable7 = /* @__PURE__ */ (() => {
    const $0 = toUnfoldable2(unfoldableArray);
    return (x2) => $0(keys2(x2));
  })();
  var forWithIndex_2 = /* @__PURE__ */ forWithIndex_(applicativeEffect)(foldableWithIndexArray);
  var $$for = /* @__PURE__ */ (() => {
    const traverse2 = traversableArray.traverse(applicativeEffect);
    return (x2) => (f) => traverse2(f)(x2);
  })();
  var for_4 = /* @__PURE__ */ for_(applicativeEffect)(foldableArray);
  var Interactive = /* @__PURE__ */ $Filter("Interactive");
  var prim = (v) => {
    if (v._2.tag === "Int") {
      return showIntImpl(v._2._1);
    }
    if (v._2.tag === "Float") {
      return toStringWith($Format("Fixed", clamp2(0)(20)(2)))(v._2._1);
    }
    if (v._2.tag === "Str") {
      return v._2._1;
    }
    return throwException(error("TableView only supports primitive values."))();
  };
  var headers = (records) => sortBy(ordString.compare)(toUnfoldable7(mapObjectString.keys(definitely("absurd")(0 < records.length ? $Maybe("Just", records[0]) : Nothing))));
  var record_isVisible = (r) => filterImpl(
    (v) => {
      if (v._1.tag === "Inert") {
        return false;
      }
      if (v._1.tag === "Reactive") {
        return true;
      }
      fail();
    },
    r
  ).length !== 0;
  var createRootElement2 = (v) => (div) => (childId) => {
    const $0 = v.colNames;
    const $1 = v.filter;
    const $2 = v.rows;
    const $3 = createChild(div)(showElementType.show(Table))(fromFoldable9([
      $Tuple("id", childId)
    ]));
    return () => {
      const rootElement = $3();
      createChild(rootElement)(showElementType.show(Caption))(fromFoldable9([
        classes(["title-text", "table-caption"]),
        $Tuple("dominant-baseline", "middle"),
        $Tuple("text-anchor", "left")
      ]))();
      const colNames$p = ["__n", ...$0];
      const $4 = createChild(rootElement)(showElementType.show(THead))(fromFoldable9([]))();
      const row = createChild($4)(showElementType.show(TR))(fromFoldable9([]))();
      forWithIndex_2(colNames$p)((j) => (colName) => {
        const value = (() => {
          if (colName === "__n") {
            if ($1 === "Relevant") {
              return "\u25B8";
            }
            return "\u25BE";
          }
          return colName;
        })();
        const $5 = createChild(row)(showElementType.show(TH))(fromFoldable9([
          classes(["table-cell", ...colName === "__n" ? ["filter-toggle", "toggle-button"] : []])
        ]));
        const $6 = setText(value);
        const $7 = setDatum({ i: -1, j: j - 1 | 0, value, colName: unsafeIndex(colNames$p)(j) });
        return () => {
          const $8 = $5();
          const $9 = $6($8)();
          return $7($9)();
        };
      })();
      const body = createChild(rootElement)(showElementType.show(TBody))(fromFoldable9([]))();
      forWithIndex_2($2)((i) => (row$1) => {
        const $5 = createChild(body)(showElementType.show(TR))(fromFoldable9([
          classes(["table-row"])
        ]));
        const $6 = setDatum({ i });
        return () => {
          const $7 = $5();
          const row$p = $6($7)();
          return forWithIndex_2([showIntImpl(i + 1 | 0), ...arrayMap(prim)(row$1)])((j) => (value) => {
            const $8 = createChild(row$p)(showElementType.show(TD))(fromFoldable9([
              classes(j >= 0 ? ["table-cell"] : [])
            ]));
            const $9 = setText(value);
            const $10 = setDatum({ i, j: j - 1 | 0, value, colName: unsafeIndex(colNames$p)(j) });
            return () => {
              const $11 = $8();
              const $12 = styles($11)(fromFoldable9([
                $Tuple("border-top", "1px solid transparent"),
                $Tuple("border-left", "1px solid transparent")
              ]))();
              const $13 = $9($12)();
              return $10($13)();
            };
          })();
        };
      })();
      return rootElement;
    };
  };
  var setSelState6 = (v) => (redraw) => (rootElement) => {
    const $0 = v.rows;
    const $1 = v.title;
    const width = definitely("absurd")(0 < $0.length ? $Maybe("Just", $0[0]) : Nothing).length;
    const visibleSucc = (visibleSucc$a0$copy) => {
      let visibleSucc$a0 = visibleSucc$a0$copy, visibleSucc$c = true, visibleSucc$r;
      while (visibleSucc$c) {
        const i = visibleSucc$a0;
        if (i === ($0.length - 1 | 0)) {
          visibleSucc$c = false;
          visibleSucc$r = Nothing;
          continue;
        }
        if (record_isVisible(unsafeIndex($0)(i + 1 | 0))) {
          visibleSucc$c = false;
          visibleSucc$r = $Maybe("Just", i + 1 | 0);
          continue;
        }
        visibleSucc$a0 = i + 1 | 0;
      }
      return visibleSucc$r;
    };
    const visiblePred = (visiblePred$a0$copy) => {
      let visiblePred$a0 = visiblePred$a0$copy, visiblePred$c = true, visiblePred$r;
      while (visiblePred$c) {
        const i = visiblePred$a0;
        if (i < 0) {
          visiblePred$c = false;
          visiblePred$r = throwException(error("absurd"))();
          continue;
        }
        if (i === 0) {
          visiblePred$c = false;
          visiblePred$r = -1;
          continue;
        }
        if (record_isVisible(unsafeIndex($0)(i - 1 | 0))) {
          visiblePred$c = false;
          visiblePred$r = i - 1 | 0;
          continue;
        }
        visiblePred$a0 = i - 1 | 0;
      }
      return visiblePred$r;
    };
    const isCellTransient = (i, j) => {
      if (i === -1 || j === -1) {
        return false;
      }
      return isTransient(unsafeIndex(unsafeIndex($0)(i))(j)._1);
    };
    const $2 = selectAll2(".table-row")(rootElement);
    const $3 = selectAll2(".table-cell")(rootElement);
    return () => {
      const cells = $3();
      for_4(cells)((cell) => {
        const $42 = datum2(cell);
        return () => {
          const v12 = $42();
          if (v12.i === -1 || v12.j === -1) {
          } else {
            const $5 = classed(selClasses)(false)(cell)();
            const $6 = classed(v12.colName === "__n" ? "" : selClassesFor(unsafeIndex(unsafeIndex($0)(v12.i))(v12.j)._1))(true)($5)();
            for_2(["mousedown", "mouseenter", "mouseleave"])((ev) => on(ev)(redraw)($6))();
          }
          return styles(cell)(fromFoldable9([
            $Tuple(
              "border-right",
              (() => {
                const $5 = v12.j === (width - 1 | 0);
                if (v12.j === (width - 1 | 0) ? isCellTransient(v12.i, v12.j) : isCellTransient(v12.i, v12.j) !== isCellTransient(v12.i, v12.j + 1 | 0)) {
                  return "1px solid blue";
                }
                if ($5) {
                  return "1px solid transparent";
                }
                return "";
              })()
            ),
            $Tuple(
              "border-bottom",
              (() => {
                const v1$1 = visibleSucc(v12.i);
                const $5 = v12.i === ($0.length - 1 | 0);
                if ((() => {
                  if (v1$1.tag === "Nothing") {
                    return isCellTransient(v12.i, v12.j);
                  }
                  if (v1$1.tag === "Just") {
                    return isCellTransient(v1$1._1, v12.j) !== isCellTransient(visiblePred(v1$1._1), v12.j) && v12.i === (v1$1._1 - 1 | 0);
                  }
                  fail();
                })()) {
                  return "1px solid blue";
                }
                if ($5) {
                  return "1px solid transparent";
                }
                return "";
              })()
            )
          ]))();
        };
      })();
      const rows$p = $2();
      const a$p = $$for(rows$p)((row) => {
        const $42 = datum2(row);
        return () => {
          const v12 = $42();
          return $Tuple(row, record_isVisible(unsafeIndex($0)(v12.i)));
        };
      })();
      const v1 = partitionImpl(snd, a$p);
      for_4(v1.no)((() => {
        const $42 = classed("hidden")(true);
        return (x2) => $42(x2._1);
      })())();
      for_4(v1.yes)((() => {
        const $42 = classed("hidden")(false);
        return (x2) => $42(x2._1);
      })())();
      const $4 = select(".table-caption")(rootElement)();
      setText($1 + " (" + showIntImpl($0.length - v1.no.length | 0) + " of " + showIntImpl($0.length) + ")")($4)();
    };
  };
  var drawable2TableView = { createRootElement: createRootElement2, setSelState: setSelState6 };
  var drawableTableView = {
    draw: (rSpec) => (figVal) => (v) => (redraw) => {
      const $0 = selListener(figVal)(redraw)((v1) => (x2) => listElement(v1.i)(field(v1.colName)(x2)));
      return () => {
        const $1 = $0();
        return draw$p(drawable2TableView)(uiHelpers)(rSpec)($1)();
      };
    }
  };
  var arrayDictToArray2 = (x2) => arrayMap((a) => arrayMap((a$1) => $$get(showString)(mapDictString)(a$1)(a))(x2));

  // output-es/App.View/index.js
  var pack = (x2) => (k) => k(drawableBarChart)(x2);
  var pack1 = (x2) => (k) => k(drawableLineChart)(x2);
  var pack2 = (x2) => (k) => k(drawableScatterPlot)(x2);
  var pack3 = (x2) => (k) => k(drawableLinkedText)(x2);
  var pack4 = (x2) => (k) => k(drawableMultiView)(x2);
  var identity26 = (x2) => x2;
  var pack5 = (x2) => (k) => k(drawableTableView)(x2);
  var pack6 = (x2) => (k) => k(drawableMatrixView)(x2);
  var view = () => (v) => (v1) => (v2) => {
    if (v1._2.tag === "Constr") {
      if (v1._2._2.tag === "Cons" && v1._2._2._2.tag === "Nil") {
        if (v1._2._1 === "BarChart") {
          return pack(record(reflectDictValSelState\u{1D54A}Ba1.from())(v1._2._2._1));
        }
        if (v1._2._1 === "LineChart") {
          return pack1(record(reflectDictValSelState\u{1D54A}Li1.from())(v1._2._2._1));
        }
        if (v1._2._1 === "ScatterPlot") {
          return pack2(record(reflectDictValSelState\u{1D54A}Sc.from())(v1._2._2._1));
        }
        if (v1._2._1 === "LinkedText") {
          return pack3(reflectValSelState\u{1D54A}Linked.from()(v1._2._2._1));
        }
        if (v1._2._1 === "MultiView") {
          const vws = _fmapObject(
            (() => {
              if (v1._2._2._1._2.tag === "Dictionary") {
                return _fmapObject(v1._2._2._1._2._1, snd);
              }
              fail();
            })(),
            view()(v)
          );
          return pack4(intersectionWith_Object(apply)(vws)(_fmapObject(vws, (v$1) => Nothing)));
        }
      }
      if (v1._2._1 === "Nil" || v1._2._1 === ":") {
        const records = arrayMap(record(identity26))(reflectValSelState\u{1D54A}ArrayV.from()(v1));
        const colNames = headers(records);
        return pack5({ title: v, filter: Interactive, colNames, rows: arrayDictToArray2(colNames)(records) });
      }
      fail();
    }
    if (v1._2.tag === "Matrix") {
      return pack6({ title: v, matrix: matrixRep(v1._2._1) });
    }
    fail();
  };

  // output-es/Control.Monad.State.Trans/index.js
  var bindStateT = (dictMonad) => ({ bind: (v) => (f) => (s) => dictMonad.Bind1().bind(v(s))((v1) => f(v1._1)(v1._2)), Apply0: () => applyStateT(dictMonad) });
  var applyStateT = (dictMonad) => {
    const $0 = dictMonad.Bind1().Apply0().Functor0();
    const functorStateT1 = { map: (f) => (v) => (s) => $0.map((v1) => $Tuple(f(v1._1), v1._2))(v(s)) };
    return {
      apply: (() => {
        const $1 = bindStateT(dictMonad);
        return (f) => (a) => $1.bind(f)((f$p) => $1.bind(a)((a$p) => applicativeStateT(dictMonad).pure(f$p(a$p))));
      })(),
      Functor0: () => functorStateT1
    };
  };
  var applicativeStateT = (dictMonad) => ({ pure: (a) => (s) => dictMonad.Applicative0().pure($Tuple(a, s)), Apply0: () => applyStateT(dictMonad) });
  var monadRecStateT = (dictMonadRec) => {
    const Monad0 = dictMonadRec.Monad0();
    const monadStateT1 = { Applicative0: () => applicativeStateT(Monad0), Bind1: () => bindStateT(Monad0) };
    return {
      tailRecM: (f) => (a) => (s) => dictMonadRec.tailRecM((v) => Monad0.Bind1().bind(f(v._1)(v._2))((v2) => Monad0.Applicative0().pure((() => {
        if (v2._1.tag === "Loop") {
          return $Step("Loop", $Tuple(v2._1._1, v2._2));
        }
        if (v2._1.tag === "Done") {
          return $Step("Done", $Tuple(v2._1._1, v2._2));
        }
        fail();
      })())))($Tuple(a, s)),
      Monad0: () => monadStateT1
    };
  };
  var monadStateStateT = (dictMonad) => {
    const monadStateT1 = { Applicative0: () => applicativeStateT(dictMonad), Bind1: () => bindStateT(dictMonad) };
    return { state: (f) => (x2) => dictMonad.Applicative0().pure(f(x2)), Monad0: () => monadStateT1 };
  };
  var monadThrowStateT = (dictMonadThrow) => {
    const Monad0 = dictMonadThrow.Monad0();
    const monadStateT1 = { Applicative0: () => applicativeStateT(Monad0), Bind1: () => bindStateT(Monad0) };
    return {
      throwError: (e) => {
        const $0 = dictMonadThrow.throwError(e);
        return (s) => Monad0.Bind1().bind($0)((x2) => Monad0.Applicative0().pure($Tuple(x2, s)));
      },
      Monad0: () => monadStateT1
    };
  };
  var monadErrorStateT = (dictMonadError) => {
    const monadThrowStateT1 = monadThrowStateT(dictMonadError.MonadThrow0());
    return { catchError: (v) => (h) => (s) => dictMonadError.catchError(v(s))((e) => h(e)(s)), MonadThrow0: () => monadThrowStateT1 };
  };

  // output-es/Graph.WithGraph/index.js
  var fromFoldable15 = /* @__PURE__ */ (() => {
    const go = (go$a0$copy) => (go$a1$copy) => {
      let go$a0 = go$a0$copy, go$a1 = go$a1$copy, go$c = true, go$r;
      while (go$c) {
        const b = go$a0, v = go$a1;
        if (v.tag === "Nil") {
          go$c = false;
          go$r = b;
          continue;
        }
        if (v.tag === "Cons") {
          go$a0 = insert3(ordVertex)(v._1)()(b);
          go$a1 = v._2;
          continue;
        }
        fail();
      }
      return go$r;
    };
    return go(Leaf);
  })();
  var mempty3 = /* @__PURE__ */ (() => monoidSet(ordVertex).mempty)();
  var monadWithGraphWithGraphT = (dictMonad) => {
    const $0 = dictMonad.Bind1().Apply0().Functor0();
    const $1 = monadStateStateT(dictMonad);
    const monadStateT = { Applicative0: () => applicativeStateT(dictMonad), Bind1: () => bindStateT(dictMonad) };
    return {
      extend: (\u03B1) => (\u03B1s) => {
        const $2 = Cons($Tuple(\u03B1, \u03B1s));
        const $3 = $1.state((s) => $Tuple(void 0, $2(s)));
        return (s) => $0.map((v1) => $Tuple(void 0, v1._2))($3(s));
      },
      Monad0: () => monadStateT
    };
  };
  var monadAllocAllocT = (dictMonad) => {
    const monadStateT = { Applicative0: () => applicativeStateT(dictMonad), Bind1: () => bindStateT(dictMonad) };
    return {
      fresh: bindStateT(dictMonad).bind(monadStateStateT(dictMonad).state((s) => {
        const s$p = 1 + s | 0;
        return $Tuple(s$p, s$p);
      }))((n) => applicativeStateT(dictMonad).pure(showIntImpl(n))),
      Monad0: () => monadStateT
    };
  };
  var runAllocT = (dictMonad) => (m) => (n) => dictMonad.Bind1().bind(m(n))((v) => dictMonad.Applicative0().pure($Tuple(
    v._2,
    $Tuple(
      fromFoldable15(listMap((x2) => showIntImpl(x2))((() => {
        const $0 = n + 1 | 0;
        if (v._2 < $0) {
          return Nil;
        }
        return range3($0)(v._2);
      })())),
      v._1
    )
  )));
  var monadAllocWithGraphAllocT = (dictMonad) => {
    const monadStateT = { Applicative0: () => applicativeStateT(dictMonad), Bind1: () => bindStateT(dictMonad) };
    const monadStateT1 = { Applicative0: () => applicativeStateT(monadStateT), Bind1: () => bindStateT(monadStateT) };
    return {
      fresh: (() => {
        const $0 = monadAllocAllocT(dictMonad).fresh;
        return (s) => monadStateT.Bind1().bind($0)((x2) => monadStateT.Applicative0().pure($Tuple(x2, s)));
      })(),
      Monad0: () => monadStateT1
    };
  };
  var freezeGraph = (dictMonad) => {
    const $0 = dictMonad.Bind1().Apply0().Functor0();
    return (dictGraph) => (m) => (\u03B1s) => {
      const $1 = dictGraph.fromEdgeList(\u03B1s);
      return $0.map((v) => $Tuple($1(spyWhen(false)("runWithGraphT edge list")(showEdgeList)(v._1)), v._2))($0.map(swap)(m(Nil)));
    };
  };
  var runWithGraphT = (dictMonad) => {
    const freezeGraph1 = freezeGraph(dictMonad);
    return (dictGraph) => {
      const freezeGraph2 = freezeGraph1(dictGraph);
      return (m) => (\u03B1s) => dictMonad.Bind1().bind(freezeGraph2(m)(\u03B1s))((v) => {
        const $0 = v._1;
        return assertWhen(true)("edgeListGC")((v1) => dictGraph.Eq0().eq($0)(dictGraph.fromEdgeList(mempty3)(toEdgeList(dictGraph)($0))))(dictMonad.Applicative0().pure($Tuple(
          $0,
          v._2
        )));
      });
    };
  };
  var runWithGraphT_spy = (dictMonad) => {
    const runWithGraphT2 = runWithGraphT(dictMonad);
    const spyFunWhenM2 = spyFunWhenM(dictMonad.Bind1().Apply0().Functor0());
    return (dictGraph) => {
      const $0 = runWithGraphT2(dictGraph);
      const $1 = spyFunWhenM2(false)("runWithGraphT")(showVertices)((x2) => showEdgeList(toEdgeList(dictGraph)(x2._1)));
      return (x2) => $1($0(x2));
    };
  };
  var runWithGraphT_spy1 = /* @__PURE__ */ runWithGraphT_spy(monadIdentity);
  var monadWithGraphAllocWithGr = (dictMonadError) => {
    const Monad0 = dictMonadError.MonadThrow0().Monad0();
    const monadStateT = { Applicative0: () => applicativeStateT(Monad0), Bind1: () => bindStateT(Monad0) };
    const bindStateT2 = bindStateT(monadStateT);
    const monadAllocWithGraphAllocT1 = monadAllocWithGraphAllocT(Monad0);
    const fresh1 = monadAllocWithGraphAllocT1.fresh;
    const monadWithGraphWithGraphT1 = monadWithGraphWithGraphT(monadStateT);
    const monadErrorStateT2 = monadErrorStateT(monadErrorStateT(dictMonadError));
    return {
      new: (\u03B1s) => bindStateT2.bind(fresh1)((\u03B1) => bindStateT2.bind(monadWithGraphWithGraphT1.extend(\u03B1)(\u03B1s))(() => applicativeStateT(monadStateT).pure(\u03B1))),
      MonadAlloc0: () => monadAllocWithGraphAllocT1,
      MonadError1: () => monadErrorStateT2,
      MonadWithGraph2: () => monadWithGraphWithGraphT1
    };
  };

  // output-es/Graph.Slice/index.js
  var pure = /* @__PURE__ */ (() => applicativeStateT(monadIdentity).pure)();
  var extend3 = /* @__PURE__ */ (() => monadWithGraphWithGraphT(monadIdentity).extend)();
  var tailRecM = /* @__PURE__ */ (() => monadRecStateT(monadRecIdentity).tailRecM)();
  var member3 = /* @__PURE__ */ (() => setSet(ordVertex).member)();
  var fromFoldable16 = /* @__PURE__ */ (() => foldableSet.foldr(Cons)(Nil))();
  var fwdSlice = (dictGraph) => {
    const runWithGraph_spy = runWithGraphT_spy1(dictGraph);
    return (v) => {
      const $0 = v._2;
      const $1 = v._1;
      return runWithGraph_spy(tailRecM((v1) => {
        if (v1.es.tag === "Nil") {
          return pure($Step("Done", void 0));
        }
        if (v1.es.tag === "Cons") {
          const $2 = lookup2(ordVertex)(v1.es._1._1)(v1.pending);
          const \u03B2s = (() => {
            if ($2.tag === "Nothing") {
              return $$$Map("Node", 1, 1, v1.es._1._2, void 0, Leaf, Leaf);
            }
            if ($2.tag === "Just") {
              return insert3(ordVertex)(v1.es._1._2)()($2._1);
            }
            fail();
          })();
          if (eqMap(eqVertex)(eqUnit).eq(\u03B2s)(dictGraph.outN($0)(v1.es._1._1))) {
            return bindStateT(monadIdentity).bind(extend3(v1.es._1._1)(\u03B2s))(() => pure($Step(
              "Loop",
              {
                pending: $$delete2(ordVertex)(v1.es._1._1)(v1.pending),
                es: foldableList.foldr(Cons)(v1.es._2)(inEdges$p(dictGraph)($0)(v1.es._1._1))
              }
            )));
          }
          return pure($Step("Loop", { pending: insert3(ordVertex)(v1.es._1._1)(\u03B2s)(v1.pending), es: v1.es._2 }));
        }
        fail();
      })({ pending: Leaf, es: inEdges(dictGraph)($0)($1) }))(assertWhen(true)("inputs are sinks")((v$1) => unsafeDifference(
        ordVertex.compare,
        $1,
        dictGraph.sinks($0)
      ).tag === "Leaf")($1))._1;
    };
  };
  var bwdSlice = (dictGraph) => {
    const runWithGraph_spy = runWithGraphT_spy1(dictGraph);
    return (v) => {
      const $0 = v._2;
      const $1 = v._1;
      return runWithGraph_spy(tailRecM((v1) => {
        if (v1["\u03B1s"].tag === "Nil") {
          if (v1.pending.tag === "Nil") {
            return pure($Step("Done", void 0));
          }
          if (v1.pending.tag === "Cons") {
            if (member3(v1.pending._1._1)(v1.visited)) {
              return pure($Step("Loop", { visited: v1.visited, "\u03B1s": Nil, pending: v1.pending._2 }));
            }
            return bindStateT(monadIdentity).bind(extend3(v1.pending._1._1)(v1.pending._1._2))(() => pure($Step(
              "Loop",
              { visited: insert3(ordVertex)(v1.pending._1._1)()(v1.visited), "\u03B1s": Nil, pending: v1.pending._2 }
            )));
          }
          fail();
        }
        if (v1["\u03B1s"].tag === "Cons") {
          const \u03B2s = dictGraph.outN($0)(v1["\u03B1s"]._1);
          return pure($Step(
            "Loop",
            {
              visited: v1.visited,
              "\u03B1s": foldableList.foldr(Cons)(v1["\u03B1s"]._2)(fromFoldable16(\u03B2s)),
              pending: $List("Cons", $Tuple(v1["\u03B1s"]._1, \u03B2s), v1.pending)
            }
          ));
        }
        fail();
      })({
        visited: Leaf,
        "\u03B1s": fromFoldable16(unsafeIntersectionWith(
          ordVertex.compare,
          $$const,
          assertWhen(true)("inputs are sinks")((v$1) => unsafeDifference(ordVertex.compare, $1, dictGraph.Vertices1().vertices($0)).tag === "Leaf")($1),
          dictGraph.sources($0)
        )),
        pending: Nil
      }))(Leaf)._1;
    };
  };

  // output-es/EvalGraph/index.js
  var setSet4 = /* @__PURE__ */ setSet(ordVertex);
  var disjointUnion2 = /* @__PURE__ */ disjointUnion(mapEnvStringVal);
  var fromFoldable17 = /* @__PURE__ */ (() => foldableSet.foldl((m) => (a) => insert3(ordString)(a)()(m))(Leaf))();
  var show22 = /* @__PURE__ */ (() => showSet(showString).show)();
  var toUnfoldable8 = /* @__PURE__ */ (() => {
    const $0 = toUnfoldable2(unfoldableList);
    return (x2) => $0(keys2(x2));
  })();
  var union1 = /* @__PURE__ */ (() => setSet(ordString).union)();
  var fv = /* @__PURE__ */ (() => fVDict(fVElim).fv)();
  var fromFoldable18 = /* @__PURE__ */ fromFoldable(foldableList);
  var greaterThanOrEq = /* @__PURE__ */ (() => {
    const $0 = ordTuple(ordInt)(ordInt);
    return (a1) => (a2) => $0.compare(a1)(a2) !== "LT";
  })();
  var show3 = (v) => "(Tuple " + showIntImpl(v._1) + " " + showIntImpl(v._2) + ")";
  var concatM = (dictMonad) => foldableList.foldr((() => {
    const $0 = dictMonad.Bind1();
    return (f) => (g) => (a) => $0.bind(f(a))(g);
  })())(dictMonad.Applicative0().pure);
  var fwdSlice2 = /* @__PURE__ */ fwdSlice(graphGraphImpl);
  var bwdSlice2 = /* @__PURE__ */ bwdSlice(graphGraphImpl);
  var mempty4 = /* @__PURE__ */ (() => monoidSet(ordVertex).mempty)();
  var vertices = /* @__PURE__ */ (() => verticesVertex(functorEnvExpr)(foldableEnvExpr).vertices)();
  var vertices1 = /* @__PURE__ */ (() => verticesVertex(functorVal)(foldableVal).vertices)();
  var matchMany = (dictMonadWithGraphAlloc) => {
    const Monad0 = dictMonadWithGraphAlloc.MonadWithGraph2().Monad0();
    const $0 = Monad0.Applicative0();
    const $1 = Monad0.Bind1();
    const $$throw2 = $$throw(dictMonadWithGraphAlloc.MonadError1().MonadThrow0());
    return (v) => (v1) => {
      if (v.tag === "Nil") {
        return $0.pure($Tuple(empty2, $Tuple(v1, setSet4.empty)));
      }
      if (v.tag === "Cons") {
        if (v1.tag === "ContElim") {
          const $2 = v._2;
          return $1.bind(match(dictMonadWithGraphAlloc)(v._1)(v1._1))((v3) => {
            const $3 = v3._2._2;
            const $4 = v3._1;
            return $1.bind(matchMany(dictMonadWithGraphAlloc)($2)(v3._2._1))((v4) => $0.pure($Tuple(
              disjointUnion2($4)(v4._1),
              $Tuple(v4._2._1, setSet4.union($3)(v4._2._2))
            )));
          });
        }
        if (v1.tag === "ContExpr") {
          return $$throw2(showIntImpl((() => {
            const go = (go$a0$copy) => (go$a1$copy) => {
              let go$a0 = go$a0$copy, go$a1 = go$a1$copy, go$c = true, go$r;
              while (go$c) {
                const b = go$a0, v$1 = go$a1;
                if (v$1.tag === "Nil") {
                  go$c = false;
                  go$r = b;
                  continue;
                }
                if (v$1.tag === "Cons") {
                  go$a0 = b + 1 | 0;
                  go$a1 = v$1._2;
                  continue;
                }
                fail();
              }
              return go$r;
            };
            return go(0)(v._2) + 1 | 0;
          })()) + " extra argument(s) to constructor/record; did you forget parentheses in lambda pattern?");
        }
      }
      fail();
    };
  };
  var match = (dictMonadWithGraphAlloc) => {
    const Monad0 = dictMonadWithGraphAlloc.MonadWithGraph2().Monad0();
    const $0 = Monad0.Applicative0();
    const Bind1 = Monad0.Bind1();
    const MonadError1 = dictMonadWithGraphAlloc.MonadError1();
    const withMsg2 = withMsg(MonadError1);
    const consistentWith2 = consistentWith(MonadError1);
    const MonadThrow0 = MonadError1.MonadThrow0();
    return (v) => (v1) => {
      if (v1.tag === "ElimVar") {
        if (v1._1 === "_") {
          return $0.pure($Tuple(empty2, $Tuple(v1._2, setSet4.empty)));
        }
        const $1 = v1._1;
        return $0.pure($Tuple(
          (() => {
            const $2 = {};
            $2[$1] = v;
            return $2;
          })(),
          $Tuple(v1._2, setSet4.empty)
        ));
      }
      if (v1.tag === "ElimConstr") {
        if (v._2.tag === "Constr") {
          const $1 = v._2._1;
          const $2 = v1._1;
          const $3 = v._2._2;
          const $4 = v._1;
          return Bind1.bind(withMsg2("Pattern mismatch")(consistentWith2($$$Map("Node", 1, 1, $1, void 0, Leaf, Leaf))(mapObjectString.keys($2))))(() => Bind1.bind(orElse(MonadThrow0)("Incomplete patterns: no branch for " + showCtr($1))(_lookup(
            Nothing,
            Just,
            $1,
            $2
          )))((\u03BA) => Bind1.bind(matchMany(dictMonadWithGraphAlloc)($3)(\u03BA))((v2) => $0.pure($Tuple(
            v2._1,
            $Tuple(v2._2._1, insert3(ordVertex)($4)()(v2._2._2))
          )))));
        }
        return Bind1.bind(dataTypeForSetCtr.dataTypeFor(MonadThrow0)(mapObjectString.keys(v1._1)))((d) => MonadThrow0.throwError(error("Pattern mismatch: found " + intercalate3("\n")(removeDocWS(prettyVal(highlightableVertex).pretty(v)).lines) + ", expected " + d._1)));
      }
      if (v1.tag === "ElimRecord") {
        if (v._2.tag === "Record") {
          const $1 = v1._1;
          const $2 = v._2._1;
          const $3 = v._1;
          const $4 = v1._2;
          return Bind1.bind(check(MonadThrow0)(unsafeDifference(ordString.compare, $1, fromFoldable17(mapObjectString.keys($2))).tag === "Leaf")("Pattern mismatch: found " + show22(mapObjectString.keys($2)) + ", expected " + show22($1)))(() => Bind1.bind(matchMany(dictMonadWithGraphAlloc)(listMap((a) => $$get(showString)(mapDictString)(a)($2))(toUnfoldable8($1)))($4))((v2) => $0.pure($Tuple(
            v2._1,
            $Tuple(v2._2._1, insert3(ordVertex)($3)()(v2._2._2))
          ))));
        }
        return MonadThrow0.throwError(error("Pattern mismatch: found " + intercalate3("\n")(removeDocWS(prettyVal(highlightableVertex).pretty(v)).lines) + ", expected " + show22(v1._1)));
      }
      fail();
    };
  };
  var graphGC = (dictGraph) => {
    const $0 = dictGraph.Vertices1();
    return (dictApply) => {
      const select\u03B1s\u{1D539}Vertex2 = select\u03B1s\u{1D539}Vertex(dictApply);
      return (dictApply1) => {
        const select\u03B1s\u{1D539}Vertex1 = select\u03B1s\u{1D539}Vertex(dictApply1);
        return (dictFoldable) => {
          const select\u03B1s\u{1D539}Vertex22 = select\u03B1s\u{1D539}Vertex2(dictFoldable);
          return (dictFoldable1) => {
            const select\u03B1s\u{1D539}Vertex3 = select\u03B1s\u{1D539}Vertex1(dictFoldable1);
            return (v) => {
              const $1 = v.g;
              const $2 = v["in\u03B1"];
              const $3 = v["out\u03B1"];
              return {
                fwd: (in\u{1D539}) => select\u03B1s\u{1D539}Vertex3["select\u{1D539}s"]($3)($0.vertices(v.graph_fwd(select\u03B1s\u{1D539}Vertex22["select\u03B1s"](in\u{1D539})($2))($1))),
                bwd: (out\u{1D539}) => select\u03B1s\u{1D539}Vertex22["select\u{1D539}s"]($2)($0.vertices(v.graph_bwd(select\u03B1s\u{1D539}Vertex3["select\u03B1s"](out\u{1D539})($3))($1)))
              };
            };
          };
        };
      };
    };
  };
  var closeDefs = (dictMonadWithGraphAlloc) => {
    const Monad0 = dictMonadWithGraphAlloc.MonadWithGraph2().Monad0();
    const Functor0 = Monad0.Bind1().Apply0().Functor0();
    const traverse2 = traversableDict.traverse(Monad0.Applicative0());
    return (\u03B3) => (\u03C1) => (\u03B1s) => Functor0.map(Env)(traverse2((\u03C3) => {
      const \u03C1$p = forDefs(\u03C1)(\u03C3);
      const $0 = $BaseVal(
        "Fun",
        $Fun(
          "Closure",
          (() => {
            const $02 = union1(fv(\u03C1$p))(fVElim.fv(\u03C3));
            return filterWithKey((x2) => {
              const $1 = setSet(ordString).member(x2)($02);
              return (v) => $1;
            })(\u03B3);
          })(),
          \u03C1$p,
          \u03C3
        )
      );
      return Functor0.map((f) => f($0))(Functor0.map(Val)(dictMonadWithGraphAlloc.new(\u03B1s)));
    })(\u03C1));
  };
  var $$eval = (dictMonadWithGraphAlloc) => {
    const MonadError1 = dictMonadWithGraphAlloc.MonadError1();
    const withMsg2 = withMsg(MonadError1);
    const MonadThrow0 = MonadError1.MonadThrow0();
    const Monad0 = dictMonadWithGraphAlloc.MonadWithGraph2().Monad0();
    const Bind1 = Monad0.Bind1();
    const Functor0 = Bind1.Apply0().Functor0();
    const Applicative0 = Monad0.Applicative0();
    const traverse3 = traversableDict.traverse(Applicative0);
    const traverse4 = traversableList.traverse(Applicative0);
    const traverse5 = traversablePair.traverse(Applicative0);
    const checkArity3 = checkArity(MonadError1);
    const sequence1 = traversableArray.traverse(Applicative0)(identity7);
    const match1 = match(dictMonadWithGraphAlloc);
    const closeDefs1 = closeDefs(dictMonadWithGraphAlloc);
    return (v) => (v1) => (v2) => {
      if (v1.tag === "Var") {
        return withMsg2("Variable lookup")(lookup$p(MonadThrow0)(showString)(mapEnvStringVal)(v1._1)(v));
      }
      if (v1.tag === "Op") {
        return withMsg2("Variable lookup")(lookup$p(MonadThrow0)(showString)(mapEnvStringVal)(v1._1)(v));
      }
      if (v1.tag === "Int") {
        return Functor0.map((f) => f($BaseVal("Int", v1._2)))(Functor0.map(Val)(dictMonadWithGraphAlloc.new(insert3(ordVertex)(v1._1)()(v2))));
      }
      if (v1.tag === "Float") {
        return Functor0.map((f) => f($BaseVal("Float", v1._2)))(Functor0.map(Val)(dictMonadWithGraphAlloc.new(insert3(ordVertex)(v1._1)()(v2))));
      }
      if (v1.tag === "Str") {
        return Functor0.map((f) => f($BaseVal("Str", v1._2)))(Functor0.map(Val)(dictMonadWithGraphAlloc.new(insert3(ordVertex)(v1._1)()(v2))));
      }
      if (v1.tag === "Record") {
        const $0 = v1._1;
        return Bind1.bind(traverse3((() => {
          const $1 = $$eval(dictMonadWithGraphAlloc)(v);
          return (a) => $1(a)(v2);
        })())(v1._2))((xvs) => Functor0.map((f) => f($BaseVal("Record", xvs)))(Functor0.map(Val)(dictMonadWithGraphAlloc.new(insert3(ordVertex)($0)()(v2)))));
      }
      if (v1.tag === "Dictionary") {
        const $0 = v1._1;
        return Bind1.bind(Functor0.map(unzip4)(traverse4(traverse5((() => {
          const $1 = $$eval(dictMonadWithGraphAlloc)(v);
          return (a) => $1(a)(v2);
        })()))(v1._2)))((v3) => {
          const v4 = unzip2(listMap((v$1) => $Tuple(v$1._2.tag === "Str" ? v$1._2._1 : typeError(v$1._2)("Str"), v$1._1))(v3._1));
          const $1 = $BaseVal("Dictionary", fromFoldable18(zipWith2(Tuple)(v4._1)(zipWith2(Tuple)(v4._2)(v3._2))));
          return Functor0.map((f) => f($1))(Functor0.map(Val)(dictMonadWithGraphAlloc.new(insert3(ordVertex)($0)()(v2))));
        });
      }
      if (v1.tag === "Constr") {
        const $0 = v1._2;
        const $1 = v1._3;
        const $2 = v1._1;
        return Bind1.bind(checkArity3($0)((() => {
          const go = (go$a0$copy) => (go$a1$copy) => {
            let go$a0 = go$a0$copy, go$a1 = go$a1$copy, go$c = true, go$r;
            while (go$c) {
              const b = go$a0, v$1 = go$a1;
              if (v$1.tag === "Nil") {
                go$c = false;
                go$r = b;
                continue;
              }
              if (v$1.tag === "Cons") {
                go$a0 = b + 1 | 0;
                go$a1 = v$1._2;
                continue;
              }
              fail();
            }
            return go$r;
          };
          return go(0)($1);
        })()))(() => Bind1.bind(traverse4((() => {
          const $3 = $$eval(dictMonadWithGraphAlloc)(v);
          return (a) => $3(a)(v2);
        })())($1))((vs) => Functor0.map((f) => f($BaseVal("Constr", $0, vs)))(Functor0.map(Val)(dictMonadWithGraphAlloc.new(insert3(ordVertex)($2)()(v2))))));
      }
      if (v1.tag === "Matrix") {
        const $0 = v1._2;
        const $1 = v1._3._1;
        const $2 = v1._3._2;
        const $3 = v1._1;
        return Bind1.bind($$eval(dictMonadWithGraphAlloc)(v)(v1._4)(v2))((v3) => {
          const v5 = intPair.unpack(v3._2);
          const $4 = v5._1._1;
          const $5 = v5._2._1;
          const $6 = v5._1._2;
          const $7 = v5._2._2;
          return Bind1.bind(check(MonadThrow0)(greaterThanOrEq($Tuple($4, $5))($Tuple(1, 1)))("array must be at least (" + show3($Tuple(1, 1)) + "); got (" + show3($Tuple(
            $4,
            $5
          )) + ")"))(() => Bind1.bind(sequence1(arrayBind(rangeImpl(1, $4))((i) => [
            sequence1(arrayBind(rangeImpl(1, $5))((j) => [
              $$eval(dictMonadWithGraphAlloc)(unionWith((v$1) => identity15)(v)(disjointUnion2((() => {
                const $8 = {};
                $8[$1] = $Val($6, $BaseVal("Int", i));
                return $8;
              })())((() => {
                const $8 = {};
                $8[$2] = $Val($7, $BaseVal("Int", j));
                return $8;
              })())))($0)(v2)
            ]))
          ])))((vss) => Functor0.map((f) => f($BaseVal("Matrix", $Tuple(vss, $Tuple($Tuple($4, $6), $Tuple($5, $7))))))(Functor0.map(Val)(dictMonadWithGraphAlloc.new(insert3(ordVertex)($3)()(v2))))));
        });
      }
      if (v1.tag === "Lambda") {
        const $0 = $BaseVal(
          "Fun",
          $Fun(
            "Closure",
            (() => {
              const $02 = fVElim.fv(v1._2);
              return filterWithKey((x2) => {
                const $1 = setSet(ordString).member(x2)($02);
                return (v$1) => $1;
              })(v);
            })(),
            empty2,
            v1._2
          )
        );
        return Functor0.map((f) => f($0))(Functor0.map(Val)(dictMonadWithGraphAlloc.new(insert3(ordVertex)(v1._1)()(v2))));
      }
      if (v1.tag === "Project") {
        const $0 = v1._2;
        return Bind1.bind($$eval(dictMonadWithGraphAlloc)(v)(v1._1)(v2))((v3) => {
          if (v3._2.tag === "Record") {
            return withMsg2("Record lookup")(lookup$p(MonadThrow0)(showString)(mapDictString)($0)(v3._2._1));
          }
          return MonadThrow0.throwError(error("Found " + intercalate3("\n")(removeDocWS(prettyVal(highlightableVertex).pretty(v3)).lines) + ", expected record"));
        });
      }
      if (v1.tag === "App") {
        const $0 = v1._2;
        return Bind1.bind($$eval(dictMonadWithGraphAlloc)(v)(v1._1)(v2))((v3) => Bind1.bind($$eval(dictMonadWithGraphAlloc)(v)($0)(v2))((v$p) => apply2(dictMonadWithGraphAlloc)(v3)(v$p)));
      }
      if (v1.tag === "Let") {
        const $0 = v1._2;
        const $1 = v1._1._1;
        return Bind1.bind($$eval(dictMonadWithGraphAlloc)(v)(v1._1._2)(v2))((v3) => Bind1.bind(match1(v3)($1))((v4) => $$eval(dictMonadWithGraphAlloc)(unionWith((v$1) => identity15)(v)(v4._1))($0)(v4._2._2)));
      }
      if (v1.tag === "LetRec") {
        const $0 = v1._2;
        const $1 = v1._1._1;
        return Bind1.bind(closeDefs1(v)(v1._1._2)(insert3(ordVertex)($1)()(v2)))((\u03B3$p) => $$eval(dictMonadWithGraphAlloc)(unionWith((v$1) => identity15)(v)(\u03B3$p))($0)(insert3(ordVertex)($1)()(v2)));
      }
      fail();
    };
  };
  var apply2 = (dictMonadWithGraphAlloc) => {
    const Bind1 = dictMonadWithGraphAlloc.MonadWithGraph2().Monad0().Bind1();
    const closeDefs1 = closeDefs(dictMonadWithGraphAlloc);
    const match1 = match(dictMonadWithGraphAlloc);
    const Functor0 = Bind1.Apply0().Functor0();
    const MonadError1 = dictMonadWithGraphAlloc.MonadError1();
    const MonadThrow0 = MonadError1.MonadThrow0();
    return (v) => (v1) => {
      const $0 = (v2) => MonadThrow0.throwError(error("Found " + intercalate3("\n")(removeDocWS(prettyVal(highlightableVertex).pretty(v2)).lines) + ", expected function"));
      if (v._2.tag === "Fun") {
        if (v._2._1.tag === "Closure") {
          const $1 = v._1;
          const $2 = v._2._1._1;
          const $3 = v._2._1._3;
          return Bind1.bind(closeDefs1($2)(v._2._1._2)($$$Map("Node", 1, 1, $1, void 0, Leaf, Leaf)))((\u03B32) => Bind1.bind(match1(v1)($3))((v3) => $$eval(dictMonadWithGraphAlloc)(unionWith((v$1) => identity15)(unionWith((v$1) => identity15)($2)(\u03B32))(v3._1))(v3._2._1.tag === "ContExpr" ? v3._2._1._1 : throwException(error("Expression expected"))())(insert3(ordVertex)($1)()(v3._2._2))));
        }
        if (v._2._1.tag === "Foreign") {
          const $1 = v._2._1._1._1;
          const $2 = v._2._1._1._2;
          const vs$p = foldableList.foldr(Cons)($List("Cons", v1, Nil))(v._2._1._2);
          if ((() => {
            const go = (go$a0$copy) => (go$a1$copy) => {
              let go$a0 = go$a0$copy, go$a1 = go$a1$copy, go$c = true, go$r;
              while (go$c) {
                const b = go$a0, v$1 = go$a1;
                if (v$1.tag === "Nil") {
                  go$c = false;
                  go$r = b;
                  continue;
                }
                if (v$1.tag === "Cons") {
                  go$a0 = b + 1 | 0;
                  go$a1 = v$1._2;
                  continue;
                }
                fail();
              }
              return go$r;
            };
            return $2._1.arity > go(0)(vs$p);
          })()) {
            return Functor0.map((f) => f($BaseVal("Fun", $Fun("Foreign", $Tuple($1, $2), vs$p))))(Functor0.map(Val)(dictMonadWithGraphAlloc.new($$$Map(
              "Node",
              1,
              1,
              v._1,
              void 0,
              Leaf,
              Leaf
            ))));
          }
          return $2._1["op'"](dictMonadWithGraphAlloc)(MonadError1)(vs$p);
        }
        if (v._2._1.tag === "PartialConstr") {
          const $1 = v._2._1._1;
          const $2 = v._2._1._2;
          const $3 = v._1;
          const n = defined(arity(monadThrowExceptT(monadIdentity))($1));
          return Bind1.bind(check(MonadThrow0)((() => {
            const go = (go$a0$copy) => (go$a1$copy) => {
              let go$a0 = go$a0$copy, go$a1 = go$a1$copy, go$c = true, go$r;
              while (go$c) {
                const b = go$a0, v$1 = go$a1;
                if (v$1.tag === "Nil") {
                  go$c = false;
                  go$r = b;
                  continue;
                }
                if (v$1.tag === "Cons") {
                  go$a0 = b + 1 | 0;
                  go$a1 = v$1._2;
                  continue;
                }
                fail();
              }
              return go$r;
            };
            return go(0)($2) < n;
          })())("Too many arguments to " + showCtr($1)))(() => {
            if ((() => {
              const go = (go$a0$copy) => (go$a1$copy) => {
                let go$a0 = go$a0$copy, go$a1 = go$a1$copy, go$c = true, go$r;
                while (go$c) {
                  const b = go$a0, v$1 = go$a1;
                  if (v$1.tag === "Nil") {
                    go$c = false;
                    go$r = b;
                    continue;
                  }
                  if (v$1.tag === "Cons") {
                    go$a0 = b + 1 | 0;
                    go$a1 = v$1._2;
                    continue;
                  }
                  fail();
                }
                return go$r;
              };
              return go(0)($2) < (n - 1 | 0);
            })()) {
              const $42 = $BaseVal(
                "Fun",
                $Fun("PartialConstr", $1, foldableList.foldr(Cons)($List("Cons", v1, Nil))($2))
              );
              return Functor0.map((f) => f($42))(Functor0.map(Val)(dictMonadWithGraphAlloc.new($$$Map(
                "Node",
                1,
                1,
                $3,
                void 0,
                Leaf,
                Leaf
              ))));
            }
            const $4 = $BaseVal("Constr", $1, foldableList.foldr(Cons)($List("Cons", v1, Nil))($2));
            return Functor0.map((f) => f($4))(Functor0.map(Val)(dictMonadWithGraphAlloc.new($$$Map(
              "Node",
              1,
              1,
              $3,
              void 0,
              Leaf,
              Leaf
            ))));
          });
        }
      }
      return $0(v1);
    };
  };
  var eval_module = (dictMonadWithGraphAlloc) => {
    const Monad0 = dictMonadWithGraphAlloc.MonadWithGraph2().Monad0();
    const $0 = Monad0.Bind1();
    const eval1 = $$eval(dictMonadWithGraphAlloc);
    const match1 = match(dictMonadWithGraphAlloc);
    const closeDefs1 = closeDefs(dictMonadWithGraphAlloc);
    return (\u03B3) => {
      const go = (v) => (v1) => (v2) => {
        if (v1.tag === "Nil") {
          return Monad0.Applicative0().pure(v);
        }
        if (v1.tag === "Cons") {
          if (v1._1.tag === "Left") {
            const $1 = v1._2;
            const $2 = v1._1._1._1;
            return $0.bind(eval1(unionWith((v$1) => identity15)(\u03B3)(v))(v1._1._1._2)(v2))((v3) => $0.bind(match1(v3)($2))((v4) => go(unionWith((v$1) => identity15)(v)(v4._1))($1)(v4._2._2)));
          }
          if (v1._1.tag === "Right") {
            const $1 = v1._2;
            return $0.bind(closeDefs1(unionWith((v$1) => identity15)(\u03B3)(v))(v1._1._1._2)(insert3(ordVertex)(v1._1._1._1)()(v2)))((\u03B3$p$p) => go(unionWith((v$1) => identity15)(v)(\u03B3$p$p))($1)(v2));
          }
        }
        fail();
      };
      return go(empty2);
    };
  };
  var eval_progCxt = (dictMonadWithGraphAlloc) => {
    const Monad0 = dictMonadWithGraphAlloc.MonadWithGraph2().Monad0();
    const $0 = Monad0.Bind1();
    const eval_module1 = eval_module(dictMonadWithGraphAlloc);
    const $1 = Monad0.Applicative0();
    const eval1 = $$eval(dictMonadWithGraphAlloc);
    const concatM1 = concatM(Monad0);
    return (v) => concatM1(foldableList.foldr(Cons)(listMap((v1) => (\u03B3) => {
      const $2 = v1._1;
      return $0.bind(eval1(\u03B3)(v1._2)(setSet4.empty))((v2) => $1.pure(unionWith((v$1) => identity15)(\u03B3)((() => {
        const $3 = {};
        $3[$2] = v2;
        return $3;
      })())));
    })(reverse2(v.datasets)))(listMap((mod) => (\u03B3) => $0.bind(eval_module1(\u03B3)(mod)(setSet4.empty))((\u03B3$p) => $1.pure(unionWith((v$1) => identity15)(\u03B3)(\u03B3$p))))(reverse2(v.mods))))(v.primitives);
  };
  var graphEval = (dictMonadError) => {
    const MonadThrow0 = dictMonadError.MonadThrow0();
    const Monad0 = MonadThrow0.Monad0();
    const bindStateT2 = bindStateT(Monad0);
    const $0 = monadAllocAllocT(Monad0);
    const fresh1 = $0.fresh;
    const alloc = traversableExpr.traverse($0.Monad0().Applicative0())((v) => fresh1);
    const runWithGraphT_spy2 = runWithGraphT_spy({
      Applicative0: () => applicativeStateT(Monad0),
      Bind1: () => bindStateT(Monad0)
    })(graphGraphImpl);
    const eval1 = $$eval(monadWithGraphAllocWithGr(dictMonadError));
    const check2 = check(monadThrowStateT(MonadThrow0));
    return (v) => (e) => {
      const $1 = v["\u03B3"];
      const $2 = spyFunWhen(false)("fwdSlice")((x2) => $Tuple(showVertices(x2._1), showEdgeList(toEdgeList(graphGraphImpl)(x2._2))))(showGraph(graphGraphImpl))(fwdSlice2);
      const $3 = spyFunWhen(false)("bwdSlice")((x2) => $Tuple(showVertices(x2._1), showEdgeList(toEdgeList(graphGraphImpl)(x2._2))))(showGraph(graphGraphImpl))(bwdSlice2);
      return Monad0.Bind1().bind(runAllocT(Monad0)(bindStateT2.bind(alloc(e))((e\u03B1) => bindStateT2.bind(runWithGraphT_spy2(eval1($1)(e\u03B1)(mempty4))(vertices($EnvExpr(
        $1,
        e\u03B1
      ))))((v1) => {
        const $4 = v1._1;
        const $5 = v1._2;
        return bindStateT2.bind(check2(unsafeDifference(ordVertex.compare, vertices1($5), $4._1.vertices).tag === "Leaf")("outputs in graph"))(() => applicativeStateT(Monad0).pure($Tuple(
          $4,
          $Tuple($EnvExpr($1, e\u03B1), $5)
        )));
      })))(v.n))((v1) => Monad0.Applicative0().pure({
        g: v1._2._2._1,
        graph_fwd: (a) => (b) => $2($Tuple(a, b)),
        graph_bwd: (a) => (b) => $3($Tuple(a, b)),
        "in\u03B1": v1._2._2._2._1,
        "out\u03B1": v1._2._2._2._2
      }));
    };
  };

  // output-es/GaloisConnection/index.js
  var identity27 = (x2) => x2;
  var semigroupoidGaloisConnect = { compose: (v) => (v1) => ({ fwd: (x2) => v.fwd(v1.fwd(x2)), bwd: (x2) => v1.bwd(v.bwd(x2)) }) };
  var categoryGaloisConnection = { identity: { fwd: identity27, bwd: identity27 }, Semigroupoid0: () => semigroupoidGaloisConnect };

  // output-es/Affjax.RequestHeader/index.js
  var $RequestHeader = (tag, _1, _2) => ({ tag, _1, _2 });

  // output-es/Affjax.ResponseFormat/index.js
  var $ResponseFormat = (tag, _1) => ({ tag, _1 });
  var identity28 = (x2) => x2;

  // output-es/Affjax.ResponseHeader/index.js
  var $ResponseHeader = (_1, _2) => ({ tag: "ResponseHeader", _1, _2 });
  var ResponseHeader = (value0) => (value1) => $ResponseHeader(value0, value1);

  // output-es/Data.Argonaut.Core/foreign.js
  function id2(x2) {
    return x2;
  }
  function stringify(j) {
    return JSON.stringify(j);
  }

  // output-es/Data.Argonaut.Core/index.js
  var jsonEmptyObject = /* @__PURE__ */ id2(empty2);

  // output-es/Data.Argonaut.Parser/foreign.js
  function _jsonParser(fail3, succ, s) {
    try {
      return succ(JSON.parse(s));
    } catch (e) {
      return fail3(e.message);
    }
  }

  // output-es/JSURI/foreign.js
  function encodeURIComponent_to_RFC3986(input) {
    return input.replace(/[!'()*]/g, function(c) {
      return "%" + c.charCodeAt(0).toString(16);
    });
  }
  function _encodeFormURLComponent(fail3, succeed, input) {
    try {
      return succeed(encodeURIComponent_to_RFC3986(encodeURIComponent(input)).replace(/%20/g, "+"));
    } catch (err) {
      return fail3(err);
    }
  }

  // output-es/Data.FormURLEncoded/index.js
  var traverse = /* @__PURE__ */ (() => traversableArray.traverse(applicativeMaybe))();
  var encode = /* @__PURE__ */ (() => {
    const $0 = functorMaybe.map(joinWith("&"));
    const $1 = traverse((v) => {
      if (v._2.tag === "Nothing") {
        return _encodeFormURLComponent((v$1) => Nothing, Just, v._1);
      }
      if (v._2.tag === "Just") {
        return applyMaybe.apply((() => {
          const $12 = _encodeFormURLComponent((v$1) => Nothing, Just, v._1);
          if ($12.tag === "Just") {
            return $Maybe(
              "Just",
              (() => {
                const $2 = $12._1;
                return (val) => $2 + "=" + val;
              })()
            );
          }
          return Nothing;
        })())(_encodeFormURLComponent((v$1) => Nothing, Just, v._2._1));
      }
      fail();
    });
    return (x2) => $0($1(x2));
  })();

  // output-es/Data.HTTP.Method/index.js
  var $Method = (tag) => tag;
  var GET = /* @__PURE__ */ $Method("GET");
  var print = (v2) => {
    if (v2.tag === "Left") {
      if (v2._1 === "OPTIONS") {
        return "OPTIONS";
      }
      if (v2._1 === "GET") {
        return "GET";
      }
      if (v2._1 === "HEAD") {
        return "HEAD";
      }
      if (v2._1 === "POST") {
        return "POST";
      }
      if (v2._1 === "PUT") {
        return "PUT";
      }
      if (v2._1 === "DELETE") {
        return "DELETE";
      }
      if (v2._1 === "TRACE") {
        return "TRACE";
      }
      if (v2._1 === "CONNECT") {
        return "CONNECT";
      }
      if (v2._1 === "PROPFIND") {
        return "PROPFIND";
      }
      if (v2._1 === "PROPPATCH") {
        return "PROPPATCH";
      }
      if (v2._1 === "MKCOL") {
        return "MKCOL";
      }
      if (v2._1 === "COPY") {
        return "COPY";
      }
      if (v2._1 === "MOVE") {
        return "MOVE";
      }
      if (v2._1 === "LOCK") {
        return "LOCK";
      }
      if (v2._1 === "UNLOCK") {
        return "UNLOCK";
      }
      if (v2._1 === "PATCH") {
        return "PATCH";
      }
      fail();
    }
    if (v2.tag === "Right") {
      return v2._1;
    }
    fail();
  };

  // output-es/Effect.Aff.Compat/index.js
  var fromEffectFnAff = (v) => makeAff((k) => () => {
    const v1 = v((x2) => k($Either("Left", x2))(), (x2) => k($Either("Right", x2))());
    return (e) => makeAff((k2) => () => {
      v1(e, (x2) => k2($Either("Left", x2))(), (x2) => k2($Either("Right", x2))());
      return nonCanceler;
    });
  });

  // output-es/Foreign/foreign.js
  function tagOf(value) {
    return Object.prototype.toString.call(value).slice(8, -1);
  }
  var isArray = Array.isArray || function(value) {
    return Object.prototype.toString.call(value) === "[object Array]";
  };

  // output-es/Foreign/index.js
  var $ForeignError = (tag, _1, _2) => ({ tag, _1, _2 });
  var renderForeignError = (v) => {
    if (v.tag === "ForeignError") {
      return v._1;
    }
    if (v.tag === "ErrorAtIndex") {
      return "Error at array index " + showIntImpl(v._1) + ": " + renderForeignError(v._2);
    }
    if (v.tag === "ErrorAtProperty") {
      return "Error at property " + showStringImpl(v._1) + ": " + renderForeignError(v._2);
    }
    if (v.tag === "TypeMismatch") {
      return "Type mismatch: expected " + v._1 + ", found " + v._2;
    }
    fail();
  };
  var unsafeReadTagged = (dictMonad) => (tag) => (value) => {
    if (tagOf(value) === tag) {
      return applicativeExceptT(dictMonad).pure(value);
    }
    return monadThrowExceptT(dictMonad).throwError($NonEmpty($ForeignError("TypeMismatch", tag, tagOf(value)), Nil));
  };

  // output-es/Affjax/foreign.js
  function _ajax(platformSpecificDriver, timeoutErrorMessageIdent, requestFailedMessageIdent, mkHeader, options) {
    return function(errback, callback) {
      var xhr = platformSpecificDriver.newXHR();
      var fixedUrl = platformSpecificDriver.fixupUrl(options.url, xhr);
      xhr.open(options.method || "GET", fixedUrl, true, options.username, options.password);
      if (options.headers) {
        try {
          for (var i = 0, header; (header = options.headers[i]) != null; i++) {
            xhr.setRequestHeader(header.field, header.value);
          }
        } catch (e) {
          errback(e);
        }
      }
      var onerror = function(msgIdent) {
        return function() {
          errback(new Error(msgIdent));
        };
      };
      xhr.onerror = onerror(requestFailedMessageIdent);
      xhr.ontimeout = onerror(timeoutErrorMessageIdent);
      xhr.onload = function() {
        callback({
          status: xhr.status,
          statusText: xhr.statusText,
          headers: xhr.getAllResponseHeaders().split("\r\n").filter(function(header2) {
            return header2.length > 0;
          }).map(function(header2) {
            var i2 = header2.indexOf(":");
            return mkHeader(header2.substring(0, i2))(header2.substring(i2 + 2));
          }),
          body: xhr.response
        });
      };
      xhr.responseType = options.responseType;
      xhr.withCredentials = options.withCredentials;
      xhr.timeout = options.timeout;
      xhr.send(options.content);
      return function(error3, cancelErrback, cancelCallback) {
        try {
          xhr.abort();
        } catch (e) {
          return cancelErrback(e);
        }
        return cancelCallback();
      };
    };
  }

  // output-es/Affjax/index.js
  var $$$Error = (tag, _1, _2) => ({ tag, _1, _2 });
  var pure2 = /* @__PURE__ */ (() => applicativeExceptT(monadIdentity).pure)();
  var alt = /* @__PURE__ */ (() => altExceptT(semigroupNonEmptyList)(monadIdentity).alt)();
  var any = /* @__PURE__ */ (() => foldableArray.foldMap((() => {
    const semigroupDisj1 = { append: (v) => (v1) => v || v1 };
    return { mempty: false, Semigroup0: () => semigroupDisj1 };
  })()))();
  var $$try3 = /* @__PURE__ */ $$try(monadErrorAff);
  var TimeoutError = /* @__PURE__ */ $$$Error("TimeoutError");
  var RequestFailedError = /* @__PURE__ */ $$$Error("RequestFailedError");
  var request = (driver2) => (req2) => {
    const fromResponse = (() => {
      if (req2.responseFormat.tag === "ArrayBuffer") {
        return unsafeReadTagged(monadIdentity)("ArrayBuffer");
      }
      if (req2.responseFormat.tag === "Blob") {
        return unsafeReadTagged(monadIdentity)("Blob");
      }
      if (req2.responseFormat.tag === "Document") {
        return (x2) => alt(unsafeReadTagged(monadIdentity)("Document")(x2))(alt(unsafeReadTagged(monadIdentity)("XMLDocument")(x2))(unsafeReadTagged(monadIdentity)("HTMLDocument")(x2)));
      }
      if (req2.responseFormat.tag === "Json") {
        const $0 = bindExceptT(monadIdentity);
        return (a) => $0.bind(unsafeReadTagged(monadIdentity)("String")(a))((x2) => req2.responseFormat._1((() => {
          if (x2 === "") {
            return pure2(jsonEmptyObject);
          }
          const $1 = _jsonParser(Left, Right, x2);
          if ($1.tag === "Left") {
            return monadThrowExceptT(monadIdentity).throwError($NonEmpty(
              $ForeignError("ForeignError", $1._1),
              Nil
            ));
          }
          if ($1.tag === "Right") {
            return pure2($1._1);
          }
          fail();
        })()));
      }
      if (req2.responseFormat.tag === "String") {
        return unsafeReadTagged(monadIdentity)("String");
      }
      if (req2.responseFormat.tag === "Ignore") {
        const $0 = req2.responseFormat._1(pure2());
        return (v) => $0;
      }
      fail();
    })();
    const send = (content2) => _map((v) => {
      if (v.tag === "Right") {
        const $0 = fromResponse(v._1.body);
        if ($0.tag === "Left") {
          return $Either("Left", $$$Error("ResponseBodyError", $0._1._1, v._1));
        }
        if ($0.tag === "Right") {
          return $Either("Right", { ...v._1, body: $0._1 });
        }
        fail();
      }
      if (v.tag === "Left") {
        return $Either(
          "Left",
          (() => {
            const message2 = message(v._1);
            if (message2 === "AffjaxTimeoutErrorMessageIdent") {
              return TimeoutError;
            }
            if (message2 === "AffjaxRequestFailedMessageIdent") {
              return RequestFailedError;
            }
            return $$$Error("XHROtherError", v._1);
          })()
        );
      }
      fail();
    })($$try3(fromEffectFnAff(_ajax(
      driver2,
      "AffjaxTimeoutErrorMessageIdent",
      "AffjaxRequestFailedMessageIdent",
      ResponseHeader,
      {
        method: print(req2.method),
        url: req2.url,
        headers: arrayMap((h) => ({
          field: (() => {
            if (h.tag === "Accept") {
              return "Accept";
            }
            if (h.tag === "ContentType") {
              return "Content-Type";
            }
            if (h.tag === "RequestHeader") {
              return h._1;
            }
            fail();
          })(),
          value: (() => {
            if (h.tag === "Accept") {
              return h._1;
            }
            if (h.tag === "ContentType") {
              return h._1;
            }
            if (h.tag === "RequestHeader") {
              return h._2;
            }
            fail();
          })()
        }))((() => {
          if (req2.content.tag === "Just") {
            if (req2.content._1.tag === "FormURLEncoded") {
              if (req2.responseFormat.tag === "Json") {
                const $0 = !any((y2) => {
                  if (y2.tag === "Accept") {
                    return true;
                  }
                  if (y2.tag === "ContentType") {
                    return false;
                  }
                  if (y2.tag === "RequestHeader") {
                    return "Accept" === y2._1;
                  }
                  fail();
                })(req2.headers) ? snoc(req2.headers)($RequestHeader("Accept", "application/json")) : req2.headers;
                if (!any((y2) => {
                  if (y2.tag === "Accept") {
                    return false;
                  }
                  if (y2.tag === "ContentType") {
                    return true;
                  }
                  if (y2.tag === "RequestHeader") {
                    return "Content-Type" === y2._1;
                  }
                  fail();
                })($0)) {
                  return snoc($0)($RequestHeader("ContentType", "application/x-www-form-urlencoded"));
                }
                return $0;
              }
              if (!any((y2) => {
                if (y2.tag === "Accept") {
                  return false;
                }
                if (y2.tag === "ContentType") {
                  return true;
                }
                if (y2.tag === "RequestHeader") {
                  return "Content-Type" === y2._1;
                }
                fail();
              })(req2.headers)) {
                return snoc(req2.headers)($RequestHeader("ContentType", "application/x-www-form-urlencoded"));
              }
              return req2.headers;
            }
            if (req2.content._1.tag === "Json") {
              if (req2.responseFormat.tag === "Json") {
                const $0 = !any((y2) => {
                  if (y2.tag === "Accept") {
                    return true;
                  }
                  if (y2.tag === "ContentType") {
                    return false;
                  }
                  if (y2.tag === "RequestHeader") {
                    return "Accept" === y2._1;
                  }
                  fail();
                })(req2.headers) ? snoc(req2.headers)($RequestHeader("Accept", "application/json")) : req2.headers;
                if (!any((y2) => {
                  if (y2.tag === "Accept") {
                    return false;
                  }
                  if (y2.tag === "ContentType") {
                    return true;
                  }
                  if (y2.tag === "RequestHeader") {
                    return "Content-Type" === y2._1;
                  }
                  fail();
                })($0)) {
                  return snoc($0)($RequestHeader("ContentType", "application/json"));
                }
                return $0;
              }
              if (!any((y2) => {
                if (y2.tag === "Accept") {
                  return false;
                }
                if (y2.tag === "ContentType") {
                  return true;
                }
                if (y2.tag === "RequestHeader") {
                  return "Content-Type" === y2._1;
                }
                fail();
              })(req2.headers)) {
                return snoc(req2.headers)($RequestHeader("ContentType", "application/json"));
              }
              return req2.headers;
            }
            if (req2.responseFormat.tag === "Json" && !any((y2) => {
              if (y2.tag === "Accept") {
                return true;
              }
              if (y2.tag === "ContentType") {
                return false;
              }
              if (y2.tag === "RequestHeader") {
                return "Accept" === y2._1;
              }
              fail();
            })(req2.headers)) {
              return snoc(req2.headers)($RequestHeader("Accept", "application/json"));
            }
            return req2.headers;
          }
          if (req2.content.tag === "Nothing") {
            if (req2.responseFormat.tag === "Json" && !any((y2) => {
              if (y2.tag === "Accept") {
                return true;
              }
              if (y2.tag === "ContentType") {
                return false;
              }
              if (y2.tag === "RequestHeader") {
                return "Accept" === y2._1;
              }
              fail();
            })(req2.headers)) {
              return snoc(req2.headers)($RequestHeader("Accept", "application/json"));
            }
            return req2.headers;
          }
          fail();
        })()),
        content: content2,
        responseType: (() => {
          if (req2.responseFormat.tag === "ArrayBuffer") {
            return "arraybuffer";
          }
          if (req2.responseFormat.tag === "Blob") {
            return "blob";
          }
          if (req2.responseFormat.tag === "Document") {
            return "document";
          }
          if (req2.responseFormat.tag === "Json") {
            return "text";
          }
          if (req2.responseFormat.tag === "String") {
            return "text";
          }
          if (req2.responseFormat.tag === "Ignore") {
            return "";
          }
          fail();
        })(),
        username: (() => {
          if (req2.username.tag === "Nothing") {
            return nullImpl;
          }
          if (req2.username.tag === "Just") {
            return notNull(req2.username._1);
          }
          fail();
        })(),
        password: (() => {
          if (req2.password.tag === "Nothing") {
            return nullImpl;
          }
          if (req2.password.tag === "Just") {
            return notNull(req2.password._1);
          }
          fail();
        })(),
        withCredentials: req2.withCredentials,
        timeout: req2.timeout.tag === "Just" ? req2.timeout._1 : 0
      }
    ))));
    if (req2.content.tag === "Nothing") {
      return send(nullImpl);
    }
    if (req2.content.tag === "Just") {
      if (req2.content._1.tag === "ArrayView") {
        return send(notNull(req2.content._1._1(unsafeCoerce)));
      }
      if (req2.content._1.tag === "Blob") {
        return send(notNull(req2.content._1._1));
      }
      if (req2.content._1.tag === "Document") {
        return send(notNull(req2.content._1._1));
      }
      if (req2.content._1.tag === "String") {
        return send(notNull(req2.content._1._1));
      }
      if (req2.content._1.tag === "FormData") {
        return send(notNull(req2.content._1._1));
      }
      if (req2.content._1.tag === "FormURLEncoded") {
        const $0 = encode(req2.content._1._1);
        if ($0.tag === "Just") {
          return send(notNull($0._1));
        }
        return _pure($Either("Left", $$$Error("RequestContentError", "Body contains values that cannot be encoded as application/x-www-form-urlencoded")));
      }
      if (req2.content._1.tag === "Json") {
        return send(notNull(stringify(req2.content._1._1)));
      }
    }
    fail();
  };
  var printError = (v) => {
    if (v.tag === "RequestContentError") {
      return "There was a problem with the request content: " + v._1;
    }
    if (v.tag === "ResponseBodyError") {
      return "There was a problem with the response body: " + renderForeignError(v._1);
    }
    if (v.tag === "TimeoutError") {
      return "There was a problem making the request: timeout";
    }
    if (v.tag === "RequestFailedError") {
      return "There was a problem making the request: request failed";
    }
    if (v.tag === "XHROtherError") {
      return "There was a problem making the request: " + message(v._1);
    }
    fail();
  };
  var defaultRequest = {
    method: /* @__PURE__ */ $Either("Left", GET),
    url: "/",
    headers: [],
    content: Nothing,
    username: Nothing,
    password: Nothing,
    withCredentials: false,
    responseFormat: /* @__PURE__ */ $ResponseFormat("Ignore", identity28),
    timeout: Nothing
  };

  // output-es/Affjax.Web/foreign.js
  var driver = {
    newXHR: function() {
      return new XMLHttpRequest();
    },
    fixupUrl: function(url) {
      return url || "/";
    }
  };

  // output-es/Parsing.String/index.js
  var updatePosSingle = (v) => (cp) => (after) => {
    if (cp === 10) {
      return { index: v.index + 1 | 0, line: v.line + 1 | 0, column: 1 };
    }
    if (cp === 13) {
      const v2 = codePointAt2(0)(after);
      if (v2.tag === "Just" && v2._1 === 10) {
        return { index: v.index + 1 | 0, line: v.line, column: v.column };
      }
      return { index: v.index + 1 | 0, line: v.line + 1 | 0, column: 1 };
    }
    if (cp === 9) {
      return { index: v.index + 1 | 0, line: v.line, column: (v.column + 8 | 0) - intMod(v.column - 1 | 0)(8) | 0 };
    }
    return { index: v.index + 1 | 0, line: v.line, column: v.column + 1 | 0 };
  };
  var updatePosString = (updatePosString$a0$copy) => (updatePosString$a1$copy) => (updatePosString$a2$copy) => {
    let updatePosString$a0 = updatePosString$a0$copy;
    let updatePosString$a1 = updatePosString$a1$copy;
    let updatePosString$a2 = updatePosString$a2$copy;
    let updatePosString$c = true;
    let updatePosString$r;
    while (updatePosString$c) {
      const pos = updatePosString$a0, before = updatePosString$a1, after = updatePosString$a2;
      const v = uncons2(before);
      if (v.tag === "Nothing") {
        updatePosString$c = false;
        updatePosString$r = pos;
        continue;
      }
      if (v.tag === "Just") {
        updatePosString$a0 = v._1.tail === "" ? updatePosSingle(pos)(v._1.head)(after) : updatePosSingle(pos)(v._1.head)(v._1.tail);
        updatePosString$a1 = v._1.tail;
        updatePosString$a2 = after;
        continue;
      }
      fail();
    }
    return updatePosString$r;
  };
  var satisfyCodePoint = (f) => (v, $0, $1, $2, $3) => {
    const v3 = uncons2(v._1);
    if (v3.tag === "Nothing") {
      return $2(v, $ParseError("Unexpected EOF", v._2));
    }
    if (v3.tag === "Just") {
      if (f(v3._1.head)) {
        return $3($ParseState(v3._1.tail, updatePosSingle(v._2)(v3._1.head)(v3._1.tail), true), v3._1.head);
      }
      return $2(v, $ParseError("Predicate unsatisfied", v._2));
    }
    fail();
  };
  var satisfy = (f) => (v, $0, $1, $2, $3) => {
    const v3 = uncons2(v._1);
    if (v3.tag === "Nothing") {
      return $2(v, $ParseError("Unexpected EOF", v._2));
    }
    if (v3.tag === "Just") {
      if (v3._1.head < 0 || v3._1.head > 65535) {
        return $2(v, $ParseError("Expected Char", v._2));
      }
      if (v3._1.head >= 0 && v3._1.head <= 65535) {
        const ch = fromCharCode(v3._1.head);
        if (f(ch)) {
          return $3($ParseState(v3._1.tail, updatePosSingle(v._2)(v3._1.head)(v3._1.tail), true), ch);
        }
        return $2(v, $ParseError("Predicate unsatisfied", v._2));
      }
    }
    fail();
  };
  var eof = (v, $0, $1, $2, $3) => {
    if (v._1 === "") {
      return $3($ParseState(v._1, v._2, true), void 0);
    }
    return $2(v, $ParseError("Expected EOF", v._2));
  };
  var consumeWith = (f) => (v, $0, $1, $2, $3) => {
    const v3 = f(v._1);
    if (v3.tag === "Left") {
      return $2(v, $ParseError(v3._1, v._2));
    }
    if (v3.tag === "Right") {
      return $3($ParseState(v3._1.remainder, updatePosString(v._2)(v3._1.consumed)(v3._1.remainder), v3._1.consumed !== ""), v3._1.value);
    }
    fail();
  };
  var string3 = (str) => consumeWith((input) => {
    const v = stripPrefix(str)(input);
    if (v.tag === "Just") {
      return $Either("Right", { value: str, consumed: str, remainder: v._1 });
    }
    return $Either("Left", "Expected " + showStringImpl(str));
  });

  // output-es/Data.CodePoint.Unicode/index.js
  var isUpper = (x2) => checkAttr([512, 524288])(x2);
  var isSpace = (c) => {
    if (c <= 823) {
      return c === 32 || c >= 9 && c <= 13 || c === 160;
    }
    return checkAttrS([2])(c);
  };
  var isOctDigit = (c) => {
    const diff = c - 48 | 0;
    return diff <= 7 && diff >= 0;
  };
  var isDecDigit = (c) => {
    const diff = c - 48 | 0;
    return diff <= 9 && diff >= 0;
  };
  var isHexDigit = (c) => {
    const diff = c - 48 | 0;
    const diff$1 = c - 65 | 0;
    return diff <= 9 && diff >= 0 || (() => {
      const diff$2 = c - 97 | 0;
      return diff$1 <= 5 && diff$1 >= 0 || diff$2 <= 5 && diff$2 >= 0;
    })();
  };
  var isAlphaNum = (x2) => checkAttr([524288, 512, 4096, 1048576, 16384, 8388608, 4194304, 2097152, 131072, 256, 16777216])(x2);
  var isAlpha = (x2) => checkAttr([4096, 512, 524288, 1048576, 16384])(x2);
  var hexDigitToInt = (c) => {
    const hexUpper = c - 65 | 0;
    const hexLower = c - 97 | 0;
    const dec2 = c - 48 | 0;
    if (dec2 <= 9 && dec2 >= 0) {
      return $Maybe("Just", dec2);
    }
    if (hexLower <= 5 && hexLower >= 0) {
      return $Maybe("Just", hexLower + 10 | 0);
    }
    if (hexUpper <= 5 && hexUpper >= 0) {
      return $Maybe("Just", hexUpper + 10 | 0);
    }
    return Nothing;
  };

  // output-es/Parsing.String.Basic/index.js
  var show12 = /* @__PURE__ */ showArrayImpl(showCharImpl);
  var satisfyCP = (p) => satisfy((x2) => p(toCharCode(x2)));
  var space = /* @__PURE__ */ withErrorMessage(/* @__PURE__ */ satisfyCP(isSpace))("space");
  var upper2 = /* @__PURE__ */ withErrorMessage(/* @__PURE__ */ satisfyCP(isUpper))("uppercase letter");
  var oneOf = (ss) => withLazyErrorMessage(satisfy((a) => elem(eqChar)(a)(ss)))((v) => "one of " + show12(ss));
  var octDigit = /* @__PURE__ */ withErrorMessage(/* @__PURE__ */ satisfyCP(isOctDigit))("oct digit");
  var noneOf = (ss) => withLazyErrorMessage(satisfy((a) => notElem(eqChar)(a)(ss)))((v) => "none of " + show12(ss));
  var letter = /* @__PURE__ */ withErrorMessage(/* @__PURE__ */ satisfyCP(isAlpha))("letter");
  var hexDigit = /* @__PURE__ */ withErrorMessage(/* @__PURE__ */ satisfyCP(isHexDigit))("hex digit");
  var digit = /* @__PURE__ */ withErrorMessage(/* @__PURE__ */ satisfyCP(isDecDigit))("digit");
  var alphaNum = /* @__PURE__ */ withErrorMessage(/* @__PURE__ */ satisfyCP(isAlphaNum))("letter or digit");

  // output-es/Data.String.Unicode/index.js
  var convert = (f) => {
    const $0 = arrayMap(f);
    return (x2) => fromCodePointArray($0(toCodePointArray(x2)));
  };
  var toLowerSimple = /* @__PURE__ */ convert(uTowlower);
  var toUpperSimple = /* @__PURE__ */ convert(uTowupper);

  // output-es/Parsing.Token/index.js
  var identity29 = (x2) => x2;
  var choice3 = /* @__PURE__ */ choice(foldableArray);
  var toUnfoldable9 = /* @__PURE__ */ toUnfoldable2(unfoldableArray);
  var theReservedNames = (v) => {
    if (v.caseSensitive) {
      return sortBy(ordString.compare)(v.reservedNames);
    }
    return sortBy(ordString.compare)(arrayMap(toLower)(v.reservedNames));
  };
  var oneLineComment = (v) => {
    const $0 = skipMany(satisfy((v1) => v1 !== "\n"));
    return (state1, more, lift12, $$throw2, done) => more((v2) => more((v1) => {
      const $1 = state1._3;
      return string3(v.commentLine)(
        state1,
        more,
        lift12,
        (v2$1, $2) => $$throw2($ParseState(v2$1._1, v2$1._2, $1), $2),
        (state2, a) => more((v2$1) => more((v3) => $0(state2, more, lift12, $$throw2, (state3, a$1) => more((v4) => done(state3, a$1)))))
      );
    }));
  };
  var isReserved = (isReserved$a0$copy) => (isReserved$a1$copy) => {
    let isReserved$a0 = isReserved$a0$copy, isReserved$a1 = isReserved$a1$copy, isReserved$c = true, isReserved$r;
    while (isReserved$c) {
      const names2 = isReserved$a0, name3 = isReserved$a1;
      const v = unconsImpl((v2) => Nothing, (x2) => (xs) => $Maybe("Just", { head: x2, tail: xs }), names2);
      if (v.tag === "Nothing") {
        isReserved$c = false;
        isReserved$r = false;
        continue;
      }
      if (v.tag === "Just") {
        const v1 = ordString.compare(v._1.head)(name3);
        if (v1 === "LT") {
          isReserved$a0 = v._1.tail;
          isReserved$a1 = name3;
          continue;
        }
        if (v1 === "EQ") {
          isReserved$c = false;
          isReserved$r = true;
          continue;
        }
        if (v1 === "GT") {
          isReserved$c = false;
          isReserved$r = false;
          continue;
        }
      }
      fail();
    }
    return isReserved$r;
  };
  var inCommentSingle = (v) => {
    const startEnd = [...toCharArray(v.commentEnd), ...toCharArray(v.commentStart)];
    const go$lazy = binding(() => lazyParserT.defer((v$1) => {
      const $0 = skipMany1(noneOf(startEnd));
      const $1 = withErrorMessage((() => {
        const $12 = oneOf(startEnd);
        return (state1, more, lift12, $$throw2, done) => more((v2) => more((v1) => $12(
          state1,
          more,
          lift12,
          $$throw2,
          (state2, a) => more((v2$1) => more((v3) => go$lazy()(state2, more, lift12, $$throw2, (state3, a$1) => more((v4) => done(state3, a$1)))))
        )));
      })())("end of comment");
      return (v2, $2, $3, $4, $5) => {
        const $6 = v2._1;
        const $7 = v2._2;
        return $2((v3) => $2((v1) => string3(v.commentEnd)(
          $ParseState($6, $7, false),
          $2,
          $3,
          (v2$1, $8) => $2((v5) => {
            const $9 = v2._1;
            const $10 = v2._2;
            return $2((v3$1) => {
              const $11 = (v4, $112) => {
                const $12 = v4._3;
                return $2((v5$1) => {
                  if ($12) {
                    return $4(v4, $112);
                  }
                  return $1(v2, $2, $3, $4, $5);
                });
              };
              return $2((v2$2) => $2((v1$1) => $0(
                $ParseState($9, $10, false),
                $2,
                $3,
                $11,
                (state2, a) => $2((v2$3) => $2((v3$2) => go$lazy()(state2, $2, $3, $11, (state3, a$1) => $2((v4) => $5(state3, a$1)))))
              )));
            });
          }),
          (state2, a) => $2((v2$1) => $5(state2, void 0))
        )));
      };
    }));
    const go = go$lazy();
    return go;
  };
  var multiLineComment = (v) => {
    const $0 = inComment(v);
    return (state1, more, lift12, $$throw2, done) => more((v2) => more((v1) => {
      const $1 = state1._3;
      return string3(v.commentStart)(
        state1,
        more,
        lift12,
        (v2$1, $2) => $$throw2($ParseState(v2$1._1, v2$1._2, $1), $2),
        (state2, a) => more((v2$1) => more((v3) => $0(state2, more, lift12, $$throw2, (state3, a$1) => more((v4) => done(state3, a$1)))))
      );
    }));
  };
  var inCommentMulti = (v) => {
    const startEnd = [...toCharArray(v.commentEnd), ...toCharArray(v.commentStart)];
    const go$lazy = binding(() => lazyParserT.defer((v$1) => {
      const $0 = multiLineComment(v);
      const $1 = skipMany1(noneOf(startEnd));
      const $2 = withErrorMessage((() => {
        const $22 = oneOf(startEnd);
        return (state1, more, lift12, $$throw2, done) => more((v2) => more((v1) => $22(
          state1,
          more,
          lift12,
          $$throw2,
          (state2, a) => more((v2$1) => more((v3) => go$lazy()(state2, more, lift12, $$throw2, (state3, a$1) => more((v4) => done(state3, a$1)))))
        )));
      })())("end of comment");
      return (v2, $3, $4, $5, $6) => {
        const $7 = v2._1;
        const $8 = v2._2;
        return $3((v3) => $3((v1) => string3(v.commentEnd)(
          $ParseState($7, $8, false),
          $3,
          $4,
          (v2$1, $9) => $3((v5) => {
            const $10 = v2._1;
            const $11 = v2._2;
            return $3((v3$1) => {
              const $12 = (v4, $122) => {
                const $13 = v4._3;
                return $3((v5$1) => {
                  if ($13) {
                    return $5(v4, $122);
                  }
                  const $14 = v2._1;
                  const $15 = v2._2;
                  return $3((v3$2) => {
                    const $16 = (v4$1, $162) => {
                      const $17 = v4$1._3;
                      return $3((v5$2) => {
                        if ($17) {
                          return $5(v4$1, $162);
                        }
                        return $2(v2, $3, $4, $5, $6);
                      });
                    };
                    return $3((v2$2) => $3((v1$1) => $1(
                      $ParseState($14, $15, false),
                      $3,
                      $4,
                      $16,
                      (state2, a) => $3((v2$3) => $3((v3$3) => go$lazy()(state2, $3, $4, $16, (state3, a$1) => $3((v4$1) => $6(state3, a$1)))))
                    )));
                  });
                });
              };
              return $3((v2$2) => $3((v1$1) => $0(
                $ParseState($10, $11, false),
                $3,
                $4,
                $12,
                (state2, a) => $3((v2$3) => $3((v3$2) => go$lazy()(state2, $3, $4, $12, (state3, a$1) => $3((v4) => $6(state3, a$1)))))
              )));
            });
          }),
          (state2, a) => $3((v2$1) => $6(state2, void 0))
        )));
      };
    }));
    const go = go$lazy();
    return go;
  };
  var inComment = (v) => {
    if (v.nestedComments) {
      return inCommentMulti(v);
    }
    return inCommentSingle(v);
  };
  var whiteSpace$p = (v) => {
    if (v.commentLine === "" && v.commentStart === "") {
      return skipMany(withErrorMessage(skipMany1(satisfyCodePoint(isSpace)))(""));
    }
    if (v.commentLine === "") {
      return skipMany((() => {
        const $0 = withErrorMessage(multiLineComment(v))("");
        return (v2, $1, $2, $3, $4) => {
          const $5 = v2._1;
          const $6 = v2._2;
          return $1((v3) => skipMany1(satisfyCodePoint(isSpace))(
            $ParseState($5, $6, false),
            $1,
            $2,
            (v4, $7) => {
              const $8 = v4._3;
              return $1((v5) => {
                if ($8) {
                  return $3(v4, $7);
                }
                return $0(v2, $1, $2, $3, $4);
              });
            },
            $4
          ));
        };
      })());
    }
    if (v.commentStart === "") {
      return skipMany((() => {
        const $0 = withErrorMessage(oneLineComment(v))("");
        return (v2, $1, $2, $3, $4) => {
          const $5 = v2._1;
          const $6 = v2._2;
          return $1((v3) => skipMany1(satisfyCodePoint(isSpace))(
            $ParseState($5, $6, false),
            $1,
            $2,
            (v4, $7) => {
              const $8 = v4._3;
              return $1((v5) => {
                if ($8) {
                  return $3(v4, $7);
                }
                return $0(v2, $1, $2, $3, $4);
              });
            },
            $4
          ));
        };
      })());
    }
    return skipMany((() => {
      const $0 = oneLineComment(v);
      const $1 = withErrorMessage(multiLineComment(v))("");
      return (v2, $2, $3, $4, $5) => {
        const $6 = v2._1;
        const $7 = v2._2;
        return $2((v3) => skipMany1(satisfyCodePoint(isSpace))(
          $ParseState($6, $7, false),
          $2,
          $3,
          (v4, $8) => {
            const $9 = v4._3;
            return $2((v5) => {
              if ($9) {
                return $4(v4, $8);
              }
              const $10 = v2._1;
              const $11 = v2._2;
              return $2((v3$1) => $0(
                $ParseState($10, $11, false),
                $2,
                $3,
                (v4$1, $12) => {
                  const $13 = v4$1._3;
                  return $2((v5$1) => {
                    if ($13) {
                      return $4(v4$1, $12);
                    }
                    return $1(v2, $2, $3, $4, $5);
                  });
                },
                $5
              ));
            });
          },
          $5
        ));
      };
    })());
  };
  var makeTokenParser = (v) => {
    const $0 = withErrorMessage(satisfy((v$1) => v$1 === "-"))("'-'");
    const $1 = withErrorMessage(satisfy((v$1) => v$1 === "+"))("'+'");
    const sign1 = (v2, $22, $32, $42, $52) => {
      const $62 = v2._1;
      const $72 = v2._2;
      return $22((v3) => $22((v1) => $0(
        $ParseState($62, $72, false),
        $22,
        $32,
        (v4, $82) => {
          const $92 = v4._3;
          return $22((v5) => {
            if ($92) {
              return $42(v4, $82);
            }
            const $102 = v2._1;
            const $112 = v2._2;
            return $22((v3$1) => $22((v1$1) => $1(
              $ParseState($102, $112, false),
              $22,
              $32,
              (v4$1, $122) => {
                const $132 = v4$1._3;
                return $22((v5$1) => {
                  if ($132) {
                    return $42(v4$1, $122);
                  }
                  return $52(v2, identity29);
                });
              },
              (state2, a) => $22((v2$1) => $52(state2, identity29))
            )));
          });
        },
        (state2, a) => $22((v2$1) => $52(state2, (a$1) => -a$1))
      )));
    };
    const $2 = oneOf(["o", "O"]);
    const $3 = some(alternativeParserT)(lazyParserT)(octDigit);
    const octal = (state1, more, lift12, $$throw2, done) => more((v2) => more((v1) => $2(
      state1,
      more,
      lift12,
      $$throw2,
      (state2, a) => more((v2$1) => more((v3) => more((v1$1) => $3(
        state2,
        more,
        lift12,
        $$throw2,
        (state2$1, a$1) => more((v2$2) => {
          const $42 = foldlArray((v1$2) => (v2$3) => {
            if (v1$2.tag === "Nothing") {
              return Nothing;
            }
            if (v1$2.tag === "Just") {
              const $43 = hexDigitToInt(toCharCode(v2$3));
              if ($43.tag === "Just") {
                return $Maybe("Just", (8 * v1$2._1 | 0) + $43._1 | 0);
              }
              return Nothing;
            }
            fail();
          })($Maybe("Just", 0))(a$1);
          if ($42.tag === "Nothing") {
            return fail2("not digits")(state2$1, more, lift12, $$throw2, (state3, a$2) => more((v4) => done(state3, a$2)));
          }
          if ($42.tag === "Just") {
            const $52 = $42._1;
            return more((v4) => done(state2$1, $52));
          }
          fail();
        })
      ))))
    )));
    const $4 = whiteSpace$p(v);
    const semi2 = (state1, more, lift12, $$throw2, done) => more((v1) => more((v2) => more((v1$1) => string3(";")(
      state1,
      more,
      lift12,
      $$throw2,
      (state2, a) => more((v2$1) => more((v3) => $4(state2, more, lift12, $$throw2, (state3, a$1) => more((v4) => more((v2$2) => done(state3, ";"))))))
    ))));
    const $5 = oneOf(["x", "X"]);
    const $6 = some(alternativeParserT)(lazyParserT)(hexDigit);
    const hexadecimal = (state1, more, lift12, $$throw2, done) => more((v2) => more((v1) => $5(
      state1,
      more,
      lift12,
      $$throw2,
      (state2, a) => more((v2$1) => more((v3) => more((v1$1) => $6(
        state2,
        more,
        lift12,
        $$throw2,
        (state2$1, a$1) => more((v2$2) => {
          const $72 = foldlArray((v1$2) => (v2$3) => {
            if (v1$2.tag === "Nothing") {
              return Nothing;
            }
            if (v1$2.tag === "Just") {
              const $73 = hexDigitToInt(toCharCode(v2$3));
              if ($73.tag === "Just") {
                return $Maybe("Just", (16 * v1$2._1 | 0) + $73._1 | 0);
              }
              return Nothing;
            }
            fail();
          })($Maybe("Just", 0))(a$1);
          if ($72.tag === "Nothing") {
            return fail2("not digits")(state2$1, more, lift12, $$throw2, (state3, a$2) => more((v4) => done(state3, a$2)));
          }
          if ($72.tag === "Just") {
            const $82 = $72._1;
            return more((v4) => done(state2$1, $82));
          }
          fail();
        })
      ))))
    )));
    const fraction = withErrorMessage((() => {
      const $72 = withErrorMessage(satisfy((v$1) => v$1 === "."))("'.'");
      return (state1, more, lift12, $$throw2, done) => more((v1) => $72(
        state1,
        more,
        lift12,
        $$throw2,
        (state2, a) => more((v2) => {
          const $82 = withErrorMessage(some(alternativeParserT)(lazyParserT)(digit))("fraction");
          return more((v1$1) => $82(
            state2,
            more,
            lift12,
            $$throw2,
            (state2$1, a$1) => more((v2$1) => {
              const $92 = foldrArray((v1$2) => (v2$2) => {
                if (v2$2.tag === "Nothing") {
                  return Nothing;
                }
                if (v2$2.tag === "Just") {
                  const $93 = hexDigitToInt(toCharCode(v1$2));
                  if ($93.tag === "Just") {
                    return $Maybe("Just", (v2$2._1 + toNumber($93._1)) / 10);
                  }
                  if ($93.tag === "Nothing") {
                    return Nothing;
                  }
                }
                fail();
              })($Maybe("Just", 0))(a$1);
              if ($92.tag === "Nothing") {
                return fail2("not digit")(state2$1, more, lift12, $$throw2, done);
              }
              if ($92.tag === "Just") {
                return done(state2$1, $92._1);
              }
              fail();
            })
          ));
        })
      ));
    })())("fraction");
    const escapeGap = withErrorMessage((() => {
      const $72 = some(alternativeParserT)(lazyParserT)(space);
      const $82 = withErrorMessage(satisfy((v$1) => v$1 === "\\"))("'\\\\'");
      return (state1, more, lift12, $$throw2, done) => more((v2) => more((v1) => $72(
        state1,
        more,
        lift12,
        $$throw2,
        (state2, a) => more((v2$1) => more((v3) => $82(state2, more, lift12, $$throw2, (state3, a$1) => more((v4) => done(state3, a$1)))))
      )));
    })())("end of string gap");
    const escapeEmpty = withErrorMessage(satisfy((v$1) => v$1 === "&"))("'&'");
    const $7 = some(alternativeParserT)(lazyParserT)(digit);
    const decimal = (state1, more, lift12, $$throw2, done) => more((v1) => $7(
      state1,
      more,
      lift12,
      $$throw2,
      (state2, a) => more((v2) => {
        const $82 = foldlArray((v1$1) => (v2$1) => {
          if (v1$1.tag === "Nothing") {
            return Nothing;
          }
          if (v1$1.tag === "Just") {
            const $83 = hexDigitToInt(toCharCode(v2$1));
            if ($83.tag === "Just") {
              return $Maybe("Just", (10 * v1$1._1 | 0) + $83._1 | 0);
            }
            return Nothing;
          }
          fail();
        })($Maybe("Just", 0))(a);
        if ($82.tag === "Nothing") {
          return fail2("not digits")(state2, more, lift12, $$throw2, done);
        }
        if ($82.tag === "Just") {
          return done(state2, $82._1);
        }
        fail();
      })
    ));
    const power = (e) => {
      if (e < 0) {
        return 1 / power(-e);
      }
      return pow(10)(toNumber(e));
    };
    const $8 = oneOf(["e", "E"]);
    const exponent$p = withErrorMessage((state1, more, lift12, $$throw2, done) => more((v1) => $8(
      state1,
      more,
      lift12,
      $$throw2,
      (state2, a) => more((v2) => more((v1$1) => sign1(
        state2,
        more,
        lift12,
        $$throw2,
        (state2$1, a$1) => more((v2$1) => {
          const $92 = withErrorMessage(decimal)("exponent");
          return more((v1$2) => $92(state2$1, more, lift12, $$throw2, (state2$2, a$2) => more((v2$2) => done(state2$2, power(a$1(a$2))))));
        })
      )))
    )))("exponent");
    const fractExponent = (n) => (v2, $92, $102, $112, $122) => {
      const $132 = v2._1;
      const $142 = v2._2;
      return $92((v3) => {
        const $152 = (v4, $153) => {
          const $162 = v4._3;
          return $92((v5) => {
            if ($162) {
              return $112(v4, $153);
            }
            return $92((v1) => exponent$p(v2, $92, $102, $112, (state2, a) => $92((v2$1) => $122(state2, toNumber(n) * a))));
          });
        };
        return $92((v1) => fraction(
          $ParseState($132, $142, false),
          $92,
          $102,
          $152,
          (state2, a) => $92((v2$1) => $92((v1$1) => {
            const $162 = (state2$1, a$1) => $92((v2$2) => $122(state2$1, (toNumber(n) + a) * a$1));
            const $17 = state2._1;
            const $18 = state2._2;
            return $92((v3$1) => exponent$p(
              $ParseState($17, $18, false),
              $92,
              $102,
              (v4, $19) => {
                const $20 = v4._3;
                return $92((v5) => {
                  if ($20) {
                    return $152(v4, $19);
                  }
                  return $162(state2, 1);
                });
              },
              $162
            ));
          }))
        ));
      });
    };
    const decimalFloat = (state1, more, lift12, $$throw2, done) => more((v1) => decimal(
      state1,
      more,
      lift12,
      $$throw2,
      (state2, a) => more((v2) => {
        const $92 = fractExponent(a);
        const $102 = state2._1;
        const $112 = state2._2;
        return more((v3) => more((v1$1) => $92(
          $ParseState($102, $112, false),
          more,
          lift12,
          (v4, $122) => {
            const $132 = v4._3;
            return more((v5) => {
              if ($132) {
                return $$throw2(v4, $122);
              }
              return done(state2, $Either("Left", a));
            });
          },
          (state2$1, a$1) => more((v2$1) => done(state2$1, $Either("Right", a$1)))
        )));
      })
    ));
    const zeroNumber = withErrorMessage((() => {
      const $92 = withErrorMessage(satisfy((v$1) => v$1 === "0"))("'0'");
      return (state1, more, lift12, $$throw2, done) => more((v2) => more((v1) => $92(
        state1,
        more,
        lift12,
        $$throw2,
        (state2, a) => more((v2$1) => more((v3) => {
          const $102 = state2._1;
          const $112 = state2._2;
          return more((v3$1) => hexadecimal(
            $ParseState($102, $112, false),
            more,
            lift12,
            (v4, $122) => {
              const $132 = v4._3;
              return more((v5) => {
                if ($132) {
                  return $$throw2(v4, $122);
                }
                const $142 = state2._1;
                const $152 = state2._2;
                return more((v3$2) => octal(
                  $ParseState($142, $152, false),
                  more,
                  lift12,
                  (v4$1, $162) => {
                    const $17 = v4$1._3;
                    return more((v5$1) => {
                      if ($17) {
                        return $$throw2(v4$1, $162);
                      }
                      const $18 = state2._1;
                      const $19 = state2._2;
                      return more((v3$3) => decimal(
                        $ParseState($18, $19, false),
                        more,
                        lift12,
                        (v4$2, $20) => {
                          const $21 = v4$2._3;
                          return more((v5$2) => {
                            if ($21) {
                              return $$throw2(v4$2, $20);
                            }
                            return more((v4$3) => done(state2, 0));
                          });
                        },
                        (state3, a$1) => more((v4$2) => done(state3, a$1))
                      ));
                    });
                  },
                  (state3, a$1) => more((v4$1) => done(state3, a$1))
                ));
              });
            },
            (state3, a$1) => more((v4) => done(state3, a$1))
          ));
        }))
      )));
    })())("");
    const $9 = whiteSpace$p(v);
    const comma2 = (state1, more, lift12, $$throw2, done) => more((v1) => more((v2) => more((v1$1) => string3(",")(
      state1,
      more,
      lift12,
      $$throw2,
      (state2, a) => more((v2$1) => more((v3) => $9(state2, more, lift12, $$throw2, (state3, a$1) => more((v4) => more((v2$2) => done(state3, ","))))))
    ))));
    const $10 = choice3(arrayMap((v1) => {
      const $102 = v1._1;
      const $112 = v1._2;
      const $122 = withErrorMessage(satisfy((v$1) => v$1 === $102))(showCharImpl($102));
      return (state1, more, lift12, $$throw2, done) => more((v1$1) => $122(state1, more, lift12, $$throw2, (state2, a) => more((v2) => done(state2, $112))));
    })(zipWithImpl(Tuple, ["a", "b", "f", "n", "r", "t", "v", "\\", '"', "'"], ["\x07", "\b", "\f", "\n", "\r", "	", "\v", "\\", '"', "'"])));
    const $11 = withErrorMessage(satisfy((v$1) => v$1 === "o"))("'o'");
    const $12 = some(alternativeParserT)(lazyParserT)(octDigit);
    const $13 = withErrorMessage(satisfy((v$1) => v$1 === "x"))("'x'");
    const $14 = some(alternativeParserT)(lazyParserT)(hexDigit);
    const $15 = choice3(arrayMap((v1) => {
      const $152 = v1._2;
      return (v1$1, $162, $17, $18, $19) => {
        const $20 = v1$1._3;
        return $162((v1$2) => string3(v1._1)(v1$1, $162, $17, (v2, $21) => $18($ParseState(v2._1, v2._2, $20), $21), (state2, a) => $162((v2) => $19(state2, $152))));
      };
    })(zipWithImpl(
      Tuple,
      [
        "NUL",
        "SOH",
        "STX",
        "ETX",
        "EOT",
        "ENQ",
        "ACK",
        "BEL",
        "DLE",
        "DC1",
        "DC2",
        "DC3",
        "DC4",
        "NAK",
        "SYN",
        "ETB",
        "CAN",
        "SUB",
        "ESC",
        "DEL",
        "BS",
        "HT",
        "LF",
        "VT",
        "FF",
        "CR",
        "SO",
        "SI",
        "EM",
        "FS",
        "GS",
        "RS",
        "US",
        "SP"
      ],
      [
        "\0",
        "",
        "",
        "",
        "",
        "",
        "",
        "\x07",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "\x1B",
        "\x7F",
        "\b",
        "	",
        "\n",
        "\v",
        "\f",
        "\r",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        " "
      ]
    )));
    const $16 = withErrorMessage((() => {
      const $162 = withErrorMessage(satisfy((v$1) => v$1 === "^"))("'^'");
      return (state1, more, lift12, $$throw2, done) => more((v1) => $162(
        state1,
        more,
        lift12,
        $$throw2,
        (state2, a) => more((v2) => more((v1$1) => upper2(
          state2,
          more,
          lift12,
          $$throw2,
          (state2$1, a$1) => more((v2$1) => {
            const $17 = (toCharCode(a$1) - 65 | 0) + 1 | 0;
            if ($17 >= 0 && $17 <= 65535) {
              return done(state2$1, fromCharCode($17));
            }
            return fail2("invalid character code (should not happen)")(state2$1, more, lift12, $$throw2, done);
          })
        )))
      ));
    })())("escape code");
    const escapeCode = (v2, $17, $18, $19, $20) => {
      const $21 = v2._1;
      const $22 = v2._2;
      return $17((v3) => $10(
        $ParseState($21, $22, false),
        $17,
        $18,
        (v4, $23) => {
          const $24 = v4._3;
          return $17((v5) => {
            if ($24) {
              return $19(v4, $23);
            }
            const $25 = v2._1;
            const $26 = v2._2;
            return $17((v3$1) => {
              const $27 = (v4$1, $272) => {
                const $28 = v4$1._3;
                return $17((v5$1) => {
                  if ($28) {
                    return $19(v4$1, $272);
                  }
                  const $29 = v2._1;
                  const $30 = v2._2;
                  return $17((v3$2) => $15(
                    $ParseState($29, $30, false),
                    $17,
                    $18,
                    (v4$2, $31) => {
                      const $32 = v4$2._3;
                      return $17((v5$2) => {
                        if ($32) {
                          return $19(v4$2, $31);
                        }
                        return $16(v2, $17, $18, $19, $20);
                      });
                    },
                    $20
                  ));
                });
              };
              return $17((v1) => $17((v3$2) => decimal(
                $ParseState($25, $26, false),
                $17,
                $18,
                (v4$1, $28) => {
                  const $29 = v4$1._3;
                  return $17((v5$1) => {
                    if ($29) {
                      return $27(v4$1, $28);
                    }
                    const $30 = (state2, a) => $17((v2$1) => {
                      if (a > 1114111) {
                        return fail2("invalid escape sequence")(state2, $17, $18, $27, $20);
                      }
                      if (a >= 0 && a <= 65535) {
                        return $20(state2, fromCharCode(a));
                      }
                      return fail2("invalid character code (should not happen)")(state2, $17, $18, $27, $20);
                    });
                    return $17((v3$3) => {
                      const $31 = (v4$2, $312) => {
                        const $32 = v4$2._3;
                        return $17((v5$2) => {
                          if ($32) {
                            return $27(v4$2, $312);
                          }
                          return $17((v2$1) => $17((v1$1) => $13(
                            $ParseState($25, $26, false),
                            $17,
                            $18,
                            $27,
                            (state2, a) => $17((v2$2) => $17((v3$4) => $17((v1$2) => $14(
                              state2,
                              $17,
                              $18,
                              $27,
                              (state2$1, a$1) => $17((v2$3) => {
                                const $33 = foldlArray((v1$3) => (v2$4) => {
                                  if (v1$3.tag === "Nothing") {
                                    return Nothing;
                                  }
                                  if (v1$3.tag === "Just") {
                                    const $332 = hexDigitToInt(toCharCode(v2$4));
                                    if ($332.tag === "Just") {
                                      return $Maybe("Just", (16 * v1$3._1 | 0) + $332._1 | 0);
                                    }
                                    return Nothing;
                                  }
                                  fail();
                                })($Maybe("Just", 0))(a$1);
                                if ($33.tag === "Nothing") {
                                  return fail2("not digits")(state2$1, $17, $18, $27, (state3, a$2) => $17((v4$3) => $30(state3, a$2)));
                                }
                                if ($33.tag === "Just") {
                                  const $34 = $33._1;
                                  return $17((v4$3) => $30(state2$1, $34));
                                }
                                fail();
                              })
                            ))))
                          )));
                        });
                      };
                      return $17((v2$1) => $17((v1$1) => $11(
                        $ParseState($25, $26, false),
                        $17,
                        $18,
                        $31,
                        (state2, a) => $17((v2$2) => $17((v3$4) => $17((v1$2) => $12(
                          state2,
                          $17,
                          $18,
                          $31,
                          (state2$1, a$1) => $17((v2$3) => {
                            const $32 = foldlArray((v1$3) => (v2$4) => {
                              if (v1$3.tag === "Nothing") {
                                return Nothing;
                              }
                              if (v1$3.tag === "Just") {
                                const $322 = hexDigitToInt(toCharCode(v2$4));
                                if ($322.tag === "Just") {
                                  return $Maybe("Just", (8 * v1$3._1 | 0) + $322._1 | 0);
                                }
                                return Nothing;
                              }
                              fail();
                            })($Maybe("Just", 0))(a$1);
                            if ($32.tag === "Nothing") {
                              return fail2("not digits")(state2$1, $17, $18, $31, (state3, a$2) => $17((v4$2) => $30(state3, a$2)));
                            }
                            if ($32.tag === "Just") {
                              const $33 = $32._1;
                              return $17((v4$2) => $30(state2$1, $33));
                            }
                            fail();
                          })
                        ))))
                      )));
                    });
                  });
                },
                (state2, a) => $17((v2$1) => {
                  if (a > 1114111) {
                    return fail2("invalid escape sequence")(state2, $17, $18, $27, $20);
                  }
                  if (a >= 0 && a <= 65535) {
                    return $20(state2, fromCharCode(a));
                  }
                  return fail2("invalid character code (should not happen)")(state2, $17, $18, $27, $20);
                })
              )));
            });
          });
        },
        $20
      ));
    };
    return {
      identifier: (() => {
        const $17 = withErrorMessage((state1, more, lift12, $$throw2, done) => more((v1) => v.identStart(
          state1,
          more,
          lift12,
          $$throw2,
          (state2, a) => more((v2) => {
            const $172 = many(alternativeParserT)(lazyParserT)(v.identLetter);
            return more((v1$1) => $172(
              state2,
              more,
              lift12,
              $$throw2,
              (state2$1, a$1) => more((v2$1) => done(state2$1, singleton(a) + fromCharArray(a$1)))
            ));
          })
        )))("identifier");
        const $18 = whiteSpace$p(v);
        return (state1, more, lift12, $$throw2, done) => more((v2) => more((v1) => {
          const $19 = (state2, a) => more((v2$1) => more((v3) => $18(state2, more, lift12, $$throw2, (state3, a$1) => more((v4) => done(state3, a)))));
          const $20 = state1._3;
          return more((v1$1) => $17(
            state1,
            more,
            lift12,
            (v2$1, $21) => $$throw2($ParseState(v2$1._1, v2$1._2, $20), $21),
            (state2, a) => more((v2$1) => {
              if (isReserved(theReservedNames(v))(v.caseSensitive ? a : toLower(a))) {
                return fail2("reserved word " + showStringImpl(a))(
                  state2,
                  more,
                  lift12,
                  (v2$2, $21) => $$throw2($ParseState(v2$2._1, v2$2._2, $20), $21),
                  $19
                );
              }
              return $19(state2, a);
            })
          ));
        }));
      })(),
      reserved: (name3) => {
        const $17 = (() => {
          if (v.caseSensitive) {
            return (state1, more, lift12, $$throw2, done) => more((v1) => string3(name3)(state1, more, lift12, $$throw2, (state2, a) => more((v2) => done(state2, name3))));
          }
          const msg = showStringImpl(name3);
          const walk = (name$p) => {
            const v1 = uncons(name$p);
            if (v1.tag === "Nothing") {
              return (state1, v$1, v1$1, v2, done) => done(state1, void 0);
            }
            if (v1.tag === "Just") {
              const $173 = withErrorMessage((() => {
                if (checkAttr([4096, 512, 524288, 1048576, 16384])(toCharCode(v1._1.head))) {
                  const $174 = toChar(toLowerSimple(singleton(v1._1.head)));
                  if ($174.tag === "Just") {
                    const $183 = toChar(toUpperSimple(singleton(v1._1.head)));
                    if ($183.tag === "Just") {
                      const $192 = $183._1;
                      const $20 = withErrorMessage(satisfy((v$1) => v$1 === $174._1))(showCharImpl($174._1));
                      const $21 = withErrorMessage(satisfy((v$1) => v$1 === $192))(showCharImpl($192));
                      return (v2, $22, $23, $24, $25) => {
                        const $26 = v2._1;
                        const $27 = v2._2;
                        return $22((v3) => $20(
                          $ParseState($26, $27, false),
                          $22,
                          $23,
                          (v4, $28) => {
                            const $29 = v4._3;
                            return $22((v5) => {
                              if ($29) {
                                return $24(v4, $28);
                              }
                              return $21(v2, $22, $23, $24, $25);
                            });
                          },
                          $25
                        ));
                      };
                    }
                  }
                }
                return withErrorMessage(satisfy((v$1) => v$1 === v1._1.head))(showCharImpl(v1._1.head));
              })())(msg);
              const $182 = walk(v1._1.tail);
              return (state1, more, lift12, $$throw2, done) => more((v2) => more((v1$1) => $173(
                state1,
                more,
                lift12,
                $$throw2,
                (state2, a) => more((v2$1) => more((v3) => $182(state2, more, lift12, $$throw2, (state3, a$1) => more((v4) => done(state3, a$1)))))
              )));
            }
            fail();
          };
          const $172 = walk(name3);
          return (state1, more, lift12, $$throw2, done) => more((v1) => $172(state1, more, lift12, $$throw2, (state2, a) => more((v2) => done(state2, name3))));
        })();
        const $18 = withErrorMessage(notFollowedBy(v.identLetter))("end of " + name3);
        const $19 = whiteSpace$p(v);
        return (state1, more, lift12, $$throw2, done) => more((v2) => more((v1) => {
          const $20 = state1._3;
          return more((v2$1) => more((v1$1) => $17(
            state1,
            more,
            lift12,
            (v2$2, $21) => $$throw2($ParseState(v2$2._1, v2$2._2, $20), $21),
            (state2, a) => more((v2$2) => more((v3) => $18(
              state2,
              more,
              lift12,
              (v2$3, $21) => $$throw2($ParseState(v2$3._1, v2$3._2, $20), $21),
              (state3, a$1) => more((v4) => more((v2$3) => more((v3$1) => $19(state3, more, lift12, $$throw2, (state3$1, a$2) => more((v4$1) => done(state3$1, a$1))))))
            )))
          )));
        }));
      },
      operator: (() => {
        const $17 = withErrorMessage((state1, more, lift12, $$throw2, done) => more((v1) => v.opStart(
          state1,
          more,
          lift12,
          $$throw2,
          (state2, a) => more((v2) => {
            const $172 = many(alternativeParserT)(lazyParserT)(v.opLetter);
            return more((v1$1) => $172(
              state2,
              more,
              lift12,
              $$throw2,
              (state2$1, a$1) => more((v2$1) => done(state2$1, singleton(a) + fromCharArray(a$1)))
            ));
          })
        )))("operator");
        const $18 = whiteSpace$p(v);
        return (state1, more, lift12, $$throw2, done) => more((v2) => more((v1) => {
          const $19 = (state2, a) => more((v2$1) => more((v3) => $18(state2, more, lift12, $$throw2, (state3, a$1) => more((v4) => done(state3, a)))));
          const $20 = state1._3;
          return more((v1$1) => $17(
            state1,
            more,
            lift12,
            (v2$1, $21) => $$throw2($ParseState(v2$1._1, v2$1._2, $20), $21),
            (state2, a) => more((v2$1) => {
              if (isReserved(sortBy(ordString.compare)(v.reservedOpNames))(a)) {
                return fail2("reserved operator " + a)(state2, more, lift12, (v2$2, $21) => $$throw2($ParseState(v2$2._1, v2$2._2, $20), $21), $19);
              }
              return $19(state2, a);
            })
          ));
        }));
      })(),
      reservedOp: (name3) => {
        const $17 = whiteSpace$p(v);
        return (state1, more, lift12, $$throw2, done) => more((v2) => more((v1) => {
          const $18 = state1._3;
          return more((v1$1) => string3(name3)(
            state1,
            more,
            lift12,
            (v2$1, $19) => $$throw2($ParseState(v2$1._1, v2$1._2, $18), $19),
            (state2, a) => more((v2$1) => withErrorMessage(notFollowedBy(v.opLetter))("end of " + name3)(
              state2,
              more,
              lift12,
              (v2$2, $19) => $$throw2($ParseState(v2$2._1, v2$2._2, $18), $19),
              (state2$1, a$1) => more((v2$2) => more((v3) => $17(state2$1, more, lift12, $$throw2, (state3, a$2) => more((v4) => done(state3, a$1)))))
            ))
          ));
        }));
      },
      charLiteral: withErrorMessage((() => {
        const $17 = between(withErrorMessage(satisfy((v$1) => v$1 === "'"))("'\\''"))(withErrorMessage(withErrorMessage(satisfy((v$1) => v$1 === "'"))("'\\''"))("end of character"))((() => {
          const $172 = satisfy((c) => c !== "'" && c !== "\\" && c > "");
          const $182 = withErrorMessage((() => {
            const $183 = withErrorMessage(satisfy((v$1) => v$1 === "\\"))("'\\\\'");
            return (state1, more, lift12, $$throw2, done) => more((v2) => more((v1) => $183(
              state1,
              more,
              lift12,
              $$throw2,
              (state2, a) => more((v2$1) => more((v3) => escapeCode(state2, more, lift12, $$throw2, (state3, a$1) => more((v4) => done(state3, a$1)))))
            )));
          })())("literal character");
          return (v2, $19, $20, $21, $22) => {
            const $23 = v2._1;
            const $24 = v2._2;
            return $19((v3) => $172(
              $ParseState($23, $24, false),
              $19,
              $20,
              (v4, $25) => {
                const $26 = v4._3;
                return $19((v5) => {
                  if ($26) {
                    return $21(v4, $25);
                  }
                  return $182(v2, $19, $20, $21, $22);
                });
              },
              $22
            ));
          };
        })());
        const $18 = whiteSpace$p(v);
        return (state1, more, lift12, $$throw2, done) => more((v2) => more((v1) => $17(
          state1,
          more,
          lift12,
          $$throw2,
          (state2, a) => more((v2$1) => more((v3) => $18(state2, more, lift12, $$throw2, (state3, a$1) => more((v4) => done(state3, a)))))
        )));
      })())("character"),
      stringLiteral: (() => {
        const $17 = withErrorMessage((() => {
          const $172 = between(withErrorMessage(satisfy((v$1) => v$1 === '"'))(`'"'`))(withErrorMessage(withErrorMessage(satisfy((v$1) => v$1 === '"'))(`'"'`))("end of string"))(many2(alternativeParserT)(lazyParserT)((() => {
            const $173 = satisfy((c) => c !== '"' && c !== "\\" && c > "");
            const $182 = withErrorMessage((() => {
              const $183 = withErrorMessage(satisfy((v$1) => v$1 === "\\"))("'\\\\'");
              return (state1, more, lift12, $$throw2, done) => more((v1) => $183(
                state1,
                more,
                lift12,
                $$throw2,
                (state2, a) => more((v2) => {
                  const $19 = state2._1;
                  const $20 = state2._2;
                  return more((v3) => more((v1$1) => escapeGap(
                    $ParseState($19, $20, false),
                    more,
                    lift12,
                    (v4, $21) => {
                      const $22 = v4._3;
                      return more((v5) => {
                        if ($22) {
                          return $$throw2(v4, $21);
                        }
                        const $23 = state2._1;
                        const $24 = state2._2;
                        return more((v3$1) => more((v1$2) => escapeEmpty(
                          $ParseState($23, $24, false),
                          more,
                          lift12,
                          (v4$1, $25) => {
                            const $26 = v4$1._3;
                            return more((v5$1) => {
                              if ($26) {
                                return $$throw2(v4$1, $25);
                              }
                              return more((v1$3) => escapeCode(state2, more, lift12, $$throw2, (state2$1, a$1) => more((v2$1) => done(state2$1, $Maybe("Just", a$1)))));
                            });
                          },
                          (state2$1, a$1) => more((v2$1) => done(state2$1, Nothing))
                        )));
                      });
                    },
                    (state2$1, a$1) => more((v2$1) => done(state2$1, Nothing))
                  )));
                })
              ));
            })())("string character");
            return (v2, $19, $20, $21, $22) => {
              const $23 = v2._1;
              const $24 = v2._2;
              return $19((v3) => $19((v1) => $173(
                $ParseState($23, $24, false),
                $19,
                $20,
                (v4, $25) => {
                  const $26 = v4._3;
                  return $19((v5) => {
                    if ($26) {
                      return $21(v4, $25);
                    }
                    return $182(v2, $19, $20, $21, $22);
                  });
                },
                (state2, a) => $19((v2$1) => $22(state2, $Maybe("Just", a)))
              )));
            };
          })()));
          return (state1, more, lift12, $$throw2, done) => more((v1) => $172(
            state1,
            more,
            lift12,
            $$throw2,
            (state2, a) => more((v2) => done(
              state2,
              fromCharArray(toUnfoldable9(foldableList.foldr((v1$1) => (v2$1) => {
                if (v1$1.tag === "Nothing") {
                  return v2$1;
                }
                if (v1$1.tag === "Just") {
                  return $List("Cons", v1$1._1, v2$1);
                }
                fail();
              })(Nil)(a)))
            ))
          ));
        })())("literal string");
        const $18 = whiteSpace$p(v);
        return (state1, more, lift12, $$throw2, done) => more((v2) => more((v1) => $17(
          state1,
          more,
          lift12,
          $$throw2,
          (state2, a) => more((v2$1) => more((v3) => $18(state2, more, lift12, $$throw2, (state3, a$1) => more((v4) => done(state3, a)))))
        )));
      })(),
      natural: withErrorMessage((() => {
        const $17 = whiteSpace$p(v);
        return (state1, more, lift12, $$throw2, done) => more((v2) => more((v1) => {
          const $18 = (state2, a) => more((v2$1) => more((v3) => $17(state2, more, lift12, $$throw2, (state3, a$1) => more((v4) => done(state3, a)))));
          const $19 = state1._1;
          const $20 = state1._2;
          return more((v3) => zeroNumber(
            $ParseState($19, $20, false),
            more,
            lift12,
            (v4, $21) => {
              const $22 = v4._3;
              return more((v5) => {
                if ($22) {
                  return $$throw2(v4, $21);
                }
                return decimal(state1, more, lift12, $$throw2, $18);
              });
            },
            $18
          ));
        }));
      })())("natural"),
      integer: withErrorMessage((() => {
        const $17 = whiteSpace$p(v);
        const $18 = whiteSpace$p(v);
        return (state1, more, lift12, $$throw2, done) => more((v2) => more((v1) => {
          const $19 = (state2, a) => more((v2$1) => more((v3) => $18(state2, more, lift12, $$throw2, (state3, a$1) => more((v4) => done(state3, a)))));
          return more((v1$1) => more((v2$1) => more((v1$2) => sign1(
            state1,
            more,
            lift12,
            $$throw2,
            (state2, a) => more((v2$2) => more((v3) => $17(
              state2,
              more,
              lift12,
              $$throw2,
              (state3, a$1) => more((v4) => more((v2$3) => more((v1$3) => {
                const $20 = state3._1;
                const $21 = state3._2;
                return more((v3$1) => zeroNumber(
                  $ParseState($20, $21, false),
                  more,
                  lift12,
                  (v4$1, $22) => {
                    const $23 = v4$1._3;
                    return more((v5) => {
                      if ($23) {
                        return $$throw2(v4$1, $22);
                      }
                      return decimal(state3, more, lift12, $$throw2, (state2$1, a$2) => more((v2$4) => $19(state2$1, a(a$2))));
                    });
                  },
                  (state2$1, a$2) => more((v2$4) => $19(state2$1, a(a$2)))
                ));
              })))
            )))
          ))));
        }));
      })())("integer"),
      float: withErrorMessage((() => {
        const $17 = whiteSpace$p(v);
        return (state1, more, lift12, $$throw2, done) => more((v2) => more((v1) => more((v1$1) => decimal(
          state1,
          more,
          lift12,
          $$throw2,
          (state2, a) => more((v2$1) => fractExponent(a)(
            state2,
            more,
            lift12,
            $$throw2,
            (state2$1, a$1) => more((v2$2) => more((v3) => $17(state2$1, more, lift12, $$throw2, (state3, a$2) => more((v4) => done(state3, a$1)))))
          ))
        ))));
      })())("float"),
      naturalOrFloat: withErrorMessage((() => {
        const $17 = withErrorMessage(satisfy((v$1) => v$1 === "0"))("'0'");
        const $18 = fractExponent(0);
        const $19 = whiteSpace$p(v);
        return (state1, more, lift12, $$throw2, done) => more((v2) => more((v1) => {
          const $20 = (state2, a) => more((v2$1) => more((v3) => $19(state2, more, lift12, $$throw2, (state3, a$1) => more((v4) => done(state3, a)))));
          const $21 = state1._1;
          const $22 = state1._2;
          return more((v3) => {
            const $23 = (v4, $232) => {
              const $24 = v4._3;
              return more((v5) => {
                if ($24) {
                  return $$throw2(v4, $232);
                }
                return decimalFloat(state1, more, lift12, $$throw2, $20);
              });
            };
            return more((v2$1) => more((v1$1) => $17(
              $ParseState($21, $22, false),
              more,
              lift12,
              $23,
              (state2, a) => more((v2$2) => more((v3$1) => {
                const $24 = state2._1;
                const $25 = state2._2;
                return more((v3$2) => {
                  const $26 = (v4, $262) => {
                    const $27 = v4._3;
                    return more((v5) => {
                      if ($27) {
                        return $23(v4, $262);
                      }
                      const $28 = state2._1;
                      const $29 = state2._2;
                      return more((v3$3) => decimalFloat(
                        $ParseState($28, $29, false),
                        more,
                        lift12,
                        (v4$1, $30) => {
                          const $31 = v4$1._3;
                          return more((v5$1) => {
                            if ($31) {
                              return $23(v4$1, $30);
                            }
                            const $32 = state2._1;
                            const $33 = state2._2;
                            return more((v3$4) => more((v1$2) => $18(
                              $ParseState($32, $33, false),
                              more,
                              lift12,
                              (v4$2, $34) => {
                                const $35 = v4$2._3;
                                return more((v5$2) => {
                                  if ($35) {
                                    return $23(v4$2, $34);
                                  }
                                  return more((v4$3) => $20(state2, $Either("Left", 0)));
                                });
                              },
                              (state2$1, a$1) => more((v2$3) => more((v4$2) => $20(state2$1, $Either("Right", a$1))))
                            )));
                          });
                        },
                        (state3, a$1) => more((v4$1) => $20(state3, a$1))
                      ));
                    });
                  };
                  return more((v1$2) => more((v3$3) => hexadecimal(
                    $ParseState($24, $25, false),
                    more,
                    lift12,
                    (v4, $27) => {
                      const $28 = v4._3;
                      return more((v5) => {
                        if ($28) {
                          return $26(v4, $27);
                        }
                        return octal(
                          $ParseState($24, $25, false),
                          more,
                          lift12,
                          $26,
                          (state2$1, a$1) => more((v2$3) => more((v4$1) => $20(state2$1, $Either("Left", a$1))))
                        );
                      });
                    },
                    (state2$1, a$1) => more((v2$3) => more((v4) => $20(state2$1, $Either("Left", a$1))))
                  )));
                });
              }))
            )));
          });
        }));
      })())("number"),
      decimal,
      hexadecimal,
      octal,
      symbol: (name3) => {
        const $17 = whiteSpace$p(v);
        return (state1, more, lift12, $$throw2, done) => more((v1) => more((v2) => more((v1$1) => string3(name3)(
          state1,
          more,
          lift12,
          $$throw2,
          (state2, a) => more((v2$1) => more((v3) => $17(state2, more, lift12, $$throw2, (state3, a$1) => more((v4) => more((v2$2) => done(state3, name3))))))
        ))));
      },
      lexeme: (p) => {
        const $17 = whiteSpace$p(v);
        return (state1, more, lift12, $$throw2, done) => more((v2) => more((v1) => p(
          state1,
          more,
          lift12,
          $$throw2,
          (state2, a) => more((v2$1) => more((v3) => $17(state2, more, lift12, $$throw2, (state3, a$1) => more((v4) => done(state3, a)))))
        )));
      },
      whiteSpace: whiteSpace$p(v),
      parens: (p) => between((() => {
        const $17 = whiteSpace$p(v);
        return (state1, more, lift12, $$throw2, done) => more((v1) => more((v2) => more((v1$1) => string3("(")(
          state1,
          more,
          lift12,
          $$throw2,
          (state2, a) => more((v2$1) => more((v3) => $17(state2, more, lift12, $$throw2, (state3, a$1) => more((v4) => more((v2$2) => done(state3, "("))))))
        ))));
      })())((() => {
        const $17 = whiteSpace$p(v);
        return (state1, more, lift12, $$throw2, done) => more((v1) => more((v2) => more((v1$1) => string3(")")(
          state1,
          more,
          lift12,
          $$throw2,
          (state2, a) => more((v2$1) => more((v3) => $17(state2, more, lift12, $$throw2, (state3, a$1) => more((v4) => more((v2$2) => done(state3, ")"))))))
        ))));
      })())(p),
      braces: (p) => between((() => {
        const $17 = whiteSpace$p(v);
        return (state1, more, lift12, $$throw2, done) => more((v1) => more((v2) => more((v1$1) => string3("{")(
          state1,
          more,
          lift12,
          $$throw2,
          (state2, a) => more((v2$1) => more((v3) => $17(state2, more, lift12, $$throw2, (state3, a$1) => more((v4) => more((v2$2) => done(state3, "{"))))))
        ))));
      })())((() => {
        const $17 = whiteSpace$p(v);
        return (state1, more, lift12, $$throw2, done) => more((v1) => more((v2) => more((v1$1) => string3("}")(
          state1,
          more,
          lift12,
          $$throw2,
          (state2, a) => more((v2$1) => more((v3) => $17(state2, more, lift12, $$throw2, (state3, a$1) => more((v4) => more((v2$2) => done(state3, "}"))))))
        ))));
      })())(p),
      angles: (p) => between((() => {
        const $17 = whiteSpace$p(v);
        return (state1, more, lift12, $$throw2, done) => more((v1) => more((v2) => more((v1$1) => string3("<")(
          state1,
          more,
          lift12,
          $$throw2,
          (state2, a) => more((v2$1) => more((v3) => $17(state2, more, lift12, $$throw2, (state3, a$1) => more((v4) => more((v2$2) => done(state3, "<"))))))
        ))));
      })())((() => {
        const $17 = whiteSpace$p(v);
        return (state1, more, lift12, $$throw2, done) => more((v1) => more((v2) => more((v1$1) => string3(">")(
          state1,
          more,
          lift12,
          $$throw2,
          (state2, a) => more((v2$1) => more((v3) => $17(state2, more, lift12, $$throw2, (state3, a$1) => more((v4) => more((v2$2) => done(state3, ">"))))))
        ))));
      })())(p),
      brackets: (p) => between((() => {
        const $17 = whiteSpace$p(v);
        return (state1, more, lift12, $$throw2, done) => more((v1) => more((v2) => more((v1$1) => string3("[")(
          state1,
          more,
          lift12,
          $$throw2,
          (state2, a) => more((v2$1) => more((v3) => $17(state2, more, lift12, $$throw2, (state3, a$1) => more((v4) => more((v2$2) => done(state3, "["))))))
        ))));
      })())((() => {
        const $17 = whiteSpace$p(v);
        return (state1, more, lift12, $$throw2, done) => more((v1) => more((v2) => more((v1$1) => string3("]")(
          state1,
          more,
          lift12,
          $$throw2,
          (state2, a) => more((v2$1) => more((v3) => $17(state2, more, lift12, $$throw2, (state3, a$1) => more((v4) => more((v2$2) => done(state3, "]"))))))
        ))));
      })())(p),
      semi: semi2,
      comma: comma2,
      colon: (() => {
        const $17 = whiteSpace$p(v);
        return (state1, more, lift12, $$throw2, done) => more((v1) => more((v2) => more((v1$1) => string3(":")(
          state1,
          more,
          lift12,
          $$throw2,
          (state2, a) => more((v2$1) => more((v3) => $17(state2, more, lift12, $$throw2, (state3, a$1) => more((v4) => more((v2$2) => done(state3, ":"))))))
        ))));
      })(),
      dot: (() => {
        const $17 = whiteSpace$p(v);
        return (state1, more, lift12, $$throw2, done) => more((v1) => more((v2) => more((v1$1) => string3(".")(
          state1,
          more,
          lift12,
          $$throw2,
          (state2, a) => more((v2$1) => more((v3) => $17(state2, more, lift12, $$throw2, (state3, a$1) => more((v4) => more((v2$2) => done(state3, "."))))))
        ))));
      })(),
      semiSep: (p) => sepBy(p)(semi2),
      semiSep1: (p) => sepBy1(p)(semi2),
      commaSep: (p) => sepBy(p)(comma2),
      commaSep1: (p) => sepBy1(p)(comma2)
    };
  };

  // output-es/Parsing.Language/index.js
  var emptyDef = /* @__PURE__ */ (() => {
    const op$p = oneOf([":", "!", "#", "$", "%", "&", "*", "+", ".", "/", "<", "=", ">", "?", "@", "\\", "^", "|", "-", "~"]);
    return {
      commentStart: "",
      commentEnd: "",
      commentLine: "",
      nestedComments: true,
      identStart: (() => {
        const $0 = withErrorMessage(satisfy((v) => v === "_"))("'_'");
        return (v2, $1, $2, $3, $4) => {
          const $5 = v2._1;
          const $6 = v2._2;
          return $1((v3) => letter(
            $ParseState($5, $6, false),
            $1,
            $2,
            (v4, $7) => {
              const $8 = v4._3;
              return $1((v5) => {
                if ($8) {
                  return $3(v4, $7);
                }
                return $0(v2, $1, $2, $3, $4);
              });
            },
            $4
          ));
        };
      })(),
      identLetter: (() => {
        const $0 = oneOf(["_", "'"]);
        return (v2, $1, $2, $3, $4) => {
          const $5 = v2._1;
          const $6 = v2._2;
          return $1((v3) => alphaNum(
            $ParseState($5, $6, false),
            $1,
            $2,
            (v4, $7) => {
              const $8 = v4._3;
              return $1((v5) => {
                if ($8) {
                  return $3(v4, $7);
                }
                return $0(v2, $1, $2, $3, $4);
              });
            },
            $4
          ));
        };
      })(),
      opStart: op$p,
      opLetter: op$p,
      reservedOpNames: [],
      reservedNames: [],
      caseSensitive: true
    };
  })();
  var haskellStyle = /* @__PURE__ */ (() => {
    const op$p = oneOf([":", "!", "#", "$", "%", "&", "*", "+", ".", "/", "<", "=", ">", "?", "@", "\\", "^", "|", "-", "~"]);
    return {
      ...emptyDef,
      commentStart: "{-",
      commentEnd: "-}",
      commentLine: "--",
      nestedComments: true,
      identStart: letter,
      identLetter: (() => {
        const $0 = oneOf(["_", "'"]);
        return (v2, $1, $2, $3, $4) => {
          const $5 = v2._1;
          const $6 = v2._2;
          return $1((v3) => alphaNum(
            $ParseState($5, $6, false),
            $1,
            $2,
            (v4, $7) => {
              const $8 = v4._3;
              return $1((v5) => {
                if ($8) {
                  return $3(v4, $7);
                }
                return $0(v2, $1, $2, $3, $4);
              });
            },
            $4
          ));
        };
      })(),
      opStart: op$p,
      opLetter: op$p,
      reservedOpNames: [],
      reservedNames: [],
      caseSensitive: true
    };
  })();
  var haskell98Def = {
    ...haskellStyle,
    reservedOpNames: ["::", "..", "=", "\\", "|", "<-", "->", "@", "~", "=>"],
    reservedNames: [
      "let",
      "in",
      "case",
      "of",
      "if",
      "then",
      "else",
      "data",
      "type",
      "class",
      "default",
      "deriving",
      "do",
      "import",
      "infix",
      "infixl",
      "infixr",
      "instance",
      "module",
      "newtype",
      "where",
      "primitive"
    ]
  };
  var javaStyle = {
    ...emptyDef,
    commentStart: "/*",
    commentEnd: "*/",
    commentLine: "//",
    nestedComments: true,
    identStart: /* @__PURE__ */ (() => {
      const $0 = oneOf(["_", "$"]);
      return (v2, $1, $2, $3, $4) => {
        const $5 = v2._1;
        const $6 = v2._2;
        return $1((v3) => letter(
          $ParseState($5, $6, false),
          $1,
          $2,
          (v4, $7) => {
            const $8 = v4._3;
            return $1((v5) => {
              if ($8) {
                return $3(v4, $7);
              }
              return $0(v2, $1, $2, $3, $4);
            });
          },
          $4
        ));
      };
    })(),
    identLetter: /* @__PURE__ */ (() => {
      const $0 = oneOf(["_", "$"]);
      return (v2, $1, $2, $3, $4) => {
        const $5 = v2._1;
        const $6 = v2._2;
        return $1((v3) => alphaNum(
          $ParseState($5, $6, false),
          $1,
          $2,
          (v4, $7) => {
            const $8 = v4._3;
            return $1((v5) => {
              if ($8) {
                return $3(v4, $7);
              }
              return $0(v2, $1, $2, $3, $4);
            });
          },
          $4
        ));
      };
    })(),
    reservedNames: [],
    reservedOpNames: [],
    caseSensitive: false
  };

  // output-es/Util.Parse/index.js
  var some3 = (p) => {
    const $0 = some2(alternativeParserT)(lazyParserT)(p);
    return (state1, more, lift12, $$throw2, done) => more((v1) => $0(state1, more, lift12, $$throw2, (state2, a) => more((v2) => done(state2, nonEmptyListNonEmptyList.nonEmpty(a)))));
  };
  var sepBy1_try = (p) => (sep) => {
    const $0 = many2(alternativeParserT)(lazyParserT)((v1, $02, $1, $2, $3) => {
      const $4 = v1._3;
      return $02((v2) => $02((v1$1) => sep(
        v1,
        $02,
        $1,
        (v2$1, $5) => $2($ParseState(v2$1._1, v2$1._2, $4), $5),
        (state2, a) => $02((v2$1) => $02((v3) => p(state2, $02, $1, (v2$2, $5) => $2($ParseState(v2$2._1, v2$2._2, $4), $5), (state3, a$1) => $02((v4) => $3(state3, a$1)))))
      )));
    });
    return (state1, more, lift12, $$throw2, done) => more((v2) => more((v1) => p(
      state1,
      more,
      lift12,
      $$throw2,
      (state2, a) => more((v2$1) => more((v3) => $0(state2, more, lift12, $$throw2, (state3, a$1) => more((v4) => done(state3, $NonEmpty(a, a$1))))))
    )));
  };
  var sepBy_try = (p) => (sep) => {
    const $0 = sepBy1_try(p)(sep);
    return (v2, $1, $2, $3, $4) => {
      const $5 = v2._1;
      const $6 = v2._2;
      return $1((v3) => $1((v1) => $0(
        $ParseState($5, $6, false),
        $1,
        $2,
        (v4, $7) => {
          const $8 = v4._3;
          return $1((v5) => {
            if ($8) {
              return $3(v4, $7);
            }
            return $4(v2, Nil);
          });
        },
        (state2, a) => $1((v2$1) => $4(state2, $List("Cons", a._1, a._2)))
      )));
    };
  };

  // output-es/Parse/index.js
  var fromFoldable19 = ($0) => fromFoldableImpl(foldableNonEmptyList.foldr, $0);
  var onlyIf = (b) => (a) => {
    const $0 = b ? (state1, v, v1, v2, done) => done(state1, void 0) : fail2("No alternative");
    return (state1, more, lift12, $$throw2, done) => more((v1) => $0(state1, more, lift12, $$throw2, (state2, a$1) => more((v2) => done(state2, a))));
  };
  var choose2 = /* @__PURE__ */ choose(altParserT);
  var fanin3 = /* @__PURE__ */ fanin(categoryFn)(choiceFn);
  var identity30 = (x2) => x2;
  var operators = (binaryOp) => fromFoldableImpl(
    foldableList.foldr,
    listMap(arrayMap((v) => $Operator(
      "Infix",
      (() => {
        const $0 = binaryOp(v.op);
        return (v1, $1, $2, $3, $4) => {
          const $5 = v1._3;
          return $0(v1, $1, $2, (v2, $6) => $3($ParseState(v2._1, v2._2, $5), $6), $4);
        };
      })(),
      v.assoc
    )))(listMap(fromFoldable19)(groupBy2((x2) => (y2) => x2.prec === y2.prec)(sortBy2((x2) => (x$1) => {
      const $0 = ordInt.compare(x2.prec)(x$1.prec);
      if ($0 === "GT") {
        return LT;
      }
      if ($0 === "EQ") {
        return EQ;
      }
      if ($0 === "LT") {
        return GT;
      }
      fail();
    })(values2(opDefs)))))
  );
  var languageDef = /* @__PURE__ */ (() => {
    const opChar = oneOf([":", "!", "#", "$", "%", "&", "*", "+", ".", "/", "<", "=", ">", "?", "@", "\\", "^", "|", "-", "~"]);
    return {
      ...emptyDef,
      commentStart: "{-",
      commentEnd: "-}",
      commentLine: "--",
      nestedComments: true,
      identStart: (() => {
        const $0 = withErrorMessage(satisfy((v) => v === "_"))("'_'");
        return (v2, $1, $2, $3, $4) => {
          const $5 = v2._1;
          const $6 = v2._2;
          return $1((v3) => letter(
            $ParseState($5, $6, false),
            $1,
            $2,
            (v4, $7) => {
              const $8 = v4._3;
              return $1((v5) => {
                if ($8) {
                  return $3(v4, $7);
                }
                return $0(v2, $1, $2, $3, $4);
              });
            },
            $4
          ));
        };
      })(),
      identLetter: (() => {
        const $0 = oneOf(["_", "'"]);
        return (v2, $1, $2, $3, $4) => {
          const $5 = v2._1;
          const $6 = v2._2;
          return $1((v3) => alphaNum(
            $ParseState($5, $6, false),
            $1,
            $2,
            (v4, $7) => {
              const $8 = v4._3;
              return $1((v5) => {
                if ($8) {
                  return $3(v4, $7);
                }
                return $0(v2, $1, $2, $3, $4);
              });
            },
            $4
          ));
        };
      })(),
      opStart: opChar,
      opLetter: opChar,
      reservedOpNames: ["|", "..", "=", "<-", "->"],
      reservedNames: ["as", "else", "fun", "if", "in", "let", "match", "then"],
      caseSensitive: true
    };
  })();
  var token = /* @__PURE__ */ makeTokenParser(languageDef);
  var rArrow = /* @__PURE__ */ (() => token.reservedOp("->"))();
  var rBracket = /* @__PURE__ */ (() => {
    const $0 = token.symbol("]");
    return (state1, more, lift12, $$throw2, done) => more((v1) => $0(state1, more, lift12, $$throw2, (state2, a) => more((v2) => done(state2, void 0))));
  })();
  var topLevel = (p) => (state1, more, lift12, $$throw2, done) => more((v2) => more((v1) => more((v2$1) => more((v1$1) => token.whiteSpace(
    state1,
    more,
    lift12,
    $$throw2,
    (state2, a) => more((v2$2) => more((v3) => p(
      state2,
      more,
      lift12,
      $$throw2,
      (state3, a$1) => more((v4) => more((v2$3) => more((v3$1) => eof(state3, more, lift12, $$throw2, (state3$1, a$2) => more((v4$1) => done(state3$1, a$1))))))
    )))
  )))));
  var lBracket = /* @__PURE__ */ (() => {
    const $0 = token.symbol("[");
    return (state1, more, lift12, $$throw2, done) => more((v1) => $0(state1, more, lift12, $$throw2, (state2, a) => more((v2) => done(state2, void 0))));
  })();
  var lArrow = /* @__PURE__ */ (() => token.reservedOp("<-"))();
  var keyword2 = (str$p) => {
    if (elem(eqString)(str$p)(languageDef.reservedNames)) {
      return token.reserved(str$p);
    }
    return throwException(error(str$p + " is not a reserved word"))();
  };
  var ident = (state1, more, lift12, $$throw2, done) => more((v1) => token.identifier(
    state1,
    more,
    lift12,
    $$throw2,
    (state2, a) => more((v2) => onlyIf(!isCtrName(a))(a)(state2, more, lift12, $$throw2, done))
  ));
  var field2 = (p) => (state1, more, lift12, $$throw2, done) => more((v2) => more((v1) => ident(
    state1,
    more,
    lift12,
    $$throw2,
    (state2, a) => more((v2$1) => {
      const $0 = Tuple(a);
      return more((v3) => more((v2$2) => more((v1$1) => token.colon(
        state2,
        more,
        lift12,
        $$throw2,
        (state2$1, a$1) => more((v2$3) => more((v3$1) => p(state2$1, more, lift12, $$throw2, (state3, a$2) => more((v4) => more((v4$1) => done(state3, $0(a$2)))))))
      ))));
    })
  )));
  var equals = /* @__PURE__ */ (() => token.reservedOp("="))();
  var patternDelim = (v2, $0, $1, $2, $3) => {
    const $4 = v2._1;
    const $5 = v2._2;
    return $0((v3) => rArrow(
      $ParseState($4, $5, false),
      $0,
      $1,
      (v4, $6) => {
        const $7 = v4._3;
        return $0((v5) => {
          if ($7) {
            return $2(v4, $6);
          }
          return equals(v2, $0, $1, $2, $3);
        });
      },
      $3
    ));
  };
  var ellipsis = /* @__PURE__ */ (() => token.reservedOp(".."))();
  var ctr = (state1, more, lift12, $$throw2, done) => more((v1) => token.identifier(
    state1,
    more,
    lift12,
    $$throw2,
    (state2, a) => more((v2) => onlyIf(isCtrName(a))(a)(state2, more, lift12, $$throw2, done))
  ));
  var simplePattern = (pattern$p) => {
    const $0 = token.brackets((state1, v, v1, v2, done) => done(state1, PListEmpty));
    const go$lazy = binding(() => lazyParserT.defer((v) => (v2, $12, $22, $32, $4) => {
      const $5 = v2._1;
      const $6 = v2._2;
      return $12((v3) => $12((v2$1) => $12((v1) => rBracket(
        $ParseState($5, $6, false),
        $12,
        $22,
        (v4, $7) => {
          const $8 = v4._3;
          return $12((v5) => {
            if ($8) {
              return $32(v4, $7);
            }
            return $12((v2$2) => $12((v1$1) => token.comma(
              v2,
              $12,
              $22,
              $32,
              (state2, a) => $12((v2$3) => $12((v3$1) => $12((v2$4) => $12((v1$2) => pattern$p(
                state2,
                $12,
                $22,
                $32,
                (state2$1, a$1) => $12((v2$5) => {
                  const $9 = PListNext(a$1);
                  return $12((v3$2) => go$lazy()(
                    state2$1,
                    $12,
                    $22,
                    $32,
                    (state3, a$2) => $12((v4$1) => {
                      const $10 = $9(a$2);
                      return $12((v4$2) => $4(state3, $10));
                    })
                  ));
                })
              )))))
            )));
          });
        },
        (state2, a) => $12((v2$2) => $12((v3$1) => $12((v4) => $4(state2, PListEnd))))
      ))));
    }));
    const go = go$lazy();
    const $1 = token.braces((state1, more, lift12, $$throw2, done) => more((v1) => sepBy(field2(pattern$p))(token.comma)(
      state1,
      more,
      lift12,
      $$throw2,
      (state2, a) => more((v2) => done(state2, $Pattern("PRecord", a)))
    )));
    const $2 = token.parens(pattern$p);
    const $3 = token.parens((state1, more, lift12, $$throw2, done) => more((v1) => more((v2) => more((v1$1) => pattern$p(
      state1,
      more,
      lift12,
      $$throw2,
      (state2, a) => more((v2$1) => more((v3) => token.comma(
        state2,
        more,
        lift12,
        $$throw2,
        (state3, a$1) => more((v4) => more((v2$2) => more((v1$2) => pattern$p(
          state3,
          more,
          lift12,
          $$throw2,
          (state2$1, a$2) => more((v2$3) => done(
            state2$1,
            $Pattern("PConstr", "Pair", $List("Cons", a, $List("Cons", a$2, Nil)))
          ))
        ))))
      )))
    )))));
    return (v2, $4, $5, $6, $7) => {
      const $8 = v2._1;
      const $9 = v2._2;
      return $4((v3) => $0(
        $ParseState($8, $9, false),
        $4,
        $5,
        (v2$1, $10) => $4((v5) => {
          const $11 = v2._1;
          const $12 = v2._2;
          return $4((v3$1) => {
            const $13 = (v4, $132) => {
              const $14 = v4._3;
              return $4((v5$1) => {
                if ($14) {
                  return $6(v4, $132);
                }
                const $15 = v2._1;
                const $16 = v2._2;
                return $4((v3$2) => $4((v1) => $4((v1$1) => ctr(
                  $ParseState($15, $16, false),
                  $4,
                  $5,
                  (v2$2, $17) => $4((v5$2) => {
                    const $18 = v2._1;
                    const $19 = v2._2;
                    return $4((v3$3) => $1(
                      $ParseState($18, $19, false),
                      $4,
                      $5,
                      (v2$3, $20) => $4((v5$3) => {
                        const $21 = v2._1;
                        const $22 = v2._2;
                        return $4((v3$4) => $4((v1$2) => ident(
                          $ParseState($21, $22, false),
                          $4,
                          $5,
                          (v2$4, $23) => $4((v5$4) => {
                            const $24 = v2._1;
                            const $25 = v2._2;
                            return $4((v3$5) => $2($ParseState($24, $25, false), $4, $5, (v2$5, $26) => $4((v5$5) => $3(v2, $4, $5, $6, $7)), $7));
                          }),
                          (state2, a) => $4((v2$4) => $7(state2, $Pattern("PVar", a)))
                        )));
                      }),
                      $7
                    ));
                  }),
                  (state2, a) => $4((v2$2) => {
                    const $17 = PConstr(a);
                    return $4((v2$3) => $7(state2, $17(Nil)));
                  })
                ))));
              });
            };
            return $4((v2$2) => $4((v1) => lBracket(
              $ParseState($11, $12, false),
              $4,
              $5,
              $13,
              (state2, a) => $4((v2$3) => $4((v3$2) => $4((v2$4) => $4((v1$1) => pattern$p(
                state2,
                $4,
                $5,
                $13,
                (state2$1, a$1) => $4((v2$5) => {
                  const $14 = PListNonEmpty(a$1);
                  return $4((v3$3) => go(
                    state2$1,
                    $4,
                    $5,
                    $13,
                    (state3, a$2) => $4((v4) => {
                      const $15 = $14(a$2);
                      return $4((v4$1) => $7(state3, $15));
                    })
                  ));
                })
              )))))
            )));
          });
        }),
        $7
      ));
    };
  };
  var pattern2 = /* @__PURE__ */ (() => {
    const $0 = buildExprParser(operators((op) => (state1, more, lift12, $$throw2, done) => more((v1) => token.operator(
      state1,
      more,
      lift12,
      $$throw2,
      (state2, a) => more((v2) => onlyIf(":" === definitely("absurd")(charAt2(0)(a)) && op === a)((\u03C0) => (\u03C0$p) => $Pattern(
        "PConstr",
        a,
        $List("Cons", \u03C0, $List("Cons", \u03C0$p, Nil))
      ))(state2, more, lift12, $$throw2, done))
    ))));
    const go$lazy = binding(() => lazyParserT.defer((v) => $0((() => {
      const rest = (v$1) => {
        if (v$1.tag === "PConstr") {
          const $12 = v$1._1;
          const $2 = v$1._2;
          const $3 = simplePattern(go$lazy());
          return (v2, $4, $5, $6, $7) => {
            const $8 = v2._1;
            const $9 = v2._2;
            return $4((v3) => {
              const $10 = (v4, $102) => {
                const $11 = v4._3;
                return $4((v5) => {
                  if ($11) {
                    return $6(v4, $102);
                  }
                  return $7(v2, v$1);
                });
              };
              return $4((v1) => $3(
                $ParseState($8, $9, false),
                $4,
                $5,
                $10,
                (state2, a) => $4((v2$1) => rest($Pattern(
                  "PConstr",
                  $12,
                  foldableList.foldr(Cons)($List("Cons", a, Nil))($2)
                ))(state2, $4, $5, $10, $7))
              ));
            });
          };
        }
        return (state1, v$2, v1, v2, done) => done(state1, v$1);
      };
      const $1 = simplePattern(go$lazy());
      return (state1, more, lift12, $$throw2, done) => more((v1) => $1(state1, more, lift12, $$throw2, (state2, a) => more((v2) => rest(a)(state2, more, lift12, $$throw2, done))));
    })())));
    const go = go$lazy();
    return go;
  })();
  var varDefs = (expr$p) => {
    const $0 = keyword2("let");
    const $1 = sepBy1_try((state1, more, lift12, $$throw2, done) => more((v2) => more((v1) => more((v2$1) => more((v1$1) => pattern2(
      state1,
      more,
      lift12,
      $$throw2,
      (state2, a) => more((v2$2) => more((v3) => equals(
        state2,
        more,
        lift12,
        $$throw2,
        (state3, a$1) => more((v4) => more((v2$3) => {
          const $12 = VarDef2(a);
          return more((v3$1) => expr$p(state3, more, lift12, $$throw2, (state3$1, a$2) => more((v4$1) => done(state3$1, $12(a$2)))));
        }))
      )))
    ))))))(token.semi);
    return (state1, more, lift12, $$throw2, done) => more((v2) => more((v1) => $0(
      state1,
      more,
      lift12,
      $$throw2,
      (state2, a) => more((v2$1) => more((v3) => $1(state2, more, lift12, $$throw2, (state3, a$1) => more((v4) => done(state3, a$1)))))
    )));
  };
  var colonEq = /* @__PURE__ */ (() => token.reservedOp(":="))();
  var clause_uncurried = (expr$p) => (delim) => (state1, more, lift12, $$throw2, done) => more((v2) => more((v1) => pattern2(
    state1,
    more,
    lift12,
    $$throw2,
    (state2, a) => more((v2$1) => {
      const $0 = Tuple(a);
      return more((v3) => more((v2$2) => more((v1$1) => delim(
        state2,
        more,
        lift12,
        $$throw2,
        (state2$1, a$1) => more((v2$3) => more((v3$1) => expr$p(state2$1, more, lift12, $$throw2, (state3, a$2) => more((v4) => more((v4$1) => done(state3, $0(a$2)))))))
      ))));
    })
  )));
  var clause_curried = (expr$p) => (delim) => {
    const $0 = some3(simplePattern(pattern2));
    return (state1, more, lift12, $$throw2, done) => more((v1) => more((v2) => more((v1$1) => $0(
      state1,
      more,
      lift12,
      $$throw2,
      (state2, a) => more((v2$1) => {
        const $1 = Tuple(a);
        return more((v3) => more((v2$2) => more((v1$2) => delim(
          state2,
          more,
          lift12,
          $$throw2,
          (state2$1, a$1) => more((v2$3) => more((v3$1) => expr$p(
            state2$1,
            more,
            lift12,
            $$throw2,
            (state3, a$2) => more((v4) => more((v4$1) => {
              const $2 = $1(a$2);
              return more((v2$4) => done(state3, $2));
            }))
          )))
        ))));
      })
    ))));
  };
  var recDefs = (expr$p) => {
    const $0 = keyword2("let");
    const $1 = sepBy1_try((() => {
      const $12 = clause_curried(expr$p)(equals);
      return (state1, more, lift12, $$throw2, done) => more((v2) => more((v1) => ident(
        state1,
        more,
        lift12,
        $$throw2,
        (state2, a) => more((v2$1) => {
          const $2 = Tuple(a);
          return more((v3) => $12(state2, more, lift12, $$throw2, (state3, a$1) => more((v4) => done(state3, $2(a$1)))));
        })
      )));
    })())(token.semi);
    return (state1, more, lift12, $$throw2, done) => more((v2) => more((v1) => $0(
      state1,
      more,
      lift12,
      $$throw2,
      (state2, a) => more((v2$1) => more((v3) => $1(state2, more, lift12, $$throw2, (state3, a$1) => more((v4) => done(state3, a$1)))))
    )));
  };
  var defs = (expr$p) => {
    const $0 = choose2((() => {
      const $02 = varDefs(expr$p);
      return (v1, $1, $2, $3, $4) => {
        const $5 = v1._3;
        return $02(v1, $1, $2, (v2, $6) => $3($ParseState(v2._1, v2._2, $5), $6), $4);
      };
    })())(recDefs(expr$p));
    return (state1, more, lift12, $$throw2, done) => more((v1) => $0(
      state1,
      more,
      lift12,
      $$throw2,
      (state2, a) => more((v2) => done(state2, $List("Cons", a, Nil)))
    ));
  };
  var branches = (expr$p) => (branch_) => {
    const $0 = branch_(expr$p)(patternDelim);
    const $1 = token.braces(sepBy1(branch_(expr$p)(rArrow))(token.semi));
    return (v2, $2, $3, $4, $5) => {
      const $6 = v2._1;
      const $7 = v2._2;
      return $2((v3) => $2((v1) => $0(
        $ParseState($6, $7, false),
        $2,
        $3,
        (v4, $8) => {
          const $9 = v4._3;
          return $2((v5) => {
            if ($9) {
              return $4(v4, $8);
            }
            return $1(v2, $2, $3, $4, $5);
          });
        },
        (state2, a) => $2((v2$1) => $5(state2, $NonEmpty(a, Nil)))
      )));
    };
  };
  var bar = /* @__PURE__ */ (() => token.reservedOp("|"))();
  var backtick = /* @__PURE__ */ (() => {
    const $0 = token.symbol("`");
    return (state1, more, lift12, $$throw2, done) => more((v1) => $0(state1, more, lift12, $$throw2, (state2, a) => more((v2) => done(state2, void 0))));
  })();
  var expr_ = /* @__PURE__ */ (() => {
    const $0 = buildExprParser([
      [
        $Operator(
          "Infix",
          (state1, more, lift12, $$throw2, done) => more((v1) => between(backtick)(backtick)(ident)(
            state1,
            more,
            lift12,
            $$throw2,
            (state2, a) => more((v2) => done(state2, (e) => (e$p) => $Expr2("BinaryApp", e, a, e$p)))
          )),
          AssocLeft
        )
      ],
      ...operators((op) => (state1, more, lift12, $$throw2, done) => more((v1) => token.operator(
        state1,
        more,
        lift12,
        $$throw2,
        (state2, a) => more((v2) => onlyIf(op === a)((() => {
          if (op === ".") {
            return (e) => (e$p) => {
              if (e$p.tag === "Var") {
                return $Expr2("Project", e, e$p._1);
              }
              return throwException(error('Field names are not first class; got "' + intercalate3("\n")(removeDocWS(prettyExpr1(annUnit).pretty(e$p)).lines) + '".'))();
            };
          }
          if (":" === definitely("absurd")(charAt2(0)(a))) {
            return (e) => (e$p) => $Expr2("Constr", void 0, a, $List("Cons", e, $List("Cons", e$p, Nil)));
          }
          return (e) => (e$p) => $Expr2("BinaryApp", e, op, e$p);
        })())(state2, more, lift12, $$throw2, done))
      )))
    ]);
    const go$lazy = binding(() => lazyParserT.defer((v) => $0((() => {
      const $1 = keyword2("match");
      const $2 = keyword2("as");
      const $3 = branches(go$lazy())(clause_uncurried);
      const $4 = keyword2("if");
      const $5 = keyword2("then");
      const $6 = keyword2("else");
      const $7 = keyword2("fun");
      const $8 = branches(go$lazy())(clause_curried);
      const $9 = (() => {
        const $92 = sepBy1(defs(go$lazy()))(token.semi);
        const $10 = between(token.symbol("[|"))(token.symbol("|]"))((() => {
          const $102 = Matrix2();
          const $112 = token.parens((state1, more, lift12, $$throw2, done) => more((v2) => more((v1) => ident(
            state1,
            more,
            lift12,
            $$throw2,
            (state2, a) => more((v2$1) => {
              const $113 = Tuple(a);
              return more((v3) => more((v2$2) => more((v1$1) => token.comma(
                state2,
                more,
                lift12,
                $$throw2,
                (state2$1, a$1) => more((v2$3) => more((v3$1) => ident(state2$1, more, lift12, $$throw2, (state3, a$2) => more((v4) => more((v4$1) => done(state3, $113(a$2)))))))
              ))));
            })
          ))));
          const $122 = keyword2("in");
          return (state1, more, lift12, $$throw2, done) => more((v2) => more((v2$1) => more((v1) => more((v2$2) => more((v1$1) => go$lazy()(
            state1,
            more,
            lift12,
            $$throw2,
            (state2, a) => more((v2$3) => more((v3) => bar(
              state2,
              more,
              lift12,
              $$throw2,
              (state3, a$1) => more((v4) => more((v2$4) => {
                const $13 = $102(a);
                return more((v3$1) => $112(
                  state3,
                  more,
                  lift12,
                  $$throw2,
                  (state3$1, a$2) => more((v4$1) => {
                    const $14 = $13(a$2);
                    return more((v3$2) => more((v2$5) => more((v1$2) => $122(
                      state3$1,
                      more,
                      lift12,
                      $$throw2,
                      (state2$1, a$3) => more((v2$6) => more((v3$3) => go$lazy()(state2$1, more, lift12, $$throw2, (state3$2, a$4) => more((v4$2) => more((v4$3) => done(state3$2, $14(a$4)))))))
                    ))));
                  })
                ));
              }))
            )))
          ))))));
        })());
        const $11 = token.brackets((state1, v$1, v1, v2, done) => done(state1, $Expr2("ListEmpty", void 0)));
        const $12 = (() => {
          const $122 = ListNonEmpty();
          const go$1$lazy = binding(() => lazyParserT.defer((v$1) => {
            const $132 = Next();
            return (v2, $142, $152, $16, $17) => {
              const $18 = v2._1;
              const $19 = v2._2;
              return $142((v3) => $142((v2$1) => $142((v1) => rBracket(
                $ParseState($18, $19, false),
                $142,
                $152,
                (v4, $20) => {
                  const $21 = v4._3;
                  return $142((v5) => {
                    if ($21) {
                      return $16(v4, $20);
                    }
                    return $142((v2$2) => $142((v1$1) => token.comma(
                      v2,
                      $142,
                      $152,
                      $16,
                      (state2, a) => $142((v2$3) => $142((v3$1) => $142((v2$4) => $142((v1$2) => go$lazy()(
                        state2,
                        $142,
                        $152,
                        $16,
                        (state2$1, a$1) => $142((v2$5) => {
                          const $22 = $132(a$1);
                          return $142((v3$2) => go$1$lazy()(
                            state2$1,
                            $142,
                            $152,
                            $16,
                            (state3, a$2) => $142((v4$1) => {
                              const $23 = $22(a$2);
                              return $142((v4$2) => $17(state3, $23));
                            })
                          ));
                        })
                      )))))
                    )));
                  });
                },
                (state2, a) => $142((v2$2) => $142((v3$1) => $142((v4) => $17(state2, $ListRest("End", void 0)))))
              ))));
            };
          }));
          const go$1 = go$1$lazy();
          const $13 = token.brackets((() => {
            const $132 = ListComp();
            const $142 = sepBy1((() => {
              const $143 = keyword2("let");
              return (v2, $152, $16, $17, $18) => {
                const $19 = v2._1;
                const $20 = v2._2;
                return $152((v3) => {
                  const $21 = (v4, $212) => {
                    const $22 = v4._3;
                    return $152((v5) => {
                      if ($22) {
                        return $17(v4, $212);
                      }
                      const $23 = v2._1;
                      const $24 = v2._2;
                      return $152((v3$1) => $152((v1) => {
                        const $25 = (v4$1, $252) => {
                          const $26 = v4$1._3;
                          return $152((v5$1) => {
                            if ($26) {
                              return $17(v4$1, $252);
                            }
                            return $152((v1$1) => go$lazy()(v2, $152, $16, $17, (state2, a) => $152((v2$1) => $18(state2, $Qualifier("ListCompGuard", a)))));
                          });
                        };
                        return $152((v2$1) => $152((v1$1) => $152((v2$2) => $152((v1$2) => $152((v2$3) => $152((v1$3) => $143(
                          $ParseState($23, $24, false),
                          $152,
                          $16,
                          $25,
                          (state2, a) => $152((v2$4) => $152((v3$2) => pattern2(
                            state2,
                            $152,
                            $16,
                            $25,
                            (state3, a$1) => $152((v4$1) => $152((v2$5) => $152((v3$3) => equals(
                              state3,
                              $152,
                              $16,
                              $25,
                              (state3$1, a$2) => $152((v4$2) => $152((v2$6) => {
                                const $26 = VarDef2(a$1);
                                return $152((v3$4) => go$lazy()(
                                  state3$1,
                                  $152,
                                  $16,
                                  $25,
                                  (state3$2, a$3) => $152((v4$3) => {
                                    const $27 = $26(a$3);
                                    return $152((v2$7) => $18(state3$2, $Qualifier("ListCompDecl", $27)));
                                  })
                                ));
                              }))
                            ))))
                          )))
                        )))))));
                      }));
                    });
                  };
                  return $152((v2$1) => $152((v2$2) => $152((v1) => $152((v1$1) => pattern2(
                    $ParseState($19, $20, false),
                    $152,
                    $16,
                    $21,
                    (state2, a) => $152((v2$3) => {
                      const $22 = ListCompGen(a);
                      return $152((v2$4) => $152((v3$1) => lArrow(
                        state2,
                        $152,
                        $16,
                        $21,
                        (state3, a$1) => $152((v4) => $152((v3$2) => go$lazy()(state3, $152, $16, $21, (state3$1, a$2) => $152((v4$1) => $18(state3$1, $22(a$2))))))
                      )));
                    })
                  )))));
                });
              };
            })())(token.comma);
            return (state1, more, lift12, $$throw2, done) => more((v2) => more((v2$1) => more((v1) => more((v2$2) => more((v3) => go$lazy()(
              state1,
              more,
              lift12,
              $$throw2,
              (state3, a) => more((v4) => {
                const $152 = $132(a);
                return more((v2$3) => more((v3$1) => bar(
                  state3,
                  more,
                  lift12,
                  $$throw2,
                  (state3$1, a$1) => more((v4$1) => more((v3$2) => more((v1$1) => $142(
                    state3$1,
                    more,
                    lift12,
                    $$throw2,
                    (state2, a$2) => more((v2$4) => {
                      const $16 = $List("Cons", a$2._1, a$2._2);
                      return more((v4$2) => done(state2, $152($16)));
                    })
                  ))))
                )));
              })
            ))))));
          })());
          const $14 = token.brackets((state1, more, lift12, $$throw2, done) => more((v2) => more((v2$1) => more((v1) => more((v2$2) => more((v3) => go$lazy()(
            state1,
            more,
            lift12,
            $$throw2,
            (state3, a) => more((v4) => {
              const $142 = ListEnum(a);
              return more((v2$3) => more((v3$1) => ellipsis(
                state3,
                more,
                lift12,
                $$throw2,
                (state3$1, a$1) => more((v4$1) => more((v3$2) => go$lazy()(state3$1, more, lift12, $$throw2, (state3$2, a$2) => more((v4$2) => done(state3$2, $142(a$2))))))
              )));
            })
          )))))));
          const $15 = (() => {
            const $152 = Constr2();
            const $16 = (() => {
              const $162 = between(token.symbol("{|"))(token.symbol("|}"))((() => {
                const $163 = sepBy((state1, more, lift12, $$throw2, done) => more((v2) => more((v1) => more((v2$1) => more((v1$1) => go$lazy()(
                  state1,
                  more,
                  lift12,
                  $$throw2,
                  (state2, a) => more((v2$2) => more((v3) => colonEq(
                    state2,
                    more,
                    lift12,
                    $$throw2,
                    (state3, a$1) => more((v4) => more((v2$3) => {
                      const $164 = Pair(a);
                      return more((v3$1) => go$lazy()(state3, more, lift12, $$throw2, (state3$1, a$2) => more((v4$1) => done(state3$1, $164(a$2)))));
                    }))
                  )))
                ))))))(token.comma);
                const $17 = Dictionary2();
                return (state1, more, lift12, $$throw2, done) => more((v1) => $163(state1, more, lift12, $$throw2, (state2, a) => more((v2) => done(state2, $17(a)))));
              })());
              const simpleExprOrProjection = (() => {
                const $17 = (() => {
                  const $172 = (() => {
                    const $173 = token.braces((() => {
                      const $174 = Record2();
                      return (state1, more, lift12, $$throw2, done) => more((v1) => sepBy(field2(go$lazy()))(token.comma)(
                        state1,
                        more,
                        lift12,
                        $$throw2,
                        (state2, a) => more((v2) => done(state2, $174(a)))
                      ));
                    })());
                    const $18 = (() => {
                      const $182 = withErrorMessage(satisfy((v$1) => v$1 === "-"))("'-'");
                      const $19 = (() => {
                        const $192 = withErrorMessage(satisfy((v$1) => v$1 === "+"))("'+'");
                        const $20 = (() => {
                          const $202 = withErrorMessage(satisfy((v$1) => v$1 === "-"))("'-'");
                          const $21 = (() => {
                            const $212 = withErrorMessage(satisfy((v$1) => v$1 === "+"))("'+'");
                            const $22 = (() => {
                              const $222 = Str();
                              const $23 = (() => {
                                const $232 = (() => {
                                  const $233 = (() => {
                                    const $234 = token.parens(go$lazy());
                                    const $24 = token.parens(token.operator);
                                    const $25 = (() => {
                                      const $252 = token.parens((state1, more, lift12, $$throw2, done) => more((v2) => more((v2$1) => more((v3) => more((v2$2) => more((v1) => go$lazy()(
                                        state1,
                                        more,
                                        lift12,
                                        $$throw2,
                                        (state2, a) => more((v2$3) => more((v3$1) => token.comma(
                                          state2,
                                          more,
                                          lift12,
                                          $$throw2,
                                          (state3, a$1) => more((v4) => more((v4$1) => more((v3$2) => go$lazy()(
                                            state3,
                                            more,
                                            lift12,
                                            $$throw2,
                                            (state3$1, a$2) => more((v4$2) => done(
                                              state3$1,
                                              $Expr2(
                                                "Constr",
                                                void 0,
                                                "Pair",
                                                $List("Cons", a, $List("Cons", a$2, Nil))
                                              )
                                            ))
                                          ))))
                                        )))
                                      )))))));
                                      return (v2, $26, $27, $28, $29) => {
                                        const $30 = v2._1;
                                        const $31 = v2._2;
                                        return $26((v3) => {
                                          const $32 = (v4, $322) => {
                                            const $33 = v4._3;
                                            return $26((v5) => {
                                              if ($33) {
                                                return $28(v4, $322);
                                              }
                                              const $34 = v2._1;
                                              const $35 = v2._2;
                                              return $26((v3$1) => $26((v1) => token.stringLiteral(
                                                $ParseState($34, $35, false),
                                                $26,
                                                $27,
                                                (v4$1, $36) => {
                                                  const $37 = v4$1._3;
                                                  return $26((v5$1) => {
                                                    if ($37) {
                                                      return $28(v4$1, $36);
                                                    }
                                                    const $38 = v2._1;
                                                    const $39 = v2._2;
                                                    return $26((v3$2) => $234(
                                                      $ParseState($38, $39, false),
                                                      $26,
                                                      $27,
                                                      (v2$1, $40) => $26((v5$2) => {
                                                        const $41 = v2._1;
                                                        const $42 = v2._2;
                                                        return $26((v3$3) => $26((v1$1) => $24(
                                                          $ParseState($41, $42, false),
                                                          $26,
                                                          $27,
                                                          (v2$2, $43) => $26((v5$3) => $252(v2, $26, $27, $28, $29)),
                                                          (state2, a) => $26((v2$2) => $29(state2, $Expr2("Op", a)))
                                                        )));
                                                      }),
                                                      $29
                                                    ));
                                                  });
                                                },
                                                (state2, a) => $26((v2$1) => $29(state2, $222(a)))
                                              )));
                                            });
                                          };
                                          return $26((v1) => {
                                            const $33 = (state2, a) => $26((v2$1) => {
                                              const $332 = Int();
                                              return $26((v1$1) => token.natural(
                                                state2,
                                                $26,
                                                $27,
                                                (v2$2, $34) => $32($ParseState(v2$2._1, v2$2._2, false), $34),
                                                (state2$1, a$1) => $26((v2$2) => $29(state2$1, $332(a(a$1))))
                                              ));
                                            });
                                            return $26((v3$1) => $26((v1$1) => $202(
                                              $ParseState($30, $31, false),
                                              $26,
                                              $27,
                                              (v4, $34) => {
                                                const $35 = v4._3;
                                                return $26((v5) => {
                                                  if ($35) {
                                                    return $32($ParseState(v4._1, v4._2, false), $34);
                                                  }
                                                  return $26((v3$2) => $26((v1$2) => $212(
                                                    $ParseState($30, $31, false),
                                                    $26,
                                                    $27,
                                                    (v4$1, $36) => {
                                                      const $37 = v4$1._3;
                                                      return $26((v5$1) => {
                                                        if ($37) {
                                                          return $32($ParseState(v4$1._1, v4$1._2, false), $36);
                                                        }
                                                        return $33($ParseState($30, $31, false), identity30);
                                                      });
                                                    },
                                                    (state2, a) => $26((v2$1) => $33(state2, identity30))
                                                  )));
                                                });
                                              },
                                              (state2, a) => $26((v2$1) => $33(state2, (a$1) => -a$1))
                                            )));
                                          });
                                        });
                                      };
                                    })();
                                    return (v2, $26, $27, $28, $29) => {
                                      const $30 = v2._1;
                                      const $31 = v2._2;
                                      return $26((v3) => {
                                        const $32 = (v4, $322) => {
                                          const $33 = v4._3;
                                          return $26((v5) => {
                                            if ($33) {
                                              return $28(v4, $322);
                                            }
                                            return $25(v2, $26, $27, $28, $29);
                                          });
                                        };
                                        return $26((v1) => {
                                          const $33 = (state2, a) => $26((v2$1) => {
                                            const $332 = Float();
                                            return $26((v1$1) => token.float(
                                              state2,
                                              $26,
                                              $27,
                                              (v2$2, $34) => $32($ParseState(v2$2._1, v2$2._2, false), $34),
                                              (state2$1, a$1) => $26((v2$2) => $29(state2$1, $332(a(a$1))))
                                            ));
                                          });
                                          return $26((v3$1) => $26((v1$1) => $182(
                                            $ParseState($30, $31, false),
                                            $26,
                                            $27,
                                            (v4, $34) => {
                                              const $35 = v4._3;
                                              return $26((v5) => {
                                                if ($35) {
                                                  return $32($ParseState(v4._1, v4._2, false), $34);
                                                }
                                                return $26((v3$2) => $26((v1$2) => $192(
                                                  $ParseState($30, $31, false),
                                                  $26,
                                                  $27,
                                                  (v4$1, $36) => {
                                                    const $37 = v4$1._3;
                                                    return $26((v5$1) => {
                                                      if ($37) {
                                                        return $32($ParseState(v4$1._1, v4$1._2, false), $36);
                                                      }
                                                      return $33($ParseState($30, $31, false), identity30);
                                                    });
                                                  },
                                                  (state2, a) => $26((v2$1) => $33(state2, identity30))
                                                )));
                                              });
                                            },
                                            (state2, a) => $26((v2$1) => $33(state2, (a$1) => -a$1))
                                          )));
                                        });
                                      });
                                    };
                                  })();
                                  return (v2, $24, $25, $26, $27) => {
                                    const $28 = v2._1;
                                    const $29 = v2._2;
                                    return $24((v3) => $24((v1) => ident(
                                      $ParseState($28, $29, false),
                                      $24,
                                      $25,
                                      (v2$1, $30) => $24((v5) => $233(v2, $24, $25, $26, $27)),
                                      (state2, a) => $24((v2$1) => $27(state2, $Expr2("Var", a)))
                                    )));
                                  };
                                })();
                                return (v2, $24, $25, $26, $27) => {
                                  const $28 = v2._1;
                                  const $29 = v2._2;
                                  return $24((v3) => $173(
                                    $ParseState($28, $29, false),
                                    $24,
                                    $25,
                                    (v4, $30) => {
                                      const $31 = v4._3;
                                      return $24((v5) => {
                                        if ($31) {
                                          return $26(v4, $30);
                                        }
                                        return $232(v2, $24, $25, $26, $27);
                                      });
                                    },
                                    $27
                                  ));
                                };
                              })();
                              return (v2, $24, $25, $26, $27) => {
                                const $28 = v2._1;
                                const $29 = v2._2;
                                return $24((v3) => $162(
                                  $ParseState($28, $29, false),
                                  $24,
                                  $25,
                                  (v4, $30) => {
                                    const $31 = v4._3;
                                    return $24((v5) => {
                                      if ($31) {
                                        return $26(v4, $30);
                                      }
                                      return $23(v2, $24, $25, $26, $27);
                                    });
                                  },
                                  $27
                                ));
                              };
                            })();
                            return (v2, $23, $24, $25, $26) => {
                              const $27 = v2._1;
                              const $28 = v2._2;
                              return $23((v3) => $23((v1) => $23((v1$1) => ctr(
                                $ParseState($27, $28, false),
                                $23,
                                $24,
                                (v2$1, $29) => $23((v5) => $22(v2, $23, $24, $25, $26)),
                                (state2, a) => $23((v2$1) => {
                                  const $29 = $152(a);
                                  return $23((v2$2) => $26(state2, $29(Nil)));
                                })
                              ))));
                            };
                          })();
                          return (v2, $22, $23, $24, $25) => {
                            const $26 = v2._1;
                            const $27 = v2._2;
                            return $22((v3) => $14(
                              $ParseState($26, $27, false),
                              $22,
                              $23,
                              (v4, $28) => {
                                const $29 = v4._3;
                                return $22((v5) => {
                                  if ($29) {
                                    return $24(v4, $28);
                                  }
                                  return $21(v2, $22, $23, $24, $25);
                                });
                              },
                              $25
                            ));
                          };
                        })();
                        return (v2, $21, $22, $23, $24) => {
                          const $25 = v2._1;
                          const $26 = v2._2;
                          return $21((v3) => $13(
                            $ParseState($25, $26, false),
                            $21,
                            $22,
                            (v4, $27) => {
                              const $28 = v4._3;
                              return $21((v5) => {
                                if ($28) {
                                  return $23(v4, $27);
                                }
                                return $20(v2, $21, $22, $23, $24);
                              });
                            },
                            $24
                          ));
                        };
                      })();
                      return (v2, $20, $21, $22, $23) => {
                        const $24 = v2._1;
                        const $25 = v2._2;
                        return $20((v3) => {
                          const $26 = (v4, $262) => {
                            const $27 = v4._3;
                            return $20((v5) => {
                              if ($27) {
                                return $22(v4, $262);
                              }
                              return $19(v2, $20, $21, $22, $23);
                            });
                          };
                          return $20((v2$1) => $20((v1) => lBracket(
                            $ParseState($24, $25, false),
                            $20,
                            $21,
                            $26,
                            (state2, a) => $20((v2$2) => $20((v3$1) => $20((v2$3) => $20((v1$1) => go$lazy()(
                              state2,
                              $20,
                              $21,
                              $26,
                              (state2$1, a$1) => $20((v2$4) => {
                                const $27 = $122(a$1);
                                return $20((v3$2) => go$1(
                                  state2$1,
                                  $20,
                                  $21,
                                  $26,
                                  (state3, a$2) => $20((v4) => {
                                    const $28 = $27(a$2);
                                    return $20((v4$1) => $23(state3, $28));
                                  })
                                ));
                              })
                            )))))
                          )));
                        });
                      };
                    })();
                    return (v2, $19, $20, $21, $22) => {
                      const $23 = v2._1;
                      const $24 = v2._2;
                      return $19((v3) => $11($ParseState($23, $24, false), $19, $20, (v2$1, $25) => $19((v5) => $18(v2, $19, $20, $21, $22)), $22));
                    };
                  })();
                  return (v2, $18, $19, $20, $21) => {
                    const $22 = v2._1;
                    const $23 = v2._2;
                    return $18((v3) => $10(
                      $ParseState($22, $23, false),
                      $18,
                      $19,
                      (v4, $24) => {
                        const $25 = v4._3;
                        return $18((v5) => {
                          if ($25) {
                            return $20(v4, $24);
                          }
                          return $172(v2, $18, $19, $20, $21);
                        });
                      },
                      $21
                    ));
                  };
                })();
                return (state1, more, lift12, $$throw2, done) => more((v1) => $17(
                  state1,
                  more,
                  lift12,
                  $$throw2,
                  (state2, a) => more((v2) => {
                    const $18 = Project2(a);
                    const $19 = token.reservedOp(".");
                    const $20 = state2._1;
                    const $21 = state2._2;
                    return more((v3) => {
                      const $22 = (v4, $222) => {
                        const $23 = v4._3;
                        return more((v5) => {
                          if ($23) {
                            return $$throw2(v4, $222);
                          }
                          return done(state2, a);
                        });
                      };
                      return more((v1$1) => more((v2$1) => more((v1$2) => $19(
                        $ParseState($20, $21, false),
                        more,
                        lift12,
                        $22,
                        (state2$1, a$1) => more((v2$2) => more((v3$1) => ident(state2$1, more, lift12, $22, (state3, a$2) => more((v4) => more((v2$3) => done(state3, $18(a$2)))))))
                      ))));
                    });
                  })
                ));
              })();
              const rest = (v$1) => {
                if (v$1.tag === "Constr") {
                  const $172 = v$1._2;
                  const $18 = v$1._3;
                  const $19 = v$1._1;
                  return (v2, $20, $21, $22, $23) => {
                    const $24 = v2._1;
                    const $25 = v2._2;
                    return $20((v3) => {
                      const $26 = (v4, $262) => {
                        const $27 = v4._3;
                        return $20((v5) => {
                          if ($27) {
                            return $22(v4, $262);
                          }
                          return $23(v2, v$1);
                        });
                      };
                      return $20((v1) => simpleExprOrProjection(
                        $ParseState($24, $25, false),
                        $20,
                        $21,
                        $26,
                        (state2, a) => $20((v2$1) => rest($Expr2(
                          "Constr",
                          $19,
                          $172,
                          foldableList.foldr(Cons)($List("Cons", a, Nil))($18)
                        ))(state2, $20, $21, $26, $23))
                      ));
                    });
                  };
                }
                const $17 = App3(v$1);
                return (v2, $18, $19, $20, $21) => {
                  const $22 = v2._1;
                  const $23 = v2._2;
                  return $18((v3) => {
                    const $24 = (v4, $242) => {
                      const $25 = v4._3;
                      return $18((v5) => {
                        if ($25) {
                          return $20(v4, $242);
                        }
                        return $21(v2, v$1);
                      });
                    };
                    return $18((v1) => $18((v1$1) => simpleExprOrProjection(
                      $ParseState($22, $23, false),
                      $18,
                      $19,
                      $24,
                      (state2, a) => $18((v2$1) => {
                        const $25 = $17(a);
                        return $18((v2$2) => rest($25)(state2, $18, $19, $24, $21));
                      })
                    )));
                  });
                };
              };
              return (state1, more, lift12, $$throw2, done) => more((v1) => simpleExprOrProjection(
                state1,
                more,
                lift12,
                $$throw2,
                (state2, a) => more((v2) => rest(a)(state2, more, lift12, $$throw2, done))
              ));
            })();
            return (v2, $17, $18, $19, $20) => {
              const $21 = v2._1;
              const $22 = v2._2;
              return $17((v3) => {
                const $23 = (v4, $232) => {
                  const $24 = v4._3;
                  return $17((v5) => {
                    if ($24) {
                      return $19(v4, $232);
                    }
                    return $16(v2, $17, $18, $19, $20);
                  });
                };
                return $17((v1) => $17((v1$1) => $92(
                  $ParseState($21, $22, false),
                  $17,
                  $18,
                  $23,
                  (state2, a) => $17((v2$1) => {
                    const $24 = bindList.bind($List("Cons", a._1, a._2))(identity13);
                    return $17((v2$2) => {
                      const $25 = foldableList.foldr((def) => fanin3(Let2)(LetRec2)(def));
                      const $26 = keyword2("in");
                      return $17((v1$2) => $17((v1$3) => $17((v2$3) => $17((v1$4) => $26(
                        state2,
                        $17,
                        $18,
                        $23,
                        (state2$1, a$1) => $17((v2$4) => $17((v3$1) => go$lazy()(
                          state2$1,
                          $17,
                          $18,
                          $23,
                          (state3, a$2) => $17((v4) => $17((v2$5) => {
                            const $27 = $25(a$2);
                            return $17((v2$6) => $20(state3, $27($24)));
                          }))
                        )))
                      )))));
                    });
                  })
                )));
              });
            };
          })();
          return (v2, $16, $17, $18, $19) => {
            const $20 = v2._1;
            const $21 = v2._2;
            return $16((v3) => {
              const $22 = (v4, $222) => {
                const $23 = v4._3;
                return $16((v5) => {
                  if ($23) {
                    return $18(v4, $222);
                  }
                  return $15(v2, $16, $17, $18, $19);
                });
              };
              return $16((v1) => $16((v2$1) => $16((v1$1) => $7(
                $ParseState($20, $21, false),
                $16,
                $17,
                $22,
                (state2, a) => $16((v2$2) => $16((v3$1) => $8(state2, $16, $17, $22, (state3, a$1) => $16((v4) => $16((v2$3) => $19(state3, $Expr2("Lambda", a$1)))))))
              ))));
            });
          };
        })();
        return (v2, $13, $14, $15, $16) => {
          const $17 = v2._1;
          const $18 = v2._2;
          return $13((v3) => {
            const $19 = (v4, $192) => {
              const $20 = v4._3;
              return $13((v5) => {
                if ($20) {
                  return $15(v4, $192);
                }
                return $12(v2, $13, $14, $15, $16);
              });
            };
            return $13((v2$1) => $13((v2$2) => $13((v1) => $13((v2$3) => $13((v2$4) => $13((v1$1) => $13((v2$5) => $13((v3$1) => $13((v2$6) => $13((v1$2) => $4(
              $ParseState($17, $18, false),
              $13,
              $14,
              $19,
              (state2, a) => $13((v2$7) => $13((v3$2) => go$lazy()(
                state2,
                $13,
                $14,
                $19,
                (state3, a$1) => $13((v4) => $13((v4$1) => {
                  const $20 = IfElse(a$1);
                  return $13((v2$8) => $13((v3$3) => $5(
                    state3,
                    $13,
                    $14,
                    $19,
                    (state3$1, a$2) => $13((v4$2) => $13((v3$4) => go$lazy()(
                      state3$1,
                      $13,
                      $14,
                      $19,
                      (state3$2, a$3) => $13((v4$3) => {
                        const $21 = $20(a$3);
                        return $13((v2$9) => $13((v3$5) => $6(
                          state3$2,
                          $13,
                          $14,
                          $19,
                          (state3$3, a$4) => $13((v4$4) => $13((v3$6) => go$lazy()(state3$3, $13, $14, $19, (state3$4, a$5) => $13((v4$5) => $16(state3$4, $21(a$5))))))
                        )));
                      })
                    )))
                  )));
                }))
              )))
            )))))))))));
          });
        };
      })();
      return (v2, $10, $11, $12, $13) => {
        const $14 = v2._1;
        const $15 = v2._2;
        return $10((v3) => {
          const $16 = (v4, $162) => {
            const $17 = v4._3;
            return $10((v5) => {
              if ($17) {
                return $12(v4, $162);
              }
              return $9(v2, $10, $11, $12, $13);
            });
          };
          return $10((v2$1) => $10((v1) => $10((v2$2) => $10((v1$1) => $10((v2$3) => $10((v1$2) => $1(
            $ParseState($14, $15, false),
            $10,
            $11,
            $16,
            (state2, a) => $10((v2$4) => $10((v3$1) => go$lazy()(
              state2,
              $10,
              $11,
              $16,
              (state3, a$1) => $10((v4) => $10((v2$5) => $10((v3$2) => $2(
                state3,
                $10,
                $11,
                $16,
                (state3$1, a$2) => $10((v4$1) => $10((v2$6) => {
                  const $17 = MatchAs(a$1);
                  return $10((v3$3) => $3(state3$1, $10, $11, $16, (state3$2, a$3) => $10((v4$2) => $13(state3$2, $17(a$3)))));
                }))
              ))))
            )))
          )))))));
        });
      };
    })())));
    const go = go$lazy();
    return go;
  })();
  var module_ = /* @__PURE__ */ (() => {
    const $0 = topLevel((() => {
      const $02 = sepBy_try(defs(expr_))(token.semi);
      return (state1, more, lift12, $$throw2, done) => more((v2) => more((v1) => $02(
        state1,
        more,
        lift12,
        $$throw2,
        (state2, a) => more((v2$1) => more((v3) => token.semi(state2, more, lift12, $$throw2, (state3, a$1) => more((v4) => done(state3, a)))))
      )));
    })());
    return (state1, more, lift12, $$throw2, done) => more((v1) => $0(
      state1,
      more,
      lift12,
      $$throw2,
      (state2, a) => more((v2) => done(state2, $Module(bindList.bind(a)(identity13))))
    ));
  })();

  // output-es/Trace/index.js
  var $AppTrace = (tag, _1, _2, _3) => ({ tag, _1, _2, _3 });
  var $ForeignTrace$p = (_1, _2) => ({ tag: "ForeignTrace'", _1, _2 });
  var $Match = (tag, _1, _2) => ({ tag, _1, _2 });
  var $Trace = (tag, _1, _2, _3, _4) => ({ tag, _1, _2, _3, _4 });
  var $VarDef3 = (_1, _2) => ({ tag: "VarDef", _1, _2 });
  var unions3 = /* @__PURE__ */ unions(foldableList)(ordString);
  var unions12 = /* @__PURE__ */ unions(foldableDict)(ordString);
  var Const2 = /* @__PURE__ */ $Trace("Const");
  var bVMatch = {
    bv: (v) => {
      if (v.tag === "MatchVar") {
        return $$$Map("Node", 1, 1, v._1, void 0, Leaf, Leaf);
      }
      if (v.tag === "MatchVarAnon") {
        return Leaf;
      }
      if (v.tag === "MatchConstr") {
        return unions3(listMap(bVMatch.bv)(v._2));
      }
      if (v.tag === "MatchRecord") {
        return unions12(_fmapObject(v._1, bVMatch.bv));
      }
      fail();
    }
  };

  // output-es/Eval/index.js
  var disjointUnion3 = /* @__PURE__ */ disjointUnion(mapEnvStringVal);
  var fromFoldable20 = /* @__PURE__ */ (() => foldableSet.foldl((m) => (a) => insert3(ordString)(a)()(m))(Leaf))();
  var show23 = /* @__PURE__ */ (() => showSet(showString).show)();
  var toUnfoldable10 = /* @__PURE__ */ (() => {
    const $0 = toUnfoldable2(unfoldableList);
    return (x2) => $0(keys2(x2));
  })();
  var fromFoldable110 = /* @__PURE__ */ fromFoldable(foldableList);
  var union5 = /* @__PURE__ */ (() => setSet(ordString).union)();
  var fv2 = /* @__PURE__ */ (() => fVDict(fVElim).fv)();
  var unzip5 = /* @__PURE__ */ unzip3(functorDict);
  var unzip1 = /* @__PURE__ */ unzip3(functorList);
  var greaterThanOrEq1 = /* @__PURE__ */ (() => {
    const $0 = ordTuple(ordInt)(ordInt);
    return (a1) => (a2) => $0.compare(a1)(a2) !== "LT";
  })();
  var show32 = (v) => "(Tuple " + showIntImpl(v._1) + " " + showIntImpl(v._2) + ")";
  var erase1 = /* @__PURE__ */ (() => functorElim.map((v) => {
  }))();
  var matchMany2 = (dictMonadError) => {
    const MonadThrow0 = dictMonadError.MonadThrow0();
    const Monad0 = MonadThrow0.Monad0();
    const $0 = Monad0.Applicative0();
    const $1 = Monad0.Bind1();
    return (dictAnn) => {
      const BoundedMeetSemilattice1 = dictAnn.BoundedLattice1().BoundedMeetSemilattice1();
      const top3 = BoundedMeetSemilattice1.top;
      return (v) => (v1) => {
        if (v.tag === "Nil") {
          return $0.pure($Tuple(empty2, $Tuple(v1, $Tuple(top3, Nil))));
        }
        if (v.tag === "Cons") {
          if (v1.tag === "ContElim") {
            const $2 = v._2;
            return $1.bind(match3(dictMonadError)(dictAnn)(v._1)(v1._1))((v3) => {
              const $3 = v3._2._2._2;
              const $4 = v3._2._2._1;
              const $5 = v3._1;
              return $1.bind(matchMany2(dictMonadError)(dictAnn)($2)(v3._2._1))((v4) => $0.pure($Tuple(
                disjointUnion3($5)(v4._1),
                $Tuple(v4._2._1, $Tuple(BoundedMeetSemilattice1.MeetSemilattice0().meet($4)(v4._2._2._1), $List("Cons", $3, v4._2._2._2)))
              )));
            });
          }
          if (v1.tag === "ContExpr") {
            return MonadThrow0.throwError(error(showIntImpl((() => {
              const go = (go$a0$copy) => (go$a1$copy) => {
                let go$a0 = go$a0$copy, go$a1 = go$a1$copy, go$c = true, go$r;
                while (go$c) {
                  const b = go$a0, v$1 = go$a1;
                  if (v$1.tag === "Nil") {
                    go$c = false;
                    go$r = b;
                    continue;
                  }
                  if (v$1.tag === "Cons") {
                    go$a0 = b + 1 | 0;
                    go$a1 = v$1._2;
                    continue;
                  }
                  fail();
                }
                return go$r;
              };
              return go(0)(v._2) + 1 | 0;
            })()) + " extra argument(s) to constructor/record; did you forget parentheses in lambda pattern?"));
          }
        }
        fail();
      };
    };
  };
  var match3 = (dictMonadError) => {
    const MonadThrow0 = dictMonadError.MonadThrow0();
    const Monad0 = MonadThrow0.Monad0();
    const $0 = Monad0.Applicative0();
    const Bind1 = Monad0.Bind1();
    const withMsg2 = withMsg(dictMonadError);
    const consistentWith2 = consistentWith(dictMonadError);
    return (dictAnn) => {
      const BoundedMeetSemilattice1 = dictAnn.BoundedLattice1().BoundedMeetSemilattice1();
      const top3 = BoundedMeetSemilattice1.top;
      const $1 = BoundedMeetSemilattice1.MeetSemilattice0();
      const prettyP4 = prettyP(prettyVal(dictAnn.Highlightable0()));
      return (v) => (v1) => {
        if (v1.tag === "ElimVar") {
          if (v1._1 === "_") {
            return $0.pure($Tuple(
              empty2,
              $Tuple(v1._2, $Tuple(top3, $Match("MatchVarAnon", $Val(void 0, functorBaseVal.map((v$1) => {
              })(v._2)))))
            ));
          }
          const $2 = v1._1;
          return $0.pure($Tuple(
            (() => {
              const $3 = {};
              $3[$2] = v;
              return $3;
            })(),
            $Tuple(v1._2, $Tuple(top3, $Match("MatchVar", $2, $Val(void 0, functorBaseVal.map((v$1) => {
            })(v._2)))))
          ));
        }
        if (v1.tag === "ElimConstr") {
          if (v._2.tag === "Constr") {
            const $2 = v._2._1;
            const $3 = v1._1;
            const $4 = v._2._2;
            const $5 = v._1;
            return Bind1.bind(withMsg2("Pattern mismatch")(consistentWith2($$$Map("Node", 1, 1, $2, void 0, Leaf, Leaf))(mapObjectString.keys($3))))(() => Bind1.bind(orElse(MonadThrow0)("Incomplete patterns: no branch for " + showCtr($2))(_lookup(
              Nothing,
              Just,
              $2,
              $3
            )))((\u03BA) => Bind1.bind(matchMany2(dictMonadError)(dictAnn)($4)(\u03BA))((v2) => $0.pure($Tuple(
              v2._1,
              $Tuple(v2._2._1, $Tuple($1.meet($5)(v2._2._2._1), $Match("MatchConstr", $2, v2._2._2._2)))
            )))));
          }
          return Bind1.bind(dataTypeForSetCtr.dataTypeFor(MonadThrow0)(mapObjectString.keys(v1._1)))((d) => MonadThrow0.throwError(error("Pattern mismatch: found " + prettyP4(v) + ", expected " + d._1)));
        }
        if (v1.tag === "ElimRecord") {
          if (v._2.tag === "Record") {
            const $2 = v1._1;
            const $3 = v._2._1;
            const $4 = v._1;
            const $5 = v1._2;
            return Bind1.bind(check(MonadThrow0)(unsafeDifference(ordString.compare, $2, fromFoldable20(mapObjectString.keys($3))).tag === "Leaf")("Pattern mismatch: found " + show23(mapObjectString.keys($3)) + ", expected " + show23($2)))(() => {
              const xs$p = toUnfoldable10($2);
              return Bind1.bind(matchMany2(dictMonadError)(dictAnn)(listMap((a) => $$get(showString)(mapDictString)(a)($3))(xs$p))($5))((v2) => $0.pure($Tuple(
                v2._1,
                $Tuple(
                  v2._2._1,
                  $Tuple($1.meet($4)(v2._2._2._1), $Match("MatchRecord", fromFoldable110(zipWith2(Tuple)(xs$p)(v2._2._2._2))))
                )
              )));
            });
          }
          return MonadThrow0.throwError(error("Pattern mismatch: found " + prettyP4(v) + ", expected " + show23(v1._1)));
        }
        fail();
      };
    };
  };
  var closeDefs2 = (\u03B3) => (\u03C1) => (\u03B1) => _fmapObject(
    \u03C1,
    (\u03C3) => {
      const \u03C1$p = forDefs(\u03C1)(\u03C3);
      return $Val(
        \u03B1,
        $BaseVal(
          "Fun",
          $Fun(
            "Closure",
            (() => {
              const $0 = union5(fv2(\u03C1$p))(fVElim.fv(\u03C3));
              return filterWithKey((x2) => {
                const $1 = setSet(ordString).member(x2)($0);
                return (v) => $1;
              })(\u03B3);
            })(),
            \u03C1$p,
            \u03C3
          )
        )
      );
    }
  );
  var checkArity2 = (dictMonadError) => {
    const MonadThrow0 = dictMonadError.MonadThrow0();
    return (c) => (n) => MonadThrow0.Monad0().Bind1().bind(arity(MonadThrow0)(c))((n$p) => check(MonadThrow0)(n$p >= n)(showCtr(c) + " got " + showIntImpl(n) + " argument(s), expects at most " + showIntImpl(n$p)));
  };
  var $$eval2 = (dictMonadError) => {
    const MonadThrow0 = dictMonadError.MonadThrow0();
    const Monad0 = MonadThrow0.Monad0();
    const Bind1 = Monad0.Bind1();
    const Functor0 = Bind1.Apply0().Functor0();
    const Applicative0 = Monad0.Applicative0();
    const traverse3 = traversableDict.traverse(Applicative0);
    const traverse4 = traversableList.traverse(Applicative0);
    const traverse5 = traversablePair.traverse(Applicative0);
    const checkArity1 = checkArity2(dictMonadError);
    const sequence1 = traversableList.traverse(Applicative0)(identity10);
    const match1 = match3(dictMonadError);
    return (dictAnn) => {
      const $0 = dictAnn.BoundedLattice1().BoundedMeetSemilattice1().MeetSemilattice0();
      const prettyP4 = prettyP(prettyVal(dictAnn.Highlightable0()));
      const match22 = match1(dictAnn);
      return (v) => (v1) => {
        if (v._2.tag === "Var") {
          const $1 = v._2._1;
          return Functor0.map((v2) => $Tuple($Trace("Var", $1), v2))(lookup$p(MonadThrow0)(showString)(mapEnvStringVal)($1)(v._1));
        }
        if (v._2.tag === "Op") {
          const $1 = v._2._1;
          return Functor0.map((v2) => $Tuple($Trace("Op", $1), v2))(lookup$p(MonadThrow0)(showString)(mapEnvStringVal)($1)(v._1));
        }
        if (v._2.tag === "Int") {
          return Applicative0.pure($Tuple(Const2, $Val($0.meet(v._2._1)(v1), $BaseVal("Int", v._2._2))));
        }
        if (v._2.tag === "Float") {
          return Applicative0.pure($Tuple(Const2, $Val($0.meet(v._2._1)(v1), $BaseVal("Float", v._2._2))));
        }
        if (v._2.tag === "Str") {
          return Applicative0.pure($Tuple(Const2, $Val($0.meet(v._2._1)(v1), $BaseVal("Str", v._2._2))));
        }
        if (v._2.tag === "Record") {
          const $1 = v._2._1;
          const $2 = v._1;
          return Bind1.bind(Functor0.map(unzip5)(traverse3((e) => $$eval2(dictMonadError)(dictAnn)($EnvExpr($2, e))(v1))(v._2._2)))((v2) => Applicative0.pure($Tuple(
            $Trace("Record", v2._1),
            $Val($0.meet($1)(v1), $BaseVal("Record", v2._2))
          )));
        }
        if (v._2.tag === "Dictionary") {
          const $1 = v._2._1;
          const $2 = v._1;
          return Bind1.bind(Functor0.map((x2) => {
            const $3 = unzip2(listMap(toTuple)(x2));
            return $Tuple(unzip1($3._1), unzip1($3._2));
          })(traverse4(traverse5((e) => $$eval2(dictMonadError)(dictAnn)($EnvExpr($2, e))(v1)))(v._2._2)))((v2) => {
            const v3 = unzip1(listMap((v$1) => $Tuple(v$1._2.tag === "Str" ? v$1._2._1 : typeError(v$1._2)("Str"), v$1._1))(v2._1._2));
            const d = fromFoldable110(zipWith2(Tuple)(v3._1)(zipWith2(Tuple)(v3._2)(v2._2._2)));
            return Applicative0.pure($Tuple(
              $Trace(
                "Dictionary",
                zipWith2(Tuple)(v3._1)(zipWith2(Tuple)(v2._1._1)(v2._2._1)),
                _fmapObject(d, (x2) => $Val(void 0, functorBaseVal.map((v$1) => {
                })(x2._2._2)))
              ),
              $Val($0.meet($1)(v1), $BaseVal("Dictionary", d))
            ));
          });
        }
        if (v._2.tag === "Constr") {
          const $1 = v._2._2;
          const $2 = v._2._3;
          const $3 = v._2._1;
          const $4 = v._1;
          return Bind1.bind(checkArity1($1)((() => {
            const go = (go$a0$copy) => (go$a1$copy) => {
              let go$a0 = go$a0$copy, go$a1 = go$a1$copy, go$c = true, go$r;
              while (go$c) {
                const b = go$a0, v$1 = go$a1;
                if (v$1.tag === "Nil") {
                  go$c = false;
                  go$r = b;
                  continue;
                }
                if (v$1.tag === "Cons") {
                  go$a0 = b + 1 | 0;
                  go$a1 = v$1._2;
                  continue;
                }
                fail();
              }
              return go$r;
            };
            return go(0)($2);
          })()))(() => Bind1.bind(Functor0.map(unzip1)(traverse4((e) => $$eval2(dictMonadError)(dictAnn)($EnvExpr($4, e))(v1))($2)))((v2) => Applicative0.pure($Tuple(
            $Trace("Constr", $1, v2._1),
            $Val($0.meet($3)(v1), $BaseVal("Constr", $1, v2._2))
          ))));
        }
        if (v._2.tag === "Matrix") {
          const $1 = v._2._2;
          const $2 = v._2._3._1;
          const $3 = v._2._3._2;
          const $4 = v._2._1;
          const $5 = v._1;
          return Bind1.bind($$eval2(dictMonadError)(dictAnn)($EnvExpr($5, v._2._4))(v1))((v2) => {
            const $6 = v2._1;
            const v4 = intPair.unpack(v2._2._2);
            const $7 = v4._1._1;
            const $8 = v4._2._1;
            const $9 = v4._1._2;
            const $10 = v4._2._2;
            return Bind1.bind(check(MonadThrow0)(greaterThanOrEq1($Tuple($7, $8))($Tuple(1, 1)))("array must be at least (" + show32($Tuple(
              1,
              1
            )) + "); got (" + show32($Tuple($7, $8)) + ")"))(() => Bind1.bind(Functor0.map((() => {
              const $11 = listMap((x2) => {
                const $112 = unzip1(x2);
                return $Tuple(
                  fromFoldableImpl(foldableList.foldr, $112._1),
                  fromFoldableImpl(foldableList.foldr, $112._2)
                );
              });
              return (x2) => {
                const $12 = unzip1($11(x2));
                return $Tuple(
                  fromFoldableImpl(foldableList.foldr, $12._1),
                  fromFoldableImpl(foldableList.foldr, $12._2)
                );
              };
            })())(sequence1(bindList.bind(range3(1)($7))((i) => $List(
              "Cons",
              sequence1(bindList.bind(range3(1)($8))((j) => $List(
                "Cons",
                $$eval2(dictMonadError)(dictAnn)($EnvExpr(
                  unionWith((v$1) => identity15)($5)(disjointUnion3((() => {
                    const $11 = {};
                    $11[$2] = $Val($9, $BaseVal("Int", i));
                    return $11;
                  })())((() => {
                    const $11 = {};
                    $11[$3] = $Val($10, $BaseVal("Int", j));
                    return $11;
                  })())),
                  $1
                ))(v1),
                Nil
              ))),
              Nil
            )))))((v5) => Applicative0.pure($Tuple(
              $Trace("Matrix", v5._1, $Tuple($2, $3), $Tuple($7, $8), $6),
              $Val($0.meet($4)(v1), $BaseVal("Matrix", $Tuple(v5._2, $Tuple($Tuple($7, $9), $Tuple($8, $10)))))
            ))));
          });
        }
        if (v._2.tag === "Lambda") {
          return Applicative0.pure($Tuple(
            Const2,
            $Val(
              $0.meet(v._2._1)(v1),
              $BaseVal(
                "Fun",
                $Fun(
                  "Closure",
                  (() => {
                    const $1 = fVElim.fv(v._2._2);
                    return filterWithKey((x2) => {
                      const $2 = setSet(ordString).member(x2)($1);
                      return (v$1) => $2;
                    })(v._1);
                  })(),
                  empty2,
                  v._2._2
                )
              )
            )
          ));
        }
        if (v._2.tag === "Project") {
          const $1 = v._2._2;
          return Bind1.bind($$eval2(dictMonadError)(dictAnn)($EnvExpr(v._1, v._2._1))(v1))((v2) => {
            if (v2._2._2.tag === "Record") {
              return Functor0.map((v4) => $Tuple($Trace("Project", v2._1, $1), v4))(lookup$p(MonadThrow0)(showString)(mapDictString)($1)(v2._2._2._1));
            }
            return MonadThrow0.throwError(error("Found " + prettyP4(v2._2) + ", expected record"));
          });
        }
        if (v._2.tag === "App") {
          const $1 = v._2._2;
          const $2 = v._1;
          return Bind1.bind($$eval2(dictMonadError)(dictAnn)($EnvExpr($2, v._2._1))(v1))((v2) => {
            const $3 = v2._1;
            const $4 = v2._2;
            return Bind1.bind($$eval2(dictMonadError)(dictAnn)($EnvExpr($2, $1))(v1))((v4) => {
              const $5 = v4._1;
              return Bind1.bind(apply3(dictMonadError)(dictAnn)($Tuple($4, v4._2)))((v5) => Applicative0.pure($Tuple($Trace("App", $3, $5, v5._1), v5._2)));
            });
          });
        }
        if (v._2.tag === "Let") {
          const $1 = v._2._2;
          const $2 = v._1;
          const $3 = v._2._1._1;
          return Bind1.bind($$eval2(dictMonadError)(dictAnn)($EnvExpr($2, v._2._1._2))(v1))((v2) => {
            const $4 = v2._1;
            return Bind1.bind(match22(v2._2)($3))((v4) => {
              const $5 = v4._2._2._2;
              return Bind1.bind($$eval2(dictMonadError)(dictAnn)($EnvExpr(unionWith((v$1) => identity15)($2)(v4._1), $1))(v4._2._2._1))((v5) => Applicative0.pure($Tuple(
                $Trace("Let", $VarDef3($5, $4), v5._1),
                v5._2
              )));
            });
          });
        }
        if (v._2.tag === "LetRec") {
          const $1 = v._2._1._2;
          return Bind1.bind($$eval2(dictMonadError)(dictAnn)($EnvExpr(
            unionWith((v$1) => identity15)(v._1)(closeDefs2(v._1)($1)($0.meet(v._2._1._1)(v1))),
            v._2._2
          ))($0.meet(v._2._1._1)(v1)))((v2) => Applicative0.pure($Tuple(
            $Trace("LetRec", $RecDefs(void 0, _fmapObject($1, erase1)), v2._1),
            v2._2
          )));
        }
        fail();
      };
    };
  };
  var apply3 = (dictMonadError) => {
    const MonadThrow0 = dictMonadError.MonadThrow0();
    const Monad0 = MonadThrow0.Monad0();
    const Bind1 = Monad0.Bind1();
    const match1 = match3(dictMonadError);
    const $0 = Monad0.Applicative0();
    return (dictAnn) => {
      const match22 = match1(dictAnn);
      const prettyP4 = prettyP(prettyVal(dictAnn.Highlightable0()));
      return (v) => {
        const $1 = (v1) => MonadThrow0.throwError(error("Found " + prettyP4(v1) + ", expected function"));
        if (v._1._2.tag === "Fun") {
          if (v._1._2._1.tag === "Closure") {
            const $2 = v._1._1;
            const $3 = v._1._2._1._1;
            const $4 = v._1._2._1._2;
            const \u03B32 = closeDefs2($3)($4)($2);
            return Bind1.bind(match22(v._2)(v._1._2._1._3))((v2) => {
              const $5 = v2._2._2._2;
              return Bind1.bind($$eval2(dictMonadError)(dictAnn)($EnvExpr(
                unionWith((v$1) => identity15)(unionWith((v$1) => identity15)($3)(\u03B32))(v2._1),
                v2._2._1.tag === "ContExpr" ? v2._2._1._1 : throwException(error("Expression expected"))()
              ))(dictAnn.BoundedLattice1().BoundedMeetSemilattice1().MeetSemilattice0().meet($2)(v2._2._2._1)))((v3) => $0.pure($Tuple(
                $AppTrace("AppClosure", fromFoldable20(mapObjectString.keys($4)), $5, v3._1),
                v3._2
              )));
            });
          }
          if (v._1._2._1.tag === "Foreign") {
            const $2 = v._1._2._1._1._1;
            const $3 = v._1._2._1._2;
            const $4 = v._1._2._1._1._2;
            const vs$p = foldableList.foldr(Cons)($List("Cons", v._2, Nil))($3);
            return Bind1.bind((() => {
              const $5 = $4._1;
              return Bind1.bind((() => {
                const go = (go$a0$copy) => (go$a1$copy) => {
                  let go$a0 = go$a0$copy, go$a1 = go$a1$copy, go$c = true, go$r;
                  while (go$c) {
                    const b = go$a0, v$1 = go$a1;
                    if (v$1.tag === "Nil") {
                      go$c = false;
                      go$r = b;
                      continue;
                    }
                    if (v$1.tag === "Cons") {
                      go$a0 = b + 1 | 0;
                      go$a1 = v$1._2;
                      continue;
                    }
                    fail();
                  }
                  return go$r;
                };
                return $5.arity > go(0)(vs$p);
              })() ? $0.pure($Tuple(Nothing, $Val(v._1._1, $BaseVal("Fun", $Fun("Foreign", $Tuple($2, $4), vs$p))))) : Bind1.Apply0().Functor0().map((v$1) => $Tuple($Maybe("Just", v$1._1), v$1._2))($5.op(dictAnn)(dictMonadError)(vs$p)))((v3) => $0.pure($Tuple(
                $Tuple($2, $ForeignTrace$p($ForeignOp$p($5), v3._1)),
                v3._2
              )));
            })())((v2) => $0.pure($Tuple(
              $AppTrace(
                "AppForeign",
                (() => {
                  const go = (go$a0$copy) => (go$a1$copy) => {
                    let go$a0 = go$a0$copy, go$a1 = go$a1$copy, go$c = true, go$r;
                    while (go$c) {
                      const b = go$a0, v$1 = go$a1;
                      if (v$1.tag === "Nil") {
                        go$c = false;
                        go$r = b;
                        continue;
                      }
                      if (v$1.tag === "Cons") {
                        go$a0 = b + 1 | 0;
                        go$a1 = v$1._2;
                        continue;
                      }
                      fail();
                    }
                    return go$r;
                  };
                  return go(0)($3) + 1 | 0;
                })(),
                v2._1
              ),
              v2._2
            )));
          }
          if (v._1._2._1.tag === "PartialConstr") {
            const $2 = v._1._2._1._1;
            const $3 = v._1._2._1._2;
            const n = defined(arity(monadThrowExceptT(monadIdentity))($2));
            const v$p = (() => {
              const go = (go$a0$copy) => (go$a1$copy) => {
                let go$a0 = go$a0$copy, go$a1 = go$a1$copy, go$c = true, go$r;
                while (go$c) {
                  const b = go$a0, v$1 = go$a1;
                  if (v$1.tag === "Nil") {
                    go$c = false;
                    go$r = b;
                    continue;
                  }
                  if (v$1.tag === "Cons") {
                    go$a0 = b + 1 | 0;
                    go$a1 = v$1._2;
                    continue;
                  }
                  fail();
                }
                return go$r;
              };
              return go(0)($3) < (n - 1 | 0);
            })() ? $Val(
              v._1._1,
              $BaseVal(
                "Fun",
                $Fun("PartialConstr", $2, foldableList.foldr(Cons)($List("Cons", v._2, Nil))($3))
              )
            ) : $Val(
              v._1._1,
              $BaseVal("Constr", $2, foldableList.foldr(Cons)($List("Cons", v._2, Nil))($3))
            );
            return Bind1.bind(check(MonadThrow0)((() => {
              const go = (go$a0$copy) => (go$a1$copy) => {
                let go$a0 = go$a0$copy, go$a1 = go$a1$copy, go$c = true, go$r;
                while (go$c) {
                  const b = go$a0, v$1 = go$a1;
                  if (v$1.tag === "Nil") {
                    go$c = false;
                    go$r = b;
                    continue;
                  }
                  if (v$1.tag === "Cons") {
                    go$a0 = b + 1 | 0;
                    go$a1 = v$1._2;
                    continue;
                  }
                  fail();
                }
                return go$r;
              };
              return go(0)($3) < n;
            })())("Too many arguments to " + showCtr($2)))(() => $0.pure($Tuple($AppTrace("AppConstr", $2), v$p)));
          }
        }
        return $1(v._2);
      };
    };
  };
  var apply22 = (dictMonadError) => {
    const Monad0 = dictMonadError.MonadThrow0().Monad0();
    const $0 = Monad0.Bind1();
    const apply1 = apply3(dictMonadError);
    return (dictAnn) => {
      const apply32 = apply1(dictAnn);
      return (v) => {
        const $1 = v._2._2;
        return $0.bind(apply32($Tuple(v._1, v._2._1)))((v3) => {
          const $2 = v3._1;
          return $0.bind(apply32($Tuple(v3._2, $1)))((v4) => Monad0.Applicative0().pure($Tuple($Tuple($2, v4._1), v4._2)));
        });
      };
    };
  };

  // output-es/EvalBwd/index.js
  var disjointUnion_inv2 = /* @__PURE__ */ disjointUnion_inv(ordString)(mapEnvStringVal);
  var toUnfoldable11 = /* @__PURE__ */ toAscUnfoldable(unfoldableList);
  var fromFoldable21 = /* @__PURE__ */ fromFoldable(foldableList);
  var fromFoldable111 = /* @__PURE__ */ (() => foldableSet.foldl((m) => (a) => insert3(ordString)(a)()(m))(Leaf))();
  var botOfUnit$x215Raw$x2152 = (dictBoundedJoinSemilattice) => ({
    botOf: (() => {
      const $0 = dictBoundedJoinSemilattice.bot;
      const $1 = functorVal.map((() => {
        const $12 = dictBoundedJoinSemilattice.bot;
        return (v) => $12;
      })());
      return (x2) => $Tuple($0, $1(x2._2));
    })()
  });
  var union6 = /* @__PURE__ */ (() => setSet(ordString).union)();
  var disjointUnion4 = /* @__PURE__ */ disjointUnion(mapEnvStringVal);
  var foldl1 = /* @__PURE__ */ (() => foldable1NonEmpty(foldableList).foldl1)();
  var matchManyBwd = (dictAnn) => (v) => (v1) => (v2) => (v3) => {
    if (v3.tag === "Nil") {
      if (isEmpty(v)) {
        return $Tuple(Nil, v1);
      }
      return throwException(error("absurd"))();
    }
    if (v3.tag === "Cons") {
      const v4 = disjointUnion_inv2(bVMatch.bv(v3._1))(v);
      const v5 = matchBwd(dictAnn)(v4._1)(v1)(v2)(v3._1);
      const v7 = matchManyBwd(dictAnn)(v4._2)($Cont("ContElim", v5._2))(v2)(v3._2);
      return $Tuple(foldableList.foldr(Cons)($List("Cons", v5._1, Nil))(v7._1), v7._2);
    }
    fail();
  };
  var matchBwd = (dictAnn) => {
    const botOf = functorVal.map((() => {
      const $0 = dictAnn.BoundedLattice1().BoundedJoinSemilattice0().bot;
      return (v) => $0;
    })());
    return (v) => (v1) => (v2) => (v3) => {
      if (v3.tag === "MatchVar") {
        if (eqMap(eqString)(eqUnit).eq(mapObjectString.keys(v))($$$Map(
          "Node",
          1,
          1,
          v3._1,
          void 0,
          Leaf,
          Leaf
        ))) {
          return $Tuple($$get(showString)(mapEnvStringVal)(v3._1)(v), $Elim("ElimVar", v3._1, v1));
        }
        return $Tuple(botOf(v3._2), $Elim("ElimVar", v3._1, v1));
      }
      if (v3.tag === "MatchVarAnon") {
        if (isEmpty(v)) {
          return $Tuple(botOf(v3._1), $Elim("ElimVar", "_", v1));
        }
        return throwException(error("absurd"))();
      }
      if (v3.tag === "MatchConstr") {
        const $0 = v3._1;
        const v4 = matchManyBwd(dictAnn)(v)(v1)(v2)(reverse2(v3._2));
        const $1 = v4._2;
        return $Tuple(
          $Val(v2, $BaseVal("Constr", $0, v4._1)),
          $Elim(
            "ElimConstr",
            (() => {
              const $2 = {};
              $2[$0] = $1;
              return $2;
            })()
          )
        );
      }
      if (v3.tag === "MatchRecord") {
        const v4 = unzip2(toUnfoldable11(v3._1));
        const v5 = matchManyBwd(dictAnn)(v)(v1)(v2)(reverse2(v4._2));
        return $Tuple(
          $Val(v2, $BaseVal("Record", fromFoldable21(zipWith2(Tuple)(v4._1)(v5._1)))),
          $Elim("ElimRecord", fromFoldable111(mapObjectString.keys(v3._1)), v5._2)
        );
      }
      fail();
    };
  };
  var closeDefsBwd = (dictAnn) => {
    const BoundedJoinSemilattice0 = dictAnn.BoundedLattice1().BoundedJoinSemilattice0();
    const JoinSemilattice0 = BoundedJoinSemilattice0.JoinSemilattice0();
    const join1 = mapDictString.unionWith(joinSemilatticeElim(JoinSemilattice0).join);
    const bot1 = BoundedJoinSemilattice0.bot;
    return (\u03B3) => {
      const v = foldrWithIndexDefault(foldableWithIndexStringDi)((f) => (v2) => (v1) => {
        const v22 = $$get(showString)(mapEnvStringVal)(f)(\u03B3);
        if (v22._2.tag === "Fun" && v22._2._1.tag === "Closure") {
          const $0 = v22._2._1._3;
          return $Tuple(
            mutate(($1) => () => {
              $1[f] = $0;
              return $1;
            })(v1._1),
            $Tuple(
              unionWith(joinSemilatticeVal(JoinSemilattice0).join)(v1._2._1)(v22._2._1._1),
              $Tuple(join1(v1._2._2._1)(v22._2._1._2), JoinSemilattice0.join(v1._2._2._2)(v22._1))
            )
          );
        }
        return throwException(error("absurd"))();
      })($Tuple(empty2, $Tuple(empty2, $Tuple(empty2, bot1))))(\u03B3);
      return $Tuple(v._2._1, $Tuple(join1(v._2._2._1)(v._1), v._2._2._2));
    };
  };
  var evalBwd$p = (dictAnn) => {
    const BoundedJoinSemilattice0 = dictAnn.BoundedLattice1().BoundedJoinSemilattice0();
    const bot1 = BoundedJoinSemilattice0.bot;
    const JoinSemilattice0 = BoundedJoinSemilattice0.JoinSemilattice0();
    const join1 = JoinSemilattice0.join;
    const matchBwd1 = matchBwd(dictAnn);
    const closeDefsBwd1 = closeDefsBwd(dictAnn);
    return (v) => (v1) => {
      const $0 = (t2, v2, x2) => {
        const v3 = evalBwd$p(dictAnn)($Val(
          bot1,
          $BaseVal(
            "Record",
            (() => {
              const $02 = {};
              $02[x2] = v2;
              return $02;
            })()
          )
        ))(t2);
        return $Tuple(v3._1, $Tuple($Expr("Project", v3._2._1, x2), v3._2._2));
      };
      const $1 = (t1, t2, t3, v2) => {
        const v3 = applyBwd(dictAnn)($Tuple(t3, v2));
        const v4 = evalBwd$p(dictAnn)(v3._1)(t1);
        const v5 = evalBwd$p(dictAnn)(v3._2)(t2);
        return $Tuple(
          unionWith(joinSemilatticeVal(JoinSemilattice0).join)(v4._1)(v5._1),
          $Tuple($Expr("App", v4._2._1, v5._2._1), join1(v4._2._2)(v5._2._2))
        );
      };
      const $2 = (t1, t2, v2, w) => {
        const v3 = evalBwd$p(dictAnn)(v2)(t2);
        const v4 = append_inv(ordString)(mapEnvStringVal)(bVMatch.bv(w))(v3._1);
        const v5 = matchBwd1(v4._2)($Cont("ContExpr", $Expr("Record", bot1, empty2)))(v3._2._2)(w);
        const v6 = evalBwd$p(dictAnn)(v5._1)(t1);
        return $Tuple(
          unionWith(joinSemilatticeVal(JoinSemilattice0).join)(v4._1)(v6._1),
          $Tuple($Expr("Let", $VarDef(v5._2, v6._2._1), v3._2._1), v6._2._2)
        );
      };
      const $3 = (t2, v2, \u03C1) => {
        const v3 = evalBwd$p(dictAnn)(v2)(t2);
        const v4 = append_inv(ordString)(mapEnvStringVal)(fromFoldable111(mapObjectString.keys(\u03C1)))(v3._1);
        const v5 = closeDefsBwd1(v4._2);
        return $Tuple(
          unionWith(joinSemilatticeVal(JoinSemilattice0).join)(v4._1)(v5._1),
          $Tuple($Expr("LetRec", $RecDefs(join1(v3._2._2)(v5._2._2), v5._2._1), v3._2._1), join1(v3._2._2)(v5._2._2))
        );
      };
      if (v1.tag === "Var") {
        const $4 = v1._1;
        return $Tuple(
          (() => {
            const $5 = {};
            $5[$4] = v;
            return $5;
          })(),
          $Tuple($Expr("Var", $4), bot1)
        );
      }
      if (v1.tag === "Op") {
        const $4 = v1._1;
        return $Tuple(
          (() => {
            const $5 = {};
            $5[$4] = v;
            return $5;
          })(),
          $Tuple($Expr("Op", $4), bot1)
        );
      }
      if (v1.tag === "Const") {
        if (v._2.tag === "Str") {
          return $Tuple(empty2, $Tuple($Expr("Str", v._1, v._2._1), v._1));
        }
        if (v._2.tag === "Int") {
          return $Tuple(empty2, $Tuple($Expr("Int", v._1, v._2._1), v._1));
        }
        if (v._2.tag === "Float") {
          return $Tuple(empty2, $Tuple($Expr("Float", v._1, v._2._1), v._1));
        }
        if (v._2.tag === "Fun" && v._2._1.tag === "Closure") {
          return $Tuple(v._2._1._1, $Tuple($Expr("Lambda", v._1, v._2._1._3), v._1));
        }
        return throwException(error("absurd"))();
      }
      if (v._2.tag === "Record") {
        if (v1.tag === "Record") {
          const $4 = evalBwd$p(dictAnn);
          const x\u03B3e\u03B1s = _fmapObject(intersectionWith_Object(Tuple)(v._2._1)(v1._1), (v$1) => $4(v$1._1)(v$1._2));
          return $Tuple(
            foldrArray((v$1) => (v1$1) => unionWith(joinSemilatticeVal(JoinSemilattice0).join)(v$1)(v1$1))(empty2)(values(_fmapObject(
              x\u03B3e\u03B1s,
              fst
            ))),
            $Tuple(
              $Expr("Record", v._1, _fmapObject(x\u03B3e\u03B1s, (x2) => x2._2._1)),
              foldrArray(join1)(v._1)(values(_fmapObject(x\u03B3e\u03B1s, (x2) => x2._2._2)))
            )
          );
        }
        if (v1.tag === "Project") {
          return $0(v1._1, v, v1._2);
        }
        if (v1.tag === "App") {
          return $1(v1._1, v1._2, v1._3, v);
        }
        if (v1.tag === "Let") {
          return $2(v1._1._2, v1._2, v, v1._1._1);
        }
        if (v1.tag === "LetRec") {
          return $3(v1._2, v, v1._1._2);
        }
        return throwException(error("absurd"))();
      }
      if (v._2.tag === "Dictionary") {
        if (v1.tag === "Dictionary") {
          const s\u03B1vs$p = expandableDictDict(botOfUnit$x215Raw$x2152(BoundedJoinSemilattice0))((() => {
            const $4 = expandableValRawVal(BoundedJoinSemilattice0);
            return { expand: (v$1) => (v1$1) => $Tuple(v$1._1, $4.expand(v$1._2)(v1$1._2)) };
          })()).expand(v._2._1)(_fmapObject(v1._2, (v2) => $Tuple(void 0, v2)));
          const \u03B3e\u03B1s = listMap((v2) => evalBwd$p(dictAnn)($Val(
            $$get(showString)(mapDictString)(v2._1)(s\u03B1vs$p)._1,
            $BaseVal("Str", v2._1)
          ))(v2._2._1))(v1._1);
          const \u03B3e\u03B1s$p = listMap((v2) => evalBwd$p(dictAnn)($$get(showString)(mapDictString)(v2._1)(s\u03B1vs$p)._2)(v2._2._2))(v1._1);
          return $Tuple(
            foldableList.foldr((v$1) => (v1$1) => unionWith(joinSemilatticeVal(JoinSemilattice0).join)(v$1)(v1$1))(empty2)(foldableList.foldr(Cons)(listMap(fst)(\u03B3e\u03B1s$p))(listMap(fst)(\u03B3e\u03B1s))),
            $Tuple(
              $Expr(
                "Dictionary",
                v._1,
                listMap(fromTuple)(zipWith2(Tuple)(listMap((x2) => x2._2._1)(\u03B3e\u03B1s))(listMap((x2) => x2._2._1)(\u03B3e\u03B1s$p)))
              ),
              foldableList.foldr(join1)(v._1)(foldableList.foldr(Cons)(listMap((x2) => x2._2._2)(\u03B3e\u03B1s$p))(listMap((x2) => x2._2._2)(\u03B3e\u03B1s)))
            )
          );
        }
        if (v1.tag === "Project") {
          return $0(v1._1, v, v1._2);
        }
        if (v1.tag === "App") {
          return $1(v1._1, v1._2, v1._3, v);
        }
        if (v1.tag === "Let") {
          return $2(v1._1._2, v1._2, v, v1._1._1);
        }
        if (v1.tag === "LetRec") {
          return $3(v1._2, v, v1._1._2);
        }
        return throwException(error("absurd"))();
      }
      if (v._2.tag === "Constr") {
        if (v1.tag === "Constr") {
          const v2 = foldableList.foldr((v22) => (v3) => {
            const v4 = evalBwd$p(dictAnn)(v22._1)(v22._2);
            return $Tuple(
              unionWith(joinSemilatticeVal(JoinSemilattice0).join)(v3._1)(v4._1),
              $Tuple($List("Cons", v4._2._1, v3._2._1), join1(v3._2._2)(v4._2._2))
            );
          })($Tuple(empty2, $Tuple(Nil, v._1)))(zipWith2(Tuple)(v._2._2)(v1._2));
          return $Tuple(v2._1, $Tuple($Expr("Constr", v._1, v1._1, v2._2._1), v2._2._2));
        }
        if (v1.tag === "Project") {
          return $0(v1._1, v, v1._2);
        }
        if (v1.tag === "App") {
          return $1(v1._1, v1._2, v1._3, v);
        }
        if (v1.tag === "Let") {
          return $2(v1._1._2, v1._2, v, v1._1._1);
        }
        if (v1.tag === "LetRec") {
          return $3(v1._2, v, v1._1._2);
        }
        return throwException(error("absurd"))();
      }
      if (v._2.tag === "Matrix" && v1.tag === "Matrix") {
        const $4 = v1._3._1;
        const $5 = v1._3._2;
        const $6 = v1._1;
        const $7 = v._2._1._1;
        const $8 = v1._2._1;
        const $9 = v1._2._2;
        const $10 = nonEmptyListNonEmptyList.nonEmpty(bindList.bind(applyList.apply(listMap(Tuple)(range3(1)($4)))(range3(1)($5)))(applicativeList.pure));
        const v3 = foldl1((v42) => {
          const $11 = v42._2._1;
          const $12 = v42._2._2._1;
          const $13 = v42._2._2._2._1;
          const $14 = v42._2._2._2._2;
          const $15 = v42._1;
          return (v5) => $Tuple(
            unionWith(joinSemilatticeVal(JoinSemilattice0).join)($15)(v5._1),
            $Tuple(
              joinSemilatticeExpr(JoinSemilattice0).join($11)(v5._2._1),
              $Tuple(join1($12)(v5._2._2._1), $Tuple(join1($13)(v5._2._2._2._1), join1($14)(v5._2._2._2._2)))
            )
          );
        })((() => {
          const $11 = (v32) => {
            const v42 = evalBwd$p(dictAnn)(unsafeIndex(unsafeIndex($7)(v32._1 - 1 | 0))(v32._2 - 1 | 0))(unsafeIndex(unsafeIndex($6)(v32._1 - 1 | 0))(v32._2 - 1 | 0));
            const v5 = append_inv(ordString)(mapEnvStringVal)(union6($$$Map(
              "Node",
              1,
              1,
              $8,
              void 0,
              Leaf,
              Leaf
            ))($$$Map("Node", 1, 1, $9, void 0, Leaf, Leaf)))(v42._1);
            const \u03B30 = unionWith((v$1) => identity15)(disjointUnion4((() => {
              const $113 = {};
              $113[$8] = $Val(bot1, $BaseVal("Int", $4));
              return $113;
            })())((() => {
              const $113 = {};
              $113[$9] = $Val(bot1, $BaseVal("Int", $5));
              return $113;
            })()))(v5._2);
            const $112 = $$get(showString)(mapEnvStringVal)($8)(\u03B30);
            const $12 = $$get(showString)(mapEnvStringVal)($9)(\u03B30);
            if ($112._2.tag === "Int" && $12._2.tag === "Int") {
              return $Tuple(v5._1, $Tuple(v42._2._1, $Tuple(v42._2._2, $Tuple($112._1, $12._1))));
            }
            fail();
          };
          return $NonEmpty($11($10._1), listMap(($12) => $11($12))($10._2));
        })());
        const v4 = evalBwd$p(dictAnn)($Val(
          bot1,
          $BaseVal(
            "Constr",
            "Pair",
            $List(
              "Cons",
              $Val(join1(v3._2._2._2._1)(v._2._1._2._1._2), $BaseVal("Int", $4)),
              $List("Cons", $Val(join1(v3._2._2._2._2)(v._2._1._2._2._2), $BaseVal("Int", $5)), Nil)
            )
          )
        ))(v1._4);
        return $Tuple(
          unionWith(joinSemilatticeVal(JoinSemilattice0).join)(v3._1)(v4._1),
          $Tuple($Expr("Matrix", v._1, v3._2._1, $Tuple($8, $9), v4._2._1), join1(join1(v._1)(v3._2._2._1))(v4._2._2))
        );
      }
      if (v1.tag === "Project") {
        return $0(v1._1, v, v1._2);
      }
      if (v1.tag === "App") {
        return $1(v1._1, v1._2, v1._3, v);
      }
      if (v1.tag === "Let") {
        return $2(v1._1._2, v1._2, v, v1._1._1);
      }
      if (v1.tag === "LetRec") {
        return $3(v1._2, v, v1._1._2);
      }
      return throwException(error("absurd"))();
    };
  };
  var applyBwd = (dictAnn) => {
    const closeDefsBwd1 = closeDefsBwd(dictAnn);
    const matchBwd1 = matchBwd(dictAnn);
    const BoundedJoinSemilattice0 = dictAnn.BoundedLattice1().BoundedJoinSemilattice0();
    const JoinSemilattice0 = BoundedJoinSemilattice0.JoinSemilattice0();
    const bot1 = BoundedJoinSemilattice0.bot;
    return (v) => {
      if (v._1.tag === "AppClosure") {
        const v2 = evalBwd$p(dictAnn)(v._2)(v._1._3);
        const v3 = append_inv(ordString)(mapEnvStringVal)(bVMatch.bv(v._1._2))(v2._1);
        const v4 = append_inv(ordString)(mapEnvStringVal)(v._1._1)(v3._1);
        const v5 = closeDefsBwd1(v4._2);
        const v6 = matchBwd1(v3._2)($Cont("ContExpr", v2._2._1))(v2._2._2)(v._1._2);
        return $Tuple(
          $Val(
            JoinSemilattice0.join(v2._2._2)(v5._2._2),
            $BaseVal("Fun", $Fun("Closure", unionWith(joinSemilatticeVal(JoinSemilattice0).join)(v4._1)(v5._1), v5._2._1, v6._2))
          ),
          v6._1
        );
      }
      if (v._1.tag === "AppForeign") {
        if (v._1._2._2._1._1.arity > v._1._1) {
          if (v._2._2.tag === "Fun" && v._2._2._1.tag === "Foreign") {
            const $02 = definitely("absurd")(unsnoc2(v._2._2._1._2));
            return $Tuple(
              $Val(v._2._1, $BaseVal("Fun", $Fun("Foreign", $Tuple(v._1._2._1, $ForeignOp$p(v._1._2._2._1._1)), $02.init))),
              $02.last
            );
          }
          fail();
        }
        const $0 = definitely("absurd")(unsnoc2(v._1._2._2._1._1.op_bwd(dictAnn)($Tuple(definitely("absurd")(v._1._2._2._2), v._2))));
        return $Tuple($Val(bot1, $BaseVal("Fun", $Fun("Foreign", $Tuple(v._1._2._1, $ForeignOp$p(v._1._2._2._1._1)), $0.init))), $0.last);
      }
      if (v._1.tag === "AppConstr") {
        if (v._2._2.tag === "Constr") {
          if (v._2._2._1 === v._1._1) {
            const v33 = definitely("absurd")(unsnoc2(v._2._2._2));
            return $Tuple($Val(v._2._1, $BaseVal("Fun", $Fun("PartialConstr", v._1._1, v33.init))), v33.last);
          }
          const v32 = definitely("absurd")(unsnoc2(throwException(error("absurd"))()._1));
          return $Tuple(
            $Val(throwException(error("absurd"))()._2, $BaseVal("Fun", $Fun("PartialConstr", v._1._1, v32.init))),
            v32.last
          );
        }
        if (v._2._2.tag === "Fun" && v._2._2._1.tag === "PartialConstr" && v._2._2._1._1 === v._1._1) {
          const v32 = definitely("absurd")(unsnoc2(v._2._2._1._2));
          return $Tuple($Val(v._2._1, $BaseVal("Fun", $Fun("PartialConstr", v._1._1, v32.init))), v32.last);
        }
        const v3 = definitely("absurd")(unsnoc2(throwException(error("absurd"))()._1));
        return $Tuple(
          $Val(throwException(error("absurd"))()._2, $BaseVal("Fun", $Fun("PartialConstr", v._1._1, v3.init))),
          v3.last
        );
      }
      fail();
    };
  };
  var apply2Bwd = (dictAnn) => {
    const applyBwd1 = applyBwd(dictAnn);
    return (v) => {
      const v2 = applyBwd1($Tuple(v._1._2, v._2));
      const v3 = applyBwd1($Tuple(v._1._1, v2._1));
      return $Tuple(v3._1, $Tuple(v3._2, v2._2));
    };
  };

  // output-es/Primitive.Defs/index.js
  var erase = /* @__PURE__ */ (() => functorVal.map((v) => {
  }))();
  var unzip6 = /* @__PURE__ */ unzip3(functorDict);
  var foldM4 = (dictMonad) => (f) => (b0) => foldableDict.foldl((b) => (a) => dictMonad.Bind1().bind(b)((a$1) => f(a$1)(a)))(dictMonad.Applicative0().pure(b0));
  var foldWithIndexM = (dictMonad) => (f) => (a0) => foldableWithIndexStringDi.foldlWithIndex((i) => (ma) => (b) => dictMonad.Bind1().bind(ma)((() => {
    const $0 = f(i);
    return (a) => $0(a)(b);
  })()))(dictMonad.Applicative0().pure(a0));
  var disjointUnion5 = /* @__PURE__ */ disjointUnion(mapDictString);
  var unary2 = /* @__PURE__ */ unary(boundedJoinSemilatticeUni);
  var binary2 = /* @__PURE__ */ binary(boundedJoinSemilatticeUni);
  var binaryZero2 = /* @__PURE__ */ binaryZero(boundedJoinSemilatticeUni);
  var binaryZero1 = /* @__PURE__ */ (() => binaryZero2({ isZero: fanin2(isZeroInt.isZero)(isZeroNumber.isZero) }))();
  var binaryZero22 = /* @__PURE__ */ binaryZero2(isZeroInt);
  var pow3 = /* @__PURE__ */ union4(asNumberIntOrNumber)(asNumberIntOrNumber)(asIntNumber)(asIntNumber)((x2) => (y2) => pow(toNumber(x2))(toNumber(y2)))(pow);
  var numToStr = (v2) => {
    if (v2.tag === "Left") {
      return showIntImpl(v2._1);
    }
    if (v2.tag === "Right") {
      return showNumberImpl(v2._1);
    }
    fail();
  };
  var notEquals = /* @__PURE__ */ union4(asBooleanBoolean)(asBooleanBoolean)(asIntNumberOrString)(asIntNumberOrString)((x2) => (y2) => x2 !== y2)(/* @__PURE__ */ union4(asBooleanBoolean)(asBooleanBoolean)(asNumberString)(asNumberString)((x2) => (y2) => x2 !== y2)((x2) => (y2) => x2 !== y2));
  var matrixUpdate = /* @__PURE__ */ $Tuple(
    "matrixUpdate",
    /* @__PURE__ */ $ForeignOp$p({
      arity: 3,
      "op'": (dictMonadWithGraphAlloc) => (dictMonadError) => {
        const MonadThrow0 = dictMonadError.MonadThrow0();
        const Functor0 = MonadThrow0.Monad0().Bind1().Apply0().Functor0();
        return (v) => {
          if (v.tag === "Cons" && v._1._2.tag === "Matrix" && v._2.tag === "Cons" && v._2._1._2.tag === "Constr" && v._2._1._2._2.tag === "Cons" && v._2._1._2._2._1._2.tag === "Int" && v._2._1._2._2._2.tag === "Cons" && v._2._1._2._2._2._1._2.tag === "Int" && v._2._1._2._2._2._2.tag === "Nil" && v._2._2.tag === "Cons" && v._2._2._2.tag === "Nil" && v._2._1._2._1 === "Pair") {
            const $0 = v._2._2._1;
            const $1 = $BaseVal("Matrix", matrixPut(v._2._1._2._2._1._2._1)(v._2._1._2._2._2._1._2._1)((v$1) => $0)(v._1._2._1));
            return Functor0.map((f) => f($1))(Functor0.map(Val)(dictMonadWithGraphAlloc.new($$$Map(
              "Node",
              1,
              1,
              v._1._1,
              void 0,
              Leaf,
              Leaf
            ))));
          }
          return MonadThrow0.throwError(error("Matrix, pair of integers and value expected"));
        };
      },
      op: (dictAnn) => (dictMonadError) => {
        const MonadThrow0 = dictMonadError.MonadThrow0();
        return (v) => {
          if (v.tag === "Cons" && v._1._2.tag === "Matrix" && v._2.tag === "Cons" && v._2._1._2.tag === "Constr" && v._2._1._2._2.tag === "Cons" && v._2._1._2._2._1._2.tag === "Int" && v._2._1._2._2._2.tag === "Cons" && v._2._1._2._2._2._1._2.tag === "Int" && v._2._1._2._2._2._2.tag === "Nil" && v._2._2.tag === "Cons" && v._2._2._2.tag === "Nil" && v._2._1._2._1 === "Pair") {
            const $0 = v._2._1._2._2._1._2._1;
            const $1 = v._2._1._2._2._2._1._2._1;
            const $2 = v._2._2._1;
            return MonadThrow0.Monad0().Applicative0().pure($Tuple(
              $Tuple($Tuple($0, $1), $Val(void 0, functorBaseVal.map((v$1) => {
              })(matrixGet($0)($1)(v._1._2._1)._2))),
              $Val(v._1._1, $BaseVal("Matrix", matrixPut($0)($1)((v$1) => $2)(v._1._2._1)))
            ));
          }
          return MonadThrow0.throwError(error("Matrix, pair of integers and value expected"));
        };
      },
      op_bwd: (dictAnn) => {
        const BoundedJoinSemilattice0 = dictAnn.BoundedLattice1().BoundedJoinSemilattice0();
        const bot = BoundedJoinSemilattice0.bot;
        return (v) => {
          if (v._2._2.tag === "Matrix") {
            return $List(
              "Cons",
              $Val(
                v._2._1,
                $BaseVal(
                  "Matrix",
                  matrixPut(v._1._1._1)(v._1._1._2)((() => {
                    const $0 = BoundedJoinSemilattice0.bot;
                    const $1 = $Val($0, functorBaseVal.map((v$1) => $0)(v._1._2._2));
                    return (v$1) => $1;
                  })())(v._2._2._1)
                )
              ),
              $List(
                "Cons",
                $Val(
                  bot,
                  $BaseVal(
                    "Constr",
                    "Pair",
                    $List(
                      "Cons",
                      $Val(bot, $BaseVal("Int", v._1._1._1)),
                      $List("Cons", $Val(bot, $BaseVal("Int", v._1._1._2)), Nil)
                    )
                  )
                ),
                $List("Cons", matrixGet(v._1._1._1)(v._1._1._2)(v._2._2._1), Nil)
              )
            );
          }
          fail();
        };
      }
    })
  );
  var matrixLookup = /* @__PURE__ */ $Tuple(
    "!",
    /* @__PURE__ */ $ForeignOp$p({
      arity: 2,
      "op'": (dictMonadWithGraphAlloc) => (dictMonadError) => {
        const MonadThrow0 = dictMonadError.MonadThrow0();
        return (v) => {
          if (v.tag === "Cons" && v._1._2.tag === "Matrix" && v._2.tag === "Cons" && v._2._1._2.tag === "Constr" && v._2._1._2._2.tag === "Cons" && v._2._1._2._2._1._2.tag === "Int" && v._2._1._2._2._2.tag === "Cons" && v._2._1._2._2._2._1._2.tag === "Int" && v._2._1._2._2._2._2.tag === "Nil" && v._2._2.tag === "Nil" && v._2._1._2._1 === "Pair") {
            return MonadThrow0.Monad0().Applicative0().pure(matrixGet(v._2._1._2._2._1._2._1)(v._2._1._2._2._2._1._2._1)(v._1._2._1));
          }
          return MonadThrow0.throwError(error("Matrix and pair of integers expected"));
        };
      },
      op: (dictAnn) => (dictMonadError) => {
        const MonadThrow0 = dictMonadError.MonadThrow0();
        return (v) => {
          if (v.tag === "Cons" && v._1._2.tag === "Matrix" && v._2.tag === "Cons" && v._2._1._2.tag === "Constr" && v._2._1._2._2.tag === "Cons" && v._2._1._2._2._1._2.tag === "Int" && v._2._1._2._2._2.tag === "Cons" && v._2._1._2._2._2._1._2.tag === "Int" && v._2._1._2._2._2._2.tag === "Nil" && v._2._2.tag === "Nil" && v._2._1._2._1 === "Pair") {
            const $0 = v._2._1._2._2._1._2._1;
            const $1 = v._2._1._2._2._2._1._2._1;
            return MonadThrow0.Monad0().Applicative0().pure($Tuple(
              $Tuple(functorMatrixRep.map((v$1) => {
              })(v._1._2._1), $Tuple($0, $1)),
              matrixGet($0)($1)(v._1._2._1)
            ));
          }
          return MonadThrow0.throwError(error("Matrix and pair of integers expected"));
        };
      },
      op_bwd: (dictAnn) => {
        const BoundedJoinSemilattice0 = dictAnn.BoundedLattice1().BoundedJoinSemilattice0();
        const bot = BoundedJoinSemilattice0.bot;
        return (v) => {
          const $0 = v._2;
          return $List(
            "Cons",
            $Val(
              bot,
              $BaseVal(
                "Matrix",
                matrixPut(v._1._2._1)(v._1._2._2)((v$1) => $0)(functorMatrixRep.map((() => {
                  const $1 = BoundedJoinSemilattice0.bot;
                  return (v$1) => $1;
                })())(v._1._1))
              )
            ),
            $List(
              "Cons",
              $Val(
                bot,
                $BaseVal(
                  "Constr",
                  "Pair",
                  $List(
                    "Cons",
                    $Val(bot, $BaseVal("Int", v._1._2._1)),
                    $List("Cons", $Val(bot, $BaseVal("Int", v._1._2._2)), Nil)
                  )
                )
              ),
              Nil
            )
          );
        };
      }
    })
  );
  var log3 = (v2) => {
    if (v2.tag === "Left") {
      return log(toNumber(v2._1));
    }
    if (v2.tag === "Right") {
      return log(v2._1);
    }
    fail();
  };
  var lessThanEquals = /* @__PURE__ */ union4(asBooleanBoolean)(asBooleanBoolean)(asIntNumberOrString)(asIntNumberOrString)((a1) => (a2) => a1 <= a2)(/* @__PURE__ */ union4(asBooleanBoolean)(asBooleanBoolean)(asNumberString)(asNumberString)((a1) => (a2) => a1 <= a2)((a1) => (a2) => a1 <= a2));
  var lessThan = /* @__PURE__ */ union4(asBooleanBoolean)(asBooleanBoolean)(asIntNumberOrString)(asIntNumberOrString)((a1) => (a2) => a1 < a2)(/* @__PURE__ */ union4(asBooleanBoolean)(asBooleanBoolean)(asNumberString)(asNumberString)((a1) => (a2) => a1 < a2)((a1) => (a2) => a1 < a2));
  var greaterThanEquals = /* @__PURE__ */ union4(asBooleanBoolean)(asBooleanBoolean)(asIntNumberOrString)(asIntNumberOrString)((a1) => (a2) => a1 >= a2)(/* @__PURE__ */ union4(asBooleanBoolean)(asBooleanBoolean)(asNumberString)(asNumberString)((a1) => (a2) => a1 >= a2)((a1) => (a2) => a1 >= a2));
  var greaterThan = /* @__PURE__ */ union4(asBooleanBoolean)(asBooleanBoolean)(asIntNumberOrString)(asIntNumberOrString)((a1) => (a2) => a1 > a2)(/* @__PURE__ */ union4(asBooleanBoolean)(asBooleanBoolean)(asNumberString)(asNumberString)((a1) => (a2) => a1 > a2)((a1) => (a2) => a1 > a2));
  var extern = (dictBoundedJoinSemilattice) => {
    const bot = dictBoundedJoinSemilattice.bot;
    return (v) => $Tuple(v._1, $Val(bot, $BaseVal("Fun", $Fun("Foreign", $Tuple(v._1, v._2), Nil))));
  };
  var extern1 = /* @__PURE__ */ extern(boundedJoinSemilatticeUni);
  var error_ = /* @__PURE__ */ $Tuple(
    "error",
    /* @__PURE__ */ $ForeignOp$p({
      arity: 1,
      "op'": (dictMonadWithGraphAlloc) => (dictMonadError) => {
        const MonadThrow0 = dictMonadError.MonadThrow0();
        return (v) => {
          if (v.tag === "Cons" && v._1._2.tag === "Str" && v._2.tag === "Nil") {
            return MonadThrow0.Monad0().Applicative0().pure(throwException(error(v._1._2._1))());
          }
          return MonadThrow0.throwError(error("String expected"));
        };
      },
      op: (dictAnn) => (dictMonadError) => {
        const $$throw2 = $$throw(dictMonadError.MonadThrow0());
        return (v) => {
          if (v.tag === "Cons" && v._1._2.tag === "Str" && v._2.tag === "Nil") {
            return throwException(error(v._1._2._1))();
          }
          return $$throw2("String expected");
        };
      },
      op_bwd: (dictAnn) => (v) => throwException(error("unimplemented"))()
    })
  );
  var divide = /* @__PURE__ */ union4(asNumberIntOrNumber)(asNumberIntOrNumber)(asIntNumber)(asIntNumber)((x2) => (y2) => toNumber(x2) / toNumber(y2))(numDiv);
  var dims = /* @__PURE__ */ $Tuple(
    "dims",
    /* @__PURE__ */ $ForeignOp$p({
      arity: 1,
      "op'": (dictMonadWithGraphAlloc) => (dictMonadError) => {
        const MonadThrow0 = dictMonadError.MonadThrow0();
        const Bind1 = MonadThrow0.Monad0().Bind1();
        const Functor0 = Bind1.Apply0().Functor0();
        return (v) => {
          if (v.tag === "Cons" && v._1._2.tag === "Matrix" && v._2.tag === "Nil") {
            const $0 = v._1._2._1._2._2._1;
            const $1 = v._1._1;
            const $2 = v._1._2._1._2._2._2;
            return Bind1.bind(Functor0.map((f) => f($BaseVal("Int", v._1._2._1._2._1._1)))(Functor0.map(Val)(dictMonadWithGraphAlloc.new($$$Map(
              "Node",
              1,
              1,
              v._1._2._1._2._1._2,
              void 0,
              Leaf,
              Leaf
            )))))((v1) => Bind1.bind(Functor0.map((f) => f($BaseVal("Int", $0)))(Functor0.map(Val)(dictMonadWithGraphAlloc.new($$$Map(
              "Node",
              1,
              1,
              $2,
              void 0,
              Leaf,
              Leaf
            )))))((v2) => Functor0.map((f) => f($BaseVal("Constr", "Pair", $List("Cons", v1, $List("Cons", v2, Nil)))))(Functor0.map(Val)(dictMonadWithGraphAlloc.new($$$Map(
              "Node",
              1,
              1,
              $1,
              void 0,
              Leaf,
              Leaf
            ))))));
          }
          return MonadThrow0.throwError(error("Matrix expected"));
        };
      },
      op: (dictAnn) => (dictMonadError) => {
        const MonadThrow0 = dictMonadError.MonadThrow0();
        return (v) => {
          if (v.tag === "Cons" && v._1._2.tag === "Matrix" && v._2.tag === "Nil") {
            return MonadThrow0.Monad0().Applicative0().pure($Tuple(
              arrayMap(arrayMap(erase))(v._1._2._1._1),
              $Val(
                v._1._1,
                $BaseVal(
                  "Constr",
                  "Pair",
                  $List(
                    "Cons",
                    $Val(v._1._2._1._2._1._2, $BaseVal("Int", v._1._2._1._2._1._1)),
                    $List("Cons", $Val(v._1._2._1._2._2._2, $BaseVal("Int", v._1._2._1._2._2._1)), Nil)
                  )
                )
              )
            ));
          }
          return MonadThrow0.throwError(error("Matrix expected"));
        };
      },
      op_bwd: (dictAnn) => {
        const botOf = functorVal.map((() => {
          const $0 = dictAnn.BoundedLattice1().BoundedJoinSemilattice0().bot;
          return (v) => $0;
        })());
        return (v) => {
          if (v._2._2.tag === "Constr" && v._2._2._2.tag === "Cons" && v._2._2._2._1._2.tag === "Int" && v._2._2._2._2.tag === "Cons" && v._2._2._2._2._1._2.tag === "Int" && v._2._2._2._2._2.tag === "Nil" && v._2._2._1 === "Pair") {
            return $List(
              "Cons",
              $Val(
                v._2._1,
                $BaseVal(
                  "Matrix",
                  $Tuple(
                    arrayMap(arrayMap(botOf))(v._1),
                    $Tuple($Tuple(v._2._2._2._1._2._1, v._2._2._2._1._1), $Tuple(v._2._2._2._2._1._2._1, v._2._2._2._2._1._1))
                  )
                )
              ),
              Nil
            );
          }
          fail();
        };
      }
    })
  );
  var dict_map = /* @__PURE__ */ $Tuple(
    "dict_map",
    /* @__PURE__ */ $ForeignOp$p({
      arity: 2,
      "op'": (dictMonadWithGraphAlloc) => {
        const apply4 = apply2(dictMonadWithGraphAlloc);
        return (dictMonadError) => {
          const MonadThrow0 = dictMonadError.MonadThrow0();
          const Monad0 = MonadThrow0.Monad0();
          const Bind1 = Monad0.Bind1();
          const traverse1 = traversableDict.traverse(Monad0.Applicative0());
          const Functor0 = Bind1.Apply0().Functor0();
          return (v) => {
            if (v.tag === "Cons" && v._2.tag === "Cons" && v._2._1._2.tag === "Dictionary" && v._2._2.tag === "Nil") {
              const $0 = v._1;
              const $1 = v._2._1._1;
              return Bind1.bind(traverse1((v2) => {
                const $2 = v2._1;
                return Functor0.map((v3) => $Tuple($2, v3))(apply4($0)(v2._2));
              })(v._2._1._2._1))((d$p) => Functor0.map((f) => f($BaseVal("Dictionary", d$p)))(Functor0.map(Val)(dictMonadWithGraphAlloc.new($$$Map(
                "Node",
                1,
                1,
                $1,
                void 0,
                Leaf,
                Leaf
              )))));
            }
            return MonadThrow0.throwError(error("Function and dictionary expected"));
          };
        };
      },
      op: (dictAnn) => (dictMonadError) => {
        const MonadThrow0 = dictMonadError.MonadThrow0();
        const Monad0 = MonadThrow0.Monad0();
        const Bind1 = Monad0.Bind1();
        const $0 = Bind1.Apply0().Functor0();
        const Applicative0 = Monad0.Applicative0();
        const traverse1 = traversableDict.traverse(Applicative0);
        const apply4 = apply3(dictMonadError)(dictAnn);
        return (v) => {
          if (v.tag === "Cons" && v._2.tag === "Cons" && v._2._1._2.tag === "Dictionary" && v._2._2.tag === "Nil") {
            const $1 = v._1;
            const $2 = v._2._1._1;
            return Bind1.bind($0.map(unzip6)(traverse1((v2) => {
              const $3 = v2._1;
              return $0.map((m) => $Tuple(m._1, $Tuple($3, m._2)))(apply4($Tuple($1, v2._2)));
            })(v._2._1._2._1)))((v2) => Applicative0.pure($Tuple(
              $Tuple($Val(void 0, functorBaseVal.map((v$1) => {
              })($1._2)), v2._1),
              $Val($2, $BaseVal("Dictionary", v2._2))
            )));
          }
          return MonadThrow0.throwError(error("Function and dictionary expected"));
        };
      },
      op_bwd: (dictAnn) => {
        const applyBwd2 = applyBwd(dictAnn);
        const BoundedJoinSemilattice0 = dictAnn.BoundedLattice1().BoundedJoinSemilattice0();
        return (v) => {
          if (v._2._2.tag === "Dictionary") {
            const v2 = unzip6(intersectionWith_Object((t2) => (v3) => {
              const $0 = applyBwd2($Tuple(t2, v3._2));
              return $Tuple($0._1, $Tuple(v3._1, $0._2));
            })(v._1._2)(v._2._2._1));
            return $List(
              "Cons",
              fold((z) => (v$1) => joinSemilatticeVal(BoundedJoinSemilattice0.JoinSemilattice0()).join(z))((() => {
                const $0 = BoundedJoinSemilattice0.bot;
                return $Val($0, functorBaseVal.map((v$1) => $0)(v._1._1._2));
              })())(v2._1),
              $List("Cons", $Val(v._2._1, $BaseVal("Dictionary", v2._2)), Nil)
            );
          }
          fail();
        };
      }
    })
  );
  var dict_intersectionWith = /* @__PURE__ */ $Tuple(
    "dict_intersectionWith",
    /* @__PURE__ */ $ForeignOp$p({
      arity: 3,
      "op'": (dictMonadWithGraphAlloc) => {
        const apply4 = apply2(dictMonadWithGraphAlloc);
        return (dictMonadError) => {
          const MonadThrow0 = dictMonadError.MonadThrow0();
          const Monad0 = MonadThrow0.Monad0();
          const Bind1 = Monad0.Bind1();
          const Apply0 = Bind1.Apply0();
          const $0 = Apply0.Functor0();
          const sequence1 = traversableDict.sequence(Monad0.Applicative0());
          return (v) => {
            if (v.tag === "Cons" && v._2.tag === "Cons" && v._2._1._2.tag === "Dictionary" && v._2._2.tag === "Cons" && v._2._2._1._2.tag === "Dictionary" && v._2._2._2.tag === "Nil") {
              const $1 = v._1;
              return Apply0.apply($0.map(Val)(dictMonadWithGraphAlloc.new(insert3(ordVertex)(v._2._2._1._1)()($$$Map(
                "Node",
                1,
                1,
                v._2._1._1,
                void 0,
                Leaf,
                Leaf
              )))))($0.map(Dictionary3)($0.map(DictRep)(sequence1(intersectionWith_Object((v2) => (v3) => {
                const $2 = v2._2;
                const $3 = v3._2;
                return Bind1.bind(dictMonadWithGraphAlloc.new(insert3(ordVertex)(v3._1)()($$$Map(
                  "Node",
                  1,
                  1,
                  v2._1,
                  void 0,
                  Leaf,
                  Leaf
                ))))((\u03B2$p$p) => $0.map(Tuple(\u03B2$p$p))(Bind1.bind(apply4($1)($2))((a) => apply4(a)($3))));
              })(v._2._1._2._1)(v._2._2._1._2._1)))));
            }
            return MonadThrow0.throwError(error("Function and two dictionaries expected"));
          };
        };
      },
      op: (dictAnn) => {
        const $0 = dictAnn.BoundedLattice1().BoundedMeetSemilattice1().MeetSemilattice0();
        return (dictMonadError) => {
          const MonadThrow0 = dictMonadError.MonadThrow0();
          const Monad0 = MonadThrow0.Monad0();
          const Bind1 = Monad0.Bind1();
          const Applicative0 = Monad0.Applicative0();
          const apply23 = apply22(dictMonadError)(dictAnn);
          return (v) => {
            if (v.tag === "Cons" && v._2.tag === "Cons" && v._2._1._2.tag === "Dictionary" && v._2._2.tag === "Cons" && v._2._2._1._2.tag === "Dictionary" && v._2._2._2.tag === "Nil") {
              const $1 = v._1;
              const $2 = v._2._1._1;
              const $3 = v._2._2._1._1;
              return Bind1.bind(traversableDict.traverse(Applicative0)(identity16)(intersectionWith_Object((v2) => {
                const $4 = v2._2;
                const $5 = v2._1;
                return (v3) => {
                  const $6 = v3._1;
                  return Bind1.Apply0().Functor0().map((v4) => $Tuple($0.meet($5)($6), v4))(apply23($Tuple($1, $Tuple($4, v3._2))));
                };
              })(v._2._1._2._1)(v._2._2._1._2._1)))((d$p$p) => Applicative0.pure($Tuple(
                $Tuple($Val(void 0, functorBaseVal.map((v$1) => {
                })($1._2)), _fmapObject(d$p$p, (x2) => x2._2._1)),
                $Val($0.meet($2)($3), $BaseVal("Dictionary", _fmapObject(d$p$p, (m) => $Tuple(m._1, m._2._2))))
              )));
            }
            return MonadThrow0.throwError(error("Function and two dictionaries expected"));
          };
        };
      },
      op_bwd: (dictAnn) => {
        const apply2Bwd2 = apply2Bwd(dictAnn);
        const BoundedJoinSemilattice0 = dictAnn.BoundedLattice1().BoundedJoinSemilattice0();
        return (v) => {
          if (v._2._2.tag === "Dictionary") {
            const d$p = intersectionWith_Object((tt) => (v2) => $Tuple(v2._1, apply2Bwd2($Tuple(tt, v2._2))))(v._1._2)(v._2._2._1);
            return $List(
              "Cons",
              fold((z) => (v$1) => joinSemilatticeVal(BoundedJoinSemilattice0.JoinSemilattice0()).join(z))((() => {
                const $0 = BoundedJoinSemilattice0.bot;
                return $Val($0, functorBaseVal.map((v$1) => $0)(v._1._1._2));
              })())(_fmapObject(d$p, (x2) => x2._2._1)),
              $List(
                "Cons",
                $Val(v._2._1, $BaseVal("Dictionary", _fmapObject(d$p, (m) => $Tuple(m._1, m._2._2._1)))),
                $List(
                  "Cons",
                  $Val(v._2._1, $BaseVal("Dictionary", _fmapObject(d$p, (m) => $Tuple(m._1, m._2._2._2)))),
                  Nil
                )
              )
            );
          }
          fail();
        };
      }
    })
  );
  var dict_get = /* @__PURE__ */ $Tuple(
    "dict_get",
    /* @__PURE__ */ $ForeignOp$p({
      arity: 2,
      "op'": (dictMonadWithGraphAlloc) => (dictMonadError) => {
        const MonadThrow0 = dictMonadError.MonadThrow0();
        return (v) => {
          if (v.tag === "Cons" && v._1._2.tag === "Str" && v._2.tag === "Cons" && v._2._1._2.tag === "Dictionary" && v._2._2.tag === "Nil") {
            return orElse(MonadThrow0)('Key "' + v._1._2._1 + '" not found')((() => {
              const $0 = _lookup(Nothing, Just, v._1._2._1, v._2._1._2._1);
              if ($0.tag === "Just") {
                return $Maybe("Just", $0._1._2);
              }
              return Nothing;
            })());
          }
          return MonadThrow0.throwError(error("String and dictionary expected"));
        };
      },
      op: (dictAnn) => (dictMonadError) => {
        const MonadThrow0 = dictMonadError.MonadThrow0();
        return (v) => {
          if (v.tag === "Cons" && v._1._2.tag === "Str" && v._2.tag === "Cons" && v._2._1._2.tag === "Dictionary" && v._2._2.tag === "Nil") {
            const $0 = v._1._2._1;
            return MonadThrow0.Monad0().Bind1().Apply0().Functor0().map((v1) => $Tuple($0, v1))(orElse(MonadThrow0)('Key "' + $0 + '" not found')((() => {
              const $1 = _lookup(Nothing, Just, $0, v._2._1._2._1);
              if ($1.tag === "Just") {
                return $Maybe("Just", $1._1._2);
              }
              return Nothing;
            })()));
          }
          return MonadThrow0.throwError(error("String and dictionary expected"));
        };
      },
      op_bwd: (dictAnn) => {
        const bot = dictAnn.BoundedLattice1().BoundedJoinSemilattice0().bot;
        return (v) => {
          const $0 = v._1;
          return $List(
            "Cons",
            $Val(bot, $BaseVal("Str", $0)),
            $List(
              "Cons",
              $Val(
                bot,
                $BaseVal(
                  "Dictionary",
                  (() => {
                    const $1 = {};
                    $1[$0] = $Tuple(bot, v._2);
                    return $1;
                  })()
                )
              ),
              Nil
            )
          );
        };
      }
    })
  );
  var dict_fromRecord = /* @__PURE__ */ $Tuple(
    "dict_fromRecord",
    /* @__PURE__ */ $ForeignOp$p({
      arity: 1,
      "op'": (dictMonadWithGraphAlloc) => (dictMonadError) => {
        const MonadThrow0 = dictMonadError.MonadThrow0();
        const Monad0 = MonadThrow0.Monad0();
        const Bind1 = Monad0.Bind1();
        const traverse2 = traversableDict.traverse(Monad0.Applicative0());
        const Functor0 = Bind1.Apply0().Functor0();
        return (v) => {
          if (v.tag === "Cons" && v._1._2.tag === "Record" && v._2.tag === "Nil") {
            const $0 = v._1._1;
            return Bind1.bind(traverse2((v1) => Functor0.map((v2) => $Tuple(v2, v1))(dictMonadWithGraphAlloc.new($$$Map(
              "Node",
              1,
              1,
              $0,
              void 0,
              Leaf,
              Leaf
            ))))(v._1._2._1))((xvs$p) => Functor0.map((f) => f($BaseVal("Dictionary", xvs$p)))(Functor0.map(Val)(dictMonadWithGraphAlloc.new($$$Map(
              "Node",
              1,
              1,
              $0,
              void 0,
              Leaf,
              Leaf
            )))));
          }
          return MonadThrow0.throwError(error("Record expected."));
        };
      },
      op: (dictAnn) => (dictMonadError) => {
        const MonadThrow0 = dictMonadError.MonadThrow0();
        return (v) => {
          if (v.tag === "Cons" && v._1._2.tag === "Record" && v._2.tag === "Nil") {
            const $0 = v._1._1;
            return MonadThrow0.Monad0().Applicative0().pure($Tuple(
              void 0,
              $Val($0, $BaseVal("Dictionary", _fmapObject(v._1._2._1, (v1) => $Tuple($0, v1))))
            ));
          }
          return MonadThrow0.throwError(error("Record expected."));
        };
      },
      op_bwd: (dictAnn) => (v) => {
        if (v._2._2.tag === "Dictionary") {
          return $List(
            "Cons",
            $Val(
              fold((z) => (v$1) => dictAnn.BoundedLattice1().BoundedJoinSemilattice0().JoinSemilattice0().join(z))(v._2._1)(_fmapObject(
                v._2._2._1,
                fst
              )),
              $BaseVal("Record", _fmapObject(v._2._2._1, snd))
            ),
            Nil
          );
        }
        fail();
      }
    })
  );
  var dict_foldl = /* @__PURE__ */ $Tuple(
    "dict_foldl",
    /* @__PURE__ */ $ForeignOp$p({
      arity: 3,
      "op'": (dictMonadWithGraphAlloc) => {
        const apply4 = apply2(dictMonadWithGraphAlloc);
        return (dictMonadError) => {
          const MonadThrow0 = dictMonadError.MonadThrow0();
          const Monad0 = MonadThrow0.Monad0();
          return (v) => {
            if (v.tag === "Cons" && v._2.tag === "Cons" && v._2._2.tag === "Cons" && v._2._2._1._2.tag === "Dictionary" && v._2._2._2.tag === "Nil") {
              const $0 = v._1;
              return foldM4(Monad0)((u1) => (v2) => {
                const $1 = v2._2;
                return Monad0.Bind1().bind(apply4($0)(u1))((a) => apply4(a)($1));
              })(v._2._1)(v._2._2._1._2._1);
            }
            return MonadThrow0.throwError(error("Function, value and dictionary expected"));
          };
        };
      },
      op: (dictAnn) => (dictMonadError) => {
        const MonadThrow0 = dictMonadError.MonadThrow0();
        const Monad0 = MonadThrow0.Monad0();
        const Bind1 = Monad0.Bind1();
        const $0 = Bind1.Apply0().Functor0();
        const apply23 = apply22(dictMonadError)(dictAnn);
        return (v) => {
          if (v.tag === "Cons" && v._2.tag === "Cons" && v._2._2.tag === "Cons" && v._2._2._1._2.tag === "Dictionary" && v._2._2._2.tag === "Nil") {
            const $1 = v._1;
            return Bind1.bind(foldWithIndexM(Monad0)((s) => (v2) => {
              const $2 = v2._1;
              const $3 = v2._2;
              return (v3) => $0.map((v$1) => $Tuple($List("Cons", $Tuple(s, v$1._1), $2), v$1._2))(apply23($Tuple(
                $1,
                $Tuple($3, v3._2)
              )));
            })($Tuple(Nil, v._2._1))(v._2._2._1._2._1))((v2) => Monad0.Applicative0().pure($Tuple(
              $Tuple($Val(void 0, functorBaseVal.map((v$1) => {
              })($1._2)), v2._1),
              v2._2
            )));
          }
          return MonadThrow0.throwError(error("Function, value and dictionary expected"));
        };
      },
      op_bwd: (dictAnn) => {
        const apply2Bwd2 = apply2Bwd(dictAnn);
        const BoundedJoinSemilattice0 = dictAnn.BoundedLattice1().BoundedJoinSemilattice0();
        const bot = BoundedJoinSemilattice0.bot;
        return (v) => {
          const go = (go$a0$copy) => (go$a1$copy) => {
            let go$a0 = go$a0$copy, go$a1 = go$a1$copy, go$c = true, go$r;
            while (go$c) {
              const b = go$a0, v$1 = go$a1;
              if (v$1.tag === "Nil") {
                go$c = false;
                go$r = b;
                continue;
              }
              if (v$1.tag === "Cons") {
                go$a0 = (() => {
                  const $0 = v$1._1._1;
                  const v5 = apply2Bwd2($Tuple(v$1._1._2, b._2._1));
                  return $Tuple(
                    joinSemilatticeVal(BoundedJoinSemilattice0.JoinSemilattice0()).join(b._1)(v5._1),
                    $Tuple(
                      v5._2._1,
                      mutate(($1) => () => {
                        $1[$0] = $Tuple(bot, v5._2._2);
                        return $1;
                      })(b._2._2)
                    )
                  );
                })();
                go$a1 = v$1._2;
                continue;
              }
              fail();
            }
            return go$r;
          };
          const v2 = go($Tuple(
            (() => {
              const $0 = BoundedJoinSemilattice0.bot;
              return $Val($0, functorBaseVal.map((v$1) => $0)(v._1._1._2));
            })(),
            $Tuple(v._2, empty2)
          ))(v._1._2);
          return $List(
            "Cons",
            v2._1,
            $List("Cons", v2._2._1, $List("Cons", $Val(bot, $BaseVal("Dictionary", v2._2._2)), Nil))
          );
        };
      }
    })
  );
  var dict_disjointUnion = /* @__PURE__ */ $Tuple(
    "dict_disjointUnion",
    /* @__PURE__ */ $ForeignOp$p({
      arity: 2,
      "op'": (dictMonadWithGraphAlloc) => (dictMonadError) => {
        const MonadThrow0 = dictMonadError.MonadThrow0();
        const Functor0 = MonadThrow0.Monad0().Bind1().Apply0().Functor0();
        return (v) => {
          if (v.tag === "Cons" && v._1._2.tag === "Dictionary" && v._2.tag === "Cons" && v._2._1._2.tag === "Dictionary" && v._2._2.tag === "Nil") {
            const $0 = $BaseVal("Dictionary", disjointUnion5(v._1._2._1)(v._2._1._2._1));
            return Functor0.map((f) => f($0))(Functor0.map(Val)(dictMonadWithGraphAlloc.new(insert3(ordVertex)(v._2._1._1)()($$$Map(
              "Node",
              1,
              1,
              v._1._1,
              void 0,
              Leaf,
              Leaf
            )))));
          }
          return MonadThrow0.throwError(error("Dictionaries expected"));
        };
      },
      op: (dictAnn) => (dictMonadError) => {
        const MonadThrow0 = dictMonadError.MonadThrow0();
        return (v) => {
          if (v.tag === "Cons" && v._1._2.tag === "Dictionary" && v._2.tag === "Cons" && v._2._1._2.tag === "Dictionary" && v._2._2.tag === "Nil") {
            const $0 = v._2._1._2._1;
            return MonadThrow0.Monad0().Applicative0().pure($Tuple(
              $Tuple(_fmapObject(v._1._2._1, (v$1) => {
              }), _fmapObject($0, (v$1) => {
              })),
              $Val(dictAnn.BoundedLattice1().BoundedMeetSemilattice1().MeetSemilattice0().meet(v._1._1)(v._2._1._1), $BaseVal("Dictionary", disjointUnion5(v._1._2._1)($0)))
            ));
          }
          return MonadThrow0.throwError(error("Dictionaries expected"));
        };
      },
      op_bwd: (dictAnn) => (v) => {
        if (v._2._2.tag === "Dictionary") {
          return $List(
            "Cons",
            $Val(v._2._1, $BaseVal("Dictionary", mapFObjectString.difference(v._2._2._1)(v._1._2))),
            $List("Cons", $Val(v._2._1, $BaseVal("Dictionary", mapFObjectString.difference(v._2._2._1)(v._1._1))), Nil)
          );
        }
        fail();
      }
    })
  );
  var dict_difference = /* @__PURE__ */ $Tuple(
    "dict_difference",
    /* @__PURE__ */ $ForeignOp$p({
      arity: 2,
      "op'": (dictMonadWithGraphAlloc) => (dictMonadError) => {
        const MonadThrow0 = dictMonadError.MonadThrow0();
        const Functor0 = MonadThrow0.Monad0().Bind1().Apply0().Functor0();
        return (v) => {
          if (v.tag === "Cons" && v._1._2.tag === "Dictionary" && v._2.tag === "Cons" && v._2._1._2.tag === "Dictionary" && v._2._2.tag === "Nil") {
            const $0 = $BaseVal("Dictionary", mapFObjectString.difference(v._1._2._1)(v._2._1._2._1));
            return Functor0.map((f) => f($0))(Functor0.map(Val)(dictMonadWithGraphAlloc.new(insert3(ordVertex)(v._2._1._1)()($$$Map(
              "Node",
              1,
              1,
              v._1._1,
              void 0,
              Leaf,
              Leaf
            )))));
          }
          return MonadThrow0.throwError(error("Dictionaries expected."));
        };
      },
      op: (dictAnn) => (dictMonadError) => {
        const MonadThrow0 = dictMonadError.MonadThrow0();
        return (v) => {
          if (v.tag === "Cons" && v._1._2.tag === "Dictionary" && v._2.tag === "Cons" && v._2._1._2.tag === "Dictionary" && v._2._2.tag === "Nil") {
            return MonadThrow0.Monad0().Applicative0().pure($Tuple(
              void 0,
              $Val(
                dictAnn.BoundedLattice1().BoundedMeetSemilattice1().MeetSemilattice0().meet(v._1._1)(v._2._1._1),
                $BaseVal("Dictionary", mapFObjectString.difference(v._1._2._1)(v._2._1._2._1))
              )
            ));
          }
          return MonadThrow0.throwError(error("Dictionaries expected."));
        };
      },
      op_bwd: (dictAnn) => (v) => {
        if (v._2._2.tag === "Dictionary") {
          return $List(
            "Cons",
            $Val(v._2._1, $BaseVal("Dictionary", v._2._2._1)),
            $List("Cons", $Val(v._2._1, $BaseVal("Dictionary", empty2)), Nil)
          );
        }
        fail();
      }
    })
  );
  var debugLog = /* @__PURE__ */ $Tuple(
    "debugLog",
    /* @__PURE__ */ $ForeignOp$p({
      arity: 1,
      "op'": (dictMonadWithGraphAlloc) => (dictMonadError) => {
        const MonadThrow0 = dictMonadError.MonadThrow0();
        return (v) => {
          if (v.tag === "Cons" && v._2.tag === "Nil") {
            const $0 = v._1;
            return MonadThrow0.Monad0().Applicative0().pure(_trace($0, (v$1) => $0));
          }
          return MonadThrow0.throwError(error("Single value expected"));
        };
      },
      op: (dictAnn) => (dictMonadError) => {
        const MonadThrow0 = dictMonadError.MonadThrow0();
        return (v) => {
          if (v.tag === "Cons" && v._2.tag === "Nil") {
            const $0 = v._1;
            return MonadThrow0.Monad0().Applicative0().pure($Tuple(void 0, _trace($0, (v$1) => $0)));
          }
          return MonadThrow0.throwError(error("Single value expected"));
        };
      },
      op_bwd: (dictAnn) => (v) => throwException(error("unimplemented"))()
    })
  );
  var primitives = /* @__PURE__ */ fromFoldable(foldableArray)([
    /* @__PURE__ */ $Tuple(
      ":",
      /* @__PURE__ */ $Val(void 0, /* @__PURE__ */ $BaseVal("Fun", /* @__PURE__ */ $Fun("PartialConstr", ":", Nil)))
    ),
    /* @__PURE__ */ unary2("ceiling")({ i: number5, o: $$int, fwd: ceil2 }),
    /* @__PURE__ */ extern1(debugLog),
    /* @__PURE__ */ extern1(dims),
    /* @__PURE__ */ extern1(error_),
    /* @__PURE__ */ unary2("floor")({ i: number5, o: $$int, fwd: floor2 }),
    /* @__PURE__ */ unary2("log")({ i: intOrNumber, o: number5, fwd: log3 }),
    /* @__PURE__ */ unary2("numToStr")({ i: intOrNumber, o: string2, fwd: numToStr }),
    /* @__PURE__ */ binary2("+")({
      i1: intOrNumber,
      i2: intOrNumber,
      o: intOrNumber,
      fwd: /* @__PURE__ */ union4(asIntIntOrNumber)(asNumberIntOrNumber)(asIntNumber)(asIntNumber)(intAdd)(numAdd)
    }),
    /* @__PURE__ */ binary2("-")({
      i1: intOrNumber,
      i2: intOrNumber,
      o: intOrNumber,
      fwd: /* @__PURE__ */ union4(asIntIntOrNumber)(asNumberIntOrNumber)(asIntNumber)(asIntNumber)(intSub)(numSub)
    }),
    /* @__PURE__ */ binaryZero1("*")({
      i: intOrNumber,
      o: intOrNumber,
      fwd: /* @__PURE__ */ union4(asIntIntOrNumber)(asNumberIntOrNumber)(asIntNumber)(asIntNumber)(intMul)(numMul)
    }),
    /* @__PURE__ */ binaryZero1("**")({ i: intOrNumber, o: intOrNumber, fwd: pow3 }),
    /* @__PURE__ */ binaryZero1("/")({ i: intOrNumber, o: intOrNumber, fwd: divide }),
    /* @__PURE__ */ binary2("==")({
      i1: intOrNumberOrString,
      i2: intOrNumberOrString,
      o: $$boolean,
      fwd: /* @__PURE__ */ union4(asBooleanBoolean)(asBooleanBoolean)(asIntNumberOrString)(asIntNumberOrString)(eqIntImpl)(/* @__PURE__ */ unionStr(asBooleanBoolean)(asNumberString)(eqNumberImpl)(eqStringImpl))
    }),
    /* @__PURE__ */ binary2("/=")({ i1: intOrNumberOrString, i2: intOrNumberOrString, o: $$boolean, fwd: notEquals }),
    /* @__PURE__ */ binary2("<")({ i1: intOrNumberOrString, i2: intOrNumberOrString, o: $$boolean, fwd: lessThan }),
    /* @__PURE__ */ binary2(">")({ i1: intOrNumberOrString, i2: intOrNumberOrString, o: $$boolean, fwd: greaterThan }),
    /* @__PURE__ */ binary2("<=")({ i1: intOrNumberOrString, i2: intOrNumberOrString, o: $$boolean, fwd: lessThanEquals }),
    /* @__PURE__ */ binary2(">=")({ i1: intOrNumberOrString, i2: intOrNumberOrString, o: $$boolean, fwd: greaterThanEquals }),
    /* @__PURE__ */ binary2("++")({ i1: string2, i2: string2, o: string2, fwd: concatString }),
    /* @__PURE__ */ extern1(matrixLookup),
    /* @__PURE__ */ extern1(dict_difference),
    /* @__PURE__ */ extern1(dict_disjointUnion),
    /* @__PURE__ */ extern1(dict_foldl),
    /* @__PURE__ */ extern1(dict_fromRecord),
    /* @__PURE__ */ extern1(dict_get),
    /* @__PURE__ */ extern1(dict_intersectionWith),
    /* @__PURE__ */ extern1(dict_map),
    /* @__PURE__ */ extern1(matrixUpdate),
    /* @__PURE__ */ binaryZero22("div")({ i: $$int, o: $$int, fwd: intDiv2 }),
    /* @__PURE__ */ binaryZero22("mod")({ i: $$int, o: $$int, fwd: intMod }),
    /* @__PURE__ */ binaryZero22("quot")({ i: $$int, o: $$int, fwd: quot }),
    /* @__PURE__ */ binaryZero22("rem")({ i: $$int, o: $$int, fwd: rem })
  ]);

  // output-es/ProgCxt/index.js
  var identity31 = (x2) => x2;
  var functorProgCxt = {
    map: (f) => (m) => ({
      ...m,
      datasets: listMap((m$1) => $Tuple(m$1._1, functorExpr.map(f)(m$1._2)))(m.datasets),
      mods: listMap(functorModule.map(f))(m.mods),
      primitives: _fmapObject(m.primitives, functorVal.map(f))
    })
  };
  var foldableProgCxt = {
    foldl: (f) => (z) => (m) => {
      const go = (go$a0$copy) => (go$a1$copy) => {
        let go$a0 = go$a0$copy, go$a1 = go$a1$copy, go$c = true, go$r;
        while (go$c) {
          const b = go$a0, v = go$a1;
          if (v.tag === "Nil") {
            go$c = false;
            go$r = b;
            continue;
          }
          if (v.tag === "Cons") {
            go$a0 = foldableModule.foldl(f)(b)(v._1);
            go$a1 = v._2;
            continue;
          }
          fail();
        }
        return go$r;
      };
      return fold((z$1) => (v) => foldableVal.foldl(f)(z$1))(go((() => {
        const go$1 = (go$1$a0$copy) => (go$1$a1$copy) => {
          let go$1$a0 = go$1$a0$copy, go$1$a1 = go$1$a1$copy, go$1$c = true, go$1$r;
          while (go$1$c) {
            const b = go$1$a0, v = go$1$a1;
            if (v.tag === "Nil") {
              go$1$c = false;
              go$1$r = b;
              continue;
            }
            if (v.tag === "Cons") {
              go$1$a0 = foldableExpr.foldl(f)(b)(v._1._2);
              go$1$a1 = v._2;
              continue;
            }
            fail();
          }
          return go$1$r;
        };
        return go$1(z)(m.datasets);
      })())(m.mods))(m.primitives);
    },
    foldr: (f) => (z) => (m) => foldableList.foldr((b) => (a) => foldableExpr.foldr(f)(a)(b._2))(foldableList.foldr((() => {
      const $0 = foldrDefault(foldableModule)(f);
      return (b) => (a) => $0(a)(b);
    })())(foldableEnv.foldr(f)(z)(m.primitives))(m.mods))(m.datasets),
    foldMap: (dictMonoid) => {
      const $0 = dictMonoid.Semigroup0();
      const foldMap5 = foldableList.foldMap(dictMonoid);
      const foldMap7 = foldableExpr.foldMap(dictMonoid);
      const foldMap9 = foldableEnv.foldMap(dictMonoid);
      return (f) => (m) => $0.append(foldMap5((() => {
        const $1 = foldMap7(f);
        return (v) => $1(v._2);
      })())(m.datasets))($0.append(foldMap5(foldableModule.foldMap(dictMonoid)(f))(m.mods))(foldMap9(f)(m.primitives)));
    }
  };
  var traversableProgCxt = {
    traverse: (dictApplicative) => {
      const Apply0 = dictApplicative.Apply0();
      const traverse5 = traversableList.traverse(dictApplicative);
      const traverse7 = traversableExpr.traverse(dictApplicative);
      const traverse8 = traversableModule.traverse(dictApplicative);
      const traverse9 = traversableEnv.traverse(dictApplicative);
      return (f) => (m) => Apply0.apply(Apply0.apply(Apply0.Functor0().map((v1) => (v2) => (v3) => ({ ...m, datasets: v1, mods: v2, primitives: v3 }))(traverse5(traversableTuple.traverse(dictApplicative)(traverse7(f)))(m.datasets)))(traverse5(traverse8(f))(m.mods)))(traverse9(f)(m.primitives));
    },
    sequence: (dictApplicative) => (v) => traversableProgCxt.traverse(dictApplicative)(identity31)(v),
    Functor0: () => functorProgCxt,
    Foldable1: () => foldableProgCxt
  };

  // output-es/Module/index.js
  var boundedLattice2 = { BoundedJoinSemilattice0: () => boundedJoinSemilatticeUni, BoundedMeetSemilattice1: () => boundedMeetSemilatticeUni };
  var verticesVertex2 = /* @__PURE__ */ verticesVertex(functorProgCxt)(foldableProgCxt);
  var concatM2 = (dictMonad) => foldrArray((() => {
    const $0 = dictMonad.Bind1();
    return (f) => (g) => (a) => $0.bind(f(a))(g);
  })())(dictMonad.Applicative0().pure);
  var parse = (dictMonadError) => {
    const $0 = dictMonadError.MonadThrow0();
    const $1 = $0.Monad0().Applicative0().pure;
    return (src) => {
      const $2 = runParserT1(src);
      return (x2) => {
        const $3 = $2(x2);
        if ($3.tag === "Left") {
          return $0.throwError(error(showParseError.show($3._1)));
        }
        if ($3.tag === "Right") {
          return $1($3._1);
        }
        fail();
      };
    };
  };
  var loadFile = (v) => (v1) => (dictMonadAff) => {
    const MonadEffect0 = dictMonadAff.MonadEffect0();
    const Monad0 = MonadEffect0.Monad0();
    const Bind1 = Monad0.Bind1();
    return (dictMonadError) => Bind1.bind(dictMonadAff.liftAff(request(driver)({
      ...defaultRequest,
      url: v + "/" + v1 + ".fld",
      method: $Either("Left", GET),
      responseFormat: $ResponseFormat("String", identity28)
    })))((result) => {
      if (result.tag === "Left") {
        const $0 = result._1;
        return Bind1.bind(MonadEffect0.liftEffect(log2("Failed with " + printError($0))))(() => dictMonadError.MonadThrow0().throwError(error(printError($0))));
      }
      if (result.tag === "Right") {
        return Monad0.Applicative0().pure(result._1.body);
      }
      fail();
    });
  };
  var module_2 = (dictMonadAff) => {
    const Monad0 = dictMonadAff.MonadEffect0().Monad0();
    const $0 = Monad0.Bind1();
    return (dictMonadError) => {
      const parse1 = parse(dictMonadError);
      const desugarModuleFwd = moduleFwd(dictMonadError)(boundedLattice2);
      return (file) => (v) => {
        const $1 = v.mods;
        return $0.bind(loadFile("fluid")(file)(dictMonadAff)(dictMonadError))((src) => $0.bind($0.bind(parse1(src)(module_))(desugarModuleFwd))((mod) => Monad0.Applicative0().pure({
          ...v,
          mods: $List("Cons", mod, $1)
        })));
      };
    };
  };
  var parseProgram = (folder) => (file) => (dictMonadAff) => (dictMonadError) => dictMonadAff.MonadEffect0().Monad0().Bind1().bind(loadFile(folder)(file)(dictMonadAff)(dictMonadError))((() => {
    const $0 = parse(dictMonadError);
    return (a) => $0(a)(topLevel(expr_));
  })());
  var initialConfig = (dictMonadError) => {
    const Monad0 = dictMonadError.MonadThrow0().Monad0();
    const Bind1 = Monad0.Bind1();
    const Applicative0 = Monad0.Applicative0();
    const $0 = monadAllocAllocT(Monad0);
    const fresh1 = $0.fresh;
    const alloc = traversableProgCxt.traverse($0.Monad0().Applicative0())((v) => fresh1);
    const $1 = bindStateT(Monad0);
    const runWithGraphT_spy2 = runWithGraphT_spy({
      Applicative0: () => applicativeStateT(Monad0),
      Bind1: () => bindStateT(Monad0)
    })(graphGraphImpl);
    const eval_progCxt2 = eval_progCxt(monadWithGraphAllocWithGr(dictMonadError));
    return (dictFV) => (e) => (progCxt) => Bind1.bind(Applicative0.pure())(() => Bind1.bind(runAllocT(Monad0)($1.bind(alloc(progCxt))((progCxt$p) => $1.bind(runWithGraphT_spy2(eval_progCxt2(progCxt$p))(verticesVertex2.vertices(progCxt$p)))((v) => applicativeStateT(Monad0).pure($Tuple(
      progCxt$p,
      (() => {
        const $2 = dictFV.fv(e);
        return filterWithKey((x2) => {
          const $3 = setSet(ordString).member(x2)($2);
          return (v$1) => $3;
        })(v._2);
      })()
    )))))(0))((v) => Applicative0.pure({ n: v._1, progCxt: v._2._2._1, "\u03B3": v._2._2._2 })));
  };
  var datasetAs = (dictMonadAff) => {
    const Monad0 = dictMonadAff.MonadEffect0().Monad0();
    const $0 = Monad0.Bind1();
    return (dictMonadError) => {
      const desug1 = exprFwd(boundedLattice2)(dictMonadError)(joinSemilatticeUnit);
      return (v) => (v1) => {
        const $1 = v1.datasets;
        const $2 = v._1;
        return $0.bind($0.bind(parseProgram("fluid")(v._2)(dictMonadAff)(dictMonadError))(desug1))((e\u03B1) => Monad0.Applicative0().pure({
          ...v1,
          datasets: $List("Cons", $Tuple($2, e\u03B1), $1)
        }));
      };
    };
  };
  var loadProgCxt = (dictMonadAff) => {
    const Monad0 = dictMonadAff.MonadEffect0().Monad0();
    const $0 = Monad0.Bind1();
    const concatM1 = concatM2(Monad0);
    const module_1 = module_2(dictMonadAff);
    const datasetAs1 = datasetAs(dictMonadAff);
    return (dictMonadError) => {
      const module_22 = module_1(dictMonadError);
      const datasetAs2 = datasetAs1(dictMonadError);
      return (mods) => (datasets) => $0.bind($0.bind(Monad0.Applicative0().pure({ primitives, mods: Nil, datasets: Nil }))(concatM1(arrayMap((x2) => module_22(x2))([
        "lib/prelude",
        ...mods
      ]))))(concatM1(arrayMap((x2) => datasetAs2($Tuple(x2._1, x2._2)))(datasets)));
    };
  };

  // output-es/App.Fig/index.js
  var highlightableSelState2 = /* @__PURE__ */ highlightableSelState(highlightableBoolean)(joinSemilatticeBoolean);
  var prettyP3 = /* @__PURE__ */ prettyP(/* @__PURE__ */ prettyEnv(highlightableSelState2));
  var prettyP1 = /* @__PURE__ */ prettyP(/* @__PURE__ */ prettyVal(highlightableSelState2));
  var botOf2 = /* @__PURE__ */ (() => ({ botOf: functorSelState.map((v) => false) }))();
  var getPersistent = (v) => {
    if (v.tag === "Inert") {
      return false;
    }
    if (v.tag === "Reactive") {
      return v._1.persistent;
    }
    fail();
  };
  var getTransient = (v) => {
    if (v.tag === "Inert") {
      return false;
    }
    if (v.tag === "Reactive") {
      return v._1.transient;
    }
    fail();
  };
  var boundedLattice3 = { BoundedJoinSemilattice0: () => boundedJoinSemilatticeUni, BoundedMeetSemilattice1: () => boundedMeetSemilatticeUni };
  var fromFoldable25 = /* @__PURE__ */ foldlArray((m) => (a) => insert3(ordString)(a)()(m))(Leaf);
  var graphGC2 = /* @__PURE__ */ graphGC(graphGraphImpl);
  var graphGC1 = /* @__PURE__ */ graphGC2(applyEnvExpr)(applyVal)(foldableEnvExpr)(foldableVal);
  var graphGC22 = /* @__PURE__ */ graphGC2(applyVal)(applyEnvExpr)(foldableVal)(foldableEnvExpr);
  var dual = (v) => ({
    fwd: (x2) => _fmapObject(v.bwd(functorEnvExpr.map(boolNot)(x2)), functorVal.map(boolNot)),
    bwd: (x2) => functorEnvExpr.map(boolNot)(v.fwd(_fmapObject(x2, functorVal.map(boolNot))))
  });
  var neg12 = { neg: (x2) => functorSelState.map(boolNot)(x2) };
  var joinSemilatticeSelState2 = /* @__PURE__ */ joinSemilatticeSelState(joinSemilatticeBoolean);
  var meet = /* @__PURE__ */ (() => {
    const $0 = joinSemilatticeVal(joinSemilatticeSelState2);
    return {
      fwd: (x2) => {
        const $1 = $0.join($Val(functorSelState.map(boolNot)(x2._1._1), functorBaseVal.map(neg12.neg)(x2._1._2)))($Val(
          functorSelState.map(boolNot)(x2._2._1),
          functorBaseVal.map(neg12.neg)(x2._2._2)
        ));
        return $Val(functorSelState.map(boolNot)($1._1), functorBaseVal.map(neg12.neg)($1._2));
      },
      bwd: (x2) => {
        const $1 = functorSelState.map(boolNot)(x2._1);
        const $2 = functorBaseVal.map(neg12.neg)(x2._2);
        return $Tuple(
          $Val(functorSelState.map(boolNot)($1), functorBaseVal.map(neg12.neg)($2)),
          $Val(functorSelState.map(boolNot)($1), functorBaseVal.map(neg12.neg)($2))
        );
      }
    };
  })();
  var meet1 = {
    fwd: (x2) => _fmapObject(
      unionWith(joinSemilatticeVal(joinSemilatticeSelState2).join)(_fmapObject(x2._1, functorVal.map(neg12.neg)))(_fmapObject(
        x2._2,
        functorVal.map(neg12.neg)
      )),
      functorVal.map(neg12.neg)
    ),
    bwd: (x2) => {
      const $0 = _fmapObject(x2, functorVal.map(neg12.neg));
      return $Tuple(_fmapObject($0, functorVal.map(neg12.neg)), _fmapObject($0, functorVal.map(neg12.neg)));
    }
  };
  var sequence_3 = /* @__PURE__ */ traverse_(applicativeEffect)(foldableDict)(identity6);
  var unprojExpr = (dictBoundedMeetSemilattice) => (v) => {
    const $0 = v._2;
    return {
      fwd: (\u03B3) => $EnvExpr(
        \u03B3,
        functorExpr.map((() => {
          const $1 = dictBoundedMeetSemilattice.top;
          return (v$1) => $1;
        })())($0)
      ),
      bwd: (v1) => v1._1
    };
  };
  var setOutputView = (\u03B4vw) => (fig) => ({ ...fig, out_view: fig.out_view.tag === "Just" ? $Maybe("Just", \u03B4vw(fig.out_view._1)) : Nothing });
  var setInputView = (x2) => (\u03B4vw) => (fig) => ({
    ...fig,
    in_views: (() => {
      const $0 = _lookup(Nothing, Just, x2, fig.in_views);
      const $1 = (() => {
        if ($0.tag === "Just") {
          return $0._1;
        }
        if ($0.tag === "Nothing") {
          return Nothing;
        }
        fail();
      })();
      const $2 = $1.tag === "Just" ? $Maybe("Just", \u03B4vw($1._1)) : Nothing;
      return mutate(($3) => () => {
        $3[x2] = $2;
        return $3;
      })(fig.in_views);
    })()
  });
  var selectionResult = (v) => {
    if (v.dir === "LinkedOutputs") {
      const v2 = v.linkedOutputs.bwd(v.v);
      return $Tuple(
        applyVal.apply($Val(
          (() => {
            const $0 = v.v._1;
            return (b) => applySelState.apply(functorSelState.map(as\u{1D54A})($0))(b);
          })(),
          functorBaseVal.map((a) => (b) => applySelState.apply(functorSelState.map(as\u{1D54A})(a))(b))(v.v._2)
        ))(v2._1),
        _fmapObject(spyWhen(false)("Mediating inputs")(prettyP3)(v2._2), functorVal.map((v3) => functorSelState.map(to\u{1D54A})(v3)))
      );
    }
    if (v.dir === "LinkedInputs") {
      const v1 = v.linkedInputs.bwd(v["\u03B3"]);
      return $Tuple(
        (() => {
          const $0 = spyWhen(false)("Mediating outputs")(prettyP1)(v1._2);
          return $Val(functorSelState.map(to\u{1D54A})($0._1), functorBaseVal.map((v2) => functorSelState.map(to\u{1D54A})(v2))($0._2));
        })(),
        intersectionWith_Object(apply)(_fmapObject(
          _fmapObject(v["\u03B3"], functorVal.map((a) => (b) => applySelState.apply(functorSelState.map(as\u{1D54A})(a))(b))),
          applyVal.apply
        ))(v1._1)
      );
    }
    fail();
  };
  var selectOutput = (\u03B4v) => (v) => ({ ...v, v: \u03B4v(v.v), "\u03B3": v.dir === "LinkedInputs" ? _fmapObject(v["\u03B3"], functorVal.map(botOf2.botOf)) : v["\u03B3"], dir: LinkedOutputs });
  var selectInput = (x2) => (\u03B4v) => (v) => ({
    ...v,
    "\u03B3": envVal(x2)(\u03B4v)(v["\u03B3"]),
    v: v.dir === "LinkedOutputs" ? $Val(functorSelState.map((v$1) => false)(v.v._1), functorBaseVal.map(botOf2.botOf)(v.v._2)) : v.v,
    dir: LinkedInputs
  });
  var lift = (dictApply) => {
    const $0 = dictApply.Functor0();
    return (dictApply1) => {
      const $1 = dictApply1.Functor0();
      return (selState_f) => (selState_g) => (v) => ({
        bwd: (v1) => dictApply.apply(dictApply.apply(selState_f)(v.bwd($1.map(getPersistent)(v1))))(v.bwd($1.map(getTransient)(v1))),
        fwd: (\u03B3) => dictApply1.apply(dictApply1.apply(selState_g)(v.fwd($0.map(getPersistent)(\u03B3))))(v.fwd($0.map(getTransient)(\u03B3)))
      });
    };
  };
  var lift1 = /* @__PURE__ */ lift(applyEnv)(applyVal);
  var lift3 = /* @__PURE__ */ lift(applyVal)(applyEnv);
  var loadFig = (v) => (dictMonadAff) => {
    const Monad0 = dictMonadAff.MonadEffect0().Monad0();
    const $0 = Monad0.Bind1();
    const loadProgCxt2 = loadProgCxt(dictMonadAff);
    return (dictMonadError) => {
      const desug1 = exprFwd(boundedLattice3)(dictMonadError)(joinSemilatticeUnit);
      const loadProgCxt1 = loadProgCxt2(dictMonadError);
      const initialConfig2 = initialConfig(dictMonadError)(fVExpr);
      const graphEval2 = graphEval(dictMonadError);
      const $1 = v.datasets;
      const $2 = v.imports;
      const $3 = v.inputs;
      return $0.bind(parseProgram("fluid/example")(v.file)(dictMonadAff)(dictMonadError))((s) => $0.bind(desug1(s))((e) => $0.bind($0.bind(loadProgCxt1($2)($1))(initialConfig2(e)))((gconfig) => $0.bind(graphEval2(gconfig)(e))((v1) => {
        const v2 = functorEnvExpr.map((v$1) => {
        })(v1["in\u03B1"]);
        const \u03B30 = _fmapObject(v1["in\u03B1"]._1, functorVal.map((v$1) => false));
        const v0 = $Val(false, functorBaseVal.map((v$1) => false)(v1["out\u03B1"]._2));
        const $4 = unrestrictGC(boundedMeetSemilatticeBoo)(v2._1)(fromFoldable25($3));
        const $5 = unprojExpr(boundedMeetSemilatticeBoo)($EnvExpr(v2._1, v2._2));
        const focus = { fwd: (x2) => $5.fwd($4.fwd(x2)), bwd: (x2) => $4.bwd($5.bwd(x2)) };
        const $6 = graphGC1(v1);
        const gc = { fwd: (x2) => $6.fwd(focus.fwd(x2)), bwd: (x2) => focus.bwd($6.bwd(x2)) };
        const $7 = gc.fwd(\u03B30);
        const vInert = $Val(selState($7._1), functorBaseVal.map(selState)($7._2));
        const \u03B3Inert = _fmapObject(
          _fmapObject(gc.bwd($Val(true, functorBaseVal.map((v$1) => true)(v1["out\u03B1"]._2))), functorVal.map(boolNot)),
          functorVal.map(selState)
        );
        const $8 = graphGC22({
          g: $GraphImpl({ out: v1.g._1.in_, in_: v1.g._1.out, sinks: v1.g._1.sources, sources: v1.g._1.sinks, vertices: v1.g._1.vertices }),
          graph_fwd: v1.graph_fwd,
          graph_bwd: v1.graph_bwd,
          "in\u03B1": v1["out\u03B1"],
          "out\u03B1": v1["in\u03B1"]
        });
        const $9 = dual(focus);
        const gc_dual = { fwd: (x2) => $9.fwd($8.fwd(x2)), bwd: (x2) => $8.bwd($9.bwd(x2)) };
        return Monad0.Applicative0().pure({
          spec: v,
          s,
          "\u03B3": intersectionWith_Object(apply)(_fmapObject(
            intersectionWith_Object(apply)(_fmapObject(\u03B3Inert, applyVal.apply))(\u03B30),
            applyVal.apply
          ))(\u03B30),
          v: applyVal.apply(applyVal.apply(vInert)(v0))(v0),
          linkedOutputs: (() => {
            const $10 = lift3(vInert)(\u03B3Inert)(gc_dual);
            const $11 = lift1(\u03B3Inert)(vInert)(gc);
            return {
              fwd: (x2) => $11.fwd(meet1.fwd($Tuple($10.fwd(x2._1), categoryGaloisConnection.identity.fwd(x2._2)))),
              bwd: (x2) => {
                const $12 = meet1.bwd($11.bwd(x2));
                return $Tuple($10.bwd($12._1), categoryGaloisConnection.identity.bwd($12._2));
              }
            };
          })(),
          linkedInputs: (() => {
            const $10 = lift1(\u03B3Inert)(vInert)(gc);
            const $11 = lift3(vInert)(\u03B3Inert)(gc_dual);
            return {
              fwd: (x2) => $11.fwd(meet.fwd($Tuple($10.fwd(x2._1), categoryGaloisConnection.identity.fwd(x2._2)))),
              bwd: (x2) => {
                const $12 = meet.bwd($11.bwd(x2));
                return $Tuple($10.bwd($12._1), categoryGaloisConnection.identity.bwd($12._2));
              }
            };
          })(),
          dir: LinkedOutputs,
          in_views: _mapWithKey(v2._1, (v3) => (v4) => Nothing),
          out_view: Nothing
        });
      }))));
    };
  };
  var drawFig = (divId) => (fig) => {
    const $0 = drawFig(divId);
    const $1 = selectionResult(fig);
    const $2 = intersectionWith_Object(apply)(_mapWithKey($1._2, view()))(fig.in_views);
    const $3 = view()("output")($1._1)(fig.out_view)((dictDrawable) => (view2) => dictDrawable.draw({ divId, suffix: "output", view: view2 })(selectOutput)(setOutputView)((x2) => $0(x2(fig))));
    return () => {
      $3();
      return sequence_3(_mapWithKey(
        $2,
        (x2) => (view1) => {
          const $4 = divId + "-input";
          return view1((dictDrawable) => (view2) => dictDrawable.draw({ divId: $4, suffix: x2, view: view2 })(selectInput(x2))(setInputView(x2))((x$1) => $0(x$1(fig))));
        }
      ))();
    };
  };

  // output-es/Effect.Aff.Class/index.js
  var monadAffAff = { liftAff: (x2) => x2, MonadEffect0: () => monadEffectAff };

  // output-es/Article/index.js
  var figSpec = { datasets: [/* @__PURE__ */ $Tuple("methane", "data/methane-emissions")], imports: [], file: "line-chart", inputs: ["methane"] };
  var main = /* @__PURE__ */ runAffs_((v) => drawFig(v._1)(v._2))([
    /* @__PURE__ */ _map((v) => $Tuple("fig", v))(/* @__PURE__ */ loadFig(figSpec)(monadAffAff)(monadErrorAff))
  ]);

  // <stdin>
  main();
})();
