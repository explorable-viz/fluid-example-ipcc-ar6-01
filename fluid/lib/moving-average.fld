let zipPairs = zipWith (fun x y -> {x : x, y : y});
let getXs = map (fun rec -> rec.x);
let getYs = map (fun rec -> rec.y);

-- ISSUE: With the ones that shrink, the values near the ends will be incorrect,
-- since the actual number of points is less than the size of window (= 1 + (2 * window))
-- To fix this, need to change the constant we divide by, but using length induces dependency on whole list

-- Central average, but stops near the ends of the sequence
let cMAvg ns window =
    [ (sum (slice (ind - window) (ind + window + 1) ns)) / (1 + 2 * window) | ind <- [window..length ns - window] ];

let mAvgChop ps window =
    zipPairs (slice window (length ps - window) (getXs ps)) (cMAvg (getYs ps) window);

-- Central average, but end points use incomplete data
let cMAvg' ns window =
    [ (sum (slice (ind - window) (ind + window + 1) ns)) / (1 + 2 * window) | ind <- [0..length ns] ];

let mAvgShrink ps window =
    zipPairs (getXs ps) (cMAvg' (getYs ps) window);

-- Simple (rearward) average, chops the beginning off the sequence
let sMAvg ns window =
    [ (sum (slice (ind - window) (ind + 1) ns)) / window | ind <- [window..length ns] ];

let sAvgChop ps window =
    zipPairs (slice window (length ps) (getXs ps)) (sMAvg (getYs ps) window);

-- Simple (rearward average), doesn't chop beginning off
let sMAvg' ns window =
    [ (sum (slice (ind - window) (ind + 1) ns)) / window | ind <- [0..length ns] ];

let sAvgShrink ps window =
    zipPairs (getXs ps) (sMAvg' (getYs ps) window);
